{
  "repoUrl": "https://github.com/manifoldmarkets/manifold",
  "generationDate": "2025-05-29T00:18:38.510Z",
  "evalCommits": [
    {
      "sha": "b7cd62c7b065281660a02996c3b53cffcabd9e9d",
      "author": "Ian Philips",
      "date": "2025-05-27 09:41:57 -0700",
      "message": "Update gemini and prompt to ignore links/pics",
      "stats": {
        "filesChanged": 3,
        "insertions": 6,
        "deletions": 6
      },
      "selectionReason": "Simple configuration change to update AI prompt behavior - a good example of a small, focused change that modifies system behavior",
      "spec": "Update the system to use version `gemini-2.5-pro-preview-05-06` for the 'pro' tier Gemini AI model. Modify the AI prompt responsible for identifying market clarifications from creator comments. This updated prompt must instruct the AI to consider if a comment adds details not covered by a 'reasonable interpretation' of the market's existing description or title. Furthermore, the prompt must explicitly state that the AI should not issue a clarification if a reasonable interpretation of the description already handles the comment, and that links (e.g., to images, videos, or documents) should not be interpreted as clarifications by themselves without explicit creator intent. Finally, adjust the invocation of the AI service for determining a market's close date to rely on the default 'flash' Gemini model, by removing any explicit model parameter from that specific call.",
      "fileStates": [
        {
          "path": "backend/api/src/on-create-comment-on-contract.ts",
          "preContent": "import { compact } from 'lodash'\nimport { isProd, log, revalidateStaticProps } from 'shared/utils'\nimport { ContractComment } from 'common/comment'\nimport { Bet } from 'common/bet'\nimport {\n  replied_users_info,\n  createAIDescriptionUpdateNotification,\n} from 'shared/create-notification'\nimport { createCommentOnContractNotification } from 'shared/notifications/create-new-contract-comment-notif'\nimport {\n  parseJsonContentToText,\n  parseMentions,\n  richTextToString,\n} from 'common/util/parse'\nimport { Contract, contractPath } from 'common/contract'\nimport { User } from 'common/user'\nimport {\n  createSupabaseDirectClient,\n  SupabaseDirectClient,\n} from 'shared/supabase/init'\nimport { insertModReport } from 'shared/create-mod-report'\nimport { updateContract } from 'shared/supabase/contracts'\nimport { followContractInternal } from 'api/follow-contract'\nimport { getAnswer } from 'shared/supabase/answers'\nimport { anythingToRichText } from 'shared/tiptap'\nimport { getCommentsDirect } from 'shared/supabase/contract-comments'\nimport { updateMarketContinuation } from './update-market'\nimport { JSONContent } from '@tiptap/core'\nimport { cloneDeep } from 'lodash'\nimport { track } from 'shared/analytics'\nimport { DEV_HOUSE_LIQUIDITY_PROVIDER_ID } from 'common/antes'\nimport { parseGeminiResponseAsJson, promptGemini } from 'shared/helpers/gemini'\n\ntype ClarificationResponse = {\n  isClarification: boolean\n  description?: string\n}\n\nexport const onCreateCommentOnContract = async (props: {\n  contract: Contract\n  comment: ContractComment\n  creator: User\n  bet?: Bet\n}) => {\n  const { contract, comment, creator, bet } = props\n  const pg = createSupabaseDirectClient()\n  const lastCommentTime = comment.createdTime\n  await updateContract(pg, contract.id, {\n    lastCommentTime,\n    lastUpdatedTime: Date.now(),\n  })\n  await revalidateStaticProps(contractPath(contract)).catch((e) =>\n    log.error('Failed to revalidate contract after comment', {\n      e,\n      comment,\n      creator,\n    })\n  )\n\n  await followContractInternal(pg, contract.id, true, creator.id)\n\n  if (\n    creator.id === contract.creatorId &&\n    !contract.isResolved &&\n    contract.outcomeType !== 'POLL'\n  ) {\n    await checkForClarification(pg, contract, comment)\n  }\n\n  await handleCommentNotifications(pg, comment, contract, creator, bet)\n}\n\nconst getReplyInfo = async (\n  pg: SupabaseDirectClient,\n  comment: ContractComment,\n  contract: Contract\n) => {\n  if (comment.answerOutcome && contract.outcomeType === 'MULTIPLE_CHOICE') {\n    const answer = await getAnswer(pg, comment.answerOutcome)\n    const comments = await pg.manyOrNone<{\n      user_id: string\n      data: ContractComment // Need data for context\n    }>(\n      `select user_id, data\n      from contract_comments\n      where contract_id = $1 and coalesce(data->>'answerOutcome', '') = $2\n      order by created_time asc`,\n      [contract.id, answer?.id ?? '']\n    )\n    return {\n      repliedToAnswer: answer,\n      repliedToType: 'answer',\n      repliedUserId: answer?.userId,\n      commentsInSameReplyChain: comments, // Comments replying to the same answer\n    } as const\n  } else if (comment.replyToCommentId) {\n    const comments = await pg.manyOrNone<{\n      user_id: string\n      data: ContractComment\n    }>(\n      `select user_id, data\n      from contract_comments where contract_id = $1\n        and (coalesce(data->>'replyToCommentId', '') = $2\n            or comment_id = $2)\n      order by created_time asc`,\n      [contract.id, comment.replyToCommentId]\n    )\n    return {\n      repliedToAnswer: null,\n      repliedToType: 'comment',\n      repliedUserId: comments.find(\n        (c) => c.data.id === comment.replyToCommentId\n      )?.user_id,\n      commentsInSameReplyChain: comments,\n    } as const\n  } else {\n    return null\n  }\n}\n\nexport const handleCommentNotifications = async (\n  pg: SupabaseDirectClient,\n  comment: ContractComment,\n  contract: Contract,\n  commentCreator: User,\n  bet: Bet | undefined\n) => {\n  const replyInfo = await getReplyInfo(pg, comment, contract)\n\n  const modsId = 'WQJ92QkoqDPuyj6DAZ5lR6g1x573'\n  const mentionedUsers = compact(parseMentions(comment.content))\n  const mentionedMods = mentionedUsers.includes(modsId)\n\n  const repliedUsers: replied_users_info = {}\n  if (replyInfo) {\n    const {\n      repliedToType,\n      repliedUserId,\n      repliedToAnswer,\n      commentsInSameReplyChain,\n    } = replyInfo\n\n    // The parent of the reply chain could be a comment or an answer\n    if (repliedUserId && repliedToType)\n      repliedUsers[repliedUserId] = {\n        repliedToType,\n        repliedToAnswerText: repliedToAnswer?.text,\n        repliedToAnswerId: repliedToAnswer?.id,\n        bet: bet,\n      }\n\n    if (commentsInSameReplyChain) {\n      // Add users from the reply chain (parent and siblings) to notifications,\n      // excluding the commenter and the direct recipient (already added)\n      commentsInSameReplyChain.forEach((c) => {\n        if (c.user_id !== comment.userId && c.user_id !== repliedUserId) {\n          repliedUsers[c.user_id] = {\n            repliedToType: 'comment',\n            repliedToAnswerText: undefined,\n            repliedToAnswerId: undefined,\n            bet: undefined,\n          }\n        }\n      })\n    }\n  }\n  if (mentionedMods) {\n    await insertModReport(comment)\n  }\n\n  // Prepare context for Gemini check\n  let threadContext: string | null = null\n  let newCommentText = ''\n  if (replyInfo?.commentsInSameReplyChain) {\n    // Build the thread context: comments in the same chain + the new comment\n    const threadComments = [\n      ...replyInfo.commentsInSameReplyChain\n        .filter((c) => c.data.id !== comment.id) // Filter out the new comment itself\n        .map((c) => ({\n          userId: c.user_id,\n          userName: c.data.userName,\n          userUsername: c.data.userUsername,\n          content: c.data.content,\n        })),\n    ]\n\n    threadContext = threadComments\n      .map((c) => {\n        const authorTag =\n          c.userId === contract.creatorId ? '[CREATOR]' : '[USER]'\n        const name = c.userName\n          ? `${c.userName} (@${c.userUsername})`\n          : `User ${c.userId.substring(0, 4)}`\n        return `${authorTag} ${name}: ${richTextToString(c.content)}`\n      })\n      .join('\\n---\\n') // Separator between comments\n  }\n\n  // Format the new comment text\n  const newCommentAuthorTag =\n    comment.userId === contract.creatorId ? '[CREATOR]' : '[USER]'\n  newCommentText = `${newCommentAuthorTag} ${\n    commentCreator.name\n      ? `${commentCreator.name} (@${commentCreator.username})`\n      : `User ${commentCreator.id.substring(0, 4)}`\n  }: ${richTextToString(comment.content)}`\n\n  // Check if comment needs response using Gemini, now with context\n  const checkResult =\n    comment.userId === contract.creatorId\n      ? { needsResponse: false }\n      : await checkCommentNeedsResponse(contract, threadContext, newCommentText)\n  const needsResponse = checkResult.needsResponse\n\n  await createCommentOnContractNotification(\n    comment.id,\n    commentCreator,\n    richTextToString(comment.content),\n    contract,\n    repliedUsers,\n    mentionedUsers,\n    needsResponse\n  )\n  return [...mentionedUsers, ...Object.keys(repliedUsers)]\n}\n\nconst checkForClarification = async (\n  pg: SupabaseDirectClient,\n  contract: Contract,\n  comment: ContractComment\n) => {\n  let commentsContext = ''\n  let answerContext = ''\n\n  if (comment.replyToCommentId) {\n    const originalComment = await getCommentsDirect(pg, {\n      contractId: contract.id,\n      commentId: comment.replyToCommentId,\n    })\n    const relatedComments = await getCommentsDirect(pg, {\n      contractId: contract.id,\n      replyToCommentId: comment.replyToCommentId,\n    })\n\n    const replyToAnswerId =\n      comment.answerOutcome ||\n      originalComment.find((c) => c.answerOutcome)?.answerOutcome\n    // Get answer context if this is a reply to an answer\n    if (replyToAnswerId) {\n      const answer = await getAnswer(pg, replyToAnswerId)\n      if (answer) {\n        const isCreatorAnswer = answer.userId === contract.creatorId\n        answerContext = `ANSWER (submitted by ${\n          isCreatorAnswer ? 'creator' : 'user'\n        }) BEING DISCUSSED:\n${answer.text}`\n      }\n    }\n\n    commentsContext = [...originalComment, ...relatedComments]\n      .filter((c) => c.id !== comment.id)\n      .map((c) => {\n        const isCreator = c.userId === contract.creatorId\n        return `${isCreator ? 'Creator' : 'User'}: ${richTextToString(\n          c.content\n        )}`\n      })\n      .join('\\n')\n  }\n\n  const closeTimeDetail = contract.closeTime\n    ? `Market is set to close on ${new Date(contract.closeTime).toISOString()}`\n    : ''\n\n  const prompt = `SYSTEM: You are analyzing a ${\n    commentsContext ? 'comment thread' : 'comment'\n  } on a prediction market (that is managed by a creator) to determine if the creator's latest comment clarifies the resolution criteria.\n\nCONTEXT:\nMarket question: ${contract.question}\n${closeTimeDetail}\nMarket description: ${\n    typeof contract.description === 'string'\n      ? contract.description\n      : richTextToString(contract.description)\n  }\n\n${answerContext}\n${commentsContext ? `COMMENT THREAD:\\n${commentsContext}` : ''}\n\nCREATOR'S LATEST COMMENT:\n${richTextToString(comment.content)}\n\nSYSTEM: Please analyze if the creator's latest comment ${\n    commentsContext ? '(in context of the comment thread)' : ''\n  } is clarifying or adding important details about how the market will be resolved, that is not already covered by the market's description/question title. \n\n  ONLY choose to issue a clarification if you are CERTAIN that the creator's comment is unambiguously changing the resolution criteria as outlined in the description/question.\n  Do not issue clarifications for everything the creator says, only clarifications on how the market will resolve.\n  A clarification should very likely be a response to a question from a user about how the market will resolve in x case. Ignore lighthearted commentary and banter.\n  If the creator is about to resolve the market, and detailing their reasoning, do not try to summarize the comment. In this case, just add a note that they're about to resolve the market and to see the linked comment for more details.\n  If the creator says that they're going to update the description themselves, or they indicate their comment ${\n    commentsContext ? '(or their comments in the thread)' : ''\n  } shouldn't be used to update the description, do not issue a clarification.\n\nReturn a JSON response with:\n{\n  \"isClarification\": boolean, // true if the comment clarifies resolution criteria\n  \"description\": string // If isClarification is true, provide markdown formatted text to append to the current description. Use bold for important terms and bullet points for lists. Otherwise, return an empty string.\n}\n\nFormat the description in markdown, sticking to just the following:\n- Use **bold** for important terms\n- Use bullet points for lists\n\nI will append the title of 'Update from creator' to the beginning of the description. You do not need to include this in your response.\nBe as concise as possible. I will link your clarification to the creator's comment, so when in doubt, err on the side of brevity and let the user check out the comment for more details.\nNOTE: If the creator explicitly states that their comment is not a clarification, such as saying \"these comments are not a clarification,\" then you must not treat it as clarifying or changing the resolution criteria. In that case, return {\"isClarification\": false, \"description\": \"\"}.\nOnly return the raw JSON object without any markdown code blocks, backticks, additional formatting, or anything else.`\n\n  try {\n    const response = await promptGemini(prompt, {\n      model: 'gemini-2.5-pro-preview-03-25',\n    })\n    log('Clarification response:', {\n      question: contract.question,\n      contractId: contract.id,\n      slug: contract.slug,\n      response,\n    })\n    if (!response) {\n      log.error('No response from ai clarification')\n      return\n    }\n    const clarification = parseGeminiResponseAsJson(\n      response\n    ) as ClarificationResponse\n\n    if (clarification.isClarification && clarification.description) {\n      const dateParts = new Date()\n        .toLocaleDateString('en-US', {\n          timeZone: 'America/Los_Angeles',\n          year: 'numeric',\n          month: '2-digit',\n          day: '2-digit',\n        })\n        .split('/')\n      const date = `${dateParts[2]}-${dateParts[0]}-${dateParts[1]}`\n      const timeZone = new Date()\n        .toLocaleDateString('en-US', { timeZoneName: 'short' })\n        .includes('PDT')\n        ? 'PDT'\n        : 'PST'\n\n      const formattedDescription = clarification.description.replace(\n        /\\n[•\\-*] /g,\n        '\\n   - '\n      )\n      const summaryNote = `(AI summary of [creator comment](${contractPath(\n        contract\n      )}#${comment.id}))`\n\n      const markdownToAppend = `- Update ${date} (${timeZone}) ${summaryNote}: ${formattedDescription} `\n\n      const appendDescription = anythingToRichText({\n        markdown: markdownToAppend,\n      })\n      // Create deep copy of the old description to update history correctly\n      const oldDescription = cloneDeep(contract.description)\n      let newDescription: JSONContent | undefined\n\n      if (typeof oldDescription === 'string') {\n        newDescription = anythingToRichText({\n          markdown: `${oldDescription}${appendDescription}`,\n        })\n      } else {\n        oldDescription.content?.push(\n          { type: 'paragraph' }, // acts as newline\n          ...(appendDescription?.content ?? [])\n        )\n        newDescription = oldDescription\n      }\n      await updateContract(pg, contract.id, {\n        description: newDescription,\n      })\n      const editorID = isProd()\n        ? '8lZo8X5lewh4hnCoreI7iSc0GxK2' // ManifoldAI user id, lol\n        : DEV_HOUSE_LIQUIDITY_PROVIDER_ID\n      await updateMarketContinuation(\n        contract,\n        editorID,\n        undefined,\n        undefined,\n        undefined,\n        undefined,\n        newDescription\n      )\n      track(editorID, 'ai clarification added', {\n        contractId: contract.id,\n        slug: contract.slug,\n        question: contract.question,\n      })\n\n      await createAIDescriptionUpdateNotification(contract, markdownToAppend)\n    }\n  } catch (e) {\n    log.error('Error checking for clarification:', { e })\n  }\n}\n\nexport const checkCommentNeedsResponse = async (\n  contract: Contract,\n  threadContext: string | null,\n  newCommentText: string\n) => {\n  const prompt = `\n  Analyze the NEWEST COMMENT on a prediction market and determine if it requires a response from the market creator.\n\n  The creator is a user of Manifold Markets that created the market and resolves it using their judgement, along with the title and description of the market.\n\n  The NEWEST COMMENT should be considered as needing a response if it:\n  1. Asks for clarification about the market or its resolution criteria\n  2. Requests the market to be resolved\n  3. Points out potential issues that need to be addressed\n  4. (If relevant to the market) Requests an update on the status of the market from the creator\n  5. Asks a direct question to the market creator and the question is related to the market\n\n  Market title: ${contract.question}\n  Market description: ${parseJsonContentToText(contract.description)}\n\n  ${\n    threadContext\n      ? `COMMENT THREAD CONTEXT (previous messages):\\n\\`\\`\\`\\n${threadContext}\\n\\`\\`\\`\\nThe thread context uses [USER] and [CREATOR] tags. Discussions between users not addressing the creator should NOT be considered as needing a response.`\n      : 'This is a top-level comment (not a reply).'\n  }\n\n  NEWEST COMMENT (Analyze this comment for whether a response is needed):\n  \\`\\`\\`\n  ${newCommentText}\n  \\`\\`\\`\n\n  Return a JSON object with:\n  - needsResponse: boolean // True if the *newest comment* requires a response based ONLY on its content and the criteria above.\n  - reason: string (brief explanation why, or empty if no response needed)\n\n  Only return the JSON object, no other text.`\n\n  try {\n    const response = await promptGemini(prompt)\n    const result = parseGeminiResponseAsJson(response)\n    return result as { needsResponse: boolean; reason: string }\n  } catch (error) {\n    log.error(`Error checking if comment needs response: ${error}`)\n    // Default to false if there's an error\n    return { needsResponse: false, reason: '' }\n  }\n}\n",
          "postContent": "import { compact } from 'lodash'\nimport { isProd, log, revalidateStaticProps } from 'shared/utils'\nimport { ContractComment } from 'common/comment'\nimport { Bet } from 'common/bet'\nimport {\n  replied_users_info,\n  createAIDescriptionUpdateNotification,\n} from 'shared/create-notification'\nimport { createCommentOnContractNotification } from 'shared/notifications/create-new-contract-comment-notif'\nimport {\n  parseJsonContentToText,\n  parseMentions,\n  richTextToString,\n} from 'common/util/parse'\nimport { Contract, contractPath } from 'common/contract'\nimport { User } from 'common/user'\nimport {\n  createSupabaseDirectClient,\n  SupabaseDirectClient,\n} from 'shared/supabase/init'\nimport { insertModReport } from 'shared/create-mod-report'\nimport { updateContract } from 'shared/supabase/contracts'\nimport { followContractInternal } from 'api/follow-contract'\nimport { getAnswer } from 'shared/supabase/answers'\nimport { anythingToRichText } from 'shared/tiptap'\nimport { getCommentsDirect } from 'shared/supabase/contract-comments'\nimport { updateMarketContinuation } from './update-market'\nimport { JSONContent } from '@tiptap/core'\nimport { cloneDeep } from 'lodash'\nimport { track } from 'shared/analytics'\nimport { DEV_HOUSE_LIQUIDITY_PROVIDER_ID } from 'common/antes'\nimport { parseGeminiResponseAsJson, promptGemini } from 'shared/helpers/gemini'\n\ntype ClarificationResponse = {\n  isClarification: boolean\n  description?: string\n}\n\nexport const onCreateCommentOnContract = async (props: {\n  contract: Contract\n  comment: ContractComment\n  creator: User\n  bet?: Bet\n}) => {\n  const { contract, comment, creator, bet } = props\n  const pg = createSupabaseDirectClient()\n  const lastCommentTime = comment.createdTime\n  await updateContract(pg, contract.id, {\n    lastCommentTime,\n    lastUpdatedTime: Date.now(),\n  })\n  await revalidateStaticProps(contractPath(contract)).catch((e) =>\n    log.error('Failed to revalidate contract after comment', {\n      e,\n      comment,\n      creator,\n    })\n  )\n\n  await followContractInternal(pg, contract.id, true, creator.id)\n\n  if (\n    creator.id === contract.creatorId &&\n    !contract.isResolved &&\n    contract.outcomeType !== 'POLL'\n  ) {\n    await checkForClarification(pg, contract, comment)\n  }\n\n  await handleCommentNotifications(pg, comment, contract, creator, bet)\n}\n\nconst getReplyInfo = async (\n  pg: SupabaseDirectClient,\n  comment: ContractComment,\n  contract: Contract\n) => {\n  if (comment.answerOutcome && contract.outcomeType === 'MULTIPLE_CHOICE') {\n    const answer = await getAnswer(pg, comment.answerOutcome)\n    const comments = await pg.manyOrNone<{\n      user_id: string\n      data: ContractComment // Need data for context\n    }>(\n      `select user_id, data\n      from contract_comments\n      where contract_id = $1 and coalesce(data->>'answerOutcome', '') = $2\n      order by created_time asc`,\n      [contract.id, answer?.id ?? '']\n    )\n    return {\n      repliedToAnswer: answer,\n      repliedToType: 'answer',\n      repliedUserId: answer?.userId,\n      commentsInSameReplyChain: comments, // Comments replying to the same answer\n    } as const\n  } else if (comment.replyToCommentId) {\n    const comments = await pg.manyOrNone<{\n      user_id: string\n      data: ContractComment\n    }>(\n      `select user_id, data\n      from contract_comments where contract_id = $1\n        and (coalesce(data->>'replyToCommentId', '') = $2\n            or comment_id = $2)\n      order by created_time asc`,\n      [contract.id, comment.replyToCommentId]\n    )\n    return {\n      repliedToAnswer: null,\n      repliedToType: 'comment',\n      repliedUserId: comments.find(\n        (c) => c.data.id === comment.replyToCommentId\n      )?.user_id,\n      commentsInSameReplyChain: comments,\n    } as const\n  } else {\n    return null\n  }\n}\n\nexport const handleCommentNotifications = async (\n  pg: SupabaseDirectClient,\n  comment: ContractComment,\n  contract: Contract,\n  commentCreator: User,\n  bet: Bet | undefined\n) => {\n  const replyInfo = await getReplyInfo(pg, comment, contract)\n\n  const modsId = 'WQJ92QkoqDPuyj6DAZ5lR6g1x573'\n  const mentionedUsers = compact(parseMentions(comment.content))\n  const mentionedMods = mentionedUsers.includes(modsId)\n\n  const repliedUsers: replied_users_info = {}\n  if (replyInfo) {\n    const {\n      repliedToType,\n      repliedUserId,\n      repliedToAnswer,\n      commentsInSameReplyChain,\n    } = replyInfo\n\n    // The parent of the reply chain could be a comment or an answer\n    if (repliedUserId && repliedToType)\n      repliedUsers[repliedUserId] = {\n        repliedToType,\n        repliedToAnswerText: repliedToAnswer?.text,\n        repliedToAnswerId: repliedToAnswer?.id,\n        bet: bet,\n      }\n\n    if (commentsInSameReplyChain) {\n      // Add users from the reply chain (parent and siblings) to notifications,\n      // excluding the commenter and the direct recipient (already added)\n      commentsInSameReplyChain.forEach((c) => {\n        if (c.user_id !== comment.userId && c.user_id !== repliedUserId) {\n          repliedUsers[c.user_id] = {\n            repliedToType: 'comment',\n            repliedToAnswerText: undefined,\n            repliedToAnswerId: undefined,\n            bet: undefined,\n          }\n        }\n      })\n    }\n  }\n  if (mentionedMods) {\n    await insertModReport(comment)\n  }\n\n  // Prepare context for Gemini check\n  let threadContext: string | null = null\n  let newCommentText = ''\n  if (replyInfo?.commentsInSameReplyChain) {\n    // Build the thread context: comments in the same chain + the new comment\n    const threadComments = [\n      ...replyInfo.commentsInSameReplyChain\n        .filter((c) => c.data.id !== comment.id) // Filter out the new comment itself\n        .map((c) => ({\n          userId: c.user_id,\n          userName: c.data.userName,\n          userUsername: c.data.userUsername,\n          content: c.data.content,\n        })),\n    ]\n\n    threadContext = threadComments\n      .map((c) => {\n        const authorTag =\n          c.userId === contract.creatorId ? '[CREATOR]' : '[USER]'\n        const name = c.userName\n          ? `${c.userName} (@${c.userUsername})`\n          : `User ${c.userId.substring(0, 4)}`\n        return `${authorTag} ${name}: ${richTextToString(c.content)}`\n      })\n      .join('\\n---\\n') // Separator between comments\n  }\n\n  // Format the new comment text\n  const newCommentAuthorTag =\n    comment.userId === contract.creatorId ? '[CREATOR]' : '[USER]'\n  newCommentText = `${newCommentAuthorTag} ${\n    commentCreator.name\n      ? `${commentCreator.name} (@${commentCreator.username})`\n      : `User ${commentCreator.id.substring(0, 4)}`\n  }: ${richTextToString(comment.content)}`\n\n  // Check if comment needs response using Gemini, now with context\n  const checkResult =\n    comment.userId === contract.creatorId\n      ? { needsResponse: false }\n      : await checkCommentNeedsResponse(contract, threadContext, newCommentText)\n  const needsResponse = checkResult.needsResponse\n\n  await createCommentOnContractNotification(\n    comment.id,\n    commentCreator,\n    richTextToString(comment.content),\n    contract,\n    repliedUsers,\n    mentionedUsers,\n    needsResponse\n  )\n  return [...mentionedUsers, ...Object.keys(repliedUsers)]\n}\n\nconst checkForClarification = async (\n  pg: SupabaseDirectClient,\n  contract: Contract,\n  comment: ContractComment\n) => {\n  let commentsContext = ''\n  let answerContext = ''\n\n  if (comment.replyToCommentId) {\n    const originalComment = await getCommentsDirect(pg, {\n      contractId: contract.id,\n      commentId: comment.replyToCommentId,\n    })\n    const relatedComments = await getCommentsDirect(pg, {\n      contractId: contract.id,\n      replyToCommentId: comment.replyToCommentId,\n    })\n\n    const replyToAnswerId =\n      comment.answerOutcome ||\n      originalComment.find((c) => c.answerOutcome)?.answerOutcome\n    // Get answer context if this is a reply to an answer\n    if (replyToAnswerId) {\n      const answer = await getAnswer(pg, replyToAnswerId)\n      if (answer) {\n        const isCreatorAnswer = answer.userId === contract.creatorId\n        answerContext = `ANSWER (submitted by ${\n          isCreatorAnswer ? 'creator' : 'user'\n        }) BEING DISCUSSED:\n${answer.text}`\n      }\n    }\n\n    commentsContext = [...originalComment, ...relatedComments]\n      .filter((c) => c.id !== comment.id)\n      .map((c) => {\n        const isCreator = c.userId === contract.creatorId\n        return `${isCreator ? 'Creator' : 'User'}: ${richTextToString(\n          c.content\n        )}`\n      })\n      .join('\\n')\n  }\n\n  const closeTimeDetail = contract.closeTime\n    ? `Market is set to close on ${new Date(contract.closeTime).toISOString()}`\n    : ''\n\n  const prompt = `SYSTEM: You are analyzing a ${\n    commentsContext ? 'comment thread' : 'comment'\n  } on a prediction market (that is managed by a creator) to determine if the creator's latest comment clarifies the resolution criteria.\n\nCONTEXT:\nMarket question: ${contract.question}\n${closeTimeDetail}\nMarket description: ${\n    typeof contract.description === 'string'\n      ? contract.description\n      : richTextToString(contract.description)\n  }\n\n${answerContext}\n${commentsContext ? `COMMENT THREAD:\\n${commentsContext}` : ''}\n\nCREATOR'S LATEST COMMENT:\n${richTextToString(comment.content)}\n\nSYSTEM: Please analyze if the creator's latest comment ${\n    commentsContext ? '(in context of the comment thread)' : ''\n  } is clarifying or adding important details about how the market will be resolved, that is not already covered by a reasonable interpretation of the market's description/question title. \n\n  ONLY choose to issue a clarification if you are CERTAIN that the creator's comment is unambiguously changing the resolution criteria as outlined in the description/question.\n  Do not issue clarifications if a reasonable interpretation of the description already handles the creator's comment. \n  Do not issue clarifications for everything the creator says, only clarifications on how the market will resolve.\n  Do not attempt to interpret images/videos/google drive/doc/any other links as clarifications by themselves. The creator will say something if it's intended to be a clarification.\n  A clarification should very likely be a response to a question from a user about how the market will resolve in x case. Ignore lighthearted commentary and banter.\n  If the creator is about to resolve the market, and detailing their reasoning, do not try to summarize the comment. In this case, just add a note that they're about to resolve the market and to see the linked comment for more details.\n  If the creator says that they're going to update the description themselves, or they indicate their comment ${\n    commentsContext ? '(or their comments in the thread)' : ''\n  } shouldn't be used to update the description, do not issue a clarification.\n\nReturn a JSON response with:\n{\n  \"isClarification\": boolean, // true if the comment clarifies resolution criteria\n  \"description\": string // If isClarification is true, provide markdown formatted text to append to the current description. Use bold for important terms and bullet points for lists. Otherwise, return an empty string.\n}\n\nFormat the description in markdown, sticking to just the following:\n- Use **bold** for important terms\n- Use bullet points for lists\n\nI will append the title of 'Update from creator' to the beginning of the description. You do not need to include this in your response.\nBe as concise as possible. I will link your clarification to the creator's comment, so when in doubt, err on the side of brevity and let the user check out the comment for more details.\nNOTE: If the creator explicitly states that their comment is not a clarification, such as saying \"these comments are not a clarification,\" then you must not treat it as clarifying or changing the resolution criteria. In that case, return {\"isClarification\": false, \"description\": \"\"}.\nOnly return the raw JSON object without any markdown code blocks, backticks, additional formatting, or anything else.`\n\n  try {\n    const response = await promptGemini(prompt, {\n      model: 'gemini-2.5-pro-preview-05-06',\n    })\n    log('Clarification response:', {\n      question: contract.question,\n      contractId: contract.id,\n      slug: contract.slug,\n      response,\n    })\n    if (!response) {\n      log.error('No response from ai clarification')\n      return\n    }\n    const clarification = parseGeminiResponseAsJson(\n      response\n    ) as ClarificationResponse\n\n    if (clarification.isClarification && clarification.description) {\n      const dateParts = new Date()\n        .toLocaleDateString('en-US', {\n          timeZone: 'America/Los_Angeles',\n          year: 'numeric',\n          month: '2-digit',\n          day: '2-digit',\n        })\n        .split('/')\n      const date = `${dateParts[2]}-${dateParts[0]}-${dateParts[1]}`\n      const timeZone = new Date()\n        .toLocaleDateString('en-US', { timeZoneName: 'short' })\n        .includes('PDT')\n        ? 'PDT'\n        : 'PST'\n\n      const formattedDescription = clarification.description.replace(\n        /\\n[•\\-*] /g,\n        '\\n   - '\n      )\n      const summaryNote = `(AI summary of [creator comment](${contractPath(\n        contract\n      )}#${comment.id}))`\n\n      const markdownToAppend = `- Update ${date} (${timeZone}) ${summaryNote}: ${formattedDescription} `\n\n      const appendDescription = anythingToRichText({\n        markdown: markdownToAppend,\n      })\n      // Create deep copy of the old description to update history correctly\n      const oldDescription = cloneDeep(contract.description)\n      let newDescription: JSONContent | undefined\n\n      if (typeof oldDescription === 'string') {\n        newDescription = anythingToRichText({\n          markdown: `${oldDescription}${appendDescription}`,\n        })\n      } else {\n        oldDescription.content?.push(\n          { type: 'paragraph' }, // acts as newline\n          ...(appendDescription?.content ?? [])\n        )\n        newDescription = oldDescription\n      }\n      await updateContract(pg, contract.id, {\n        description: newDescription,\n      })\n      const editorID = isProd()\n        ? '8lZo8X5lewh4hnCoreI7iSc0GxK2' // ManifoldAI user id, lol\n        : DEV_HOUSE_LIQUIDITY_PROVIDER_ID\n      await updateMarketContinuation(\n        contract,\n        editorID,\n        undefined,\n        undefined,\n        undefined,\n        undefined,\n        newDescription\n      )\n      track(editorID, 'ai clarification added', {\n        contractId: contract.id,\n        slug: contract.slug,\n        question: contract.question,\n      })\n\n      await createAIDescriptionUpdateNotification(contract, markdownToAppend)\n    }\n  } catch (e) {\n    log.error('Error checking for clarification:', { e })\n  }\n}\n\nexport const checkCommentNeedsResponse = async (\n  contract: Contract,\n  threadContext: string | null,\n  newCommentText: string\n) => {\n  const prompt = `\n  Analyze the NEWEST COMMENT on a prediction market and determine if it requires a response from the market creator.\n\n  The creator is a user of Manifold Markets that created the market and resolves it using their judgement, along with the title and description of the market.\n\n  The NEWEST COMMENT should be considered as needing a response if it:\n  1. Asks for clarification about the market or its resolution criteria\n  2. Requests the market to be resolved\n  3. Points out potential issues that need to be addressed\n  4. (If relevant to the market) Requests an update on the status of the market from the creator\n  5. Asks a direct question to the market creator and the question is related to the market\n\n  Market title: ${contract.question}\n  Market description: ${parseJsonContentToText(contract.description)}\n\n  ${\n    threadContext\n      ? `COMMENT THREAD CONTEXT (previous messages):\\n\\`\\`\\`\\n${threadContext}\\n\\`\\`\\`\\nThe thread context uses [USER] and [CREATOR] tags. Discussions between users not addressing the creator should NOT be considered as needing a response.`\n      : 'This is a top-level comment (not a reply).'\n  }\n\n  NEWEST COMMENT (Analyze this comment for whether a response is needed):\n  \\`\\`\\`\n  ${newCommentText}\n  \\`\\`\\`\n\n  Return a JSON object with:\n  - needsResponse: boolean // True if the *newest comment* requires a response based ONLY on its content and the criteria above.\n  - reason: string (brief explanation why, or empty if no response needed)\n\n  Only return the JSON object, no other text.`\n\n  try {\n    const response = await promptGemini(prompt)\n    const result = parseGeminiResponseAsJson(response)\n    return result as { needsResponse: boolean; reason: string }\n  } catch (error) {\n    log.error(`Error checking if comment needs response: ${error}`)\n    // Default to false if there's an error\n    return { needsResponse: false, reason: '' }\n  }\n}\n"
        },
        {
          "path": "backend/shared/src/helpers/ai-close-date.ts",
          "preContent": "import * as dayjs from 'dayjs'\nimport * as utc from 'dayjs/plugin/utc'\nimport { log } from 'shared/utils'\nimport { promptGemini } from './gemini'\ndayjs.extend(utc)\n\nexport const getCloseDate = async (question: string, utcOffset?: number) => {\n  const now = dayjs.utc().format('M/D/YYYY h:mm a')\n\n  let response\n  try {\n    const prompt = `Please return the user's desired end date and nothing else for their question in the form: MM/DD/YYYY HH:mm am/pm.\n     The end date will serve as a reminder to decide the outcome of their question.\n     If a question is titled by 'date', the end date should be the minute before that time happens.\n     For example, if the question is 'by 2028', the end date should be the minute before 2028: 12/31/2027 11:59 pm.\n     Examples:\n     Question: 'Will I go to school tomorrow?'\n     now: ${now}\n     End date: ${dayjs().add(1, 'day').format('M/D/YYYY h:mm a')}\n\n     Question: 'Will humans land on Mars by 2028?'\n     End date: 12/31/2027 11:59 pm\n     (Note how the end date is the minute before 2028, ie in 2027.)\n\n     Question: 'Will the stock market crash in 2026?'\n     End date: 12/31/2026 11:59 pm\n\n     Question: 'Will Ezra Klein run for office by EOY 2025?'\n     End date: 12/31/2025 11:59 pm\n     (Note how the end date is the minute before the end of 2025, ie in 2025.)\n\n    Here's their question, and remember: ONLY return the end date in the form: MM/DD/YYYY HH:mm am/pm and make sure it's after the current date.\n\n    Question: ${question}\n    Now: ${now}\n    End date:`\n    response = await promptGemini(prompt, {\n      model: 'gemini-2.0-flash',\n    })\n  } catch (e: any) {\n    log.error('Error generating close date', { e })\n    return undefined\n  }\n\n  if (!response) return undefined\n\n  const utcTime = dayjs.utc(response, 'M/D/YYYY h:mm a')\n  const timestamp = utcTime.valueOf()\n  if (!timestamp || !isFinite(timestamp) || utcTime.isBefore(dayjs())) {\n    log.error('Invalid close date', { response })\n    return undefined\n  }\n\n  // adjust for local timezone\n  return utcTime.utcOffset(utcOffset ?? 0).valueOf()\n}\n",
          "postContent": "import * as dayjs from 'dayjs'\nimport * as utc from 'dayjs/plugin/utc'\nimport { log } from 'shared/utils'\nimport { promptGemini } from './gemini'\ndayjs.extend(utc)\n\nexport const getCloseDate = async (question: string, utcOffset?: number) => {\n  const now = dayjs.utc().format('M/D/YYYY h:mm a')\n\n  let response\n  try {\n    const prompt = `Please return the user's desired end date and nothing else for their question in the form: MM/DD/YYYY HH:mm am/pm.\n     The end date will serve as a reminder to decide the outcome of their question.\n     If a question is titled by 'date', the end date should be the minute before that time happens.\n     For example, if the question is 'by 2028', the end date should be the minute before 2028: 12/31/2027 11:59 pm.\n     Examples:\n     Question: 'Will I go to school tomorrow?'\n     now: ${now}\n     End date: ${dayjs().add(1, 'day').format('M/D/YYYY h:mm a')}\n\n     Question: 'Will humans land on Mars by 2028?'\n     End date: 12/31/2027 11:59 pm\n     (Note how the end date is the minute before 2028, ie in 2027.)\n\n     Question: 'Will the stock market crash in 2026?'\n     End date: 12/31/2026 11:59 pm\n\n     Question: 'Will Ezra Klein run for office by EOY 2025?'\n     End date: 12/31/2025 11:59 pm\n     (Note how the end date is the minute before the end of 2025, ie in 2025.)\n\n    Here's their question, and remember: ONLY return the end date in the form: MM/DD/YYYY HH:mm am/pm and make sure it's after the current date.\n\n    Question: ${question}\n    Now: ${now}\n    End date:`\n    response = await promptGemini(prompt)\n  } catch (e: any) {\n    log.error('Error generating close date', { e })\n    return undefined\n  }\n\n  if (!response) return undefined\n\n  const utcTime = dayjs.utc(response, 'M/D/YYYY h:mm a')\n  const timestamp = utcTime.valueOf()\n  if (!timestamp || !isFinite(timestamp) || utcTime.isBefore(dayjs())) {\n    log.error('Invalid close date', { response })\n    return undefined\n  }\n\n  // adjust for local timezone\n  return utcTime.utcOffset(utcOffset ?? 0).valueOf()\n}\n"
        },
        {
          "path": "backend/shared/src/helpers/gemini.ts",
          "preContent": "import { GoogleGenerativeAI } from '@google/generative-ai'\nimport { log } from 'shared/utils'\nimport { APIError } from 'common/api/utils'\n\nexport const models = {\n  flash: 'gemini-2.0-flash' as const,\n  pro: 'gemini-2.5-pro-preview-03-25' as const,\n}\n\nexport type model_types = (typeof models)[keyof typeof models]\n\nexport const promptGemini = async (\n  prompt: string,\n  options: { system?: string; model?: model_types } = {}\n) => {\n  const { model = models.flash, system } = options\n\n  const apiKey = process.env.GEMINI_API_KEY\n\n  if (!apiKey) {\n    throw new APIError(500, 'Missing GEMINI_API_KEY')\n  }\n\n  const genAI = new GoogleGenerativeAI(apiKey)\n  const geminiModel = genAI.getGenerativeModel({ model })\n\n  try {\n    // Combine system prompt and user prompt if system is provided\n    const fullPrompt = system ? `${system}\\n\\n${prompt}` : prompt\n\n    const result = await geminiModel.generateContent(fullPrompt)\n    const response = result.response.text()\n\n    log('Gemini returned message:', response)\n    return response\n  } catch (error: any) {\n    log.error(`Error with Gemini API: ${error.message}`)\n    throw new APIError(500, 'Failed to get response from Gemini')\n  }\n}\n\n// Helper function to clean Gemini responses from markdown formatting\nconst removeJsonTicksFromGeminiResponse = (response: string): string => {\n  // Remove markdown code block formatting if present\n  const jsonBlockRegex = /```(?:json)?\\s*([\\s\\S]*?)```/\n  const match = response.match(jsonBlockRegex)\n\n  if (match && match[1]) {\n    return match[1].trim()\n  }\n\n  // If no markdown formatting found, return the original response\n  return response.trim()\n}\n\n// Helper function to ensure the response is valid JSON\nexport const parseGeminiResponseAsJson = (response: string): any => {\n  const cleanedResponse = removeJsonTicksFromGeminiResponse(response)\n\n  try {\n    // Try to parse as is\n    return JSON.parse(cleanedResponse)\n  } catch (error) {\n    // If parsing fails, try to handle common issues\n\n    // Check if it's an array wrapped in extra text\n    const arrayStart = cleanedResponse.indexOf('[')\n    const arrayEnd = cleanedResponse.lastIndexOf(']')\n\n    if (arrayStart !== -1 && arrayEnd !== -1 && arrayEnd > arrayStart) {\n      const potentialArray = cleanedResponse.substring(arrayStart, arrayEnd + 1)\n      try {\n        return JSON.parse(potentialArray)\n      } catch (e) {\n        // If still fails, throw the original error\n        throw error\n      }\n    }\n\n    // If we can't fix it, throw the original error\n    throw error\n  }\n}\n",
          "postContent": "import { GoogleGenerativeAI } from '@google/generative-ai'\nimport { log } from 'shared/utils'\nimport { APIError } from 'common/api/utils'\n\nexport const models = {\n  flash: 'gemini-2.0-flash' as const,\n  pro: 'gemini-2.5-pro-preview-05-06' as const,\n}\n\nexport type model_types = (typeof models)[keyof typeof models]\n\nexport const promptGemini = async (\n  prompt: string,\n  options: { system?: string; model?: model_types } = {}\n) => {\n  const { model = models.flash, system } = options\n\n  const apiKey = process.env.GEMINI_API_KEY\n\n  if (!apiKey) {\n    throw new APIError(500, 'Missing GEMINI_API_KEY')\n  }\n\n  const genAI = new GoogleGenerativeAI(apiKey)\n  const geminiModel = genAI.getGenerativeModel({ model })\n\n  try {\n    // Combine system prompt and user prompt if system is provided\n    const fullPrompt = system ? `${system}\\n\\n${prompt}` : prompt\n\n    const result = await geminiModel.generateContent(fullPrompt)\n    const response = result.response.text()\n\n    log('Gemini returned message:', response)\n    return response\n  } catch (error: any) {\n    log.error(`Error with Gemini API: ${error.message}`)\n    throw new APIError(500, 'Failed to get response from Gemini')\n  }\n}\n\n// Helper function to clean Gemini responses from markdown formatting\nconst removeJsonTicksFromGeminiResponse = (response: string): string => {\n  // Remove markdown code block formatting if present\n  const jsonBlockRegex = /```(?:json)?\\s*([\\s\\S]*?)```/\n  const match = response.match(jsonBlockRegex)\n\n  if (match && match[1]) {\n    return match[1].trim()\n  }\n\n  // If no markdown formatting found, return the original response\n  return response.trim()\n}\n\n// Helper function to ensure the response is valid JSON\nexport const parseGeminiResponseAsJson = (response: string): any => {\n  const cleanedResponse = removeJsonTicksFromGeminiResponse(response)\n\n  try {\n    // Try to parse as is\n    return JSON.parse(cleanedResponse)\n  } catch (error) {\n    // If parsing fails, try to handle common issues\n\n    // Check if it's an array wrapped in extra text\n    const arrayStart = cleanedResponse.indexOf('[')\n    const arrayEnd = cleanedResponse.lastIndexOf(']')\n\n    if (arrayStart !== -1 && arrayEnd !== -1 && arrayEnd > arrayStart) {\n      const potentialArray = cleanedResponse.substring(arrayStart, arrayEnd + 1)\n      try {\n        return JSON.parse(potentialArray)\n      } catch (e) {\n        // If still fails, throw the original error\n        throw error\n      }\n    }\n\n    // If we can't fix it, throw the original error\n    throw error\n  }\n}\n"
        }
      ]
    },
    {
      "sha": "eb2fc1492e3dd80f94c4b2554875a11689219d2b",
      "author": "Ian Philips",
      "date": "2025-05-22 11:10:02 -0700",
      "message": "Let creators abandon their groups",
      "stats": {
        "filesChanged": 3,
        "insertions": 33,
        "deletions": 37
      },
      "selectionReason": "Allows group creators to abandon their groups - implements user permission and group management functionality",
      "spec": "Update the topic interaction features: 1. In the topic title display area (`QuestionsTopicTitle`), wrap the topic name with a `Tooltip` component to show the full topic name on hover. 2. Consolidate topic following functionality by introducing a single toggle button in `QuestionsTopicTitle`. This button should: a. Display \"Follow\" with an outline bookmark icon when the user is not following the topic. b. Display \"Following\" with a filled bookmark icon when the user is following the topic. c. Toggle the user's follow status for the topic upon clicking, handling both follow and unfollow actions. d. Be disabled if the user is not authenticated, if the follow/unfollow action is in progress, or if the initial follow status is still loading/undetermined. e. Not be rendered for topics that are inherently un-followable (e.g., as identified by `TOPIC_IDS_YOU_CANT_FOLLOW`). This new button replaces the previous separate \"Follow\" button. 3. Remove the \"Unfollow\" option from the `TopicOptions` dropdown menu. Consequently, the `TopicOptions` component should no longer accept or utilize an `unfollow` prop, and any logic that conditionally showed the \"Unfollow\" option based on whether the user was the creator of the topic should be removed. 4. Modify the `useIsFollowingTopic` hook: ensure that the `isFollowing` state is not set to `false` if the user's authorization status (`isAuthorized`) is `undefined` (i.e., still loading). The hook should only set `isFollowing` to `false` due to lack of authorization if `isAuthorized` explicitly resolves to `false`; otherwise, it should await the API response to determine follow status when authorized.",
      "fileStates": [
        {
          "path": "web/components/topics/questions-topic-title.tsx",
          "preContent": "import { Group } from 'common/group'\nimport { BookmarkIcon, PlusCircleIcon } from '@heroicons/react/outline'\nimport { CopyLinkOrShareButton } from 'web/components/buttons/copy-link-button'\nimport { Button } from 'web/components/buttons/button'\nimport { AddContractToGroupModal } from 'web/components/topics/add-contract-to-group-modal'\nimport {\n  internalFollowTopic,\n  internalUnfollowTopic,\n} from 'web/components/topics/topics-button'\nimport { TopicOptions } from 'web/components/topics/topic-options'\nimport { Row } from 'web/components/layout/row'\nimport { useIsFollowingTopic } from 'web/hooks/use-group-supabase'\nimport { forwardRef, Ref, useState } from 'react'\n// import { TopicDropdown } from 'web/components/topics/topic-dropdown'\nimport { useIsMobile } from 'web/hooks/use-is-mobile'\nimport { TOPIC_IDS_YOU_CANT_FOLLOW } from 'common/supabase/groups'\nimport { getTopicShareUrl } from 'common/util/share'\nimport { useUser } from 'web/hooks/use-user'\n\nexport const QuestionsTopicTitle = forwardRef(\n  (props: { topic: Group; addAbout: () => void }, ref: Ref<HTMLDivElement>) => {\n    const { topic, addAbout } = props\n    const { isFollowing, setIsFollowing } = useIsFollowingTopic(topic.slug)\n    const [showAddContract, setShowAddContract] = useState(false)\n    const [loading, setLoading] = useState(false)\n    const user = useUser()\n    const isMobile = useIsMobile()\n\n    return (\n      <Row\n        className={\n          'col-span-8 h-11 justify-between gap-1 sm:mb-1 xl:col-span-7'\n        }\n        ref={ref}\n      >\n        <h1 className=\"text-primary-700 self-center truncate text-2xl\">\n          {topic.name}\n        </h1>\n        <Row>\n          <CopyLinkOrShareButton\n            url={getTopicShareUrl(topic.slug, user?.username)}\n            className={'gap-1 whitespace-nowrap'}\n            eventTrackingName={'copy questions page link'}\n            size={isMobile ? 'sm' : 'md'}\n          >\n            Share\n          </CopyLinkOrShareButton>\n          {isFollowing && !isMobile && user ? (\n            <>\n              <Button\n                color={'gray-white'}\n                size={isMobile ? 'sm' : 'md'}\n                className={'whitespace-nowrap'}\n                onClick={() => setShowAddContract(true)}\n              >\n                <Row>\n                  <PlusCircleIcon className={'mr-1 h-5 w-5'} />\n                  Add questions\n                </Row>\n              </Button>\n              {showAddContract && user && (\n                <AddContractToGroupModal\n                  group={topic}\n                  open={showAddContract}\n                  setOpen={setShowAddContract}\n                  user={user}\n                />\n              )}\n            </>\n          ) : (\n            !isFollowing &&\n            !TOPIC_IDS_YOU_CANT_FOLLOW.includes(topic.id) &&\n            user && (\n              <Button\n                color={'gray-white'}\n                className={'whitespace-nowrap'}\n                loading={loading}\n                size={isMobile ? 'sm' : 'md'}\n                onClick={() => {\n                  setLoading(true)\n                  internalFollowTopic(user, topic)\n                    .then(() => {\n                      setIsFollowing(true)\n                    })\n                    .finally(() => {\n                      setLoading(false)\n                    })\n                }}\n              >\n                {!loading && <BookmarkIcon className={'mr-1 h-5 w-5'} />}\n                Follow\n              </Button>\n            )\n          )}\n\n          <TopicOptions\n            group={topic}\n            isMember={!!isFollowing}\n            unfollow={() => {\n              setIsFollowing(false)\n              internalUnfollowTopic(user, topic).catch(() =>\n                // undo optimistic update\n                setIsFollowing(true)\n              )\n            }}\n            addAbout={addAbout}\n            user={user}\n            className={'flex [&_*]:flex [&_button]:pr-2'}\n          />\n        </Row>\n      </Row>\n    )\n  }\n)\n",
          "postContent": "import { Group } from 'common/group'\nimport { BookmarkIcon, PlusCircleIcon } from '@heroicons/react/outline'\nimport { BookmarkIcon as FilledBookmark } from '@heroicons/react/solid'\nimport { CopyLinkOrShareButton } from 'web/components/buttons/copy-link-button'\nimport { Button } from 'web/components/buttons/button'\nimport { AddContractToGroupModal } from 'web/components/topics/add-contract-to-group-modal'\nimport {\n  internalFollowTopic,\n  internalUnfollowTopic,\n} from 'web/components/topics/topics-button'\nimport { TopicOptions } from 'web/components/topics/topic-options'\nimport { Row } from 'web/components/layout/row'\nimport { useIsFollowingTopic } from 'web/hooks/use-group-supabase'\nimport { forwardRef, Ref, useState } from 'react'\nimport { useIsMobile } from 'web/hooks/use-is-mobile'\nimport { TOPIC_IDS_YOU_CANT_FOLLOW } from 'common/supabase/groups'\nimport { getTopicShareUrl } from 'common/util/share'\nimport { useUser } from 'web/hooks/use-user'\nimport { Tooltip } from '../widgets/tooltip'\n\nexport const QuestionsTopicTitle = forwardRef(\n  (props: { topic: Group; addAbout: () => void }, ref: Ref<HTMLDivElement>) => {\n    const { topic, addAbout } = props\n    const { isFollowing, setIsFollowing } = useIsFollowingTopic(topic.slug)\n    const [showAddContract, setShowAddContract] = useState(false)\n    const [loading, setLoading] = useState(false)\n    const user = useUser()\n    const isMobile = useIsMobile()\n\n    return (\n      <Row\n        className={\n          'col-span-8 h-11 justify-between gap-1 sm:mb-1 xl:col-span-7'\n        }\n        ref={ref}\n      >\n        <h1 className=\"text-primary-700 self-center truncate text-2xl\">\n          <Tooltip text={topic.name}>{topic.name}</Tooltip>\n        </h1>\n        <Row>\n          <CopyLinkOrShareButton\n            url={getTopicShareUrl(topic.slug, user?.username)}\n            className={'gap-1 whitespace-nowrap'}\n            eventTrackingName={'copy questions page link'}\n            size={isMobile ? 'sm' : 'md'}\n          >\n            Share\n          </CopyLinkOrShareButton>\n          {!TOPIC_IDS_YOU_CANT_FOLLOW.includes(topic.id) && (\n            <Button\n              color={'gray-white'}\n              className={'whitespace-nowrap'}\n              loading={loading}\n              disabled={loading || !user || isFollowing === undefined}\n              size={isMobile ? 'sm' : 'md'}\n              onClick={async () => {\n                setLoading(true)\n                if (isFollowing) {\n                  await internalUnfollowTopic(user, topic)\n                  setIsFollowing(false)\n                } else {\n                  await internalFollowTopic(user, topic)\n                  setIsFollowing(true)\n                }\n                setLoading(false)\n              }}\n            >\n              {loading ? null : isFollowing ? (\n                <FilledBookmark className={'mr-1 h-5 w-5'} />\n              ) : (\n                <BookmarkIcon className={'mr-1 h-5 w-5'} />\n              )}\n              {isFollowing ? 'Following' : 'Follow'}\n            </Button>\n          )}\n          {isFollowing && !isMobile && user ? (\n            <>\n              <Button\n                color={'gray-white'}\n                size={isMobile ? 'sm' : 'md'}\n                className={'whitespace-nowrap'}\n                onClick={() => setShowAddContract(true)}\n              >\n                <Row>\n                  <PlusCircleIcon className={'mr-1 h-5 w-5'} />\n                  Add questions\n                </Row>\n              </Button>\n              {showAddContract && user && (\n                <AddContractToGroupModal\n                  group={topic}\n                  open={showAddContract}\n                  setOpen={setShowAddContract}\n                  user={user}\n                />\n              )}\n            </>\n          ) : null}\n\n          <TopicOptions\n            group={topic}\n            isMember={!!isFollowing}\n            unfollow={() => {\n              setIsFollowing(false)\n              internalUnfollowTopic(user, topic).catch(() =>\n                // undo optimistic update\n                setIsFollowing(true)\n              )\n            }}\n            addAbout={addAbout}\n            user={user}\n            className={'flex [&_*]:flex [&_button]:pr-2'}\n          />\n        </Row>\n      </Row>\n    )\n  }\n)\n"
        },
        {
          "path": "web/components/topics/topic-options.tsx",
          "preContent": "import { Group, GroupRole, PrivacyStatusType } from 'common/group'\nimport { User } from 'common/user'\nimport { useState } from 'react'\nimport { useGroupRole } from 'web/hooks/use-group-supabase'\nimport { buildArray } from 'common/util/array'\nimport {\n  DotsVerticalIcon,\n  PencilIcon,\n  PlusIcon,\n  PlusCircleIcon,\n  TrashIcon,\n} from '@heroicons/react/solid'\nimport DropdownMenu, {\n  DropdownItem,\n} from 'web/components/widgets/dropdown-menu'\nimport clsx from 'clsx'\nimport { Modal } from 'web/components/layout/modal'\nimport { Col } from 'web/components/layout/col'\nimport { EditableTopicName } from 'web/components/topics/editable-topic-name'\nimport router from 'next/router'\nimport {\n  AddContractToGroupModal,\n  AddContractToGroupPermissionType,\n} from 'web/components/topics/add-contract-to-group-modal'\nimport { BsFillPersonDashFill } from 'react-icons/bs'\nimport { BiSolidVolumeMute } from 'react-icons/bi'\nimport { usePrivateUser } from 'web/hooks/use-user'\nimport { blockGroup, unBlockGroup } from 'web/components/topics/topic-dropdown'\nimport { useIsMobile } from 'web/hooks/use-is-mobile'\nimport { DeleteTopicModal } from './delete-topic-modal'\nimport { JSONEmpty } from 'web/components/contract/contract-description'\n\nexport function TopicOptions(props: {\n  group: Group\n  user: User | null | undefined\n  isMember: boolean\n  unfollow: () => void\n  addAbout: () => void\n  className?: string\n}) {\n  const { group, user, isMember, unfollow, addAbout, className } = props\n  const privateUser = usePrivateUser()\n  const [editingName, setEditingName] = useState(false)\n  const [showAddContract, setShowAddContract] = useState(false)\n  const [showDelete, setShowDelete] = useState(false)\n  const userRole = useGroupRole(group.id, user)\n  const isCreator = group.creatorId == user?.id\n  const isMobile = useIsMobile()\n\n  const hasAbout = !!group.about && !JSONEmpty(group.about)\n\n  const groupOptionItems = buildArray(\n    isMember &&\n      isMobile && {\n        name: 'Add questions',\n        icon: <PlusCircleIcon className=\"h-5 w-5\" />,\n        onClick: () => setShowAddContract(true),\n      },\n    userRole === 'admin' && {\n      name: 'Edit name',\n      icon: <PencilIcon className=\"h-5 w-5\" />,\n      onClick: () => setEditingName(true),\n    },\n    userRole === 'admin' &&\n      !hasAbout && {\n        name: 'Add description',\n        icon: <PlusIcon className=\"h-5 w-5\" />,\n        onClick: addAbout,\n      },\n    isMember &&\n      !isCreator && {\n        name: 'Unfollow',\n        icon: <BsFillPersonDashFill className=\"h-5 w-5\" />,\n        onClick: unfollow,\n      },\n    !isMember &&\n      privateUser && {\n        name: privateUser.blockedGroupSlugs?.includes(group.slug)\n          ? 'Unblock topic'\n          : 'Block topic',\n        icon: <BiSolidVolumeMute className=\"h-5 w-5\" />,\n        onClick: () =>\n          privateUser.blockedGroupSlugs?.includes(group.slug)\n            ? unBlockGroup(group.slug)\n            : blockGroup(group.slug),\n      },\n    userRole === 'admin' && {\n      name: 'Delete',\n      icon: <TrashIcon className=\"text-scarlet-500 h-5 w-5\" />,\n      onClick: () => setShowDelete(true),\n    }\n  ) as DropdownItem[]\n  return (\n    <>\n      <DropdownMenu\n        closeOnClick={true}\n        items={groupOptionItems}\n        buttonContent={<DotsVerticalIcon className={clsx('h-5 w-5')} />}\n        className={className}\n        menuItemsClass=\"flex flex-col\"\n        withinOverflowContainer={true}\n      />\n      <Modal open={editingName} setOpen={setEditingName}>\n        <Col className={'bg-canvas-50 rounded-md p-4'}>\n          <span className={'text-lg font-bold'}>Edit Topic Name</span>\n          <div className={''}>\n            <EditableTopicName\n              group={group}\n              isEditing={editingName}\n              onFinishEditing={(changed) => {\n                setEditingName(false)\n                if (changed) router.reload()\n              }}\n            />\n          </div>\n        </Col>\n      </Modal>\n      {showAddContract && user && (\n        <AddContractToGroupModal\n          group={group}\n          open={showAddContract}\n          setOpen={setShowAddContract}\n          user={user}\n        />\n      )}\n      <DeleteTopicModal\n        group={group}\n        open={showDelete}\n        setOpen={setShowDelete}\n      />\n    </>\n  )\n}\n\nexport function getAddContractToGroupPermission(\n  privacyStatus: PrivacyStatusType,\n  userRole: GroupRole | null | undefined,\n  isCreator?: boolean\n): AddContractToGroupPermissionType {\n  if (userRole === 'admin' || userRole === 'moderator' || isCreator) {\n    return 'any'\n  }\n  if (privacyStatus == 'public') {\n    return 'new'\n  }\n\n  return 'none'\n}\n",
          "postContent": "import { Group, GroupRole, PrivacyStatusType } from 'common/group'\nimport { User } from 'common/user'\nimport { useState } from 'react'\nimport { useGroupRole } from 'web/hooks/use-group-supabase'\nimport { buildArray } from 'common/util/array'\nimport {\n  DotsVerticalIcon,\n  PencilIcon,\n  PlusIcon,\n  PlusCircleIcon,\n  TrashIcon,\n} from '@heroicons/react/solid'\nimport DropdownMenu, {\n  DropdownItem,\n} from 'web/components/widgets/dropdown-menu'\nimport clsx from 'clsx'\nimport { Modal } from 'web/components/layout/modal'\nimport { Col } from 'web/components/layout/col'\nimport { EditableTopicName } from 'web/components/topics/editable-topic-name'\nimport router from 'next/router'\nimport {\n  AddContractToGroupModal,\n  AddContractToGroupPermissionType,\n} from 'web/components/topics/add-contract-to-group-modal'\nimport { BiSolidVolumeMute } from 'react-icons/bi'\nimport { usePrivateUser } from 'web/hooks/use-user'\nimport { blockGroup, unBlockGroup } from 'web/components/topics/topic-dropdown'\nimport { useIsMobile } from 'web/hooks/use-is-mobile'\nimport { DeleteTopicModal } from './delete-topic-modal'\nimport { JSONEmpty } from 'web/components/contract/contract-description'\n\nexport function TopicOptions(props: {\n  group: Group\n  user: User | null | undefined\n  isMember: boolean\n  unfollow: () => void\n  addAbout: () => void\n  className?: string\n}) {\n  const { group, user, isMember, addAbout, className } = props\n  const privateUser = usePrivateUser()\n  const [editingName, setEditingName] = useState(false)\n  const [showAddContract, setShowAddContract] = useState(false)\n  const [showDelete, setShowDelete] = useState(false)\n  const userRole = useGroupRole(group.id, user)\n  const isMobile = useIsMobile()\n\n  const hasAbout = !!group.about && !JSONEmpty(group.about)\n\n  const groupOptionItems = buildArray(\n    isMember &&\n      isMobile && {\n        name: 'Add questions',\n        icon: <PlusCircleIcon className=\"h-5 w-5\" />,\n        onClick: () => setShowAddContract(true),\n      },\n    userRole === 'admin' && {\n      name: 'Edit name',\n      icon: <PencilIcon className=\"h-5 w-5\" />,\n      onClick: () => setEditingName(true),\n    },\n    userRole === 'admin' &&\n      !hasAbout && {\n        name: 'Add description',\n        icon: <PlusIcon className=\"h-5 w-5\" />,\n        onClick: addAbout,\n      },\n    !isMember &&\n      privateUser && {\n        name: privateUser.blockedGroupSlugs?.includes(group.slug)\n          ? 'Unblock topic'\n          : 'Block topic',\n        icon: <BiSolidVolumeMute className=\"h-5 w-5\" />,\n        onClick: () =>\n          privateUser.blockedGroupSlugs?.includes(group.slug)\n            ? unBlockGroup(group.slug)\n            : blockGroup(group.slug),\n      },\n    userRole === 'admin' && {\n      name: 'Delete',\n      icon: <TrashIcon className=\"text-scarlet-500 h-5 w-5\" />,\n      onClick: () => setShowDelete(true),\n    }\n  ) as DropdownItem[]\n  return (\n    <>\n      <DropdownMenu\n        closeOnClick={true}\n        items={groupOptionItems}\n        buttonContent={<DotsVerticalIcon className={clsx('h-5 w-5')} />}\n        className={className}\n        menuItemsClass=\"flex flex-col\"\n        withinOverflowContainer={true}\n      />\n      <Modal open={editingName} setOpen={setEditingName}>\n        <Col className={'bg-canvas-50 rounded-md p-4'}>\n          <span className={'text-lg font-bold'}>Edit Topic Name</span>\n          <div className={''}>\n            <EditableTopicName\n              group={group}\n              isEditing={editingName}\n              onFinishEditing={(changed) => {\n                setEditingName(false)\n                if (changed) router.reload()\n              }}\n            />\n          </div>\n        </Col>\n      </Modal>\n      {showAddContract && user && (\n        <AddContractToGroupModal\n          group={group}\n          open={showAddContract}\n          setOpen={setShowAddContract}\n          user={user}\n        />\n      )}\n      <DeleteTopicModal\n        group={group}\n        open={showDelete}\n        setOpen={setShowDelete}\n      />\n    </>\n  )\n}\n\nexport function getAddContractToGroupPermission(\n  privacyStatus: PrivacyStatusType,\n  userRole: GroupRole | null | undefined,\n  isCreator?: boolean\n): AddContractToGroupPermissionType {\n  if (userRole === 'admin' || userRole === 'moderator' || isCreator) {\n    return 'any'\n  }\n  if (privacyStatus == 'public') {\n    return 'new'\n  }\n\n  return 'none'\n}\n"
        },
        {
          "path": "web/hooks/use-group-supabase.ts",
          "preContent": "import { Contract } from 'common/contract'\nimport { Group, GroupRole, Topic } from 'common/group'\nimport { User } from 'common/user'\nimport { useEffect, useState } from 'react'\nimport { api, getUserIsFollowingTopic } from 'web/lib/api/api'\nimport { db } from 'web/lib/supabase/db'\nimport {\n  getGroup,\n  getGroupFromSlug,\n  getMemberRole,\n} from 'web/lib/supabase/group'\nimport {\n  getGroupsWhereUserHasRole,\n  listGroupsBySlug,\n} from 'web/lib/supabase/groups'\nimport { usePersistentInMemoryState } from 'client-common/hooks/use-persistent-in-memory-state'\nimport { useIsAuthorized } from './use-user'\nimport { useAsyncData } from 'web/hooks/use-async-data'\nimport { isAdminId, isModId } from 'common/envs/constants'\n\nexport function useIsFollowingTopic(groupSlug?: string) {\n  const [isFollowing, setIsFollowing] = usePersistentInMemoryState<\n    boolean | undefined\n  >(undefined, 'is-member-' + groupSlug)\n  const isAuthorized = useIsAuthorized()\n  useEffect(() => {\n    if (!isAuthorized || !groupSlug) {\n      setIsFollowing(false)\n    } else {\n      getUserIsFollowingTopic({ groupSlug }).then((result) => {\n        setIsFollowing(result.isGroupMember)\n      })\n    }\n  }, [groupSlug, isAuthorized])\n  return { isFollowing, setIsFollowing }\n}\n\nexport function useMemberGroupIdsOnLoad(\n  userId: string | undefined | null\n): string[] | undefined {\n  const [groupIds, setGroupIds] = usePersistentInMemoryState<\n    string[] | undefined\n  >(undefined, `member-group-ids-${userId ?? ''}`)\n  useEffect(() => {\n    if (!userId) return\n    db.from('group_members')\n      .select('group_id')\n      .eq('member_id', userId)\n      .then((result) => {\n        if (result) {\n          const groupIds = (result as any).data.map((row: any) => row.group_id)\n          setGroupIds(groupIds)\n        }\n      })\n  }, [userId])\n  return groupIds\n}\n\nexport const useTopicsWithContract = (\n  contractId: string,\n  initial?: Topic[]\n) => {\n  const [topics, setTopics] = useState<Topic[]>(initial ?? [])\n\n  const addTopic = async (topic: Topic) => {\n    await api('market/:contractId/group', { contractId, groupId: topic.id })\n    setTopics((prev) => [...(prev ?? []), topic])\n  }\n\n  const removeTopic = async (topic: Topic) => {\n    await api('market/:contractId/group', {\n      contractId,\n      groupId: topic.id,\n      remove: true,\n    })\n    setTopics((prev) => prev?.filter((g) => g.id !== topic.id))\n  }\n\n  return { topics, addTopic, removeTopic }\n}\n\nexport function useNewUserMemberTopicsAndContracts(\n  user: User | null | undefined,\n  enabled: boolean\n) {\n  type TopicWithContracts = {\n    topic: Topic\n    contracts: Contract[]\n  }\n  const [groups, setGroups] = usePersistentInMemoryState<\n    TopicWithContracts[] | undefined\n  >(undefined, `member-topics-and-contracts-${user?.id ?? ''}`)\n\n  useEffect(() => {\n    if (!groups?.length) setGroups(undefined) // Show loading indicator right after selecting topics\n    if (enabled)\n      api('get-groups-with-top-contracts', {}).then((result) => {\n        setGroups(result)\n      })\n    else setGroups([])\n  }, [enabled, user?.shouldShowWelcome])\n\n  return groups\n}\n\nexport function useGroupRole(\n  groupId: string | undefined,\n  user: User | null | undefined\n) {\n  const [userRole, setUserRole] = useState<GroupRole | null | undefined>(\n    undefined\n  )\n  const isMod = !user ? false : isModId(user.id) || isAdminId(user.id)\n  useEffect(() => {\n    getTranslatedMemberRole(groupId, user).then((role) => setUserRole(role))\n  }, [user, groupId])\n\n  return isMod ? 'admin' : userRole\n}\n\nexport async function getTranslatedMemberRole(\n  groupId: string | undefined,\n  user: User | null | undefined\n) {\n  if (user && groupId) {\n    try {\n      return await getMemberRole(user, groupId)\n    } catch (e) {\n      console.error(e)\n    }\n  }\n  return null\n}\n\nexport function useGroupFromSlug(groupSlug: string) {\n  return useAsyncData(groupSlug, (slug) => getGroupFromSlug(slug))\n}\nexport function useGroupFromId(groupId: string) {\n  return useAsyncData(groupId, (id) => getGroup(id))\n}\n\nexport function useGroupsFromIds(groupIds: string[]) {\n  const groups = useAsyncData(groupIds, (ids) => Promise.all(ids.map(getGroup)))\n  return groups ? groups.filter((g): g is Group => !!g) : groups\n}\n\nexport function useListGroupsBySlug(groupSlugs: string[]) {\n  return useAsyncData(groupSlugs, listGroupsBySlug)\n}\n\nexport function useGroupsWhereUserHasRole(userId: string | undefined) {\n  return useAsyncData(userId, getGroupsWhereUserHasRole)\n}\n",
          "postContent": "import { Contract } from 'common/contract'\nimport { Group, GroupRole, Topic } from 'common/group'\nimport { User } from 'common/user'\nimport { useEffect, useState } from 'react'\nimport { api, getUserIsFollowingTopic } from 'web/lib/api/api'\nimport { db } from 'web/lib/supabase/db'\nimport {\n  getGroup,\n  getGroupFromSlug,\n  getMemberRole,\n} from 'web/lib/supabase/group'\nimport {\n  getGroupsWhereUserHasRole,\n  listGroupsBySlug,\n} from 'web/lib/supabase/groups'\nimport { usePersistentInMemoryState } from 'client-common/hooks/use-persistent-in-memory-state'\nimport { useIsAuthorized } from './use-user'\nimport { useAsyncData } from 'web/hooks/use-async-data'\nimport { isAdminId, isModId } from 'common/envs/constants'\n\nexport function useIsFollowingTopic(groupSlug?: string) {\n  const [isFollowing, setIsFollowing] = usePersistentInMemoryState<\n    boolean | undefined\n  >(undefined, 'is-member-' + groupSlug)\n  const isAuthorized = useIsAuthorized()\n  useEffect(() => {\n    if (isAuthorized === false || !groupSlug) {\n      setIsFollowing(false)\n    } else {\n      getUserIsFollowingTopic({ groupSlug }).then((result) => {\n        setIsFollowing(result.isGroupMember)\n      })\n    }\n  }, [groupSlug, isAuthorized])\n  return { isFollowing, setIsFollowing }\n}\n\nexport function useMemberGroupIdsOnLoad(\n  userId: string | undefined | null\n): string[] | undefined {\n  const [groupIds, setGroupIds] = usePersistentInMemoryState<\n    string[] | undefined\n  >(undefined, `member-group-ids-${userId ?? ''}`)\n  useEffect(() => {\n    if (!userId) return\n    db.from('group_members')\n      .select('group_id')\n      .eq('member_id', userId)\n      .then((result) => {\n        if (result) {\n          const groupIds = (result as any).data.map((row: any) => row.group_id)\n          setGroupIds(groupIds)\n        }\n      })\n  }, [userId])\n  return groupIds\n}\n\nexport const useTopicsWithContract = (\n  contractId: string,\n  initial?: Topic[]\n) => {\n  const [topics, setTopics] = useState<Topic[]>(initial ?? [])\n\n  const addTopic = async (topic: Topic) => {\n    await api('market/:contractId/group', { contractId, groupId: topic.id })\n    setTopics((prev) => [...(prev ?? []), topic])\n  }\n\n  const removeTopic = async (topic: Topic) => {\n    await api('market/:contractId/group', {\n      contractId,\n      groupId: topic.id,\n      remove: true,\n    })\n    setTopics((prev) => prev?.filter((g) => g.id !== topic.id))\n  }\n\n  return { topics, addTopic, removeTopic }\n}\n\nexport function useNewUserMemberTopicsAndContracts(\n  user: User | null | undefined,\n  enabled: boolean\n) {\n  type TopicWithContracts = {\n    topic: Topic\n    contracts: Contract[]\n  }\n  const [groups, setGroups] = usePersistentInMemoryState<\n    TopicWithContracts[] | undefined\n  >(undefined, `member-topics-and-contracts-${user?.id ?? ''}`)\n\n  useEffect(() => {\n    if (!groups?.length) setGroups(undefined) // Show loading indicator right after selecting topics\n    if (enabled)\n      api('get-groups-with-top-contracts', {}).then((result) => {\n        setGroups(result)\n      })\n    else setGroups([])\n  }, [enabled, user?.shouldShowWelcome])\n\n  return groups\n}\n\nexport function useGroupRole(\n  groupId: string | undefined,\n  user: User | null | undefined\n) {\n  const [userRole, setUserRole] = useState<GroupRole | null | undefined>(\n    undefined\n  )\n  const isMod = !user ? false : isModId(user.id) || isAdminId(user.id)\n  useEffect(() => {\n    getTranslatedMemberRole(groupId, user).then((role) => setUserRole(role))\n  }, [user, groupId])\n\n  return isMod ? 'admin' : userRole\n}\n\nexport async function getTranslatedMemberRole(\n  groupId: string | undefined,\n  user: User | null | undefined\n) {\n  if (user && groupId) {\n    try {\n      return await getMemberRole(user, groupId)\n    } catch (e) {\n      console.error(e)\n    }\n  }\n  return null\n}\n\nexport function useGroupFromSlug(groupSlug: string) {\n  return useAsyncData(groupSlug, (slug) => getGroupFromSlug(slug))\n}\nexport function useGroupFromId(groupId: string) {\n  return useAsyncData(groupId, (id) => getGroup(id))\n}\n\nexport function useGroupsFromIds(groupIds: string[]) {\n  const groups = useAsyncData(groupIds, (ids) => Promise.all(ids.map(getGroup)))\n  return groups ? groups.filter((g): g is Group => !!g) : groups\n}\n\nexport function useListGroupsBySlug(groupSlugs: string[]) {\n  return useAsyncData(groupSlugs, listGroupsBySlug)\n}\n\nexport function useGroupsWhereUserHasRole(userId: string | undefined) {\n  return useAsyncData(userId, getGroupsWhereUserHasRole)\n}\n"
        }
      ]
    },
    {
      "sha": "d6424f375771691943a35b3d6bea460c1a33c9f5",
      "author": "Ian Philips",
      "date": "2025-05-22 10:46:01 -0700",
      "message": "Track hide comments",
      "stats": {
        "filesChanged": 2,
        "insertions": 13,
        "deletions": 0
      },
      "selectionReason": "Simple feature addition to track comment hiding - demonstrates adding basic analytics/tracking functionality",
      "spec": "Modify the 'hide-comment' API endpoint. The endpoint must now return a JSON object with a 'success' boolean field, indicating the outcome of the operation (e.g., `{\"success\": true}`). Additionally, implement event tracking for this action: an event named 'hide_comment' should be dispatched when a comment is hidden or unhidden. This event must include the following properties: 'contractId', 'commentId', 'hidden' (a boolean representing the new visibility state), and 'userId' (the ID of the user performing the action).",
      "fileStates": [
        {
          "path": "backend/api/src/hide-comment.ts",
          "preContent": "import { isAdminId, isModId } from 'common/envs/constants'\nimport {\n  getContract,\n  getUser,\n  revalidateContractStaticProps,\n} from 'shared/utils'\nimport { getComment } from 'shared/supabase/contract-comments'\nimport { createSupabaseDirectClient } from 'shared/supabase/init'\nimport { updateData } from 'shared/supabase/utils'\nimport { APIError, type APIHandler } from './helpers/endpoint'\n\nexport const hideComment: APIHandler<'hide-comment'> = async (\n  { commentPath },\n  auth\n) => {\n  // Comment path is of the form /[username]/[contractId]/comment/[commentId] because firebase\n  const [, contractId, , commentId] = commentPath.split('/')\n  if (!contractId || !commentId) {\n    throw new APIError(\n      400,\n      'Invalid comment path. If you can read this, tell sinclair to change this endpoint to have more sensible inputs'\n    )\n  }\n\n  const pg = createSupabaseDirectClient()\n  const user = await getUser(auth.uid)\n  if (!user) throw new APIError(404, 'User not found')\n  if (user.isBannedFromPosting || user.userDeleted)\n    throw new APIError(\n      403,\n      'You are banned from posting or your account has been deleted'\n    )\n\n  const contract = await getContract(pg, contractId)\n  if (!contract) throw new APIError(404, 'Contract not found')\n\n  const isContractCreator = contract.creatorId === auth.uid\n\n  if (!isAdminId(auth.uid) && !isContractCreator && !isModId(auth.uid)) {\n    throw new APIError(\n      403,\n      'Only the market creator or mod can hide/unhide comments'\n    )\n  }\n\n  const comment = await getComment(pg, commentId)\n  const hide = !comment.hidden\n  if ((isAdminId(comment.userId) || isModId(comment.userId)) && hide) {\n    throw new APIError(403, 'You cannot hide comments from admins or mods')\n  }\n\n  // update the comment\n  await updateData(pg, 'contract_comments', 'comment_id', {\n    comment_id: commentId,\n    hidden: hide,\n    hiddenTime: hide ? Date.now() : undefined,\n    hiderId: auth.uid,\n  })\n\n  await revalidateContractStaticProps(contract)\n}\n",
          "postContent": "import { isAdminId, isModId } from 'common/envs/constants'\nimport {\n  getContract,\n  getUser,\n  revalidateContractStaticProps,\n} from 'shared/utils'\nimport { getComment } from 'shared/supabase/contract-comments'\nimport { createSupabaseDirectClient } from 'shared/supabase/init'\nimport { updateData } from 'shared/supabase/utils'\nimport { APIError, type APIHandler } from './helpers/endpoint'\nimport { trackPublicEvent } from 'shared/analytics'\n\nexport const hideComment: APIHandler<'hide-comment'> = async (\n  { commentPath },\n  auth\n) => {\n  // Comment path is of the form /[username]/[contractId]/comment/[commentId] because firebase\n  const [, contractId, , commentId] = commentPath.split('/')\n  if (!contractId || !commentId) {\n    throw new APIError(\n      400,\n      'Invalid comment path. If you can read this, tell sinclair to change this endpoint to have more sensible inputs'\n    )\n  }\n\n  const pg = createSupabaseDirectClient()\n  const user = await getUser(auth.uid)\n  if (!user) throw new APIError(404, 'User not found')\n  if (user.isBannedFromPosting || user.userDeleted)\n    throw new APIError(\n      403,\n      'You are banned from posting or your account has been deleted'\n    )\n\n  const contract = await getContract(pg, contractId)\n  if (!contract) throw new APIError(404, 'Contract not found')\n\n  const isContractCreator = contract.creatorId === auth.uid\n\n  if (!isAdminId(auth.uid) && !isContractCreator && !isModId(auth.uid)) {\n    throw new APIError(\n      403,\n      'Only the market creator or mod can hide/unhide comments'\n    )\n  }\n\n  const comment = await getComment(pg, commentId)\n  const hide = !comment.hidden\n  if ((isAdminId(comment.userId) || isModId(comment.userId)) && hide) {\n    throw new APIError(403, 'You cannot hide comments from admins or mods')\n  }\n\n  // update the comment\n  await updateData(pg, 'contract_comments', 'comment_id', {\n    comment_id: commentId,\n    hidden: hide,\n    hiddenTime: hide ? Date.now() : undefined,\n    hiderId: auth.uid,\n  })\n\n  await revalidateContractStaticProps(contract)\n  return {\n    result: { success: true },\n    continue: async () => {\n      await trackPublicEvent(auth.uid, 'hide_comment', {\n        contractId,\n        commentId,\n        hidden: hide,\n        userId: auth.uid,\n      })\n    },\n  }\n}\n"
        },
        {
          "path": "common/src/api/schema.ts",
          "preContent": "import { z } from 'zod'\nimport {\n  Group,\n  MAX_ID_LENGTH,\n  MySearchGroupShape,\n  LiteGroup,\n  SearchGroupParams,\n  SearchGroupShape,\n  Topic,\n} from 'common/group'\nimport {\n  createMarketProps,\n  resolveMarketProps,\n  type LiteMarket,\n  FullMarket,\n  updateMarketProps,\n} from './market-types'\nimport { type Answer } from 'common/answer'\nimport {\n  Comment,\n  CommentWithTotalReplies,\n  MAX_COMMENT_LENGTH,\n  PostComment,\n  type ContractComment,\n} from 'common/comment'\nimport { CandidateBet } from 'common/new-bet'\nimport type { Bet, LimitBet } from 'common/bet'\nimport { coerceBoolean, contentSchema } from 'common/api/zod-types'\nimport { AIGeneratedMarket, Contract, MarketContract } from 'common/contract'\nimport type { Txn, ManaPayTxn } from 'common/txn'\nimport { LiquidityProvision } from 'common/liquidity-provision'\nimport { DisplayUser, FullUser } from './user-types'\nimport { League } from 'common/leagues'\nimport { searchProps } from './market-search-types'\nimport { MAX_ANSWER_LENGTH } from 'common/answer'\nimport { type LinkPreview } from 'common/link-preview'\nimport { Headline } from 'common/news'\nimport { Row } from 'common/supabase/utils'\nimport { AnyBalanceChangeType } from 'common/balance-change'\nimport { Dashboard } from 'common/dashboard'\nimport { ChatMessage, PrivateChatMessage } from 'common/chat-message'\nimport { PrivateUser, User } from '../user'\nimport { ManaSupply } from 'common/stats'\nimport { Repost } from 'common/repost'\nimport { PERIODS } from 'common/period'\nimport { SWEEPS_MIN_BET } from 'common/economy'\nimport {\n  LivePortfolioMetrics,\n  PortfolioMetrics,\n} from 'common/portfolio-metrics'\nimport { ModReport } from '../mod-report'\n\nimport { RegistrationReturnType } from 'common/reason-codes'\nimport {\n  CheckoutSession,\n  GIDXDocument,\n  GPSProps,\n  PaymentDetail,\n  checkoutParams,\n  verificationParams,\n  cashoutRequestParams,\n  PendingCashoutStatusData,\n  cashoutParams,\n} from 'common/gidx/gidx'\nimport { notification_preference } from 'common/user-notification-preferences'\nimport { PrivateMessageChannel } from 'common/supabase/private-messages'\nimport { Notification } from 'common/notification'\nimport { NON_POINTS_BETS_LIMIT } from 'common/supabase/bets'\nimport { ContractMetric } from 'common/contract-metric'\n\nimport { JSONContent } from '@tiptap/core'\nimport { Task, TaskCategory } from 'common/todo'\nimport { ChartAnnotation } from 'common/supabase/chart-annotations'\nimport { Dictionary } from 'lodash'\nimport { Reaction } from 'common/reaction'\nimport { YEAR_MS } from 'common/util/time'\nimport { MarketDraft } from 'common/drafts'\nimport { TopLevelPost } from 'common/top-level-post'\n// mqp: very unscientific, just balancing our willingness to accept load\n// with user willingness to put up with stale data\nexport const DEFAULT_CACHE_STRATEGY =\n  'public, max-age=5, stale-while-revalidate=10'\nconst MAX_EXPIRES_AT = 1_000 * YEAR_MS\n\ntype APIGenericSchema = {\n  // GET is for retrieval, POST is to mutate something, PUT is idempotent mutation (can be repeated safely)\n  method: 'GET' | 'POST' | 'PUT'\n  //private APIs can only be called from manifold. undocumented endpoints can change or be deleted at any time!\n  visibility: 'public' | 'undocumented' | 'private'\n  // whether the endpoint requires authentication\n  authed: boolean\n  // zod schema for the request body (or for params for GET requests)\n  props: z.ZodType\n  // note this has to be JSON serializable\n  returns?: Record<string, any>\n  // Cache-Control header. like, 'max-age=60'\n  cache?: string\n  // whether the endpoint should prefer authentication even if not required\n  preferAuth?: boolean\n}\n\nlet _apiTypeCheck: { [x: string]: APIGenericSchema }\nexport const API = (_apiTypeCheck = {\n  'refresh-all-clients': {\n    method: 'POST',\n    visibility: 'public',\n    props: z.object({ message: z.string().optional() }),\n    authed: true,\n  },\n  'toggle-system-trading-status': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        token: z.enum(['MANA', 'CASH']),\n      })\n      .strict(),\n    returns: {} as { status: boolean },\n  },\n  comment: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as ContractComment,\n    props: z\n      .object({\n        contractId: z.string(),\n        content: contentSchema.optional(),\n        html: z.string().optional(),\n        markdown: z.string().optional(),\n        replyToCommentId: z.string().optional(),\n        replyToAnswerId: z.string().optional(),\n        replyToBetId: z.string().optional(),\n      })\n      .strict(),\n  },\n\n  'follow-contract': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: true },\n    props: z\n      .object({\n        contractId: z.string(),\n        follow: z.boolean(),\n      })\n      .strict(),\n  },\n  'get-contract': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as Contract,\n    props: z\n      .object({\n        contractId: z.string(),\n      })\n      .strict(),\n  },\n  'answer/:answerId': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as Answer,\n    props: z.object({ answerId: z.string() }).strict(),\n  },\n  'market/:contractId/answers': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: [] as Answer[],\n    props: z.object({ contractId: z.string() }).strict(),\n  },\n  'hide-comment': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ commentPath: z.string() }).strict(),\n  },\n  'pin-comment': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({ commentPath: z.string() }).strict(),\n  },\n  comments: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    // cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as ContractComment[],\n    props: z\n      .object({\n        contractId: z.string().optional(),\n        contractSlug: z.string().optional(),\n        afterTime: z.coerce.number().optional(),\n        limit: z.coerce.number().gte(0).lte(1000).default(1000),\n        page: z.coerce.number().gte(0).default(0),\n        userId: z.string().optional(),\n        isPolitics: coerceBoolean.optional(),\n      })\n      .strict(),\n  },\n  'user-comments': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: [] as Comment[],\n    props: z\n      .object({\n        afterTime: z.coerce.number().optional(),\n        limit: z.coerce.number().gte(0).lte(1000).default(1000),\n        page: z.coerce.number().gte(0).default(0),\n        userId: z.string(),\n      })\n      .strict(),\n  },\n  bet: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as CandidateBet & { betId: string },\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gte(SWEEPS_MIN_BET),\n        replyToCommentId: z.string().optional(),\n        limitProb: z.number().gte(0.01).lte(0.99).optional(),\n        expiresMillisAfter: z.number().lt(MAX_EXPIRES_AT).optional(),\n        silent: z.boolean().optional(),\n        expiresAt: z.number().lt(MAX_EXPIRES_AT).optional(),\n        // Used for binary and new multiple choice contracts (cpmm-multi-1).\n        outcome: z.enum(['YES', 'NO']).default('YES'),\n        //Multi\n        answerId: z.string().optional(),\n        dryRun: z.boolean().optional(),\n        deps: z.array(z.string()).optional(),\n        deterministic: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  createuser: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { user: User; privateUser: PrivateUser },\n    props: z\n      .object({\n        deviceToken: z.string().optional(),\n        adminToken: z.string().optional(),\n        visitedContractIds: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'multi-bet': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as (CandidateBet & { betId: string })[],\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gte(1),\n        limitProb: z.number().gte(0).lte(1).optional(),\n        expiresAt: z.number().lt(MAX_EXPIRES_AT).optional(),\n        answerIds: z.array(z.string()).min(1),\n        deterministic: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  'multi-sell': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as (CandidateBet & { betId: string })[],\n    props: z\n      .object({\n        contractId: z.string(),\n        answerIds: z.array(z.string()).min(1),\n        deterministic: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  leaderboard: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as { userId: string; score: number }[],\n    props: z\n      .object({\n        groupId: z.string().optional(),\n        limit: z.coerce.number().min(1).max(100).default(50),\n        token: z.enum(['MANA', 'CASH']).default('MANA'),\n        kind: z.enum(['creator', 'profit', 'loss', 'volume', 'referral']),\n      })\n      .strict(),\n  },\n  'verify-phone-number': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { status: string },\n    props: z\n      .object({\n        phoneNumber: z.string(),\n        code: z.string(),\n      })\n      .strict(),\n  },\n  'request-otp': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { status: string },\n    props: z\n      .object({\n        phoneNumber: z.string(),\n      })\n      .strict(),\n  },\n  'bet/cancel/:betId': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ betId: z.string() }).strict(),\n    returns: {} as LimitBet,\n  },\n  // sell shares\n  'market/:contractId/sell': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as CandidateBet & { betId: string },\n    props: z\n      .object({\n        contractId: z.string(),\n        shares: z.number().positive().optional(), // leave it out to sell all shares\n        outcome: z.enum(['YES', 'NO']),\n        answerId: z.string().optional(), // Required for multi binary markets\n        deterministic: z.boolean().optional(),\n        deps: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'get-user-limit-orders-with-contracts': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as {\n      bets: LimitBet[]\n      contracts: MarketContract[]\n    },\n    props: z\n      .object({\n        userId: z.string(),\n        count: z.coerce.number().lte(5000),\n        includeExpired: coerceBoolean.optional().default(false),\n        includeCancelled: coerceBoolean.optional().default(false),\n        includeFilled: coerceBoolean.optional().default(false),\n      })\n      .strict(),\n  },\n  'get-interesting-groups-from-views': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as (Group & { hasBet: boolean })[],\n    props: z\n      .object({\n        userId: z.string(),\n        contractIds: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  bets: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Bet[],\n    props: z\n      .object({\n        id: z.string().optional(),\n        userId: z.string().optional(),\n        username: z.string().optional(),\n        contractId: z.string().or(z.array(z.string())).optional(),\n        contractSlug: z.string().optional(),\n        answerId: z.string().optional(),\n        // market: z.string().optional(), // deprecated, synonym for `contractSlug`\n        limit: z.coerce\n          .number()\n          .gte(0)\n          .lte(50000)\n          .default(NON_POINTS_BETS_LIMIT),\n        before: z.string().optional(),\n        after: z.string().optional(),\n        beforeTime: z.coerce.number().optional(),\n        afterTime: z.coerce.number().optional(),\n        order: z.enum(['asc', 'desc']).optional(),\n        kinds: z.enum(['open-limit']).optional(),\n        // undocumented fields. idk what a good api interface would be\n        filterRedemptions: coerceBoolean.optional(),\n        includeZeroShareRedemptions: coerceBoolean.optional(),\n        commentRepliesOnly: coerceBoolean.optional(),\n        count: coerceBoolean.optional(),\n        points: coerceBoolean.optional(),\n      })\n      .strict(),\n  },\n  'bet-points': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: 'public, max-age=600, stale-while-revalidate=60',\n    returns: [] as Bet[],\n    props: z\n      .object({\n        contractId: z.string(),\n        answerId: z.string().optional(),\n        limit: z.coerce.number().gte(0).lte(50000).default(5000),\n        beforeTime: z.coerce.number(),\n        afterTime: z.coerce.number(),\n        filterRedemptions: coerceBoolean.optional(),\n        includeZeroShareRedemptions: coerceBoolean.optional(),\n      })\n      .strict(),\n  },\n  'unique-bet-group-count': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as { count: number },\n    props: z\n      .object({\n        contractId: z.string(),\n      })\n      .strict(),\n  },\n  'get-daily-changed-metrics-and-contracts': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    cache: 'public, max-age=900, stale-while-revalidate=90', // 15 minute cache\n    props: z\n      .object({\n        limit: z.coerce.number(),\n        userId: z.string(),\n        balance: z.coerce.number(),\n      })\n      .strict(),\n    returns: {} as {\n      manaMetrics: ContractMetric[]\n      contracts: MarketContract[]\n      manaProfit: number\n      manaInvestmentValue: number\n      balance: number\n    },\n  },\n  // deprecated. use /bets?username= instead\n  'user/:username/bets': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Bet[],\n    props: z\n      .object({\n        username: z.string(),\n        limit: z.coerce.number().gte(0).lte(1000).default(1000),\n      })\n      .strict(),\n  },\n  'group/:slug': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as Group,\n    props: z.object({ slug: z.string() }),\n  },\n  'group/:slug/groups': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as { above: LiteGroup[]; below: LiteGroup[] },\n    props: z.object({ slug: z.string() }).strict(),\n  },\n  'group/:slug/dashboards': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as {\n      id: string\n      title: string\n      slug: string\n      creatorId: string\n    }[],\n    props: z.object({ slug: z.string() }).strict(),\n  },\n  'group/by-id/:id/groups': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as { above: LiteGroup[]; below: LiteGroup[] },\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'group/by-id/:id': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as Group,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  // deprecated. use /markets?groupId= instead\n  'group/by-id/:id/markets': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as LiteMarket[],\n    props: z\n      .object({\n        id: z.string(),\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n      })\n      .strict(),\n  },\n  'group/:slug/delete': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ slug: z.string() }),\n  },\n  'group/by-id/:id/delete': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ id: z.string() }),\n  },\n  'group/:slug/block': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ slug: z.string() }),\n  },\n  'group/:slug/unblock': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ slug: z.string() }).strict(),\n  },\n  'group/by-id/:topId/group/:bottomId': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        topId: z.string(),\n        bottomId: z.string(),\n        remove: z.boolean().optional(),\n      })\n      .strict(),\n    returns: {} as { status: 'success' },\n  },\n  groups: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Group[],\n    props: z\n      .object({\n        availableToUserId: z.string().optional(),\n        beforeTime: z.coerce.number().int().optional(),\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n      })\n      .strict(),\n  },\n  'market/:id': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as LiteMarket | FullMarket,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z.object({ id: z.string(), lite: coerceBoolean.optional() }),\n  },\n  'market/:id/prob': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as {\n      prob?: number\n      answerProbs?: { [answerId: string]: number }\n    },\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'market-probs': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as {\n      [contractId: string]: {\n        prob?: number\n        answerProbs?: { [answerId: string]: number }\n      }\n    },\n    props: z\n      .object({\n        ids: z.array(z.string()).max(100),\n      })\n      .strict(),\n  },\n  'markets-by-ids': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: [] as Contract[],\n    props: z\n      .object({\n        ids: z.array(z.string()).max(100),\n      })\n      .strict(),\n  },\n  // deprecated. use /market/:id?lite=true instead\n  'market/:id/lite': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as LiteMarket,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z.object({ id: z.string() }),\n  },\n  'slug/:slug': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as LiteMarket | FullMarket,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z.object({ slug: z.string(), lite: coerceBoolean.optional() }),\n  },\n  market: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as LiteMarket,\n    props: createMarketProps,\n  },\n  'market/:contractId/update': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: updateMarketProps,\n    returns: {} as { success: true },\n  },\n  'market/:contractId/close': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    // returns: {} as LiteMarket,\n    props: z\n      .object({\n        contractId: z.string(),\n        closeTime: z.number().int().nonnegative().optional(),\n      })\n      .strict(),\n  },\n  'market/:contractId/resolve': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { message: string },\n    props: resolveMarketProps,\n  },\n  'market/:contractId/add-liquidity': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as LiquidityProvision,\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gt(0).finite(),\n      })\n      .strict(),\n  },\n  'market/:contractId/remove-liquidity': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as LiquidityProvision,\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gt(0).finite(),\n      })\n      .strict(),\n  },\n  'market/:contractId/add-bounty': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as Txn,\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gt(0).finite(),\n      })\n      .strict(),\n  },\n  'market/:contractId/award-bounty': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as Txn,\n    props: z\n      .object({\n        contractId: z.string(),\n        commentId: z.string(),\n        amount: z.number().gt(0).finite(),\n      })\n      .strict(),\n  },\n  'market/:contractId/group': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        contractId: z.string(),\n        groupId: z.string(),\n        remove: z.boolean().default(false),\n      })\n      .strict(),\n    returns: {} as { success: true },\n  },\n  'market/:contractId/groups': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({ contractId: z.string() }),\n    returns: [] as LiteGroup[],\n  },\n  'market/:contractId/answer': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { newAnswerId: string },\n    props: z\n      .object({\n        contractId: z.string().max(MAX_ANSWER_LENGTH),\n        text: z.string().min(1).max(MAX_ANSWER_LENGTH),\n      })\n      .strict(),\n  },\n  'market/:contractId/block': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ contractId: z.string() }).strict(),\n  },\n  'market/:contractId/unblock': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ contractId: z.string() }).strict(),\n  },\n  unresolve: {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { success: true },\n    props: z\n      .object({\n        contractId: z.string().max(MAX_ANSWER_LENGTH),\n        answerId: z.string().max(MAX_ANSWER_LENGTH).optional(),\n      })\n      .strict(),\n  },\n  leagues: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as League[],\n    props: z\n      .object({\n        userId: z.string().optional(),\n        cohort: z.string().optional(),\n        season: z.coerce.number().optional(),\n      })\n      .strict(),\n  },\n  markets: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as LiteMarket[],\n    props: z\n      .object({\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n        sort: z\n          .enum([\n            'created-time',\n            'updated-time',\n            'last-bet-time',\n            'last-comment-time',\n          ])\n          .optional(),\n        order: z.enum(['asc', 'desc']).optional(),\n        before: z.string().optional(),\n        userId: z.string().optional(),\n        groupId: z.string().optional(),\n      })\n      .strict(),\n  },\n  'search-markets': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as LiteMarket[],\n    props: searchProps,\n  },\n  'search-markets-full': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    preferAuth: true,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Contract[],\n    props: searchProps,\n  },\n  managram: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        amount: z.number().finite(),\n        toIds: z.array(z.string()),\n        message: z.string().max(MAX_COMMENT_LENGTH),\n        groupId: z.string().max(MAX_ID_LENGTH).optional(),\n        token: z.enum(['M$', 'CASH']).default('M$'),\n      })\n      .strict(),\n  },\n  manalink: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { slug: string },\n    props: z\n      .object({\n        amount: z.number().positive().finite().safe(),\n        expiresTime: z.number().lt(MAX_EXPIRES_AT).optional(),\n        maxUses: z.number().optional(),\n        message: z.string().optional(),\n      })\n      .strict(),\n  },\n  donate: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        amount: z.number().positive().finite().safe(),\n        to: z.string(),\n      })\n      .strict(),\n  },\n  'convert-sp-to-mana': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ amount: z.number().positive().finite().safe() }).strict(),\n  },\n  'convert-cash-to-mana': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ amount: z.number().positive().finite().safe() }).strict(),\n  },\n  'request-loan': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({}),\n    returns: {} as { payout: number },\n  },\n  // deprecated. use /txns instead\n  managrams: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: [] as ManaPayTxn[],\n    props: z\n      .object({\n        toId: z.string().optional(),\n        fromId: z.string().optional(),\n        limit: z.coerce.number().gte(0).lte(100).default(100),\n        before: z.coerce.number().optional(),\n        after: z.coerce.number().optional(),\n      })\n      .strict(),\n  },\n  'market/:id/positions': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as ContractMetric[],\n    props: z\n      .object({\n        id: z.string(),\n        userId: z.string().optional(),\n        answerId: z.string().optional(),\n        summaryOnly: z.boolean().optional(),\n        top: z.undefined().or(z.coerce.number()),\n        bottom: z.undefined().or(z.coerce.number()),\n        order: z.enum(['shares', 'profit']).optional(),\n      })\n      .strict(),\n  },\n  me: {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z.object({}),\n    returns: {} as FullUser,\n  },\n  'me/update': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({\n      name: z.string().trim().min(1).optional(),\n      username: z.string().trim().min(1).optional(),\n      avatarUrl: z.string().optional(),\n      bio: z.string().optional(),\n      website: z.string().optional(),\n      twitterHandle: z.string().optional(),\n      discordHandle: z.string().optional(),\n      // settings\n      optOutBetWarnings: z.boolean().optional(),\n      isAdvancedTrader: z.boolean().optional(),\n      //internal\n      seenStreakModal: z.boolean().optional(),\n      shouldShowWelcome: z.boolean().optional(),\n      hasSeenContractFollowModal: z.boolean().optional(),\n      hasSeenLoanModal: z.boolean().optional(),\n    }),\n    returns: {} as FullUser,\n  },\n  'me/delete': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({\n      username: z.string(), // just so you're sure\n    }),\n  },\n  'me/private': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z.object({}),\n    returns: {} as PrivateUser,\n  },\n  'me/private/update': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    props: z\n      .object({\n        email: z.string().email().optional(),\n        apiKey: z.string().optional(),\n        pushToken: z.string().optional(),\n        rejectedPushNotificationsOn: z.number().optional(),\n        lastPromptedToEnablePushNotifications: z.number().optional(),\n        interestedInPushNotifications: z.boolean().optional(),\n        hasSeenAppBannerInNotificationsOn: z.number().optional(),\n        installedAppPlatforms: z.array(z.string()).optional(),\n        paymentInfo: z.string().optional(),\n        lastAppReviewTime: z.number().optional(),\n      })\n      .strict(),\n  },\n  'user/:username': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as FullUser,\n    props: z.object({ username: z.string() }).strict(),\n  },\n  'user/:username/lite': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as DisplayUser,\n    props: z.object({ username: z.string() }).strict(),\n  },\n  'user/by-id/:id': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    // Do not add a caching strategy here. New users need up-to-date data.\n    returns: {} as FullUser,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'user/by-id/:id/lite': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as DisplayUser,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'users/by-id': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as DisplayUser[],\n    props: z.object({ ids: z.array(z.string()) }).strict(),\n  },\n  'users/by-id/balance': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as { id: string; balance: number }[],\n    props: z.object({ ids: z.array(z.string()) }).strict(),\n  },\n  'user/by-id/:id/block': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'user/by-id/:id/unblock': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  users: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as FullUser[],\n    props: z\n      .object({\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n        before: z.string().optional(),\n      })\n      .strict(),\n  },\n  'search-users': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as FullUser[],\n    props: z\n      .object({\n        term: z.string(),\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n        page: z.coerce.number().gte(0).default(0),\n      })\n      .strict(),\n  },\n  'search-contract-positions': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as DisplayUser[],\n    props: z\n      .object({\n        term: z.string(),\n        contractId: z.string(),\n        limit: z.coerce.number().gte(0).lte(100).default(10),\n      })\n      .strict(),\n  },\n  'save-twitch': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        twitchInfo: z.object({\n          twitchName: z.string().optional(),\n          controlToken: z.string().optional(),\n          botEnabled: z.boolean().optional(),\n          needsRelinking: z.boolean().optional(),\n        }),\n      })\n      .strict(),\n  },\n  'set-push-token': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({ pushToken: z.string() }).strict(),\n  },\n  'update-notif-settings': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      type: z.string() as z.ZodType<notification_preference>,\n      medium: z.enum(['email', 'browser', 'mobile']),\n      enabled: z.boolean(),\n    }),\n  },\n  headlines: {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: [] as Headline[],\n    props: z.object({\n      slug: z.enum(['politics', 'ai', 'news']).optional(),\n    }),\n  },\n  'politics-headlines': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: [] as Headline[],\n    props: z.object({}),\n  },\n  'set-news': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { success: true },\n    props: z\n      .object({\n        dashboardIds: z.array(z.string()),\n        endpoint: z.enum(['politics', 'ai', 'news']),\n      })\n      .strict(),\n  },\n  react: {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        contentId: z.string(),\n        contentType: z.enum(['comment', 'contract', 'post']),\n        commentParentType: z.enum(['post']).optional(),\n        remove: z.boolean().optional(),\n        reactionType: z.enum(['like', 'dislike']).optional().default('like'),\n      })\n      .strict(),\n    returns: { success: true },\n  },\n  post: {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    returns: {} as ContractComment,\n    props: z\n      .object({\n        contractId: z.string(),\n        betId: z.string().optional(),\n        commentId: z.string().optional(),\n        content: contentSchema.optional(),\n      })\n      .strict(),\n  },\n  'fetch-link-preview': {\n    method: 'GET',\n    visibility: 'private',\n    authed: false,\n    props: z.object({ url: z.string() }).strict(),\n    cache: 'max-age=86400, stale-while-revalidate=86400',\n    returns: {} as LinkPreview,\n  },\n  'get-related-markets': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    props: z\n      .object({\n        contractId: z.string(),\n        limit: z.coerce.number().gte(0).lte(100),\n        userId: z.string().optional(),\n        question: z.string().optional(),\n        uniqueBettorCount: z.coerce.number().gte(0).optional(),\n      })\n      .strict(),\n    returns: {} as {\n      marketsFromEmbeddings: Contract[]\n    },\n    cache: 'public, max-age=3600, stale-while-revalidate=10',\n  },\n  'get-related-markets-by-group': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: 'public, max-age=3600, stale-while-revalidate=10',\n    returns: {} as {\n      groupContracts: Contract[]\n    },\n    props: z\n      .object({\n        contractId: z.string(),\n        limit: z.coerce.number().gte(0).lte(100),\n        offset: z.coerce.number().gte(0),\n      })\n      .strict(),\n  },\n  'unlist-and-cancel-user-contracts': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        userId: z.string(),\n      })\n      .strict(),\n  },\n  'get-boost-analytics': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: false,\n    props: z\n      .object({\n        contractId: z.string(),\n      })\n      .strict(),\n    returns: {} as {\n      uniqueViewers: number\n      totalViews: number\n      uniquePromotedViewers: number\n      totalPromotedViews: number\n      boostPeriods: {\n        startTime: string\n        endTime: string\n      }[]\n    },\n  },\n  'get-seen-market-ids': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      contractIds: z.array(z.string()),\n      types: z.array(z.enum(['page', 'card', 'promoted'])).optional(),\n      since: z.number(),\n    }),\n    returns: [] as string[],\n  },\n  'search-groups': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    // Is there a way to infer return { lite:[] as LiteGroup[] } if type is 'lite'?\n    returns: {\n      full: [] as Group[],\n      lite: [] as LiteGroup[],\n    },\n    props: SearchGroupParams(SearchGroupShape),\n  },\n  'search-my-groups': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {\n      full: [] as Group[],\n      lite: [] as LiteGroup[],\n    },\n    props: SearchGroupParams(MySearchGroupShape),\n  },\n  'get-groups-with-top-contracts': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as { topic: Topic; contracts: Contract[] }[],\n    props: z.object({}),\n  },\n  'get-balance-changes': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: [] as AnyBalanceChangeType[],\n    props: z\n      .object({\n        before: z.coerce.number().optional(),\n        after: z.coerce.number().default(0),\n        userId: z.string(),\n      })\n      .strict(),\n  },\n  'get-partner-stats': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z\n      .object({\n        userId: z.string(),\n      })\n      .strict(),\n    returns: {} as {\n      status: 'success' | 'error'\n      username: string\n      numContractsCreated: number\n      numUniqueBettors: number\n      numReferrals: number\n      numReferralsWhoRetained: number\n      totalTraderIncome: number\n      totalReferralIncome: number\n      dollarsEarned: number\n    },\n  },\n  'record-contract-view': {\n    method: 'POST',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      userId: z.string().optional(),\n      contractId: z.string(),\n      kind: z.enum(['page', 'card', 'promoted']),\n    }),\n    returns: {} as { status: 'success' },\n  },\n  'record-comment-view': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({\n      contractId: z.string(),\n      commentId: z.string(),\n    }),\n    returns: {} as { status: 'success' },\n  },\n  'record-contract-interaction': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({\n      contractId: z.string(),\n      kind: z.enum([\n        'page bet',\n        'page comment',\n        'page repost',\n        'page like',\n        'card bet',\n        'card click',\n        'promoted click',\n        'card like',\n        'page share',\n        'browse click',\n      ]),\n      commentId: z.string().optional(),\n      feedReasons: z.array(z.string()).optional(),\n      feedType: z.string().optional(),\n      betGroupId: z.string().optional(),\n      betId: z.string().optional(),\n    }),\n    returns: {} as { status: 'success' },\n  },\n  'get-dashboard-from-slug': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      dashboardSlug: z.string(),\n    }),\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as Dashboard,\n  },\n  'get-posts': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    preferAuth: true,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z\n      .object({\n        sortBy: z\n          .enum(['created_time', 'importance_score'])\n          .optional()\n          .default('created_time'),\n        term: z.string().optional(),\n        limit: z.coerce.number().gte(0).lte(200).default(100),\n        userId: z.string().optional(),\n        offset: z.coerce.number().gte(0).default(0),\n        isChangeLog: coerceBoolean.optional(),\n      })\n      .strict(),\n    returns: [] as TopLevelPost[],\n  },\n  'create-public-chat-message': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as ChatMessage,\n    props: z.object({\n      content: contentSchema,\n      channelId: z.string(),\n    }),\n  },\n  'get-followed-groups': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      userId: z.string(),\n    }),\n    returns: {} as {\n      groups: Group[]\n    },\n  },\n  'get-user-portfolio': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      userId: z.string(),\n    }),\n    returns: {} as LivePortfolioMetrics,\n  },\n  'get-user-portfolio-history': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      userId: z.string(),\n      period: z.enum(PERIODS),\n    }),\n    returns: {} as PortfolioMetrics[],\n  },\n  'get-channel-memberships': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      channelId: z.coerce.number().optional(),\n      createdTime: z.string().optional(),\n      lastUpdatedTime: z.string().optional(),\n      limit: z.coerce.number(),\n    }),\n    returns: {\n      channels: [] as PrivateMessageChannel[],\n      memberIdsByChannelId: {} as { [channelId: string]: string[] },\n    },\n  },\n  'get-channel-messages': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      channelId: z.coerce.number(),\n      limit: z.coerce.number(),\n      id: z.coerce.number().optional(),\n    }),\n    returns: [] as PrivateChatMessage[],\n  },\n  'get-channel-seen-time': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      channelIds: z.array(z.coerce.number()),\n    }),\n    returns: [] as [number, string][],\n  },\n  'set-channel-seen-time': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      channelId: z.coerce.number(),\n    }),\n  },\n  'get-feed': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as {\n      contracts: Contract[]\n      comments: ContractComment[]\n      bets: Bet[]\n      reposts: Repost[]\n      idsToReason: { [id: string]: string }\n    },\n    props: z\n      .object({\n        userId: z.string(),\n        limit: z.coerce.number().gt(0).lte(100).default(100),\n        offset: z.coerce.number().gte(0).default(0),\n        ignoreContractIds: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'get-mana-supply': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as ManaSupply,\n    props: z.object({}).strict(),\n  },\n  'get-notifications': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as Notification[],\n    props: z\n      .object({\n        after: z.coerce.number().optional(),\n        limit: z.coerce.number().gte(0).lte(1000).default(100),\n      })\n      .strict(),\n  },\n  'update-mod-report': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        reportId: z.number(),\n        updates: z\n          .object({\n            status: z\n              .enum(['new', 'under review', 'resolved', 'needs admin'])\n              .optional(),\n            mod_note: z.string().optional(),\n          })\n          .partial(),\n      })\n      .strict(),\n    returns: {} as { status: string; report: ModReport },\n  },\n  'get-mod-reports': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        statuses: z.array(\n          z.enum(['new', 'under review', 'resolved', 'needs admin'])\n        ),\n        limit: z.coerce.number().gte(0).lte(100).default(25),\n        offset: z.coerce.number().gte(0).default(0),\n        count: coerceBoolean.optional(),\n      })\n      .strict(),\n    returns: {} as {\n      status: string\n      count?: number\n      reports: ModReport[]\n    },\n  },\n  'get-txn-summary-stats': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as Row<'txn_summary_stats'>[],\n    props: z\n      .object({\n        ignoreCategories: z.array(z.string()).optional(),\n        fromType: z.string().optional(),\n        toType: z.string().optional(),\n        limitDays: z.coerce.number(),\n      })\n      .strict(),\n  },\n  'get-mana-summary-stats': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as Row<'mana_supply_stats'>[],\n    props: z\n      .object({\n        limitDays: z.coerce.number(),\n      })\n      .strict(),\n  },\n  'register-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: verificationParams,\n    returns: {} as RegistrationReturnType,\n  },\n  'get-verification-status-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      documents?: GIDXDocument[]\n      message?: string\n      documentStatus?: string\n    },\n    props: z.object({}),\n  },\n  'get-monitor-status-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n    },\n    props: z.object({\n      DeviceGPS: GPSProps,\n    }),\n  },\n  'get-checkout-session-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n      session?: CheckoutSession\n    },\n    props: z.object({\n      PayActionCode: z.enum(['PAY', 'PAYOUT']).default('PAY'),\n      DeviceGPS: GPSProps,\n      userId: z.string().optional(),\n      ip: z.string().optional(),\n    }),\n  },\n  'complete-checkout-session-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n      gidxMessage?: string | null\n      details?: PaymentDetail[]\n    },\n    props: z.object(checkoutParams),\n  },\n  'complete-cashout-session-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n      gidxMessage?: string | null\n      details?: PaymentDetail[]\n    },\n    props: z.object(cashoutParams),\n  },\n  'complete-cashout-request': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n      gidxMessage?: string | null\n      details?: PaymentDetail[]\n    },\n    props: z.object(cashoutRequestParams),\n  },\n  'get-verification-documents-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      documents: GIDXDocument[]\n      utilityDocuments: GIDXDocument[]\n      idDocuments: GIDXDocument[]\n      rejectedDocuments: GIDXDocument[]\n    },\n    props: z.object({}),\n  },\n  'upload-document-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { status: string },\n    props: z.object({\n      CategoryType: z.number().gte(1).lte(7),\n      fileName: z.string(),\n      fileUrl: z.string(),\n    }),\n  },\n  'identity-callback-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as { Accepted: boolean },\n    props: z.object({\n      MerchantCustomerID: z.string(),\n      NotificationType: z.string(),\n    }),\n  },\n  'payment-callback-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as { MerchantTransactionID: string },\n    props: z\n      .object({\n        MerchantTransactionID: z.string(),\n        TransactionStatusCode: z.coerce.number(),\n        TransactionStatusMessage: z.string(),\n        StatusCode: z.coerce.number(),\n        SessionID: z.string(),\n        MerchantSessionID: z.string(),\n        SessionScore: z.coerce.number(),\n        ReasonCodes: z.array(z.string()).optional(),\n        ServiceType: z.string(),\n        StatusMessage: z.string(),\n      })\n      .strict(),\n  },\n  'get-best-comments': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { comments: ContractComment[]; contracts: Contract[] },\n    props: z.object({\n      limit: z.coerce.number().gte(0).lte(100).default(20),\n      offset: z.coerce.number().gte(0).default(0),\n      ignoreContractIds: z.array(z.string()).optional(),\n      justLikes: z.coerce.number().optional(),\n    }),\n  },\n  'get-redeemable-prize-cash': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { redeemablePrizeCash: number },\n    props: z.object({}),\n  },\n  'get-total-redeemable-prize-cash': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as { total: number },\n    props: z.object({}),\n  },\n  'get-cashouts': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as PendingCashoutStatusData[],\n    props: z\n      .object({\n        limit: z.coerce.number().gte(0).lte(100).default(10),\n        offset: z.coerce.number().gte(0).default(0),\n        userId: z.string().optional(),\n      })\n      .strict(),\n  },\n  'get-kyc-stats': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({}),\n    returns: {} as {\n      initialVerifications: {\n        count: number\n        day: string\n      }[]\n      phoneVerifications: {\n        count: number\n        day: string\n      }[]\n    },\n  },\n  txns: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z\n      .object({\n        token: z.string().optional(),\n        offset: z.coerce.number().default(0),\n        limit: z.coerce.number().gte(0).lte(100).default(100),\n        before: z.coerce.number().optional(),\n        after: z.coerce.number().optional(),\n        toId: z.string().optional(),\n        fromId: z.string().optional(),\n        category: z.string().optional(),\n        ignoreCategories: z.array(z.string()).optional(),\n      })\n      .strict(),\n    returns: [] as Txn[],\n  },\n  'generate-ai-market-suggestions': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: [] as AIGeneratedMarket[],\n    props: z\n      .object({\n        prompt: z.string(),\n        existingTitles: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'generate-ai-description': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { description: JSONContent | undefined },\n    props: z\n      .object({\n        question: z.string(),\n        description: z.string().optional(),\n        answers: z.array(z.string()).optional(),\n        outcomeType: z.string().optional(),\n        shouldAnswersSumToOne: coerceBoolean.optional(),\n        addAnswersMode: z\n          .enum(['DISABLED', 'ONLY_CREATOR', 'ANYONE'])\n          .optional(),\n      })\n      .strict(),\n  },\n  'generate-ai-answers': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as {\n      answers: string[]\n      addAnswersMode: 'DISABLED' | 'ONLY_CREATOR' | 'ANYONE'\n    },\n    props: z\n      .object({\n        question: z.string(),\n        answers: z.array(z.string()),\n        shouldAnswersSumToOne: coerceBoolean,\n        description: z.string().optional(),\n      })\n      .strict(),\n  },\n  'get-monthly-bets-2024': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ userId: z.string() }),\n    returns: [] as { month: string; bet_count: number; total_amount: number }[],\n  },\n  'get-max-min-profit-2024': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ userId: z.string() }),\n    returns: [] as {\n      profit: number\n      data: Contract\n      answer_id: string | null\n      has_no_shares: boolean\n      has_yes_shares: boolean\n    }[],\n  },\n  'get-next-loan-amount': {\n    method: 'GET',\n    visibility: 'undocumented',\n    cache: DEFAULT_CACHE_STRATEGY,\n    authed: false,\n    returns: {} as { amount: number },\n    props: z.object({\n      userId: z.string(),\n    }),\n  },\n  'create-task': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as Task,\n    props: z\n      .object({\n        text: z.string(),\n        category_id: z.number().optional(),\n        priority: z.number().default(0),\n        assignee_id: z.string().optional(),\n      })\n      .strict(),\n  },\n  'update-task': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z\n      .object({\n        id: z.number(),\n        text: z.string().optional(),\n        completed: z.boolean().optional(),\n        priority: z.number().optional(),\n        category_id: z.number().optional(),\n        archived: z.boolean().optional(),\n        assignee_id: z.string().optional(),\n      })\n      .strict(),\n  },\n  'create-category': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { id: number },\n    props: z\n      .object({\n        name: z.string(),\n        color: z.string().optional(),\n        displayOrder: z.number().optional(),\n      })\n      .strict(),\n  },\n  'get-categories': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { categories: TaskCategory[] },\n    props: z.object({}).strict(),\n  },\n  'update-category': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z\n      .object({\n        categoryId: z.number(),\n        name: z.string().optional(),\n        color: z.string().optional(),\n        displayOrder: z.number().optional(),\n        archived: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  'get-tasks': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { tasks: Task[] },\n    props: z.object({}).strict(),\n  },\n  'is-sports-interested': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { isSportsInterested: boolean },\n    props: z.object({}).strict(),\n  },\n  'get-site-activity': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as {\n      bets: Bet[]\n      comments: CommentWithTotalReplies[]\n      newContracts: Contract[]\n      relatedContracts: Contract[]\n    },\n    props: z\n      .object({\n        limit: z.coerce.number().default(10),\n        offset: z.coerce.number().default(0),\n        blockedUserIds: z.array(z.string()).optional(),\n        blockedGroupSlugs: z.array(z.string()).optional(),\n        blockedContractIds: z.array(z.string()).optional(),\n        topicIds: z.array(z.string()).optional(),\n        types: z\n          .array(z.enum(['bets', 'comments', 'markets', 'limit-orders']))\n          .optional(),\n        minBetAmount: z.coerce.number().optional(),\n        onlyFollowedTopics: coerceBoolean.optional(),\n        onlyFollowedContracts: coerceBoolean.optional(),\n        onlyFollowedUsers: coerceBoolean.optional(),\n        userId: z.string().optional(),\n      })\n      .strict(),\n  },\n  'get-sports-games': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { schedule: any[] },\n    props: z.object({}).strict(),\n  },\n  'get-market-props': {\n    method: 'GET',\n    visibility: 'public',\n    cache: DEFAULT_CACHE_STRATEGY,\n    // Could set authed false and preferAuth with an api secret if we want it to replace static props\n    authed: true,\n    returns: {} as {\n      manaContract: MarketContract\n      chartAnnotations: ChartAnnotation[]\n      topics: Topic[]\n      comments: ContractComment[]\n      pinnedComments: ContractComment[]\n      userPositionsByOutcome: {\n        YES: ContractMetric[]\n        NO: ContractMetric[]\n      }\n      topContractMetrics: ContractMetric[]\n      totalPositions: number\n      dashboards: Dashboard[]\n      cashContract: MarketContract\n      totalManaBets: number\n      totalCashBets: number\n    },\n    props: z.object({\n      slug: z.string().optional(),\n      id: z.string().optional(),\n    }),\n  },\n  'get-user-contract-metrics-with-contracts': {\n    method: 'GET',\n    visibility: 'public',\n    preferAuth: true,\n    authed: false,\n    returns: {} as {\n      metricsByContract: Dictionary<ContractMetric[]>\n      contracts: MarketContract[]\n    },\n    props: z.object({\n      userId: z.string(),\n      limit: z.coerce.number(),\n      offset: z.coerce.number().gte(0).optional(),\n      perAnswer: coerceBoolean.optional(),\n      inMani: coerceBoolean.optional(),\n    }),\n  },\n  validateIap: {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z.object({\n      receipt: z.string(),\n    }),\n  },\n  'check-sports-event': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as { exists: boolean; existingMarket?: LiteMarket },\n    props: z\n      .object({\n        sportsEventId: z.string(),\n      })\n      .strict(),\n  },\n  'comment-reactions': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Reaction[],\n    props: z\n      .object({\n        contentIds: z.array(z.string()),\n        contentType: z.enum(['comment', 'contract']),\n      })\n      .strict(),\n  },\n  'mark-all-notifications-new': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({}).strict(),\n    returns: {} as { success: boolean },\n  },\n  'get-contract-voters': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        contractId: z.string(),\n      })\n      .strict(),\n    returns: [] as DisplayUser[],\n  },\n  'get-contract-option-voters': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ contractId: z.string(), optionId: z.string() }),\n    returns: [] as DisplayUser[],\n  },\n  'purchase-contract-boost': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        contractId: z.string(),\n        startTime: z.number().positive().finite().safe(),\n        method: z.enum(['mana', 'cash']),\n      })\n      .strict(),\n    returns: {} as { success: boolean; checkoutUrl?: string },\n  },\n  'generate-ai-numeric-ranges': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as {\n      thresholds: { answers: string[]; midpoints: number[] }\n      buckets: { answers: string[]; midpoints: number[] }\n    },\n    props: z\n      .object({\n        question: z.string(),\n        min: z.number(),\n        max: z.number(),\n        description: z.string().optional(),\n        unit: z.string(),\n      })\n      .strict(),\n  },\n  'infer-numeric-unit': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as {\n      unit: string\n    },\n    props: z\n      .object({\n        question: z.string(),\n        description: z.string().optional(),\n      })\n      .strict(),\n  },\n  'generate-ai-date-ranges': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as {\n      buckets: { answers: string[]; midpoints: number[] }\n      thresholds: { answers: string[]; midpoints: number[] }\n    },\n    props: z\n      .object({\n        question: z.string(),\n        min: z.string(),\n        max: z.string(),\n        description: z.string().optional(),\n      })\n      .strict(),\n  },\n  'regenerate-numeric-midpoints': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { midpoints: number[] },\n    props: z\n      .object({\n        description: z.string().optional(),\n        question: z.string(),\n        answers: z.array(z.string()),\n        min: z.number(),\n        max: z.number(),\n        unit: z.string(),\n        tab: z.enum(['thresholds', 'buckets']),\n      })\n      .strict(),\n  },\n  'regenerate-date-midpoints': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { midpoints: number[] },\n    props: z\n      .object({\n        description: z.string().optional(),\n        question: z.string(),\n        answers: z.array(z.string()),\n        min: z.string(),\n        max: z.string(),\n        tab: z.enum(['thresholds', 'buckets']),\n      })\n      .strict(),\n  },\n\n  'generate-concise-title': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        question: z.string(),\n      })\n      .strict(),\n    returns: {} as { title: string },\n  },\n  'get-close-date': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        question: z.string(),\n        utcOffset: z.number().optional(),\n      })\n      .strict(),\n    returns: {} as { closeTime: number },\n  },\n  'refer-user': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        referredByUsername: z.string(),\n        contractId: z.string().optional(),\n      })\n      .strict(),\n    returns: {} as { success: boolean },\n  },\n\n  'save-market-draft': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { id: number },\n    props: z\n      .object({\n        data: z.object({\n          question: z.string(),\n          description: z.any().optional(),\n          outcomeType: z.string(),\n          answers: z.array(z.string()).optional(),\n          closeDate: z.string().optional(),\n          closeHoursMinutes: z.string().optional(),\n          visibility: z.string(),\n          selectedGroups: z.array(z.any()),\n          savedAt: z.number(),\n        }),\n      })\n      .strict(),\n  },\n\n  'get-market-drafts': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: [] as MarketDraft[],\n    props: z.object({}).strict(),\n  },\n\n  'delete-market-draft': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z\n      .object({\n        id: z.coerce.number(),\n      })\n      .strict(),\n  },\n  'get-season-info': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      season: z.coerce.number().int().positive().optional(),\n    }),\n    returns: {} as {\n      season: number\n      startTime: number // epoch ms\n      endTime: number | null // epoch ms, null if a *mystery* for clients\n      status: 'active' | 'processing' | 'complete'\n    },\n  },\n  'mark-notification-read': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z\n      .object({\n        notificationId: z.string(),\n      })\n      .strict(),\n  },\n  'dismiss-user-report': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        reportId: z.string(),\n      })\n      .strict(),\n    returns: {} as { success: boolean },\n  },\n  'create-post': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { post: TopLevelPost },\n    props: z\n      .object({\n        title: z.string().min(1).max(120),\n        content: contentSchema,\n        isAnnouncement: z.boolean().optional(),\n        visibility: z.enum(['public', 'unlisted']).optional(),\n        isChangeLog: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  'update-post': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { post: TopLevelPost },\n    props: z\n      .object({\n        id: z.string(),\n        title: z.string().min(1).max(480).optional(),\n        content: contentSchema.optional(),\n        visibility: z.enum(['public', 'unlisted']).optional(),\n      })\n      .strict(),\n  },\n  'create-post-comment': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { comment: PostComment },\n    props: z\n      .object({\n        postId: z.string(),\n        content: contentSchema,\n        replyToCommentId: z.string().optional(),\n      })\n      .strict(),\n  },\n  'update-post-comment': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { comment: PostComment },\n    props: z\n      .object({\n        commentId: z.string(),\n        postId: z.string(),\n        hidden: z.boolean(),\n      })\n      .strict(),\n  },\n  'follow-post': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: true },\n    props: z\n      .object({\n        postId: z.string(),\n        follow: z.boolean(),\n      })\n      .strict(),\n  },\n  'edit-post-comment': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        commentId: z.string(),\n        postId: z.string(),\n        content: contentSchema,\n      })\n      .strict(),\n    returns: {} as { success: boolean },\n  },\n} as const)\n\nexport type APIPath = keyof typeof API\nexport type APISchema<N extends APIPath> = (typeof API)[N]\n\nexport type APIParams<N extends APIPath> = z.input<APISchema<N>['props']>\nexport type ValidatedAPIParams<N extends APIPath> = z.output<\n  APISchema<N>['props']\n>\n\nexport type APIResponse<N extends APIPath> = APISchema<N> extends {\n  returns: Record<string, any>\n}\n  ? APISchema<N>['returns']\n  : void\n\nexport type APIResponseOptionalContinue<N extends APIPath> =\n  | { continue: () => Promise<void>; result: APIResponse<N> }\n  | APIResponse<N>\n",
          "postContent": "import { z } from 'zod'\nimport {\n  Group,\n  MAX_ID_LENGTH,\n  MySearchGroupShape,\n  LiteGroup,\n  SearchGroupParams,\n  SearchGroupShape,\n  Topic,\n} from 'common/group'\nimport {\n  createMarketProps,\n  resolveMarketProps,\n  type LiteMarket,\n  FullMarket,\n  updateMarketProps,\n} from './market-types'\nimport { type Answer } from 'common/answer'\nimport {\n  Comment,\n  CommentWithTotalReplies,\n  MAX_COMMENT_LENGTH,\n  PostComment,\n  type ContractComment,\n} from 'common/comment'\nimport { CandidateBet } from 'common/new-bet'\nimport type { Bet, LimitBet } from 'common/bet'\nimport { coerceBoolean, contentSchema } from 'common/api/zod-types'\nimport { AIGeneratedMarket, Contract, MarketContract } from 'common/contract'\nimport type { Txn, ManaPayTxn } from 'common/txn'\nimport { LiquidityProvision } from 'common/liquidity-provision'\nimport { DisplayUser, FullUser } from './user-types'\nimport { League } from 'common/leagues'\nimport { searchProps } from './market-search-types'\nimport { MAX_ANSWER_LENGTH } from 'common/answer'\nimport { type LinkPreview } from 'common/link-preview'\nimport { Headline } from 'common/news'\nimport { Row } from 'common/supabase/utils'\nimport { AnyBalanceChangeType } from 'common/balance-change'\nimport { Dashboard } from 'common/dashboard'\nimport { ChatMessage, PrivateChatMessage } from 'common/chat-message'\nimport { PrivateUser, User } from '../user'\nimport { ManaSupply } from 'common/stats'\nimport { Repost } from 'common/repost'\nimport { PERIODS } from 'common/period'\nimport { SWEEPS_MIN_BET } from 'common/economy'\nimport {\n  LivePortfolioMetrics,\n  PortfolioMetrics,\n} from 'common/portfolio-metrics'\nimport { ModReport } from '../mod-report'\n\nimport { RegistrationReturnType } from 'common/reason-codes'\nimport {\n  CheckoutSession,\n  GIDXDocument,\n  GPSProps,\n  PaymentDetail,\n  checkoutParams,\n  verificationParams,\n  cashoutRequestParams,\n  PendingCashoutStatusData,\n  cashoutParams,\n} from 'common/gidx/gidx'\nimport { notification_preference } from 'common/user-notification-preferences'\nimport { PrivateMessageChannel } from 'common/supabase/private-messages'\nimport { Notification } from 'common/notification'\nimport { NON_POINTS_BETS_LIMIT } from 'common/supabase/bets'\nimport { ContractMetric } from 'common/contract-metric'\n\nimport { JSONContent } from '@tiptap/core'\nimport { Task, TaskCategory } from 'common/todo'\nimport { ChartAnnotation } from 'common/supabase/chart-annotations'\nimport { Dictionary } from 'lodash'\nimport { Reaction } from 'common/reaction'\nimport { YEAR_MS } from 'common/util/time'\nimport { MarketDraft } from 'common/drafts'\nimport { TopLevelPost } from 'common/top-level-post'\n// mqp: very unscientific, just balancing our willingness to accept load\n// with user willingness to put up with stale data\nexport const DEFAULT_CACHE_STRATEGY =\n  'public, max-age=5, stale-while-revalidate=10'\nconst MAX_EXPIRES_AT = 1_000 * YEAR_MS\n\ntype APIGenericSchema = {\n  // GET is for retrieval, POST is to mutate something, PUT is idempotent mutation (can be repeated safely)\n  method: 'GET' | 'POST' | 'PUT'\n  //private APIs can only be called from manifold. undocumented endpoints can change or be deleted at any time!\n  visibility: 'public' | 'undocumented' | 'private'\n  // whether the endpoint requires authentication\n  authed: boolean\n  // zod schema for the request body (or for params for GET requests)\n  props: z.ZodType\n  // note this has to be JSON serializable\n  returns?: Record<string, any>\n  // Cache-Control header. like, 'max-age=60'\n  cache?: string\n  // whether the endpoint should prefer authentication even if not required\n  preferAuth?: boolean\n}\n\nlet _apiTypeCheck: { [x: string]: APIGenericSchema }\nexport const API = (_apiTypeCheck = {\n  'refresh-all-clients': {\n    method: 'POST',\n    visibility: 'public',\n    props: z.object({ message: z.string().optional() }),\n    authed: true,\n  },\n  'toggle-system-trading-status': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        token: z.enum(['MANA', 'CASH']),\n      })\n      .strict(),\n    returns: {} as { status: boolean },\n  },\n  comment: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as ContractComment,\n    props: z\n      .object({\n        contractId: z.string(),\n        content: contentSchema.optional(),\n        html: z.string().optional(),\n        markdown: z.string().optional(),\n        replyToCommentId: z.string().optional(),\n        replyToAnswerId: z.string().optional(),\n        replyToBetId: z.string().optional(),\n      })\n      .strict(),\n  },\n\n  'follow-contract': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: true },\n    props: z\n      .object({\n        contractId: z.string(),\n        follow: z.boolean(),\n      })\n      .strict(),\n  },\n  'get-contract': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as Contract,\n    props: z\n      .object({\n        contractId: z.string(),\n      })\n      .strict(),\n  },\n  'answer/:answerId': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as Answer,\n    props: z.object({ answerId: z.string() }).strict(),\n  },\n  'market/:contractId/answers': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: [] as Answer[],\n    props: z.object({ contractId: z.string() }).strict(),\n  },\n  'hide-comment': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z.object({ commentPath: z.string() }).strict(),\n  },\n  'pin-comment': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({ commentPath: z.string() }).strict(),\n  },\n  comments: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    // cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as ContractComment[],\n    props: z\n      .object({\n        contractId: z.string().optional(),\n        contractSlug: z.string().optional(),\n        afterTime: z.coerce.number().optional(),\n        limit: z.coerce.number().gte(0).lte(1000).default(1000),\n        page: z.coerce.number().gte(0).default(0),\n        userId: z.string().optional(),\n        isPolitics: coerceBoolean.optional(),\n      })\n      .strict(),\n  },\n  'user-comments': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: [] as Comment[],\n    props: z\n      .object({\n        afterTime: z.coerce.number().optional(),\n        limit: z.coerce.number().gte(0).lte(1000).default(1000),\n        page: z.coerce.number().gte(0).default(0),\n        userId: z.string(),\n      })\n      .strict(),\n  },\n  bet: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as CandidateBet & { betId: string },\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gte(SWEEPS_MIN_BET),\n        replyToCommentId: z.string().optional(),\n        limitProb: z.number().gte(0.01).lte(0.99).optional(),\n        expiresMillisAfter: z.number().lt(MAX_EXPIRES_AT).optional(),\n        silent: z.boolean().optional(),\n        expiresAt: z.number().lt(MAX_EXPIRES_AT).optional(),\n        // Used for binary and new multiple choice contracts (cpmm-multi-1).\n        outcome: z.enum(['YES', 'NO']).default('YES'),\n        //Multi\n        answerId: z.string().optional(),\n        dryRun: z.boolean().optional(),\n        deps: z.array(z.string()).optional(),\n        deterministic: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  createuser: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { user: User; privateUser: PrivateUser },\n    props: z\n      .object({\n        deviceToken: z.string().optional(),\n        adminToken: z.string().optional(),\n        visitedContractIds: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'multi-bet': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as (CandidateBet & { betId: string })[],\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gte(1),\n        limitProb: z.number().gte(0).lte(1).optional(),\n        expiresAt: z.number().lt(MAX_EXPIRES_AT).optional(),\n        answerIds: z.array(z.string()).min(1),\n        deterministic: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  'multi-sell': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as (CandidateBet & { betId: string })[],\n    props: z\n      .object({\n        contractId: z.string(),\n        answerIds: z.array(z.string()).min(1),\n        deterministic: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  leaderboard: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as { userId: string; score: number }[],\n    props: z\n      .object({\n        groupId: z.string().optional(),\n        limit: z.coerce.number().min(1).max(100).default(50),\n        token: z.enum(['MANA', 'CASH']).default('MANA'),\n        kind: z.enum(['creator', 'profit', 'loss', 'volume', 'referral']),\n      })\n      .strict(),\n  },\n  'verify-phone-number': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { status: string },\n    props: z\n      .object({\n        phoneNumber: z.string(),\n        code: z.string(),\n      })\n      .strict(),\n  },\n  'request-otp': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { status: string },\n    props: z\n      .object({\n        phoneNumber: z.string(),\n      })\n      .strict(),\n  },\n  'bet/cancel/:betId': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ betId: z.string() }).strict(),\n    returns: {} as LimitBet,\n  },\n  // sell shares\n  'market/:contractId/sell': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as CandidateBet & { betId: string },\n    props: z\n      .object({\n        contractId: z.string(),\n        shares: z.number().positive().optional(), // leave it out to sell all shares\n        outcome: z.enum(['YES', 'NO']),\n        answerId: z.string().optional(), // Required for multi binary markets\n        deterministic: z.boolean().optional(),\n        deps: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'get-user-limit-orders-with-contracts': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as {\n      bets: LimitBet[]\n      contracts: MarketContract[]\n    },\n    props: z\n      .object({\n        userId: z.string(),\n        count: z.coerce.number().lte(5000),\n        includeExpired: coerceBoolean.optional().default(false),\n        includeCancelled: coerceBoolean.optional().default(false),\n        includeFilled: coerceBoolean.optional().default(false),\n      })\n      .strict(),\n  },\n  'get-interesting-groups-from-views': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as (Group & { hasBet: boolean })[],\n    props: z\n      .object({\n        userId: z.string(),\n        contractIds: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  bets: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Bet[],\n    props: z\n      .object({\n        id: z.string().optional(),\n        userId: z.string().optional(),\n        username: z.string().optional(),\n        contractId: z.string().or(z.array(z.string())).optional(),\n        contractSlug: z.string().optional(),\n        answerId: z.string().optional(),\n        // market: z.string().optional(), // deprecated, synonym for `contractSlug`\n        limit: z.coerce\n          .number()\n          .gte(0)\n          .lte(50000)\n          .default(NON_POINTS_BETS_LIMIT),\n        before: z.string().optional(),\n        after: z.string().optional(),\n        beforeTime: z.coerce.number().optional(),\n        afterTime: z.coerce.number().optional(),\n        order: z.enum(['asc', 'desc']).optional(),\n        kinds: z.enum(['open-limit']).optional(),\n        // undocumented fields. idk what a good api interface would be\n        filterRedemptions: coerceBoolean.optional(),\n        includeZeroShareRedemptions: coerceBoolean.optional(),\n        commentRepliesOnly: coerceBoolean.optional(),\n        count: coerceBoolean.optional(),\n        points: coerceBoolean.optional(),\n      })\n      .strict(),\n  },\n  'bet-points': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: 'public, max-age=600, stale-while-revalidate=60',\n    returns: [] as Bet[],\n    props: z\n      .object({\n        contractId: z.string(),\n        answerId: z.string().optional(),\n        limit: z.coerce.number().gte(0).lte(50000).default(5000),\n        beforeTime: z.coerce.number(),\n        afterTime: z.coerce.number(),\n        filterRedemptions: coerceBoolean.optional(),\n        includeZeroShareRedemptions: coerceBoolean.optional(),\n      })\n      .strict(),\n  },\n  'unique-bet-group-count': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as { count: number },\n    props: z\n      .object({\n        contractId: z.string(),\n      })\n      .strict(),\n  },\n  'get-daily-changed-metrics-and-contracts': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    cache: 'public, max-age=900, stale-while-revalidate=90', // 15 minute cache\n    props: z\n      .object({\n        limit: z.coerce.number(),\n        userId: z.string(),\n        balance: z.coerce.number(),\n      })\n      .strict(),\n    returns: {} as {\n      manaMetrics: ContractMetric[]\n      contracts: MarketContract[]\n      manaProfit: number\n      manaInvestmentValue: number\n      balance: number\n    },\n  },\n  // deprecated. use /bets?username= instead\n  'user/:username/bets': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Bet[],\n    props: z\n      .object({\n        username: z.string(),\n        limit: z.coerce.number().gte(0).lte(1000).default(1000),\n      })\n      .strict(),\n  },\n  'group/:slug': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as Group,\n    props: z.object({ slug: z.string() }),\n  },\n  'group/:slug/groups': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as { above: LiteGroup[]; below: LiteGroup[] },\n    props: z.object({ slug: z.string() }).strict(),\n  },\n  'group/:slug/dashboards': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as {\n      id: string\n      title: string\n      slug: string\n      creatorId: string\n    }[],\n    props: z.object({ slug: z.string() }).strict(),\n  },\n  'group/by-id/:id/groups': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as { above: LiteGroup[]; below: LiteGroup[] },\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'group/by-id/:id': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as Group,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  // deprecated. use /markets?groupId= instead\n  'group/by-id/:id/markets': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as LiteMarket[],\n    props: z\n      .object({\n        id: z.string(),\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n      })\n      .strict(),\n  },\n  'group/:slug/delete': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ slug: z.string() }),\n  },\n  'group/by-id/:id/delete': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ id: z.string() }),\n  },\n  'group/:slug/block': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ slug: z.string() }),\n  },\n  'group/:slug/unblock': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ slug: z.string() }).strict(),\n  },\n  'group/by-id/:topId/group/:bottomId': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        topId: z.string(),\n        bottomId: z.string(),\n        remove: z.boolean().optional(),\n      })\n      .strict(),\n    returns: {} as { status: 'success' },\n  },\n  groups: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Group[],\n    props: z\n      .object({\n        availableToUserId: z.string().optional(),\n        beforeTime: z.coerce.number().int().optional(),\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n      })\n      .strict(),\n  },\n  'market/:id': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as LiteMarket | FullMarket,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z.object({ id: z.string(), lite: coerceBoolean.optional() }),\n  },\n  'market/:id/prob': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as {\n      prob?: number\n      answerProbs?: { [answerId: string]: number }\n    },\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'market-probs': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as {\n      [contractId: string]: {\n        prob?: number\n        answerProbs?: { [answerId: string]: number }\n      }\n    },\n    props: z\n      .object({\n        ids: z.array(z.string()).max(100),\n      })\n      .strict(),\n  },\n  'markets-by-ids': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: [] as Contract[],\n    props: z\n      .object({\n        ids: z.array(z.string()).max(100),\n      })\n      .strict(),\n  },\n  // deprecated. use /market/:id?lite=true instead\n  'market/:id/lite': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as LiteMarket,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z.object({ id: z.string() }),\n  },\n  'slug/:slug': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as LiteMarket | FullMarket,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z.object({ slug: z.string(), lite: coerceBoolean.optional() }),\n  },\n  market: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as LiteMarket,\n    props: createMarketProps,\n  },\n  'market/:contractId/update': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: updateMarketProps,\n    returns: {} as { success: true },\n  },\n  'market/:contractId/close': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    // returns: {} as LiteMarket,\n    props: z\n      .object({\n        contractId: z.string(),\n        closeTime: z.number().int().nonnegative().optional(),\n      })\n      .strict(),\n  },\n  'market/:contractId/resolve': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { message: string },\n    props: resolveMarketProps,\n  },\n  'market/:contractId/add-liquidity': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as LiquidityProvision,\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gt(0).finite(),\n      })\n      .strict(),\n  },\n  'market/:contractId/remove-liquidity': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as LiquidityProvision,\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gt(0).finite(),\n      })\n      .strict(),\n  },\n  'market/:contractId/add-bounty': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as Txn,\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gt(0).finite(),\n      })\n      .strict(),\n  },\n  'market/:contractId/award-bounty': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as Txn,\n    props: z\n      .object({\n        contractId: z.string(),\n        commentId: z.string(),\n        amount: z.number().gt(0).finite(),\n      })\n      .strict(),\n  },\n  'market/:contractId/group': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        contractId: z.string(),\n        groupId: z.string(),\n        remove: z.boolean().default(false),\n      })\n      .strict(),\n    returns: {} as { success: true },\n  },\n  'market/:contractId/groups': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({ contractId: z.string() }),\n    returns: [] as LiteGroup[],\n  },\n  'market/:contractId/answer': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { newAnswerId: string },\n    props: z\n      .object({\n        contractId: z.string().max(MAX_ANSWER_LENGTH),\n        text: z.string().min(1).max(MAX_ANSWER_LENGTH),\n      })\n      .strict(),\n  },\n  'market/:contractId/block': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ contractId: z.string() }).strict(),\n  },\n  'market/:contractId/unblock': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ contractId: z.string() }).strict(),\n  },\n  unresolve: {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { success: true },\n    props: z\n      .object({\n        contractId: z.string().max(MAX_ANSWER_LENGTH),\n        answerId: z.string().max(MAX_ANSWER_LENGTH).optional(),\n      })\n      .strict(),\n  },\n  leagues: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as League[],\n    props: z\n      .object({\n        userId: z.string().optional(),\n        cohort: z.string().optional(),\n        season: z.coerce.number().optional(),\n      })\n      .strict(),\n  },\n  markets: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as LiteMarket[],\n    props: z\n      .object({\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n        sort: z\n          .enum([\n            'created-time',\n            'updated-time',\n            'last-bet-time',\n            'last-comment-time',\n          ])\n          .optional(),\n        order: z.enum(['asc', 'desc']).optional(),\n        before: z.string().optional(),\n        userId: z.string().optional(),\n        groupId: z.string().optional(),\n      })\n      .strict(),\n  },\n  'search-markets': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as LiteMarket[],\n    props: searchProps,\n  },\n  'search-markets-full': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    preferAuth: true,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Contract[],\n    props: searchProps,\n  },\n  managram: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        amount: z.number().finite(),\n        toIds: z.array(z.string()),\n        message: z.string().max(MAX_COMMENT_LENGTH),\n        groupId: z.string().max(MAX_ID_LENGTH).optional(),\n        token: z.enum(['M$', 'CASH']).default('M$'),\n      })\n      .strict(),\n  },\n  manalink: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { slug: string },\n    props: z\n      .object({\n        amount: z.number().positive().finite().safe(),\n        expiresTime: z.number().lt(MAX_EXPIRES_AT).optional(),\n        maxUses: z.number().optional(),\n        message: z.string().optional(),\n      })\n      .strict(),\n  },\n  donate: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        amount: z.number().positive().finite().safe(),\n        to: z.string(),\n      })\n      .strict(),\n  },\n  'convert-sp-to-mana': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ amount: z.number().positive().finite().safe() }).strict(),\n  },\n  'convert-cash-to-mana': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ amount: z.number().positive().finite().safe() }).strict(),\n  },\n  'request-loan': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({}),\n    returns: {} as { payout: number },\n  },\n  // deprecated. use /txns instead\n  managrams: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: [] as ManaPayTxn[],\n    props: z\n      .object({\n        toId: z.string().optional(),\n        fromId: z.string().optional(),\n        limit: z.coerce.number().gte(0).lte(100).default(100),\n        before: z.coerce.number().optional(),\n        after: z.coerce.number().optional(),\n      })\n      .strict(),\n  },\n  'market/:id/positions': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as ContractMetric[],\n    props: z\n      .object({\n        id: z.string(),\n        userId: z.string().optional(),\n        answerId: z.string().optional(),\n        summaryOnly: z.boolean().optional(),\n        top: z.undefined().or(z.coerce.number()),\n        bottom: z.undefined().or(z.coerce.number()),\n        order: z.enum(['shares', 'profit']).optional(),\n      })\n      .strict(),\n  },\n  me: {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z.object({}),\n    returns: {} as FullUser,\n  },\n  'me/update': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({\n      name: z.string().trim().min(1).optional(),\n      username: z.string().trim().min(1).optional(),\n      avatarUrl: z.string().optional(),\n      bio: z.string().optional(),\n      website: z.string().optional(),\n      twitterHandle: z.string().optional(),\n      discordHandle: z.string().optional(),\n      // settings\n      optOutBetWarnings: z.boolean().optional(),\n      isAdvancedTrader: z.boolean().optional(),\n      //internal\n      seenStreakModal: z.boolean().optional(),\n      shouldShowWelcome: z.boolean().optional(),\n      hasSeenContractFollowModal: z.boolean().optional(),\n      hasSeenLoanModal: z.boolean().optional(),\n    }),\n    returns: {} as FullUser,\n  },\n  'me/delete': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({\n      username: z.string(), // just so you're sure\n    }),\n  },\n  'me/private': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z.object({}),\n    returns: {} as PrivateUser,\n  },\n  'me/private/update': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    props: z\n      .object({\n        email: z.string().email().optional(),\n        apiKey: z.string().optional(),\n        pushToken: z.string().optional(),\n        rejectedPushNotificationsOn: z.number().optional(),\n        lastPromptedToEnablePushNotifications: z.number().optional(),\n        interestedInPushNotifications: z.boolean().optional(),\n        hasSeenAppBannerInNotificationsOn: z.number().optional(),\n        installedAppPlatforms: z.array(z.string()).optional(),\n        paymentInfo: z.string().optional(),\n        lastAppReviewTime: z.number().optional(),\n      })\n      .strict(),\n  },\n  'user/:username': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as FullUser,\n    props: z.object({ username: z.string() }).strict(),\n  },\n  'user/:username/lite': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as DisplayUser,\n    props: z.object({ username: z.string() }).strict(),\n  },\n  'user/by-id/:id': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    // Do not add a caching strategy here. New users need up-to-date data.\n    returns: {} as FullUser,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'user/by-id/:id/lite': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as DisplayUser,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'users/by-id': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as DisplayUser[],\n    props: z.object({ ids: z.array(z.string()) }).strict(),\n  },\n  'users/by-id/balance': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as { id: string; balance: number }[],\n    props: z.object({ ids: z.array(z.string()) }).strict(),\n  },\n  'user/by-id/:id/block': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'user/by-id/:id/unblock': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  users: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as FullUser[],\n    props: z\n      .object({\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n        before: z.string().optional(),\n      })\n      .strict(),\n  },\n  'search-users': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as FullUser[],\n    props: z\n      .object({\n        term: z.string(),\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n        page: z.coerce.number().gte(0).default(0),\n      })\n      .strict(),\n  },\n  'search-contract-positions': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as DisplayUser[],\n    props: z\n      .object({\n        term: z.string(),\n        contractId: z.string(),\n        limit: z.coerce.number().gte(0).lte(100).default(10),\n      })\n      .strict(),\n  },\n  'save-twitch': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        twitchInfo: z.object({\n          twitchName: z.string().optional(),\n          controlToken: z.string().optional(),\n          botEnabled: z.boolean().optional(),\n          needsRelinking: z.boolean().optional(),\n        }),\n      })\n      .strict(),\n  },\n  'set-push-token': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({ pushToken: z.string() }).strict(),\n  },\n  'update-notif-settings': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      type: z.string() as z.ZodType<notification_preference>,\n      medium: z.enum(['email', 'browser', 'mobile']),\n      enabled: z.boolean(),\n    }),\n  },\n  headlines: {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: [] as Headline[],\n    props: z.object({\n      slug: z.enum(['politics', 'ai', 'news']).optional(),\n    }),\n  },\n  'politics-headlines': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: [] as Headline[],\n    props: z.object({}),\n  },\n  'set-news': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { success: true },\n    props: z\n      .object({\n        dashboardIds: z.array(z.string()),\n        endpoint: z.enum(['politics', 'ai', 'news']),\n      })\n      .strict(),\n  },\n  react: {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        contentId: z.string(),\n        contentType: z.enum(['comment', 'contract', 'post']),\n        commentParentType: z.enum(['post']).optional(),\n        remove: z.boolean().optional(),\n        reactionType: z.enum(['like', 'dislike']).optional().default('like'),\n      })\n      .strict(),\n    returns: { success: true },\n  },\n  post: {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    returns: {} as ContractComment,\n    props: z\n      .object({\n        contractId: z.string(),\n        betId: z.string().optional(),\n        commentId: z.string().optional(),\n        content: contentSchema.optional(),\n      })\n      .strict(),\n  },\n  'fetch-link-preview': {\n    method: 'GET',\n    visibility: 'private',\n    authed: false,\n    props: z.object({ url: z.string() }).strict(),\n    cache: 'max-age=86400, stale-while-revalidate=86400',\n    returns: {} as LinkPreview,\n  },\n  'get-related-markets': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    props: z\n      .object({\n        contractId: z.string(),\n        limit: z.coerce.number().gte(0).lte(100),\n        userId: z.string().optional(),\n        question: z.string().optional(),\n        uniqueBettorCount: z.coerce.number().gte(0).optional(),\n      })\n      .strict(),\n    returns: {} as {\n      marketsFromEmbeddings: Contract[]\n    },\n    cache: 'public, max-age=3600, stale-while-revalidate=10',\n  },\n  'get-related-markets-by-group': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: 'public, max-age=3600, stale-while-revalidate=10',\n    returns: {} as {\n      groupContracts: Contract[]\n    },\n    props: z\n      .object({\n        contractId: z.string(),\n        limit: z.coerce.number().gte(0).lte(100),\n        offset: z.coerce.number().gte(0),\n      })\n      .strict(),\n  },\n  'unlist-and-cancel-user-contracts': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        userId: z.string(),\n      })\n      .strict(),\n  },\n  'get-boost-analytics': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: false,\n    props: z\n      .object({\n        contractId: z.string(),\n      })\n      .strict(),\n    returns: {} as {\n      uniqueViewers: number\n      totalViews: number\n      uniquePromotedViewers: number\n      totalPromotedViews: number\n      boostPeriods: {\n        startTime: string\n        endTime: string\n      }[]\n    },\n  },\n  'get-seen-market-ids': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      contractIds: z.array(z.string()),\n      types: z.array(z.enum(['page', 'card', 'promoted'])).optional(),\n      since: z.number(),\n    }),\n    returns: [] as string[],\n  },\n  'search-groups': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    // Is there a way to infer return { lite:[] as LiteGroup[] } if type is 'lite'?\n    returns: {\n      full: [] as Group[],\n      lite: [] as LiteGroup[],\n    },\n    props: SearchGroupParams(SearchGroupShape),\n  },\n  'search-my-groups': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {\n      full: [] as Group[],\n      lite: [] as LiteGroup[],\n    },\n    props: SearchGroupParams(MySearchGroupShape),\n  },\n  'get-groups-with-top-contracts': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as { topic: Topic; contracts: Contract[] }[],\n    props: z.object({}),\n  },\n  'get-balance-changes': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: [] as AnyBalanceChangeType[],\n    props: z\n      .object({\n        before: z.coerce.number().optional(),\n        after: z.coerce.number().default(0),\n        userId: z.string(),\n      })\n      .strict(),\n  },\n  'get-partner-stats': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z\n      .object({\n        userId: z.string(),\n      })\n      .strict(),\n    returns: {} as {\n      status: 'success' | 'error'\n      username: string\n      numContractsCreated: number\n      numUniqueBettors: number\n      numReferrals: number\n      numReferralsWhoRetained: number\n      totalTraderIncome: number\n      totalReferralIncome: number\n      dollarsEarned: number\n    },\n  },\n  'record-contract-view': {\n    method: 'POST',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      userId: z.string().optional(),\n      contractId: z.string(),\n      kind: z.enum(['page', 'card', 'promoted']),\n    }),\n    returns: {} as { status: 'success' },\n  },\n  'record-comment-view': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({\n      contractId: z.string(),\n      commentId: z.string(),\n    }),\n    returns: {} as { status: 'success' },\n  },\n  'record-contract-interaction': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({\n      contractId: z.string(),\n      kind: z.enum([\n        'page bet',\n        'page comment',\n        'page repost',\n        'page like',\n        'card bet',\n        'card click',\n        'promoted click',\n        'card like',\n        'page share',\n        'browse click',\n      ]),\n      commentId: z.string().optional(),\n      feedReasons: z.array(z.string()).optional(),\n      feedType: z.string().optional(),\n      betGroupId: z.string().optional(),\n      betId: z.string().optional(),\n    }),\n    returns: {} as { status: 'success' },\n  },\n  'get-dashboard-from-slug': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      dashboardSlug: z.string(),\n    }),\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as Dashboard,\n  },\n  'get-posts': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    preferAuth: true,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z\n      .object({\n        sortBy: z\n          .enum(['created_time', 'importance_score'])\n          .optional()\n          .default('created_time'),\n        term: z.string().optional(),\n        limit: z.coerce.number().gte(0).lte(200).default(100),\n        userId: z.string().optional(),\n        offset: z.coerce.number().gte(0).default(0),\n        isChangeLog: coerceBoolean.optional(),\n      })\n      .strict(),\n    returns: [] as TopLevelPost[],\n  },\n  'create-public-chat-message': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as ChatMessage,\n    props: z.object({\n      content: contentSchema,\n      channelId: z.string(),\n    }),\n  },\n  'get-followed-groups': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      userId: z.string(),\n    }),\n    returns: {} as {\n      groups: Group[]\n    },\n  },\n  'get-user-portfolio': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      userId: z.string(),\n    }),\n    returns: {} as LivePortfolioMetrics,\n  },\n  'get-user-portfolio-history': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      userId: z.string(),\n      period: z.enum(PERIODS),\n    }),\n    returns: {} as PortfolioMetrics[],\n  },\n  'get-channel-memberships': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      channelId: z.coerce.number().optional(),\n      createdTime: z.string().optional(),\n      lastUpdatedTime: z.string().optional(),\n      limit: z.coerce.number(),\n    }),\n    returns: {\n      channels: [] as PrivateMessageChannel[],\n      memberIdsByChannelId: {} as { [channelId: string]: string[] },\n    },\n  },\n  'get-channel-messages': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      channelId: z.coerce.number(),\n      limit: z.coerce.number(),\n      id: z.coerce.number().optional(),\n    }),\n    returns: [] as PrivateChatMessage[],\n  },\n  'get-channel-seen-time': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      channelIds: z.array(z.coerce.number()),\n    }),\n    returns: [] as [number, string][],\n  },\n  'set-channel-seen-time': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      channelId: z.coerce.number(),\n    }),\n  },\n  'get-feed': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as {\n      contracts: Contract[]\n      comments: ContractComment[]\n      bets: Bet[]\n      reposts: Repost[]\n      idsToReason: { [id: string]: string }\n    },\n    props: z\n      .object({\n        userId: z.string(),\n        limit: z.coerce.number().gt(0).lte(100).default(100),\n        offset: z.coerce.number().gte(0).default(0),\n        ignoreContractIds: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'get-mana-supply': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as ManaSupply,\n    props: z.object({}).strict(),\n  },\n  'get-notifications': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as Notification[],\n    props: z\n      .object({\n        after: z.coerce.number().optional(),\n        limit: z.coerce.number().gte(0).lte(1000).default(100),\n      })\n      .strict(),\n  },\n  'update-mod-report': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        reportId: z.number(),\n        updates: z\n          .object({\n            status: z\n              .enum(['new', 'under review', 'resolved', 'needs admin'])\n              .optional(),\n            mod_note: z.string().optional(),\n          })\n          .partial(),\n      })\n      .strict(),\n    returns: {} as { status: string; report: ModReport },\n  },\n  'get-mod-reports': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        statuses: z.array(\n          z.enum(['new', 'under review', 'resolved', 'needs admin'])\n        ),\n        limit: z.coerce.number().gte(0).lte(100).default(25),\n        offset: z.coerce.number().gte(0).default(0),\n        count: coerceBoolean.optional(),\n      })\n      .strict(),\n    returns: {} as {\n      status: string\n      count?: number\n      reports: ModReport[]\n    },\n  },\n  'get-txn-summary-stats': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as Row<'txn_summary_stats'>[],\n    props: z\n      .object({\n        ignoreCategories: z.array(z.string()).optional(),\n        fromType: z.string().optional(),\n        toType: z.string().optional(),\n        limitDays: z.coerce.number(),\n      })\n      .strict(),\n  },\n  'get-mana-summary-stats': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as Row<'mana_supply_stats'>[],\n    props: z\n      .object({\n        limitDays: z.coerce.number(),\n      })\n      .strict(),\n  },\n  'register-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: verificationParams,\n    returns: {} as RegistrationReturnType,\n  },\n  'get-verification-status-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      documents?: GIDXDocument[]\n      message?: string\n      documentStatus?: string\n    },\n    props: z.object({}),\n  },\n  'get-monitor-status-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n    },\n    props: z.object({\n      DeviceGPS: GPSProps,\n    }),\n  },\n  'get-checkout-session-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n      session?: CheckoutSession\n    },\n    props: z.object({\n      PayActionCode: z.enum(['PAY', 'PAYOUT']).default('PAY'),\n      DeviceGPS: GPSProps,\n      userId: z.string().optional(),\n      ip: z.string().optional(),\n    }),\n  },\n  'complete-checkout-session-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n      gidxMessage?: string | null\n      details?: PaymentDetail[]\n    },\n    props: z.object(checkoutParams),\n  },\n  'complete-cashout-session-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n      gidxMessage?: string | null\n      details?: PaymentDetail[]\n    },\n    props: z.object(cashoutParams),\n  },\n  'complete-cashout-request': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n      gidxMessage?: string | null\n      details?: PaymentDetail[]\n    },\n    props: z.object(cashoutRequestParams),\n  },\n  'get-verification-documents-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      documents: GIDXDocument[]\n      utilityDocuments: GIDXDocument[]\n      idDocuments: GIDXDocument[]\n      rejectedDocuments: GIDXDocument[]\n    },\n    props: z.object({}),\n  },\n  'upload-document-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { status: string },\n    props: z.object({\n      CategoryType: z.number().gte(1).lte(7),\n      fileName: z.string(),\n      fileUrl: z.string(),\n    }),\n  },\n  'identity-callback-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as { Accepted: boolean },\n    props: z.object({\n      MerchantCustomerID: z.string(),\n      NotificationType: z.string(),\n    }),\n  },\n  'payment-callback-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as { MerchantTransactionID: string },\n    props: z\n      .object({\n        MerchantTransactionID: z.string(),\n        TransactionStatusCode: z.coerce.number(),\n        TransactionStatusMessage: z.string(),\n        StatusCode: z.coerce.number(),\n        SessionID: z.string(),\n        MerchantSessionID: z.string(),\n        SessionScore: z.coerce.number(),\n        ReasonCodes: z.array(z.string()).optional(),\n        ServiceType: z.string(),\n        StatusMessage: z.string(),\n      })\n      .strict(),\n  },\n  'get-best-comments': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { comments: ContractComment[]; contracts: Contract[] },\n    props: z.object({\n      limit: z.coerce.number().gte(0).lte(100).default(20),\n      offset: z.coerce.number().gte(0).default(0),\n      ignoreContractIds: z.array(z.string()).optional(),\n      justLikes: z.coerce.number().optional(),\n    }),\n  },\n  'get-redeemable-prize-cash': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { redeemablePrizeCash: number },\n    props: z.object({}),\n  },\n  'get-total-redeemable-prize-cash': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as { total: number },\n    props: z.object({}),\n  },\n  'get-cashouts': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as PendingCashoutStatusData[],\n    props: z\n      .object({\n        limit: z.coerce.number().gte(0).lte(100).default(10),\n        offset: z.coerce.number().gte(0).default(0),\n        userId: z.string().optional(),\n      })\n      .strict(),\n  },\n  'get-kyc-stats': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({}),\n    returns: {} as {\n      initialVerifications: {\n        count: number\n        day: string\n      }[]\n      phoneVerifications: {\n        count: number\n        day: string\n      }[]\n    },\n  },\n  txns: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z\n      .object({\n        token: z.string().optional(),\n        offset: z.coerce.number().default(0),\n        limit: z.coerce.number().gte(0).lte(100).default(100),\n        before: z.coerce.number().optional(),\n        after: z.coerce.number().optional(),\n        toId: z.string().optional(),\n        fromId: z.string().optional(),\n        category: z.string().optional(),\n        ignoreCategories: z.array(z.string()).optional(),\n      })\n      .strict(),\n    returns: [] as Txn[],\n  },\n  'generate-ai-market-suggestions': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: [] as AIGeneratedMarket[],\n    props: z\n      .object({\n        prompt: z.string(),\n        existingTitles: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'generate-ai-description': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { description: JSONContent | undefined },\n    props: z\n      .object({\n        question: z.string(),\n        description: z.string().optional(),\n        answers: z.array(z.string()).optional(),\n        outcomeType: z.string().optional(),\n        shouldAnswersSumToOne: coerceBoolean.optional(),\n        addAnswersMode: z\n          .enum(['DISABLED', 'ONLY_CREATOR', 'ANYONE'])\n          .optional(),\n      })\n      .strict(),\n  },\n  'generate-ai-answers': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as {\n      answers: string[]\n      addAnswersMode: 'DISABLED' | 'ONLY_CREATOR' | 'ANYONE'\n    },\n    props: z\n      .object({\n        question: z.string(),\n        answers: z.array(z.string()),\n        shouldAnswersSumToOne: coerceBoolean,\n        description: z.string().optional(),\n      })\n      .strict(),\n  },\n  'get-monthly-bets-2024': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ userId: z.string() }),\n    returns: [] as { month: string; bet_count: number; total_amount: number }[],\n  },\n  'get-max-min-profit-2024': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ userId: z.string() }),\n    returns: [] as {\n      profit: number\n      data: Contract\n      answer_id: string | null\n      has_no_shares: boolean\n      has_yes_shares: boolean\n    }[],\n  },\n  'get-next-loan-amount': {\n    method: 'GET',\n    visibility: 'undocumented',\n    cache: DEFAULT_CACHE_STRATEGY,\n    authed: false,\n    returns: {} as { amount: number },\n    props: z.object({\n      userId: z.string(),\n    }),\n  },\n  'create-task': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as Task,\n    props: z\n      .object({\n        text: z.string(),\n        category_id: z.number().optional(),\n        priority: z.number().default(0),\n        assignee_id: z.string().optional(),\n      })\n      .strict(),\n  },\n  'update-task': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z\n      .object({\n        id: z.number(),\n        text: z.string().optional(),\n        completed: z.boolean().optional(),\n        priority: z.number().optional(),\n        category_id: z.number().optional(),\n        archived: z.boolean().optional(),\n        assignee_id: z.string().optional(),\n      })\n      .strict(),\n  },\n  'create-category': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { id: number },\n    props: z\n      .object({\n        name: z.string(),\n        color: z.string().optional(),\n        displayOrder: z.number().optional(),\n      })\n      .strict(),\n  },\n  'get-categories': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { categories: TaskCategory[] },\n    props: z.object({}).strict(),\n  },\n  'update-category': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z\n      .object({\n        categoryId: z.number(),\n        name: z.string().optional(),\n        color: z.string().optional(),\n        displayOrder: z.number().optional(),\n        archived: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  'get-tasks': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { tasks: Task[] },\n    props: z.object({}).strict(),\n  },\n  'is-sports-interested': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { isSportsInterested: boolean },\n    props: z.object({}).strict(),\n  },\n  'get-site-activity': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as {\n      bets: Bet[]\n      comments: CommentWithTotalReplies[]\n      newContracts: Contract[]\n      relatedContracts: Contract[]\n    },\n    props: z\n      .object({\n        limit: z.coerce.number().default(10),\n        offset: z.coerce.number().default(0),\n        blockedUserIds: z.array(z.string()).optional(),\n        blockedGroupSlugs: z.array(z.string()).optional(),\n        blockedContractIds: z.array(z.string()).optional(),\n        topicIds: z.array(z.string()).optional(),\n        types: z\n          .array(z.enum(['bets', 'comments', 'markets', 'limit-orders']))\n          .optional(),\n        minBetAmount: z.coerce.number().optional(),\n        onlyFollowedTopics: coerceBoolean.optional(),\n        onlyFollowedContracts: coerceBoolean.optional(),\n        onlyFollowedUsers: coerceBoolean.optional(),\n        userId: z.string().optional(),\n      })\n      .strict(),\n  },\n  'get-sports-games': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { schedule: any[] },\n    props: z.object({}).strict(),\n  },\n  'get-market-props': {\n    method: 'GET',\n    visibility: 'public',\n    cache: DEFAULT_CACHE_STRATEGY,\n    // Could set authed false and preferAuth with an api secret if we want it to replace static props\n    authed: true,\n    returns: {} as {\n      manaContract: MarketContract\n      chartAnnotations: ChartAnnotation[]\n      topics: Topic[]\n      comments: ContractComment[]\n      pinnedComments: ContractComment[]\n      userPositionsByOutcome: {\n        YES: ContractMetric[]\n        NO: ContractMetric[]\n      }\n      topContractMetrics: ContractMetric[]\n      totalPositions: number\n      dashboards: Dashboard[]\n      cashContract: MarketContract\n      totalManaBets: number\n      totalCashBets: number\n    },\n    props: z.object({\n      slug: z.string().optional(),\n      id: z.string().optional(),\n    }),\n  },\n  'get-user-contract-metrics-with-contracts': {\n    method: 'GET',\n    visibility: 'public',\n    preferAuth: true,\n    authed: false,\n    returns: {} as {\n      metricsByContract: Dictionary<ContractMetric[]>\n      contracts: MarketContract[]\n    },\n    props: z.object({\n      userId: z.string(),\n      limit: z.coerce.number(),\n      offset: z.coerce.number().gte(0).optional(),\n      perAnswer: coerceBoolean.optional(),\n      inMani: coerceBoolean.optional(),\n    }),\n  },\n  validateIap: {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z.object({\n      receipt: z.string(),\n    }),\n  },\n  'check-sports-event': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as { exists: boolean; existingMarket?: LiteMarket },\n    props: z\n      .object({\n        sportsEventId: z.string(),\n      })\n      .strict(),\n  },\n  'comment-reactions': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Reaction[],\n    props: z\n      .object({\n        contentIds: z.array(z.string()),\n        contentType: z.enum(['comment', 'contract']),\n      })\n      .strict(),\n  },\n  'mark-all-notifications-new': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({}).strict(),\n    returns: {} as { success: boolean },\n  },\n  'get-contract-voters': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        contractId: z.string(),\n      })\n      .strict(),\n    returns: [] as DisplayUser[],\n  },\n  'get-contract-option-voters': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ contractId: z.string(), optionId: z.string() }),\n    returns: [] as DisplayUser[],\n  },\n  'purchase-contract-boost': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        contractId: z.string(),\n        startTime: z.number().positive().finite().safe(),\n        method: z.enum(['mana', 'cash']),\n      })\n      .strict(),\n    returns: {} as { success: boolean; checkoutUrl?: string },\n  },\n  'generate-ai-numeric-ranges': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as {\n      thresholds: { answers: string[]; midpoints: number[] }\n      buckets: { answers: string[]; midpoints: number[] }\n    },\n    props: z\n      .object({\n        question: z.string(),\n        min: z.number(),\n        max: z.number(),\n        description: z.string().optional(),\n        unit: z.string(),\n      })\n      .strict(),\n  },\n  'infer-numeric-unit': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as {\n      unit: string\n    },\n    props: z\n      .object({\n        question: z.string(),\n        description: z.string().optional(),\n      })\n      .strict(),\n  },\n  'generate-ai-date-ranges': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as {\n      buckets: { answers: string[]; midpoints: number[] }\n      thresholds: { answers: string[]; midpoints: number[] }\n    },\n    props: z\n      .object({\n        question: z.string(),\n        min: z.string(),\n        max: z.string(),\n        description: z.string().optional(),\n      })\n      .strict(),\n  },\n  'regenerate-numeric-midpoints': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { midpoints: number[] },\n    props: z\n      .object({\n        description: z.string().optional(),\n        question: z.string(),\n        answers: z.array(z.string()),\n        min: z.number(),\n        max: z.number(),\n        unit: z.string(),\n        tab: z.enum(['thresholds', 'buckets']),\n      })\n      .strict(),\n  },\n  'regenerate-date-midpoints': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { midpoints: number[] },\n    props: z\n      .object({\n        description: z.string().optional(),\n        question: z.string(),\n        answers: z.array(z.string()),\n        min: z.string(),\n        max: z.string(),\n        tab: z.enum(['thresholds', 'buckets']),\n      })\n      .strict(),\n  },\n\n  'generate-concise-title': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        question: z.string(),\n      })\n      .strict(),\n    returns: {} as { title: string },\n  },\n  'get-close-date': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        question: z.string(),\n        utcOffset: z.number().optional(),\n      })\n      .strict(),\n    returns: {} as { closeTime: number },\n  },\n  'refer-user': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        referredByUsername: z.string(),\n        contractId: z.string().optional(),\n      })\n      .strict(),\n    returns: {} as { success: boolean },\n  },\n\n  'save-market-draft': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { id: number },\n    props: z\n      .object({\n        data: z.object({\n          question: z.string(),\n          description: z.any().optional(),\n          outcomeType: z.string(),\n          answers: z.array(z.string()).optional(),\n          closeDate: z.string().optional(),\n          closeHoursMinutes: z.string().optional(),\n          visibility: z.string(),\n          selectedGroups: z.array(z.any()),\n          savedAt: z.number(),\n        }),\n      })\n      .strict(),\n  },\n\n  'get-market-drafts': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: [] as MarketDraft[],\n    props: z.object({}).strict(),\n  },\n\n  'delete-market-draft': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z\n      .object({\n        id: z.coerce.number(),\n      })\n      .strict(),\n  },\n  'get-season-info': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      season: z.coerce.number().int().positive().optional(),\n    }),\n    returns: {} as {\n      season: number\n      startTime: number // epoch ms\n      endTime: number | null // epoch ms, null if a *mystery* for clients\n      status: 'active' | 'processing' | 'complete'\n    },\n  },\n  'mark-notification-read': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z\n      .object({\n        notificationId: z.string(),\n      })\n      .strict(),\n  },\n  'dismiss-user-report': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        reportId: z.string(),\n      })\n      .strict(),\n    returns: {} as { success: boolean },\n  },\n  'create-post': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { post: TopLevelPost },\n    props: z\n      .object({\n        title: z.string().min(1).max(120),\n        content: contentSchema,\n        isAnnouncement: z.boolean().optional(),\n        visibility: z.enum(['public', 'unlisted']).optional(),\n        isChangeLog: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  'update-post': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { post: TopLevelPost },\n    props: z\n      .object({\n        id: z.string(),\n        title: z.string().min(1).max(480).optional(),\n        content: contentSchema.optional(),\n        visibility: z.enum(['public', 'unlisted']).optional(),\n      })\n      .strict(),\n  },\n  'create-post-comment': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { comment: PostComment },\n    props: z\n      .object({\n        postId: z.string(),\n        content: contentSchema,\n        replyToCommentId: z.string().optional(),\n      })\n      .strict(),\n  },\n  'update-post-comment': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { comment: PostComment },\n    props: z\n      .object({\n        commentId: z.string(),\n        postId: z.string(),\n        hidden: z.boolean(),\n      })\n      .strict(),\n  },\n  'follow-post': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: true },\n    props: z\n      .object({\n        postId: z.string(),\n        follow: z.boolean(),\n      })\n      .strict(),\n  },\n  'edit-post-comment': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        commentId: z.string(),\n        postId: z.string(),\n        content: contentSchema,\n      })\n      .strict(),\n    returns: {} as { success: boolean },\n  },\n} as const)\n\nexport type APIPath = keyof typeof API\nexport type APISchema<N extends APIPath> = (typeof API)[N]\n\nexport type APIParams<N extends APIPath> = z.input<APISchema<N>['props']>\nexport type ValidatedAPIParams<N extends APIPath> = z.output<\n  APISchema<N>['props']\n>\n\nexport type APIResponse<N extends APIPath> = APISchema<N> extends {\n  returns: Record<string, any>\n}\n  ? APISchema<N>['returns']\n  : void\n\nexport type APIResponseOptionalContinue<N extends APIPath> =\n  | { continue: () => Promise<void>; result: APIResponse<N> }\n  | APIResponse<N>\n"
        }
      ]
    },
    {
      "sha": "63bfd3bc1a03c014473459ad8170ad460f51a1e7",
      "author": "Ian Philips",
      "date": "2025-05-21 14:58:12 -0700",
      "message": "Add topic selection back to welcome flow",
      "stats": {
        "filesChanged": 3,
        "insertions": 63,
        "deletions": 74
      },
      "selectionReason": "Re-adds topic selection to welcome flow - demonstrates user onboarding flow modifications with significant UI changes",
      "spec": "Update the topic data structures and re-integrate a simplified topic selection step into the user onboarding flow. \nIn `common/src/topics.ts`:\n1. Rename the `TOPICS_TO_SUBTOPICS` map to `SEARCH_TOPICS_TO_SUBTOPICS`.\n2. Within the renamed `SEARCH_TOPICS_TO_SUBTOPICS` map, under the '🎬 Culture' parent topic, for the '🤩 Pop culture' subtopic, ensure its `groupIds` array no longer contains `eJZecx6r22G2NriYYXcC` and `4QIcUOfCSSha0JZHAg9X`. For the '🍿 Movies & TV' subtopic, ensure its `groupIds` array no longer contains `KSeNIu7AWgiBBM5FqVuB`. For the '🎮 Gaming' subtopic, ensure its `groupIds` array no longer contains `9FaZmHrfS8IcDJyu6pUD`.\n3. Remove the `TOPICS_TO_HIDE_FROM_WELCOME_FLOW` array and its associated validation logic.\n4. Define and export a new array named `WELCOME_FLOW_TOPICS`. Each element must be an object with `name: string` and `groupId: string` properties. Populate this array with the 15 topics: { name: 'Politics', groupId: 'UCnpxVUdLOZYgoMsDlHD' }, { name: 'AI', groupId: 'yEWvvwFFIqzf8JklMewp' }, { name: 'Technology', groupId: 'IlzY3moWwOcpsVZXCVej' }, { name: 'Coding', groupId: 'PZJMbrLekgJBy7OOBKGT' }, { name: 'Science', groupId: 'XMhZ5LbQoLMZiOpQJRnj' }, { name: 'Sports', groupId: '2hGlgVhIyvVaFyQAREPi' }, { name: 'Music', groupId: 'Xuc2UY8gGfjQqFXwxq5d' }, { name: 'Movies & TV', groupId: 'EUSEngFk1dGGBfaMeAmh' }, { name: 'Culture', groupId: 'XU1fOYURSnb58lgsqaly' }, { name: 'Gaming', groupId: '5FaFmmaNNFTSA5r0vTAi' }, { name: 'Finance', groupId: 'CgB83AAMkkOHSrTnzani' }, { name: 'Business', groupId: 'pmK8sntWL1SDkMm53UBR' }, { name: 'Economics', groupId: 'p88Ycq6yFd5ECKqq9PFO' }, { name: 'Crypto', groupId: 'YuJw0M1xvUHrpiRRuKso' }, { name: 'Sex & Love', groupId: '3syjPCC7PxE5KurTiTT3' }.\n5. Update the `getSubtopics` function and the `ALL_TOPICS` constant to derive their data from `SEARCH_TOPICS_TO_SUBTOPICS`.\n6. Remove the export of `ALL_PARENT_TOPICS` from this file.\n\nIn `web/components/onboarding/welcome.tsx`:\n1. Ensure the topic selection page (`TopicsPage`) is active and displayed as part of the welcome onboarding flow (controlled by the `SHOW_TOPICS` constant being true).\n2. Modify the `getTrendingAndUserCategories` function so that `hardCodedTopicIds` are derived from the `groupId` property of each topic in the `WELCOME_FLOW_TOPICS` array.\n3. Refactor the `TopicsPage` component: \n    a. Set the page title to \"What interests you?\".\n    b. Set the descriptive text below the title to \"We'll use this to customize your experience.\"\n    c. Display a primary list of topics using the `WELCOME_FLOW_TOPICS` array. Each topic should be rendered as a selectable pill button displaying its name.\n    d. Below this primary list, display a section labeled \"Suggested\" (if user has prior activity/views) or \"Trending\" (otherwise). This section should also display topics as selectable pill buttons.\n    e. Style all topic pill buttons with increased padding and text size (e.g., consistent with `!px-5 !py-5 !text-lg`).\n    f. Remove any requirement for selecting a minimum number of topics before the user can proceed. The \"Finish\" button should be enabled by default (unless in a loading state).\n    g. Implement auto-follow logic: if the user selects the 'Politics' topic (identified by group ID `UCnpxVUdLOZYgoMsDlHD` from `WELCOME_FLOW_TOPICS`), automatically follow the user account with ID `vuI5upWB8yU00rP7yxj95J2zd952`. If the user selects the 'AI' topic (identified by group ID `yEWvvwFFIqzf8JklMewp` from `WELCOME_FLOW_TOPICS`), automatically follow the user account with ID `8lZo8X5lewh4hnCoreI7iSc0GxK2`. If a topic with group ID `0d39aa2b-1447-4298-bc60-5ef67d9cea4f` is selected (e.g., from suggested/trending topics), automatically follow user `fBFdG15kdfeBmjRVEajSMLayZ2y1`.\n\nIn `web/components/search.tsx`:\n1. Update all internal references from `TOPICS_TO_SUBTOPICS` to `SEARCH_TOPICS_TO_SUBTOPICS`.\n2. Define the `ALL_PARENT_TOPICS` constant locally within this component, deriving its value from `Object.keys(SEARCH_TOPICS_TO_SUBTOPICS)`.\n3. Ensure that topic and subtopic filtering functionalities within the search interface continue to operate correctly using the `SEARCH_TOPICS_TO_SUBTOPICS` data structure.",
      "fileStates": [
        {
          "path": "common/src/topics.ts",
          "preContent": "import {\n  HIDE_FROM_NEW_USER_SLUGS,\n  PROD_MANIFOLD_LOVE_GROUP_SLUG,\n} from 'common/envs/constants'\nimport { removeEmojis } from './util/string'\n\ntype TopicInfo = { name: string; groupIds: string[]; hideFromSearch?: boolean }\n\nexport const TOPICS_TO_SUBTOPICS: { [key: string]: TopicInfo[] } = {\n  '🗳️ Politics': [\n    {\n      name: '🇺🇸 USA',\n      groupIds: [\n        'AjxQR8JMpNyDqtiqoA96', // US Politics\n        'cEzcLXuitr6o4VPI01Q1', // Trump\n        '46e04289-2b15-4997-841b-b8e1d5175c39', // trump's second term\n        'EWgcYV1JYWP19dE3BZCb', // republican party\n      ],\n    },\n    { name: '🇨🇳 China', groupIds: ['oWTzfoeemQGkSoPFn2T7'] },\n    {\n      // Ukraine-Russia War, Russia, Ukraine\n      name: '🇷🇺🇺🇦 Russia & Ukraine',\n      groupIds: [\n        'OxcXOuxXvwsXtC0Dx5sr',\n        'TIpf6j0hLpifpXN93FxE',\n        '0AKCBNjWsHwpfmPOsGf6',\n      ],\n    },\n    {\n      name: '🇮🇱🇵🇸 Israel & Hamas',\n      groupIds: [\n        'cea99c1c-afb9-49b2-adfa-9be739adce10',\n        'ECjphikMbmosJsDAAJoU', // Israel\n      ],\n    },\n    { name: '🇬🇧 UK', groupIds: ['aavkiDd6uZggfL3geuV2'] },\n    { name: '🇪🇺 Europe', groupIds: ['ue52QI4BQgJgAJJNjLHr'] },\n    { name: '🇮🇳 India', groupIds: ['Y2J00UcVhr3wKq2lAOAy'] },\n    { name: '🌎 LatAm', groupIds: ['DX94A1LQmpckcVdz5Hb3'] },\n    { name: '🌏 Africa', groupIds: ['dFsZaGwyohGDVkJi1C3E'] },\n    { name: '🌏 Middle East', groupIds: ['xg8wCPeM9JP6gD0igBrA'] },\n    { name: '🌎 Asia', groupIds: ['bPTxMZhUYsIUXsWT969d'] },\n    {\n      name: '🌐 Politics',\n      groupIds: [\n        'UCnpxVUdLOZYgoMsDlHD', // Politics default\n        'XUjgI120xjTU5n382rWL', // Canadian Politics\n      ],\n      hideFromSearch: true,\n    },\n  ],\n  '🤖 AI': [\n    {\n      name: 'AI',\n      groupIds: ['yEWvvwFFIqzf8JklMewp'],\n      hideFromSearch: true,\n    },\n    {\n      name: 'Timelines',\n      groupIds: ['GbbX9U5pYnDeftX9lxUh'],\n    },\n\n    {\n      name: 'OpenAI',\n      groupIds: ['a3ikurqO9fT46Pv9ZGkY'],\n    },\n    {\n      name: 'AI Impacts & Safety',\n      groupIds: ['DnxTZ1P5XEEfnHxy7Q7d', 'q3Su0NeV9ta4DqhqlIEq'],\n    },\n    {\n      name: 'Anthropic',\n      groupIds: ['B8jfqGL9Uqu5nejktmVi'],\n    },\n  ],\n  '💻 Tech': [\n    {\n      name: '💻 Technology',\n      groupIds: [\n        'IlzY3moWwOcpsVZXCVej', // Technology\n        'SmJk6RHToaLxLk0I1ZSC', // Space\n      ],\n    },\n    {\n      name: '🔬 Science',\n      groupIds: [\n        'XMhZ5LbQoLMZiOpQJRnj', // Science\n        '97oNExy8iFftY2EgdkLw', // Climate\n      ],\n    },\n    {\n      name: '🏥 Health',\n      groupIds: ['JpUqUqRn9sSWxrk0Sq35'],\n    },\n    {\n      name: '👨‍💻 Code',\n      groupIds: ['PZJMbrLekgJBy7OOBKGT'],\n    },\n    {\n      name: '🧮 Math',\n      groupIds: ['S1tbcVt1t5Bd9O5mVCx1'],\n    },\n  ],\n  '🏟️ Sports': [\n    {\n      name: '🏀 Basketball',\n      groupIds: [\n        'NjkFkdkvRvBHoeMDQ5NB', // Basketball\n        'beeb69e0-b36f-451a-80e1-e059df456bb1', // College Basketball\n        'i0v3cXwuxmO9fpcInVYb', // NBA\n      ],\n    },\n    {\n      // NFL, College Football\n      name: '🏈 NFL',\n      groupIds: ['TNQwmbE5p6dnKx2e6Qlp', 'ky1VPTuxrLXMnHyajZFp'],\n    },\n    { name: '⚾ Baseball', groupIds: ['786nRQzgVyUnuUtaLTGW'] },\n    { name: '⚽ Soccer', groupIds: ['ypd6vR44ZzJyN9xykx6e'] },\n    { name: '🏒 NHL', groupIds: ['lccgApXa1l7O5ZH3XfhH'] },\n    { name: '🏎️ F1', groupIds: ['OyHBKJOz9YaGkDctpwuY'] },\n    { name: '♟️ Chess', groupIds: ['ED7Cu6lVPshJkZ7FYePW'] },\n    { name: '🚲 Cycling', groupIds: ['2yisxJryUq9V5sG7P6Gy'] },\n    { name: '🎾 Tennis', groupIds: ['1mvN9vIVIopcWiAsXhzp'] },\n    { name: '🏏 Cricket', groupIds: ['LcPYoqxSRdeQMms4lR3g'] },\n    {\n      name: '🌐 Sports',\n      groupIds: ['2hGlgVhIyvVaFyQAREPi'],\n      hideFromSearch: true,\n    }, // default group\n  ],\n  '🎬 Culture': [\n    {\n      name: '🤩 Pop culture',\n      groupIds: [\n        'eJZecx6r22G2NriYYXcC', // Culture\n        'XU1fOYURSnb58lgsqaly', // Entertainment & Pop culture\n        '4QIcUOfCSSha0JZHAg9X', // celebrities\n      ],\n    },\n    {\n      name: '🍿 Movies & TV',\n      groupIds: [\n        'KSeNIu7AWgiBBM5FqVuB', // Movies\n        'EUSEngFk1dGGBfaMeAmh', // TV and Film\n      ],\n    },\n    {\n      name: '🎶 Music',\n      groupIds: ['Xuc2UY8gGfjQqFXwxq5d'],\n    },\n    {\n      name: '🎮 Gaming',\n      groupIds: [\n        '5FaFmmaNNFTSA5r0vTAi', // Gaming\n        '9FaZmHrfS8IcDJyu6pUD', // Video Games\n      ],\n    },\n    {\n      name: '🎮️ Destiny.gg',\n      groupIds: ['W2ES30fRo6CCbPNwMTTj'],\n    },\n    {\n      name: '🏴‍☠️ One Piece',\n      groupIds: ['uJSql24HUqpEpVU0FrjI'],\n    },\n  ],\n  '💵 Business': [\n    {\n      name: '📈 Finance & Stocks',\n      groupIds: [\n        'pmK8sntWL1SDkMm53UBR', // Business\n        'CgB83AAMkkOHSrTnzani', // Finance\n        'QDQfgsFiQrNNlZhsRGf5', // Stocks\n        'pK06hNX8MsNw8zaBsX2N', // Tech Stocks\n        '1a9ef4d5-dcc6-468f-a9b7-feccdaa92733', // Big Tech\n      ],\n    },\n    {\n      name: '📊 Econ',\n      groupIds: [\n        'p88Ycq6yFd5ECKqq9PFO', // Economics\n      ],\n    },\n    {\n      // Crypto, Bitcoin\n      name: '🪙 Crypto',\n      groupIds: ['YuJw0M1xvUHrpiRRuKso', 'WBeBD6FyMd0NvSL0qjMb'],\n    },\n  ],\n  '🤪 Fun': [\n    {\n      name: '🎲 Fun & games',\n      groupIds: [\n        '5V0GjAyN99OQpb96fwo8', // whale watching\n        'J8Z1KAZV31icklA4tgJW', // fairly random\n        'bBwafyeaiuwWwobwm2c4', // fun\n      ],\n    },\n    {\n      name: '🌐 Manifold',\n      groupIds: ['hzyCW27Hf9NzuXZRizeZ'],\n    },\n    {\n      name: '💪 Personal Goals',\n      groupIds: [\n        'izQp87CKagOVJp9Olm1p', // Personal goals\n        'wxAGTtNee5f2PTzjqSI2', // Personal\n      ],\n    },\n    {\n      // Sex and love, Dating\n      name: '❤️‍🔥 Sex and love',\n      groupIds: ['3syjPCC7PxE5KurTiTT3', 'j3ZE8fkeqiKmRGumy3O1'],\n    },\n    {\n      name: '🐸 Meme stocks',\n      groupIds: [\n        '524e08a3-3589-4267-9009-818d6c89cfa4', // meme-stocks\n        '2T4mM0N5az2lYcaN5G50', // permanent-markets\n      ],\n    },\n  ],\n}\n\nexport const TOPICS_TO_HIDE_FROM_WELCOME_FLOW = [] as string[]\nif (\n  !TOPICS_TO_HIDE_FROM_WELCOME_FLOW.every((topic) =>\n    Object.keys(TOPICS_TO_SUBTOPICS).includes(topic)\n  )\n) {\n  throw new Error(\n    `${TOPICS_TO_HIDE_FROM_WELCOME_FLOW.join(', ')} contains invalid topics`\n  )\n}\n\nexport const GROUP_SLUGS_TO_HIDE_FROM_WELCOME_FLOW = [\n  'world-default',\n  'shortterm-markets',\n  'daily-markets',\n  'global-macro',\n  'politics-default', // US Politics\n  'magaland',\n  'donald-trump',\n  'the-life-of-biden',\n  // 'elon-musk-14d9d9498c7e',\n  'crypto-prices', // Crypto,\n  'bitcoin-maxi',\n  'nasdaq', // Stocks\n  'stock-marketdaily',\n  'ai-stocks',\n  'prices',\n  'entertainment', // should follow smaller groups instead\n  'entertainment-12ba84d9b720',\n  'gpt5-speculation', // AI\n  'chatgpt',\n  '2024-3d9da60b52f8',\n  'coolfold',\n  'grab-bag',\n  'internet',\n  'sports-default',\n  'football', // ambiguous - both soccer and american football\n  'manifold-drama',\n  'permanent-markets',\n  'testing',\n  PROD_MANIFOLD_LOVE_GROUP_SLUG,\n  ...HIDE_FROM_NEW_USER_SLUGS,\n]\n\nexport const getSubtopics = (topic: string) =>\n  TOPICS_TO_SUBTOPICS[topic].map(\n    (subtopic) =>\n      [subtopic.name, removeEmojis(subtopic.name), subtopic.groupIds] as const\n  )\nexport const ALL_TOPICS = Object.keys(TOPICS_TO_SUBTOPICS)\n  .map((topic) => getSubtopics(topic).map(([_, subtopic]) => subtopic))\n  .flat()\n\nexport const ALL_PARENT_TOPICS = Object.keys(TOPICS_TO_SUBTOPICS)\n",
          "postContent": "import {\n  HIDE_FROM_NEW_USER_SLUGS,\n  PROD_MANIFOLD_LOVE_GROUP_SLUG,\n} from 'common/envs/constants'\nimport { removeEmojis } from './util/string'\n\ntype TopicInfo = { name: string; groupIds: string[]; hideFromSearch?: boolean }\n\nexport const SEARCH_TOPICS_TO_SUBTOPICS: { [key: string]: TopicInfo[] } = {\n  '🗳️ Politics': [\n    {\n      name: '🇺🇸 USA',\n      groupIds: [\n        'AjxQR8JMpNyDqtiqoA96', // US Politics\n        'cEzcLXuitr6o4VPI01Q1', // Trump\n        '46e04289-2b15-4997-841b-b8e1d5175c39', // trump's second term\n        'EWgcYV1JYWP19dE3BZCb', // republican party\n      ],\n    },\n    { name: '🇨🇳 China', groupIds: ['oWTzfoeemQGkSoPFn2T7'] },\n    {\n      // Ukraine-Russia War, Russia, Ukraine\n      name: '🇷🇺🇺🇦 Russia & Ukraine',\n      groupIds: [\n        'OxcXOuxXvwsXtC0Dx5sr',\n        'TIpf6j0hLpifpXN93FxE',\n        '0AKCBNjWsHwpfmPOsGf6',\n      ],\n    },\n    {\n      name: '🇮🇱🇵🇸 Israel & Hamas',\n      groupIds: [\n        'cea99c1c-afb9-49b2-adfa-9be739adce10',\n        'ECjphikMbmosJsDAAJoU', // Israel\n      ],\n    },\n    { name: '🇬🇧 UK', groupIds: ['aavkiDd6uZggfL3geuV2'] },\n    { name: '🇪🇺 Europe', groupIds: ['ue52QI4BQgJgAJJNjLHr'] },\n    { name: '🇮🇳 India', groupIds: ['Y2J00UcVhr3wKq2lAOAy'] },\n    { name: '🌎 LatAm', groupIds: ['DX94A1LQmpckcVdz5Hb3'] },\n    { name: '🌏 Africa', groupIds: ['dFsZaGwyohGDVkJi1C3E'] },\n    { name: '🌏 Middle East', groupIds: ['xg8wCPeM9JP6gD0igBrA'] },\n    { name: '🌎 Asia', groupIds: ['bPTxMZhUYsIUXsWT969d'] },\n    {\n      name: '🌐 Politics',\n      groupIds: [\n        'UCnpxVUdLOZYgoMsDlHD', // Politics default\n        'XUjgI120xjTU5n382rWL', // Canadian Politics\n      ],\n      hideFromSearch: true,\n    },\n  ],\n  '🤖 AI': [\n    {\n      name: 'AI',\n      groupIds: ['yEWvvwFFIqzf8JklMewp'],\n      hideFromSearch: true,\n    },\n    {\n      name: 'Timelines',\n      groupIds: ['GbbX9U5pYnDeftX9lxUh'],\n    },\n\n    {\n      name: 'OpenAI',\n      groupIds: ['a3ikurqO9fT46Pv9ZGkY'],\n    },\n    {\n      name: 'AI Impacts & Safety',\n      groupIds: ['DnxTZ1P5XEEfnHxy7Q7d', 'q3Su0NeV9ta4DqhqlIEq'],\n    },\n    {\n      name: 'Anthropic',\n      groupIds: ['B8jfqGL9Uqu5nejktmVi'],\n    },\n  ],\n  '💻 Tech': [\n    {\n      name: '💻 Technology',\n      groupIds: [\n        'IlzY3moWwOcpsVZXCVej', // Technology\n        'SmJk6RHToaLxLk0I1ZSC', // Space\n      ],\n    },\n    {\n      name: '🔬 Science',\n      groupIds: [\n        'XMhZ5LbQoLMZiOpQJRnj', // Science\n        '97oNExy8iFftY2EgdkLw', // Climate\n      ],\n    },\n    {\n      name: '🏥 Health',\n      groupIds: ['JpUqUqRn9sSWxrk0Sq35'],\n    },\n    {\n      name: '👨‍💻 Code',\n      groupIds: ['PZJMbrLekgJBy7OOBKGT'],\n    },\n    {\n      name: '🧮 Math',\n      groupIds: ['S1tbcVt1t5Bd9O5mVCx1'],\n    },\n  ],\n  '🏟️ Sports': [\n    {\n      name: '🏀 Basketball',\n      groupIds: [\n        'NjkFkdkvRvBHoeMDQ5NB', // Basketball\n        'beeb69e0-b36f-451a-80e1-e059df456bb1', // College Basketball\n        'i0v3cXwuxmO9fpcInVYb', // NBA\n      ],\n    },\n    {\n      // NFL, College Football\n      name: '🏈 NFL',\n      groupIds: ['TNQwmbE5p6dnKx2e6Qlp', 'ky1VPTuxrLXMnHyajZFp'],\n    },\n    { name: '⚾ Baseball', groupIds: ['786nRQzgVyUnuUtaLTGW'] },\n    { name: '⚽ Soccer', groupIds: ['ypd6vR44ZzJyN9xykx6e'] },\n    { name: '🏒 NHL', groupIds: ['lccgApXa1l7O5ZH3XfhH'] },\n    { name: '🏎️ F1', groupIds: ['OyHBKJOz9YaGkDctpwuY'] },\n    { name: '♟️ Chess', groupIds: ['ED7Cu6lVPshJkZ7FYePW'] },\n    { name: '🚲 Cycling', groupIds: ['2yisxJryUq9V5sG7P6Gy'] },\n    { name: '🎾 Tennis', groupIds: ['1mvN9vIVIopcWiAsXhzp'] },\n    { name: '🏏 Cricket', groupIds: ['LcPYoqxSRdeQMms4lR3g'] },\n    {\n      name: '🌐 Sports',\n      groupIds: ['2hGlgVhIyvVaFyQAREPi'],\n      hideFromSearch: true,\n    }, // default group\n  ],\n  '🎬 Culture': [\n    {\n      name: '🤩 Pop culture',\n      groupIds: [\n        'XU1fOYURSnb58lgsqaly', // Entertainment & Pop culture\n        // 'eJZecx6r22G2NriYYXcC', // Culture TODO: MERGE\n        // '4QIcUOfCSSha0JZHAg9X', // celebrities TODO: MERGE\n      ],\n    },\n    {\n      name: '🍿 Movies & TV',\n      groupIds: [\n        // 'KSeNIu7AWgiBBM5FqVuB', // Movies TODO: MERGE\n        'EUSEngFk1dGGBfaMeAmh', // TV and Film\n      ],\n    },\n    {\n      name: '🎶 Music',\n      groupIds: ['Xuc2UY8gGfjQqFXwxq5d'],\n    },\n    {\n      name: '🎮 Gaming',\n      groupIds: [\n        '5FaFmmaNNFTSA5r0vTAi', // Gaming\n        // '9FaZmHrfS8IcDJyu6pUD', // Video Games TODO: MERGE\n      ],\n    },\n    {\n      name: '🎮️ Destiny.gg',\n      groupIds: ['W2ES30fRo6CCbPNwMTTj'],\n    },\n    {\n      name: '🏴‍☠️ One Piece',\n      groupIds: ['uJSql24HUqpEpVU0FrjI'],\n    },\n  ],\n  '💵 Business': [\n    {\n      name: '📈 Finance & Stocks',\n      groupIds: [\n        'pmK8sntWL1SDkMm53UBR', // Business\n        'CgB83AAMkkOHSrTnzani', // Finance\n        'QDQfgsFiQrNNlZhsRGf5', // Stocks\n        'pK06hNX8MsNw8zaBsX2N', // Tech Stocks\n        '1a9ef4d5-dcc6-468f-a9b7-feccdaa92733', // Big Tech\n      ],\n    },\n    {\n      name: '📊 Econ',\n      groupIds: [\n        'p88Ycq6yFd5ECKqq9PFO', // Economics\n      ],\n    },\n    {\n      // Crypto, Bitcoin\n      name: '🪙 Crypto',\n      groupIds: ['YuJw0M1xvUHrpiRRuKso', 'WBeBD6FyMd0NvSL0qjMb'],\n    },\n  ],\n  '🤪 Fun': [\n    {\n      name: '🎲 Fun & games',\n      groupIds: [\n        '5V0GjAyN99OQpb96fwo8', // whale watching\n        'J8Z1KAZV31icklA4tgJW', // fairly random\n        'bBwafyeaiuwWwobwm2c4', // fun\n      ],\n    },\n    {\n      name: '🌐 Manifold',\n      groupIds: ['hzyCW27Hf9NzuXZRizeZ'],\n    },\n    {\n      name: '💪 Personal Goals',\n      groupIds: [\n        'izQp87CKagOVJp9Olm1p', // Personal goals\n        'wxAGTtNee5f2PTzjqSI2', // Personal\n      ],\n    },\n    {\n      // Sex and love, Dating\n      name: '❤️‍🔥 Sex and love',\n      groupIds: ['3syjPCC7PxE5KurTiTT3', 'j3ZE8fkeqiKmRGumy3O1'],\n    },\n    {\n      name: '🐸 Meme stocks',\n      groupIds: [\n        '524e08a3-3589-4267-9009-818d6c89cfa4', // meme-stocks\n        '2T4mM0N5az2lYcaN5G50', // permanent-markets\n      ],\n    },\n  ],\n}\n\nexport type WelcomeTopicInfo = { name: string; groupId: string }\n\nexport const WELCOME_FLOW_TOPICS: WelcomeTopicInfo[] = [\n  { name: 'Politics', groupId: 'UCnpxVUdLOZYgoMsDlHD' },\n  { name: 'AI', groupId: 'yEWvvwFFIqzf8JklMewp' },\n  { name: 'Technology', groupId: 'IlzY3moWwOcpsVZXCVej' },\n  { name: 'Coding', groupId: 'PZJMbrLekgJBy7OOBKGT' },\n  { name: 'Science', groupId: 'XMhZ5LbQoLMZiOpQJRnj' },\n  { name: 'Sports', groupId: '2hGlgVhIyvVaFyQAREPi' },\n  { name: 'Music', groupId: 'Xuc2UY8gGfjQqFXwxq5d' },\n  { name: 'Movies & TV', groupId: 'EUSEngFk1dGGBfaMeAmh' },\n  { name: 'Culture', groupId: 'XU1fOYURSnb58lgsqaly' },\n  { name: 'Gaming', groupId: '5FaFmmaNNFTSA5r0vTAi' },\n  { name: 'Finance', groupId: 'CgB83AAMkkOHSrTnzani' },\n  { name: 'Business', groupId: 'pmK8sntWL1SDkMm53UBR' },\n  { name: 'Economics', groupId: 'p88Ycq6yFd5ECKqq9PFO' },\n  { name: 'Crypto', groupId: 'YuJw0M1xvUHrpiRRuKso' },\n  { name: 'Sex & Love', groupId: '3syjPCC7PxE5KurTiTT3' },\n]\n\nexport const GROUP_SLUGS_TO_HIDE_FROM_WELCOME_FLOW = [\n  'world-default',\n  'shortterm-markets',\n  'daily-markets',\n  'global-macro',\n  'politics-default', // US Politics\n  'magaland',\n  'donald-trump',\n  'the-life-of-biden',\n  // 'elon-musk-14d9d9498c7e',\n  'crypto-prices', // Crypto,\n  'bitcoin-maxi',\n  'nasdaq', // Stocks\n  'stock-marketdaily',\n  'ai-stocks',\n  'prices',\n  'entertainment', // should follow smaller groups instead\n  'entertainment-12ba84d9b720',\n  'gpt5-speculation', // AI\n  'chatgpt',\n  '2024-3d9da60b52f8',\n  'coolfold',\n  'grab-bag',\n  'internet',\n  'sports-default',\n  'football', // ambiguous - both soccer and american football\n  'manifold-drama',\n  'permanent-markets',\n  'testing',\n  PROD_MANIFOLD_LOVE_GROUP_SLUG,\n  ...HIDE_FROM_NEW_USER_SLUGS,\n]\n\nexport const getSubtopics = (topic: string) =>\n  SEARCH_TOPICS_TO_SUBTOPICS[topic].map(\n    (subtopic) =>\n      [subtopic.name, removeEmojis(subtopic.name), subtopic.groupIds] as const\n  )\nexport const ALL_TOPICS = Object.keys(SEARCH_TOPICS_TO_SUBTOPICS)\n  .map((topic) => getSubtopics(topic).map(([_, subtopic]) => subtopic))\n  .flat()\n"
        },
        {
          "path": "web/components/onboarding/welcome.tsx",
          "preContent": "/* eslint-disable react/jsx-key */\nimport { useEffect, useState } from 'react'\nimport Image from 'next/image'\n\nimport { STARTING_BALANCE } from 'common/economy'\nimport { User } from 'common/user'\nimport { buildArray } from 'common/util/array'\nimport { formatMoney } from 'common/util/format'\nimport { Button } from 'web/components/buttons/button'\nimport { useUser } from 'web/hooks/use-user'\nimport { Col } from '../layout/col'\nimport { Modal } from '../layout/modal'\nimport { Row } from '../layout/row'\nimport { run } from 'common/supabase/utils'\nimport { db } from 'web/lib/supabase/db'\nimport { Group } from 'common/group'\nimport {\n  getSubtopics,\n  GROUP_SLUGS_TO_HIDE_FROM_WELCOME_FLOW,\n  TOPICS_TO_HIDE_FROM_WELCOME_FLOW,\n  TOPICS_TO_SUBTOPICS,\n} from 'common/topics'\nimport { intersection, orderBy, uniq, uniqBy } from 'lodash'\nimport { track } from 'web/lib/service/analytics'\nimport { Input } from '../widgets/input'\nimport { cleanDisplayName, cleanUsername } from 'common/util/clean-username'\nimport { api, updateUser, followTopic, followUser } from 'web/lib/api/api'\nimport { randomString } from 'common/util/random'\nimport { unfollowTopic } from 'web/lib/supabase/groups'\nimport { PillButton } from 'web/components/buttons/pill-button'\nimport { removeEmojis } from 'common/util/string'\nimport { unauthedApi } from 'common/util/api'\nimport { getSavedContractVisitsLocally } from 'web/hooks/use-save-visits'\nimport { capitalize } from 'lodash'\nimport { TRADE_TERM } from 'common/envs/constants'\nimport { convertGroup } from 'common/supabase/groups'\nimport { setCachedReferralInfoForUser } from 'web/lib/firebase/users'\n\nexport const DEFAULT_FOR_YOU = false\nconst SHOW_TOPICS = false\n\nexport function Welcome(props: { setFeedKey?: (key: string) => void }) {\n  const { setFeedKey } = props\n\n  const user = useUser()\n\n  const [open, setOpen] = useState(false)\n  const [page, setPage] = useState(0)\n\n  const shouldShowWelcomeModal = user?.shouldShowWelcome\n\n  const handleSetPage = (page: number) => {\n    if (page === 0) {\n      track('welcome screen: what is manifold')\n    } else if (page === 1) {\n      track('welcome screen: name input')\n    } else if (page === 2) {\n      track('welcome screen: how it works')\n    } else if (page === 3) {\n      track('welcome screen: topic selection')\n    }\n    setPage(page)\n  }\n\n  useEffect(() => {\n    if (!user) return\n    if (shouldShowWelcomeModal) {\n      track('welcome screen: landed')\n      setOpen(true)\n    } else {\n      // Wait until after they've had the opportunity to change their name\n      setCachedReferralInfoForUser(user)\n    }\n  }, [shouldShowWelcomeModal])\n\n  const [userInterestedTopics, setUserInterestedTopics] = useState<Group[]>([])\n  const [userBetInTopics, setUserBetInTopics] = useState<Group[]>([])\n  const [trendingTopics, setTrendingTopics] = useState<Group[]>([])\n\n  const availablePages = buildArray([\n    <WhatIsManifoldPage />,\n    <NameInputPage />,\n    <PredictionMarketPage />,\n    SHOW_TOPICS && (\n      <TopicsPage\n        trendingTopics={trendingTopics}\n        userInterestedTopics={userInterestedTopics}\n        userBetInTopics={userBetInTopics}\n        onNext={increasePage}\n        setFeedKey={setFeedKey}\n        user={user}\n        goBack={() => handleSetPage(page - 1)}\n      />\n    ),\n    // user && !humanish(user) && <OnboardingVerifyPhone onClose={increasePage} />,\n  ])\n  const showBottomButtons = page < 3\n\n  const getTrendingAndUserCategories = async (userId: string) => {\n    const hardCodedTopicIds = Object.keys(TOPICS_TO_SUBTOPICS)\n      .map((topic) => getSubtopics(topic))\n      .flat()\n      .flatMap(([_, __, groupIds]) => groupIds)\n    const [userInterestedTopicsRes, trendingTopicsRes] = await Promise.all([\n      unauthedApi('get-interesting-groups-from-views', {\n        userId,\n        contractIds: getSavedContractVisitsLocally(),\n      }),\n      run(\n        db\n          .from('groups')\n          .select('*')\n          .not('id', 'in', `(${hardCodedTopicIds.join(',')})`)\n          .not(\n            'slug',\n            'in',\n            `(${GROUP_SLUGS_TO_HIDE_FROM_WELCOME_FLOW.join(',')})`\n          )\n          .filter('slug', 'not.ilike', '%manifold%')\n          .order('importance_score', { ascending: false })\n          .limit(9)\n      ),\n    ])\n    const userInterestedTopics = orderBy(\n      userInterestedTopicsRes,\n      'importanceScore',\n      'desc'\n    )\n    const trendingTopics = trendingTopicsRes.data?.map(convertGroup)\n\n    setTrendingTopics(\n      uniqBy(\n        [\n          ...userInterestedTopics.filter(\n            (g) => !hardCodedTopicIds.includes(g.id)\n          ),\n          ...trendingTopics,\n        ],\n        (g) => g.id\n      ).slice(0, 9)\n    )\n    if (userInterestedTopics.some((g) => g.hasBet)) {\n      setUserBetInTopics(\n        userInterestedTopics.filter((g) => g.hasBet).slice(0, 5)\n      )\n    } else {\n      setUserInterestedTopics(userInterestedTopics.slice(0, 5))\n    }\n  }\n\n  useEffect(() => {\n    if (user?.id && shouldShowWelcomeModal)\n      getTrendingAndUserCategories(user.id)\n  }, [user?.id, shouldShowWelcomeModal])\n\n  async function increasePage() {\n    if (page < availablePages.length - 1) handleSetPage(page + 1)\n    else {\n      if (user) await api('me/update', { shouldShowWelcome: false })\n      track('welcome screen: complete')\n      setOpen(false)\n\n      if (window.location.pathname === '/home' && DEFAULT_FOR_YOU) {\n        window.location.reload() // reload to ensure personalized feed\n      }\n    }\n  }\n\n  function decreasePage() {\n    if (page > 0) {\n      handleSetPage(page - 1)\n    }\n  }\n\n  if (!shouldShowWelcomeModal) return <></>\n\n  return (\n    <Modal open={open} size={'md'}>\n      <Col className=\"bg-canvas-0 text-md rounded-md px-4 py-6 md:w-full md:text-lg lg:px-8\">\n        {availablePages[page]}\n        <Col>\n          {showBottomButtons && (\n            <Row className=\"mt-2 justify-between\">\n              <Button\n                color={'gray-white'}\n                className={page === 0 ? 'invisible' : ''}\n                onClick={decreasePage}\n              >\n                Previous\n              </Button>\n              <Button onClick={increasePage}>\n                {page === availablePages.length - 1 ? 'Finish' : 'Next'}\n              </Button>\n            </Row>\n          )}\n        </Col>\n      </Col>\n    </Modal>\n  )\n}\n\n// const useIsTwitch = (user: User | null | undefined) => {\n//   const router = useRouter()\n//   const isTwitch = router.pathname === '/twitch'\n\n//   useEffect(() => {\n//     if (isTwitch && user?.shouldShowWelcome) {\n//       api('me/update', { shouldShowWelcome: false })\n//     }\n//   }, [isTwitch, user?.id, user?.shouldShowWelcome])\n\n//   return isTwitch\n// }\n\nfunction WhatIsManifoldPage() {\n  return (\n    <>\n      <Image\n        className=\"h-1/3 w-1/3 place-self-center object-contain\"\n        src=\"/logo.svg\"\n        alt=\"Manifold Logo\"\n        height={256}\n        width={256}\n      />\n      <div className=\"to-ink-0mt-3 text-primary-700 mb-6 text-center text-2xl font-normal\">\n        Welcome to Manifold!\n      </div>\n      <div className=\"mb-4 text-lg\">\n        Manifold is a play money prediction market platform.\n      </div>\n      <div className=\"mb-4 text-lg\">\n        Bet on politics, tech, sports, and more. Your {TRADE_TERM}s contribute\n        to the wisdom of the crowd.\n      </div>\n    </>\n  )\n}\n\nfunction NameInputPage() {\n  const user = useUser()\n\n  const [name, setName] = useState<string>(user?.name ?? 'friend')\n  useEffect(() => {\n    if (user?.name) setName(user.name)\n  }, [user?.name === undefined])\n\n  const saveName = async () => {\n    let newName = cleanDisplayName(name)\n    if (!newName) newName = 'User'\n    if (newName === user?.name) return\n    setName(newName)\n\n    await updateUser({ name: newName })\n\n    let username = cleanUsername(newName)\n    try {\n      await updateUser({ username })\n    } catch (e) {\n      username += randomString(5)\n      await updateUser({ username })\n    }\n  }\n\n  return (\n    <>\n      <div className=\"to-ink-0mt-3 text-primary-700 mb-6 text-center text-2xl font-normal\">\n        About You\n      </div>\n      <div className=\"mb-4 flex flex-col gap-2\">\n        <p className=\"text-lg\">What should we call you?</p>\n        <div className=\"w-full max-w-xs\">\n          <Input\n            id=\"display-name\"\n            type=\"text\"\n            placeholder=\"Enter your name\"\n            value={name}\n            className=\"w-full text-lg font-semibold\"\n            maxLength={30}\n            onChange={(e) => setName(e.target.value)}\n            onBlur={saveName}\n            data-cy=\"onboarding-name-input\"\n          />\n        </div>\n      </div>\n      <div className=\"mb-4 text-lg\">\n        Your display name will be shown to other users when you place bets or\n        leave comments.\n      </div>\n    </>\n  )\n}\n\nfunction PredictionMarketPage() {\n  return (\n    <>\n      <div className=\"text-primary-700 mb-6 mt-3 text-center text-2xl font-normal\">\n        How it works\n      </div>\n      <div className=\"mt-2 text-lg\">\n        We've sent you{' '}\n        <strong className=\"text-xl\">{formatMoney(STARTING_BALANCE)}</strong> in\n        play money. {capitalize(TRADE_TERM)} on the answer you think is right.\n      </div>\n      <div className=\"mt-2 text-lg\">\n        Research shows wagering currency leads to more accurate predictions than\n        polls.\n      </div>\n      <Image\n        src=\"/welcome/manifold-example.gif\"\n        className=\"my-4 h-full w-full max-w-xl self-center object-contain\"\n        alt={'Manifold example animation'}\n        width={200}\n        height={100}\n      />\n    </>\n  )\n}\n\nfunction TopicsPage(props: {\n  onNext?: () => void\n  setFeedKey?: (key: string) => void\n  trendingTopics: Group[]\n  userInterestedTopics: Group[]\n  userBetInTopics: Group[]\n  goBack?: () => void\n  user: User | null | undefined\n}) {\n  const {\n    userInterestedTopics,\n    trendingTopics,\n    userBetInTopics,\n    onNext,\n    goBack,\n    user,\n  } = props\n\n  const [userSelectedTopics, setUserSelectedTopics] = useState<\n    string[] | undefined\n  >()\n\n  const topics = Object.keys(TOPICS_TO_SUBTOPICS).filter(\n    (topic) => !TOPICS_TO_HIDE_FROM_WELCOME_FLOW.includes(topic)\n  )\n\n  useEffect(() => {\n    if (userBetInTopics.length > 0) {\n      userBetInTopics.forEach((group) => selectTopic(group.id))\n    } else if (userInterestedTopics.length > 0) {\n      userInterestedTopics.forEach((group) => selectTopic(group.id))\n    }\n  }, [])\n\n  const selectTopic = (groupId: string) => {\n    if (selectedTopics.includes(groupId)) {\n      if (user) unfollowTopic(groupId, user.id).catch((e) => console.error(e))\n      setUserSelectedTopics((tops) => (tops ?? []).filter((t) => t !== groupId))\n    } else {\n      setUserSelectedTopics((tops) => uniq([...(tops ?? []), groupId]))\n      if (user) followTopic({ groupId }).catch((e) => console.error(e))\n    }\n  }\n\n  const [isLoading, setIsLoading] = useState(false)\n\n  const closeDialog = async () => {\n    setIsLoading(true)\n\n    // if user is following us politics\n    if (\n      intersection(selectedTopics, [\n        'AjxQR8JMpNyDqtiqoA96',\n        'pYwsGvORZFlcq7QrkI6n',\n        'cEzcLXuitr6o4VPI01Q1',\n      ]).length > 0\n    ) {\n      await followUser('vuI5upWB8yU00rP7yxj95J2zd952') // follow @ManifoldPolitics\n    }\n\n    // if user is following AI topics\n    if (\n      intersection(selectedTopics, [\n        'yEWvvwFFIqzf8JklMewp',\n        'a3ikurqO9fT46Pv9ZGkY',\n        'GbbX9U5pYnDeftX9lxUh',\n      ]).length > 0\n    ) {\n      await followUser('8lZo8X5lewh4hnCoreI7iSc0GxK2') // follow @ManifoldAI\n    }\n\n    if (\n      intersection(selectedTopics, ['0d39aa2b-1447-4298-bc60-5ef67d9cea4f'])\n        .length > 0\n    ) {\n      await followUser('fBFdG15kdfeBmjRVEajSMLayZ2y1') // follow @JasonTweenieMemes\n    }\n\n    onNext?.()\n  }\n  const selectedTopics: string[] = userSelectedTopics ?? []\n\n  const pillButton = (\n    topicWithEmoji: string,\n    topicName: string,\n    groupIds: string[]\n  ) => (\n    <PillButton\n      key={topicName}\n      selected={groupIds.every((g) => selectedTopics.includes(g))}\n      onSelect={() => {\n        groupIds.map((g) => selectTopic(g))\n        track('onboarding select topic', { name: topicName })\n      }}\n    >\n      {topicWithEmoji}\n    </PillButton>\n  )\n\n  return (\n    <Col>\n      <div className=\"text-primary-700 mb-6 text-center text-2xl font-normal\">\n        What interests you?\n      </div>\n      <div className=\"mb-4 text-lg\">\n        Select 3 or more topics to personalize your experience.\n      </div>\n      <Col className=\"h-[25rem] gap-2 overflow-y-auto sm:h-[32rem]\">\n        <Col className={'gap-1'}>\n          <div className=\"text-ink-700 text-sm\">\n            {userInterestedTopics.length > 0 || userBetInTopics.length > 0\n              ? 'Suggested'\n              : 'Trending now'}\n          </div>\n          <Row className={'flex-wrap gap-1'}>\n            {trendingTopics.map((group) => (\n              <div className=\"\" key={group.id + '-section'}>\n                {pillButton(group.name, removeEmojis(group.name), [group.id])}\n              </div>\n            ))}\n          </Row>\n        </Col>\n\n        {topics.map((topic) => (\n          <Col className=\"mb-3 gap-1\" key={topic + '-section'}>\n            <div className=\"text-ink-700 text-sm\">{topic.slice(3)}</div>\n            <Row className=\"flex flex-wrap gap-x-1 gap-y-1.5\">\n              {getSubtopics(topic)\n                .filter(([_, __, groupId]) => !!groupId)\n                .map(([subtopicWithEmoji, subtopic, groupIds]) => {\n                  return pillButton(subtopicWithEmoji, subtopic, groupIds)\n                })}\n            </Row>\n          </Col>\n        ))}\n      </Col>\n      <Row className={'mt-4 justify-between'}>\n        <Button onClick={goBack} color={'gray-white'}>\n          Previous\n        </Button>\n        <Button\n          onClick={closeDialog}\n          disabled={(userSelectedTopics ?? []).length <= 2}\n          loading={isLoading}\n        >\n          Finish\n        </Button>\n      </Row>\n    </Col>\n  )\n}\n",
          "postContent": "/* eslint-disable react/jsx-key */\nimport { useEffect, useState } from 'react'\nimport Image from 'next/image'\n\nimport { STARTING_BALANCE } from 'common/economy'\nimport { User } from 'common/user'\nimport { buildArray } from 'common/util/array'\nimport { formatMoney } from 'common/util/format'\nimport { Button } from 'web/components/buttons/button'\nimport { useUser } from 'web/hooks/use-user'\nimport { Col } from '../layout/col'\nimport { Modal } from '../layout/modal'\nimport { Row } from '../layout/row'\nimport { run } from 'common/supabase/utils'\nimport { db } from 'web/lib/supabase/db'\nimport { Group } from 'common/group'\nimport {\n  GROUP_SLUGS_TO_HIDE_FROM_WELCOME_FLOW,\n  WELCOME_FLOW_TOPICS,\n} from 'common/topics'\nimport { intersection, orderBy, uniq, uniqBy } from 'lodash'\nimport { track } from 'web/lib/service/analytics'\nimport { Input } from '../widgets/input'\nimport { cleanDisplayName, cleanUsername } from 'common/util/clean-username'\nimport { api, updateUser, followTopic, followUser } from 'web/lib/api/api'\nimport { randomString } from 'common/util/random'\nimport { unfollowTopic } from 'web/lib/supabase/groups'\nimport { PillButton } from 'web/components/buttons/pill-button'\nimport { unauthedApi } from 'common/util/api'\nimport { getSavedContractVisitsLocally } from 'web/hooks/use-save-visits'\nimport { capitalize } from 'lodash'\nimport { TRADE_TERM } from 'common/envs/constants'\nimport { convertGroup } from 'common/supabase/groups'\nimport { setCachedReferralInfoForUser } from 'web/lib/firebase/users'\nimport { removeEmojis } from 'common/util/string'\n\nexport const DEFAULT_FOR_YOU = false\nconst SHOW_TOPICS = true\n\nexport function Welcome(props: { setFeedKey?: (key: string) => void }) {\n  const { setFeedKey } = props\n\n  const user = useUser()\n\n  const [open, setOpen] = useState(false)\n  const [page, setPage] = useState(0)\n\n  const shouldShowWelcomeModal = user?.shouldShowWelcome\n\n  const handleSetPage = (page: number) => {\n    if (page === 0) {\n      track('welcome screen: what is manifold')\n    } else if (page === 1) {\n      track('welcome screen: name input')\n    } else if (page === 2) {\n      track('welcome screen: how it works')\n    } else if (page === 3) {\n      track('welcome screen: topic selection')\n    }\n    setPage(page)\n  }\n\n  useEffect(() => {\n    if (!user) return\n    if (shouldShowWelcomeModal) {\n      track('welcome screen: landed')\n      setOpen(true)\n    } else {\n      // Wait until after they've had the opportunity to change their name\n      setCachedReferralInfoForUser(user)\n    }\n  }, [shouldShowWelcomeModal])\n\n  const [userInterestedTopics, setUserInterestedTopics] = useState<Group[]>([])\n  const [userBetInTopics, setUserBetInTopics] = useState<Group[]>([])\n  const [trendingTopics, setTrendingTopics] = useState<Group[]>([])\n\n  const availablePages = buildArray([\n    <WhatIsManifoldPage />,\n    <NameInputPage />,\n    <PredictionMarketPage />,\n    SHOW_TOPICS && (\n      <TopicsPage\n        trendingTopics={trendingTopics}\n        userInterestedTopics={userInterestedTopics}\n        userBetInTopics={userBetInTopics}\n        onNext={increasePage}\n        setFeedKey={setFeedKey}\n        user={user}\n        goBack={() => handleSetPage(page - 1)}\n      />\n    ),\n    // user && !humanish(user) && <OnboardingVerifyPhone onClose={increasePage} />,\n  ])\n  const showBottomButtons = page < 3\n\n  const getTrendingAndUserCategories = async (userId: string) => {\n    const hardCodedTopicIds = WELCOME_FLOW_TOPICS.map((topic) => topic.groupId)\n    const [userInterestedTopicsRes, trendingTopicsRes] = await Promise.all([\n      unauthedApi('get-interesting-groups-from-views', {\n        userId,\n        contractIds: getSavedContractVisitsLocally(),\n      }),\n      run(\n        db\n          .from('groups')\n          .select('*')\n          .not('id', 'in', `(${hardCodedTopicIds.join(',')})`)\n          .not(\n            'slug',\n            'in',\n            `(${GROUP_SLUGS_TO_HIDE_FROM_WELCOME_FLOW.join(',')})`\n          )\n          .filter('slug', 'not.ilike', '%manifold%')\n          .order('importance_score', { ascending: false })\n          .limit(9)\n      ),\n    ])\n    const userInterestedTopics = orderBy(\n      userInterestedTopicsRes,\n      'importanceScore',\n      'desc'\n    )\n    const trendingTopics = trendingTopicsRes.data?.map(convertGroup)\n\n    setTrendingTopics(\n      uniqBy(\n        [\n          ...userInterestedTopics.filter(\n            (g) => !hardCodedTopicIds.includes(g.id)\n          ),\n          ...trendingTopics,\n        ],\n        (g) => g.id\n      ).slice(0, 9)\n    )\n    if (userInterestedTopics.some((g) => g.hasBet)) {\n      setUserBetInTopics(\n        userInterestedTopics.filter((g) => g.hasBet).slice(0, 5)\n      )\n    } else {\n      setUserInterestedTopics(userInterestedTopics.slice(0, 5))\n    }\n  }\n\n  useEffect(() => {\n    if (user?.id && shouldShowWelcomeModal)\n      getTrendingAndUserCategories(user.id)\n  }, [user?.id, shouldShowWelcomeModal])\n\n  async function increasePage() {\n    if (page < availablePages.length - 1) handleSetPage(page + 1)\n    else {\n      if (user) await api('me/update', { shouldShowWelcome: false })\n      track('welcome screen: complete')\n      setOpen(false)\n\n      if (window.location.pathname === '/home' && DEFAULT_FOR_YOU) {\n        window.location.reload() // reload to ensure personalized feed\n      }\n    }\n  }\n\n  function decreasePage() {\n    if (page > 0) {\n      handleSetPage(page - 1)\n    }\n  }\n\n  if (!shouldShowWelcomeModal) return <></>\n\n  return (\n    <Modal open={open} size={'md'}>\n      <Col className=\"bg-canvas-0 text-md rounded-md px-4 py-6 md:w-full md:text-lg lg:px-8\">\n        {availablePages[page]}\n        <Col>\n          {showBottomButtons && (\n            <Row className=\"mt-2 justify-between\">\n              <Button\n                color={'gray-white'}\n                className={page === 0 ? 'invisible' : ''}\n                onClick={decreasePage}\n              >\n                Previous\n              </Button>\n              <Button onClick={increasePage}>\n                {page === availablePages.length - 1 ? 'Finish' : 'Next'}\n              </Button>\n            </Row>\n          )}\n        </Col>\n      </Col>\n    </Modal>\n  )\n}\n\n// const useIsTwitch = (user: User | null | undefined) => {\n//   const router = useRouter()\n//   const isTwitch = router.pathname === '/twitch'\n\n//   useEffect(() => {\n//     if (isTwitch && user?.shouldShowWelcome) {\n//       api('me/update', { shouldShowWelcome: false })\n//     }\n//   }, [isTwitch, user?.id, user?.shouldShowWelcome])\n\n//   return isTwitch\n// }\n\nfunction WhatIsManifoldPage() {\n  return (\n    <>\n      <Image\n        className=\"h-1/3 w-1/3 place-self-center object-contain\"\n        src=\"/logo.svg\"\n        alt=\"Manifold Logo\"\n        height={256}\n        width={256}\n      />\n      <div className=\"to-ink-0mt-3 text-primary-700 mb-6 text-center text-2xl font-normal\">\n        Welcome to Manifold!\n      </div>\n      <div className=\"mb-4 text-lg\">\n        Manifold is a play money prediction market platform.\n      </div>\n      <div className=\"mb-4 text-lg\">\n        Bet on politics, tech, sports, and more. Your {TRADE_TERM}s contribute\n        to the wisdom of the crowd.\n      </div>\n    </>\n  )\n}\n\nfunction NameInputPage() {\n  const user = useUser()\n\n  const [name, setName] = useState<string>(user?.name ?? 'friend')\n  useEffect(() => {\n    if (user?.name) setName(user.name)\n  }, [user?.name === undefined])\n\n  const saveName = async () => {\n    let newName = cleanDisplayName(name)\n    if (!newName) newName = 'User'\n    if (newName === user?.name) return\n    setName(newName)\n\n    await updateUser({ name: newName })\n\n    let username = cleanUsername(newName)\n    try {\n      await updateUser({ username })\n    } catch (e) {\n      console.error(e)\n      username += randomString(5)\n      await updateUser({ username })\n    }\n  }\n\n  return (\n    <>\n      <div className=\"to-ink-0mt-3 text-primary-700 mb-6 text-center text-2xl font-normal\">\n        About You\n      </div>\n      <div className=\"mb-4 flex flex-col gap-2\">\n        <p className=\"text-lg\">What should we call you?</p>\n        <div className=\"w-full max-w-xs\">\n          <Input\n            id=\"display-name\"\n            type=\"text\"\n            placeholder=\"Enter your name\"\n            value={name}\n            className=\"w-full text-lg font-semibold\"\n            maxLength={30}\n            onChange={(e) => setName(e.target.value)}\n            onBlur={saveName}\n            data-cy=\"onboarding-name-input\"\n          />\n        </div>\n      </div>\n      <div className=\"mb-4 text-lg\">\n        Your display name will be shown to other users when you place bets or\n        leave comments.\n      </div>\n    </>\n  )\n}\n\nfunction PredictionMarketPage() {\n  return (\n    <>\n      <div className=\"text-primary-700 mb-6 mt-3 text-center text-2xl font-normal\">\n        How it works\n      </div>\n      <div className=\"mt-2 text-lg\">\n        We've sent you{' '}\n        <strong className=\"text-xl\">{formatMoney(STARTING_BALANCE)}</strong> in\n        play money. {capitalize(TRADE_TERM)} on the answer you think is right.\n      </div>\n      <div className=\"mt-2 text-lg\">\n        Research shows wagering currency leads to more accurate predictions than\n        polls.\n      </div>\n      <Image\n        src=\"/welcome/manifold-example.gif\"\n        className=\"my-4 h-full w-full max-w-xl self-center object-contain\"\n        alt={'Manifold example animation'}\n        width={200}\n        height={100}\n      />\n    </>\n  )\n}\n\nfunction TopicsPage(props: {\n  onNext?: () => void\n  setFeedKey?: (key: string) => void\n  trendingTopics: Group[]\n  userInterestedTopics: Group[]\n  userBetInTopics: Group[]\n  goBack?: () => void\n  user: User | null | undefined\n}) {\n  const {\n    userInterestedTopics,\n    trendingTopics,\n    userBetInTopics,\n    onNext,\n    goBack,\n    user,\n  } = props\n\n  const [userSelectedTopics, setUserSelectedTopics] = useState<\n    string[] | undefined\n  >()\n\n  useEffect(() => {\n    if (userBetInTopics.length > 0) {\n      userBetInTopics.forEach((group) => selectTopic(group.id))\n    } else if (userInterestedTopics.length > 0) {\n      userInterestedTopics.forEach((group) => selectTopic(group.id))\n    }\n  }, [])\n\n  const selectTopic = (groupId: string) => {\n    if (selectedTopics.includes(groupId)) {\n      if (user) unfollowTopic(groupId, user.id).catch((e) => console.error(e))\n      setUserSelectedTopics((tops) => (tops ?? []).filter((t) => t !== groupId))\n    } else {\n      setUserSelectedTopics((tops) => uniq([...(tops ?? []), groupId]))\n      if (user) followTopic({ groupId }).catch((e) => console.error(e))\n    }\n  }\n\n  const [isLoading, setIsLoading] = useState(false)\n\n  const closeDialog = async () => {\n    setIsLoading(true)\n\n    // if user is following us politics\n    if (\n      intersection(selectedTopics, [\n        'UCnpxVUdLOZYgoMsDlHD', // Politics\n      ]).length > 0\n    ) {\n      await followUser('vuI5upWB8yU00rP7yxj95J2zd952') // follow @ManifoldPolitics\n    }\n\n    // if user is following AI topics\n    if (\n      intersection(selectedTopics, [\n        'yEWvvwFFIqzf8JklMewp', // AI\n      ]).length > 0\n    ) {\n      await followUser('8lZo8X5lewh4hnCoreI7iSc0GxK2') // follow @ManifoldAI\n    }\n\n    if (\n      intersection(selectedTopics, ['0d39aa2b-1447-4298-bc60-5ef67d9cea4f']) // This ID is not in WELCOME_FLOW_TOPICS. Consider removing or updating if it's for a specific meme group.\n        .length > 0\n    ) {\n      await followUser('fBFdG15kdfeBmjRVEajSMLayZ2y1') // follow @JasonTweenieMemes\n    }\n\n    onNext?.()\n  }\n  const selectedTopics: string[] = userSelectedTopics ?? []\n\n  const pillButton = (\n    topicWithEmoji: string,\n    topicName: string,\n    groupId: string\n  ) => (\n    <PillButton\n      className=\"!text-ink-900 !px-5 !py-5 !text-lg\"\n      key={topicName}\n      selected={selectedTopics.includes(groupId)}\n      onSelect={() => {\n        selectTopic(groupId)\n        track('onboarding select topic', { name: topicName })\n      }}\n    >\n      {topicWithEmoji}\n    </PillButton>\n  )\n\n  return (\n    <Col>\n      <div className=\"text-primary-700 mb-2 text-2xl font-normal\">\n        What interests you?\n      </div>\n      <div className=\"text-ink-800 mb-2 text-base\">\n        We'll use this to customize your experience.\n      </div>\n      <Col className=\"h-[25rem] gap-2 overflow-y-auto sm:h-[32rem]\">\n        <Col className=\"mb-3 gap-1\">\n          <Row className=\"flex flex-wrap gap-x-3 gap-y-3\">\n            {WELCOME_FLOW_TOPICS.map((topic) => {\n              return pillButton(topic.name, topic.name, topic.groupId)\n            })}\n          </Row>\n        </Col>\n        <Col className={'gap-1'}>\n          <div className=\"text-ink-700 text-sm\">\n            {userInterestedTopics.length > 0 || userBetInTopics.length > 0\n              ? 'Suggested'\n              : 'Trending'}\n          </div>\n          <Row className=\"flex flex-wrap gap-x-3 gap-y-3\">\n            {trendingTopics.map((group) => (\n              <div className=\"\" key={group.id + '-section'}>\n                {pillButton(group.name, removeEmojis(group.name), group.id)}\n              </div>\n            ))}\n          </Row>\n        </Col>\n      </Col>\n      <Row className={'mt-4 justify-between'}>\n        <Button onClick={goBack} color={'gray-white'}>\n          Previous\n        </Button>\n        <Button onClick={closeDialog} loading={isLoading}>\n          Finish\n        </Button>\n      </Row>\n    </Col>\n  )\n}\n"
        },
        {
          "path": "web/components/search.tsx",
          "preContent": "'use client'\nimport clsx from 'clsx'\nimport { Contract } from 'common/contract'\nimport { LiteGroup } from 'common/group'\nimport { capitalize, groupBy, minBy, orderBy, sample, uniqBy } from 'lodash'\nimport { ReactNode, useEffect, useRef, useState } from 'react'\nimport { AddContractToGroupButton } from 'web/components/topics/add-contract-to-group-modal'\nimport { useDebouncedEffect } from 'web/hooks/use-debounced-effect'\nimport { useEvent } from 'client-common/hooks/use-event'\nimport { usePersistentInMemoryState } from 'client-common/hooks/use-persistent-in-memory-state'\nimport { usePersistentQueriesState } from 'web/hooks/use-persistent-query-state'\nimport { track } from 'web/lib/service/analytics'\nimport { Col } from './layout/col'\nimport { Row } from './layout/row'\nimport { FullUser } from 'common/api/user-types'\nimport { CONTRACTS_PER_SEARCH_PAGE } from 'common/supabase/contracts'\nimport { buildArray } from 'common/util/array'\nimport { Button } from 'web/components/buttons/button'\nimport { usePersistentLocalState } from 'web/hooks/use-persistent-local-state'\nimport { api, searchGroups } from 'web/lib/api/api'\nimport { searchUsers } from 'web/lib/supabase/users'\n\nimport { LoadingContractRow } from './contract/contracts-table'\nimport { ContractFilters } from './search/contract-filters'\nimport { UserResults } from './search/user-results'\nimport { BrowseTopicPills } from './topics/browse-topic-pills'\nimport { LoadMoreUntilNotVisible } from 'web/components/widgets/visibility-observer'\nimport { BinaryDigit } from 'common/tier'\nimport { useIsMobile } from 'web/hooks/use-is-mobile'\nimport { Spacer } from './layout/spacer'\nimport { useSweepstakes } from './sweepstakes-provider'\nimport { ALL_PARENT_TOPICS, TOPICS_TO_SUBTOPICS } from 'common/topics'\nimport { Carousel } from './widgets/carousel'\nimport { isEqual } from 'lodash'\nimport { SearchInput } from './search/search-input'\nimport { removeEmojis } from 'common/util/string'\nimport { useIsPageVisible } from 'web/hooks/use-page-visible'\nimport { TopLevelPost } from 'common/top-level-post'\nimport { CombinedResults } from './contract/combined-results'\nimport { APIParams } from 'common/api/schema'\nimport { useUser } from 'web/hooks/use-user'\nimport { useAPIGetter } from 'web/hooks/use-api-getter'\nimport { getFollowedGroupsCount } from 'common/supabase/groups'\nimport { db } from 'web/lib/supabase/db'\nimport { DAY_MS } from 'common/util/time'\n\nconst USERS_PER_PAGE = 100\nconst TOPICS_PER_PAGE = 100\n\nexport const SORTS = [\n  { label: 'Best', value: 'score' },\n  { label: 'Hot', value: 'freshness-score' },\n  { label: 'Liquidity', value: 'liquidity' },\n  { label: 'Subsidy', value: 'subsidy' },\n  { label: 'New', value: 'newest' },\n  { label: 'Closing soon', value: 'close-date' },\n  { label: 'Daily change', value: 'daily-score' },\n  { label: '24h volume', value: '24-hour-vol' },\n  { label: 'Total traders', value: 'most-popular' },\n  { label: 'Last activity', value: 'last-updated' },\n  { label: 'Just resolved', value: 'resolve-date' },\n  { label: 'Bounty amount', value: 'bounty-amount' },\n  { label: 'High %', value: 'prob-descending' },\n  { label: 'Low %', value: 'prob-ascending' },\n  { label: '🎲 Random!', value: 'random' },\n] as const\n\nexport const predictionMarketSorts = new Set([\n  'daily-score',\n  '24-hour-vol',\n  'liquidity',\n  'subsidy',\n  'close-date',\n  'resolve-date',\n  'most-popular',\n  'prob-descending',\n  'prob-ascending',\n  'freshness-score',\n])\n\nexport const bountySorts = new Set(['bounty-amount'])\n\nconst probSorts = new Set(['prob-descending', 'prob-ascending'])\n\nexport const BOUNTY_MARKET_SORTS = SORTS.filter(\n  (item) => !predictionMarketSorts.has(item.value)\n)\n\nexport const POLL_SORTS = BOUNTY_MARKET_SORTS.filter(\n  (item) => !bountySorts.has(item.value)\n)\n\nexport const PREDICTION_MARKET_SORTS = SORTS.filter(\n  (item) => !bountySorts.has(item.value) && !probSorts.has(item.value)\n)\n\nexport const PREDICTION_MARKET_PROB_SORTS = SORTS.filter(\n  (item) => !bountySorts.has(item.value)\n)\n\nexport type Sort = (typeof SORTS)[number]['value']\n\nexport const FILTERS = [\n  { label: 'Any status', value: 'all' },\n  { label: 'Open', value: 'open' },\n  { label: 'Closing in 7 days', value: 'closing-week' },\n  { label: 'Closing in 30 days', value: 'closing-month' },\n  { label: 'Closing in 90 days', value: 'closing-90-days' },\n  { label: 'Closed', value: 'closed' },\n  { label: 'Resolved', value: 'resolved' },\n  { label: 'Recently changed', value: 'news' },\n] as const\n\nexport type Filter = (typeof FILTERS)[number]['value']\n\nexport const CONTRACT_TYPES = [\n  { label: 'Any type', value: 'ALL' },\n  { label: 'Yes/No', value: 'BINARY' },\n  { label: 'Multiple Choice', value: 'MULTIPLE_CHOICE' },\n  { label: 'Numeric', value: 'PSEUDO_NUMERIC' },\n  { label: 'Bounty', value: 'BOUNTIED_QUESTION' },\n  { label: 'Stock', value: 'STONK' },\n  { label: 'Poll', value: 'POLL' },\n  { label: 'Posts', value: 'POSTS' },\n] as const\n\nexport const DEFAULT_SORT = 'score'\nexport const DEFAULT_SORTS = ['freshness-score', 'newest']\nexport const DEFAULT_BOUNTY_SORTS = ['bounty-amount']\n\nexport const DEFAULT_FILTERS = []\nexport const DEFAULT_FILTER = 'all'\n\nexport const DEFAULT_CONTRACT_TYPE = 'ALL'\nexport const DEFAULT_CONTRACT_TYPES = []\n\nexport const DEFAULT_TIER = '00000'\n\nexport type ContractTypeType = (typeof CONTRACT_TYPES)[number]['value']\ntype SearchType = 'Users' | 'Questions' | undefined\n\nexport type SearchParams = {\n  [QUERY_KEY]: string\n  [SORT_KEY]: Sort\n  [FILTER_KEY]: Filter\n  [CONTRACT_TYPE_KEY]: ContractTypeType\n  [SEARCH_TYPE_KEY]: SearchType\n  [PRIZE_MARKET_KEY]: BinaryDigit\n  [FOR_YOU_KEY]: BinaryDigit\n  [TOPIC_FILTER_KEY]: string\n  [SWEEPIES_KEY]: '0' | '1' | '2'\n  [GROUP_IDS_KEY]: string\n  [LIQUIDITY_KEY]: string // empty string or stringified number\n  [HAS_BETS_KEY]: '0' | '1'\n}\n\nexport const QUERY_KEY = 'q'\nexport const SORT_KEY = 's'\nexport const FILTER_KEY = 'f'\nexport const CONTRACT_TYPE_KEY = 'ct'\nexport const SEARCH_TYPE_KEY = 't'\nexport const PRIZE_MARKET_KEY = 'p'\nexport const FOR_YOU_KEY = 'fy'\nexport const MARKET_TIER_KEY = 'mt'\nexport const TOPIC_FILTER_KEY = 'tf'\nexport const SWEEPIES_KEY = 'sw'\nexport const GROUP_IDS_KEY = 'gids'\nexport const LIQUIDITY_KEY = 'li'\nexport const HAS_BETS_KEY = 'hb'\n\nexport type SupabaseAdditionalFilter = {\n  creatorId?: string\n  excludeContractIds?: string[]\n  excludeGroupSlugs?: string[]\n  excludeUserIds?: string[]\n}\n\nexport type SearchState = {\n  contracts: Contract[] | undefined\n  users: FullUser[] | undefined\n  topics: LiteGroup[] | undefined\n  shouldLoadMore: boolean\n  posts: TopLevelPost[] | undefined\n}\n\ntype SearchProps = {\n  persistPrefix: string\n  defaultSort?: Sort\n  defaultFilter?: Filter\n  defaultContractType?: ContractTypeType\n  defaultSearchType?: SearchType\n  defaultForYou?: '1' | '0'\n  additionalFilter?: SupabaseAdditionalFilter\n  highlightContractIds?: string[]\n  onContractClick?: (contract: Contract) => void\n  hideActions?: boolean\n  hideSweepsToggle?: boolean\n  headerClassName?: string\n  isWholePage?: boolean\n  // used to determine if search params should be updated in the URL\n  useUrlParams?: boolean\n  autoFocus?: boolean\n  emptyState?: ReactNode\n  hideSearch?: boolean\n  hideContractFilters?: boolean\n  topicSlug?: string\n  contractsOnly?: boolean\n  hideSearchTypes?: boolean\n  hideAvatars?: boolean\n  initialTopics?: LiteGroup[]\n  showTopicsFilterPills?: boolean\n  refreshOnVisible?: boolean\n}\n\nexport function Search(props: SearchProps) {\n  const {\n    defaultSort,\n    defaultFilter,\n    defaultContractType,\n    defaultSearchType,\n    defaultForYou,\n    additionalFilter,\n    onContractClick,\n    hideActions,\n    hideSweepsToggle,\n    highlightContractIds,\n    headerClassName,\n    persistPrefix,\n    isWholePage,\n    useUrlParams,\n    autoFocus,\n    hideContractFilters,\n    topicSlug = '',\n    contractsOnly,\n    hideSearch,\n    hideSearchTypes,\n    hideAvatars,\n    showTopicsFilterPills,\n    refreshOnVisible,\n  } = props\n\n  const isMobile = useIsMobile()\n  const { prefersPlay, setPrefersPlay } = useSweepstakes()\n  const [searchParams, setSearchParams, isReady] = useSearchQueryState({\n    defaultSort,\n    defaultFilter,\n    defaultContractType,\n    defaultSearchType,\n    defaultForYou,\n    useUrlParams,\n    persistPrefix,\n    // defaultTopicFilter: topicSlug,\n    defaultSweepies: hideSweepsToggle ? '2' : prefersPlay ? '0' : '1',\n  })\n\n  const query = searchParams[QUERY_KEY]\n  const searchType = searchParams[SEARCH_TYPE_KEY]\n  const filter = searchParams[FILTER_KEY]\n  const contractType = searchParams[CONTRACT_TYPE_KEY]\n  const prizeMarketState = searchParams[PRIZE_MARKET_KEY]\n  const sweepiesState = searchParams[SWEEPIES_KEY]\n  const groupIds = searchParams[GROUP_IDS_KEY]\n  const hasBets = searchParams[HAS_BETS_KEY] === '1'\n  // const actuallySearchParams = searchParams\n  if (topicSlug) searchParams[TOPIC_FILTER_KEY] = topicSlug\n  // if (hideSweepsToggle) actuallySearchParams[SWEEPIES_KEY] = '2'\n\n  useEffect(() => {\n    const isSweeps = sweepiesState === '1'\n    if (prefersPlay !== isSweeps) return\n    setSearchParams({\n      [SWEEPIES_KEY]: prefersPlay ? '0' : '1',\n    })\n  }, [prefersPlay, sweepiesState])\n\n  const selectedFollowed = searchParams[TOPIC_FILTER_KEY] === 'followed'\n  const showSearchTypes =\n    !!query && !hideSearchTypes && !contractsOnly && !selectedFollowed\n  const {\n    contracts,\n    users,\n    topics,\n    loading,\n    shouldLoadMore,\n    loadMoreContracts,\n    refreshContracts,\n    posts,\n  } = useSearchResults({\n    persistPrefix,\n    searchParams: searchParams,\n    includeUsersAndTopics: showSearchTypes,\n    isReady,\n    additionalFilter,\n  })\n  const visible = useIsPageVisible()\n  useEffect(() => {\n    if (visible && refreshOnVisible) {\n      refreshContracts()\n    }\n  }, [visible, refreshOnVisible])\n\n  const showTopics = topics && topics.length > 0 && query && query.length > 0\n  const showUsers = users && users.length > 0 && query && query.length > 0\n\n  const onChange = (changes: Partial<SearchParams>) => {\n    const updatedParams = { ...changes }\n\n    setSearchParams(updatedParams)\n    if (isWholePage) window.scrollTo(0, 0)\n  }\n\n  const setQuery = (query: string) => onChange({ [QUERY_KEY]: query })\n\n  const answersWithChanges = contracts?.flatMap((c) =>\n    c.mechanism === 'cpmm-multi-1'\n      ? orderBy(\n          c.answers.filter((a) => Math.abs(a.probChanges.day) > 0.02),\n          (a) => Math.abs(a.probChanges.day),\n          'desc'\n        ).slice(0, 2)\n      : []\n  )\n\n  const answersMatchingQuery = contracts?.flatMap((c) =>\n    c.mechanism === 'cpmm-multi-1'\n      ? c.answers\n          .filter((a) => a.text.toLowerCase().includes(query.toLowerCase()))\n          .slice(0, 2)\n      : []\n  )\n  const answersByContractId =\n    answersWithChanges && filter === 'news'\n      ? groupBy(answersWithChanges, 'contractId')\n      : query !== ''\n      ? groupBy(answersMatchingQuery, 'contractId')\n      : undefined\n  const emptyContractsState =\n    props.emptyState ??\n    (filter !== 'all' ||\n    contractType !== 'ALL' ||\n    prizeMarketState === '1' ||\n    sweepiesState === '1' ? (\n      <Col className=\"mt-2 items-center gap-3\">\n        <span className=\"text-ink-700 text-center\">\n          No {prefersPlay ? 'questions' : 'sweeps questions'} found under this\n          filter.\n        </span>\n        <Col className=\"gap-2\">\n          {!prefersPlay && (\n            <Button onClick={() => setPrefersPlay(true)} color=\"purple\">\n              See mana markets\n            </Button>\n          )}\n\n          <Button\n            onClick={() =>\n              onChange({\n                [FILTER_KEY]: 'all',\n                [CONTRACT_TYPE_KEY]: 'ALL',\n                [TOPIC_FILTER_KEY]: '',\n                p: '0',\n              })\n            }\n            color=\"gray-outline\"\n          >\n            Clear filter\n          </Button>\n        </Col>\n      </Col>\n    ) : query ? (\n      <NoResults />\n    ) : (\n      <Col className=\"text-ink-700 mx-2 my-6 text-center\">\n        No questions yet.\n        {topicSlug && (\n          <Row className={'mt-2 w-full items-center justify-center'}>\n            <AddContractToGroupButton groupSlug={topicSlug} />\n          </Row>\n        )}\n      </Col>\n    ))\n\n  const selectedTopic = groupIds\n    ? ALL_PARENT_TOPICS.find((topic) =>\n        TOPICS_TO_SUBTOPICS[topic].some((subtopic) =>\n          groupIds.split(',').some((id) => subtopic.groupIds.includes(id))\n        )\n      )\n    : undefined\n  const selectedSubTopic = selectedTopic\n    ? TOPICS_TO_SUBTOPICS[selectedTopic].find(\n        (subtopic) => groupIds === subtopic.groupIds.join(',')\n      )\n    : undefined\n  const selectedAll = !selectedTopic && !selectedFollowed\n  const user = useUser()\n\n  const {\n    data: followedGroupsData,\n    loading: isLoadingFollowedGroups,\n    refresh: refreshFollowedGroups,\n  } = useAPIGetter(\n    'search-my-groups',\n    {\n      limit: 150,\n      type: 'lite',\n      term: query,\n    },\n    undefined,\n    undefined,\n    !!user && selectedFollowed\n  )\n  const [followedCount, setFollowedCount] = useState<number>(0)\n  // Refresh the followed count when the page is visible\n  useEffect(() => {\n    if (visible && selectedFollowed && user?.id) {\n      getFollowedGroupsCount(db, user?.id).then((count) => {\n        setFollowedCount(count)\n      })\n    }\n  }, [visible, selectedFollowed, user?.id])\n\n  // Refresh groups that they're following if the followed count changes\n  useEffect(() => {\n    if (visible && selectedFollowed) {\n      refreshFollowedGroups()\n      refreshContracts()\n    }\n  }, [followedCount])\n\n  const usersFollowedGroups = followedGroupsData?.lite\n  const followedGroupsCount = followedGroupsData?.lite?.length ?? 0\n  const shouldLoadTrendingTopics =\n    !!user &&\n    (user.createdTime > Date.now() - DAY_MS ||\n      (followedGroupsCount < 5 && !!followedGroupsData))\n  const shouldShowTrendingTopics = selectedFollowed && shouldLoadTrendingTopics\n  const shouldShowALotOfTrendingTopics =\n    shouldShowTrendingTopics && contracts?.length === 0\n\n  const { data: trendingTopicsData, loading: isLoadingTrendingTopics } =\n    useAPIGetter(\n      'search-groups',\n      {\n        limit: 100,\n        type: 'lite',\n        term: query,\n      },\n      undefined,\n      undefined,\n      shouldLoadTrendingTopics\n    )\n  const trendingTopics = trendingTopicsData?.lite.filter(\n    (topic) => !(usersFollowedGroups ?? []).some((t) => t.id === topic.id)\n  )\n\n  return (\n    <Col className=\"w-full\">\n      <Col className={clsx('bg-canvas-0 sticky top-0 z-20', headerClassName)}>\n        <Col className=\"mb-2\">\n          {showTopicsFilterPills && (\n            <Carousel\n              fadeEdges\n              labelsParentClassName=\"gap-4 items-baseline border-b border-ink-100 dark:border-ink-200 pb-2\"\n            >\n              <button\n                className={clsx(\n                  'font-medium',\n                  selectedAll ? 'text-primary-600' : 'text-ink-500'\n                )}\n                onClick={() => {\n                  if (!selectedAll) {\n                    track('select search topic', { topic: 'all' })\n                    const changes: Partial<SearchParams> = {\n                      [GROUP_IDS_KEY]: '',\n                      [TOPIC_FILTER_KEY]: '',\n                    }\n                    onChange(changes)\n                  }\n                }}\n              >\n                All\n              </button>\n              {!!user?.id && (\n                <button\n                  className={clsx(\n                    'font-medium',\n                    selectedFollowed ? 'text-primary-600' : 'text-ink-500'\n                  )}\n                  onClick={() => {\n                    if (!selectedFollowed) {\n                      track('select search topic', { topic: 'followed' })\n                      const changes: Partial<SearchParams> = {\n                        [TOPIC_FILTER_KEY]: 'followed',\n                        [GROUP_IDS_KEY]: '',\n                      }\n                      onChange(changes)\n                    }\n                  }}\n                >\n                  Followed\n                </button>\n              )}\n              {ALL_PARENT_TOPICS.map((topic) => (\n                <button\n                  key={topic}\n                  className={clsx(\n                    'whitespace-nowrap font-medium',\n                    selectedTopic === topic\n                      ? 'text-primary-600'\n                      : 'text-ink-500'\n                  )}\n                  onClick={() => {\n                    if (selectedTopic != topic) {\n                      track('select search topic', { topic })\n                      // Join all group IDs for this topic's subtopics\n                      const allGroupIds = TOPICS_TO_SUBTOPICS[topic]\n                        .map((subtopic) => subtopic.groupIds)\n                        .flat()\n                      const changes: Partial<SearchParams> = {\n                        [GROUP_IDS_KEY]: allGroupIds.join(','),\n                        [TOPIC_FILTER_KEY]: '', // Clear direct topicSlug when a parent topic is selected\n                      }\n                      onChange(changes)\n                    }\n                  }}\n                >\n                  {removeEmojis(topic)}\n                </button>\n              ))}\n            </Carousel>\n          )}\n        </Col>\n        {!hideSearch && (\n          <SearchInput\n            value={query}\n            setValue={setQuery}\n            placeholder={\n              searchType === 'Users'\n                ? 'Search users'\n                : searchType === 'Questions' || contractsOnly\n                ? 'Search questions'\n                : isMobile\n                ? 'Search'\n                : 'Search questions, users, topics, and posts'\n            }\n            autoFocus={autoFocus}\n            loading={loading}\n          />\n        )}\n\n        {/* Subtopics row */}\n        {selectedTopic &&\n          Object.keys(TOPICS_TO_SUBTOPICS).some(\n            (topic) => topic === selectedTopic\n          ) && (\n            <Carousel fadeEdges labelsParentClassName=\"gap-1 mt-3 mb-1.5 \">\n              <button\n                onClick={() => {\n                  onChange({\n                    [GROUP_IDS_KEY]: TOPICS_TO_SUBTOPICS[selectedTopic]\n                      .map((subtopic) => subtopic.groupIds)\n                      .flat()\n                      .join(','),\n                  })\n                }}\n                className={clsx(\n                  'text-ink-500 whitespace-nowrap px-3 py-0.5 text-sm',\n                  !selectedSubTopic &&\n                    'text-primary-700 bg-primary-50 dark:bg-primary-100 rounded-full font-medium'\n                )}\n              >\n                All\n              </button>\n              {TOPICS_TO_SUBTOPICS[selectedTopic]\n                .filter(({ hideFromSearch }) => !hideFromSearch)\n                .map(({ name, groupIds }) => (\n                  <button\n                    key={name}\n                    className={clsx(\n                      'text-ink-500 whitespace-nowrap px-3 py-0.5 text-sm',\n                      searchParams[GROUP_IDS_KEY] === groupIds.join(',') &&\n                        'text-primary-700 bg-primary-50 dark:bg-primary-100 rounded-full font-medium '\n                    )}\n                    onClick={() => {\n                      if (searchParams[GROUP_IDS_KEY] === groupIds.join(',')) {\n                        onChange({\n                          [GROUP_IDS_KEY]: TOPICS_TO_SUBTOPICS[selectedTopic]\n                            .map((subtopic) => subtopic.groupIds)\n                            .flat()\n                            .join(','),\n                        })\n                      } else {\n                        track('select search subtopic', { subtopic: name })\n                        onChange({ [GROUP_IDS_KEY]: groupIds.join(',') })\n                      }\n                    }}\n                  >\n                    {removeEmojis(name)}\n                  </button>\n                ))}\n            </Carousel>\n          )}\n\n        {!hideContractFilters && (\n          <ContractFilters\n            params={searchParams}\n            updateParams={onChange}\n            topicSlug={topicSlug}\n            className={\n              searchType && searchType !== 'Questions' ? 'invisible' : ''\n            }\n            hideSweepsToggle={hideSweepsToggle}\n          />\n        )}\n      </Col>\n      <Spacer h={1} />\n      {selectedFollowed && (\n        <Col className=\"mb-2\">\n          <>\n            <Row className=\"text-ink-500 items-center gap-1 text-sm\">\n              <hr className=\"border-ink-300 ml-2 grow sm:ml-0\" />\n              <span>Your Followed Topics</span>\n              <hr className=\"border-ink-300 mr-2 grow sm:mr-0\" />\n            </Row>\n            {usersFollowedGroups ? (\n              <BrowseTopicPills\n                className={'relative w-full px-2 py-1'}\n                topics={usersFollowedGroups}\n                clipOnMobile={true}\n              />\n            ) : isLoadingFollowedGroups ? (\n              <div className=\"text-ink-500 px-2 py-3 text-sm\">\n                Loading your followed topics...\n              </div>\n            ) : null}\n          </>\n\n          {shouldShowTrendingTopics && (\n            <>\n              <Row className=\"text-ink-500 items-center gap-1 text-sm\">\n                <hr className=\"border-ink-300 ml-2 grow sm:ml-0\" />\n                <span>Explore Topics To Follow</span>\n                <hr className=\"border-ink-300 mr-2 grow sm:mr-0\" />\n              </Row>\n              {trendingTopics ? (\n                <BrowseTopicPills\n                  className={'relative w-full px-2 py-1'}\n                  topics={trendingTopics}\n                  clipOnMobile={!shouldShowALotOfTrendingTopics}\n                  initialShown={shouldShowALotOfTrendingTopics ? 20 : undefined}\n                />\n              ) : isLoadingTrendingTopics ? (\n                <div className=\"text-ink-500 px-2 py-3 text-sm\">\n                  Loading trending topics...\n                </div>\n              ) : null}\n            </>\n          )}\n        </Col>\n      )}\n      {showSearchTypes && (\n        <Col>\n          {showTopics && (\n            <>\n              <Row className=\"text-ink-500 items-center gap-1 text-sm\">\n                <hr className=\"border-ink-300 ml-2 grow sm:ml-0\" />\n                <span>\n                  {!query || !topics?.length\n                    ? ''\n                    : topics.length >= 100\n                    ? '100+'\n                    : `${topics.length}`}{' '}\n                  {!query || !topics?.length ? 'Topics' : 'topics'}\n                </span>\n                <hr className=\"border-ink-300 mr-2 grow sm:mr-0\" />\n              </Row>\n              <BrowseTopicPills\n                className={'relative w-full px-2 pb-4'}\n                topics={topics}\n              />\n            </>\n          )}\n          {showUsers && <UserResults userResults={users} />}\n          {(showTopics || showUsers) && (\n            <Row className=\"text-ink-500 items-center gap-1 text-sm\">\n              <hr className=\"border-ink-300 ml-2 grow sm:ml-0\" />\n              <span>\n                {!query || !contracts?.length\n                  ? ''\n                  : contracts.length >= 100\n                  ? '100+'\n                  : shouldLoadMore && !loading\n                  ? `${contracts.length}+`\n                  : `${contracts.length}`}{' '}\n                {!query || !contracts?.length ? 'Questions' : 'questions'}\n              </span>\n              <hr className=\"border-ink-300 mr-2 grow sm:mr-0\" />\n            </Row>\n          )}\n        </Col>\n      )}\n\n      {!contracts && !posts ? (\n        <LoadingContractResults />\n      ) : contracts?.length === 0 && posts?.length === 0 ? (\n        emptyContractsState\n      ) : (\n        <>\n          {contracts || posts ? (\n            <CombinedResults\n              contracts={contracts ?? []}\n              posts={posts ?? []}\n              searchParams={searchParams}\n              onContractClick={onContractClick}\n              highlightContractIds={highlightContractIds}\n              answersByContractId={answersByContractId}\n              hideAvatars={hideAvatars}\n              hideActions={hideActions}\n              hasBets={hasBets}\n            />\n          ) : null}\n          <LoadMoreUntilNotVisible loadMore={loadMoreContracts} />\n          {shouldLoadMore && <LoadingContractResults />}\n          {!shouldLoadMore && (\n            <NoMoreResults params={searchParams} onChange={onChange} />\n          )}\n        </>\n      )}\n    </Col>\n  )\n}\n\nconst NoResults = () => {\n  const [message] = useState(\n    sample([\n      'no questions found x.x',\n      'no questions found u_u',\n      'no questions found T_T',\n      'no questions found :c',\n      'no questions found :(',\n      'no questions found :(',\n      'no questions found :(',\n      'that search is too bananas for me 🍌',\n      'only nothingness',\n    ])\n  )\n\n  return (\n    <span className=\"text-ink-700 mx-2 my-6 text-center\">\n      {capitalize(message)}\n    </span>\n  )\n}\n\nexport const LoadingContractResults = () => {\n  return (\n    <Col className=\"w-full\">\n      <LoadingContractRow />\n      <LoadingContractRow />\n      <LoadingContractRow />\n    </Col>\n  )\n}\n\nexport const NoMoreResults = (props: {\n  params: SearchParams\n  onChange: (changes: Partial<SearchParams>) => void\n}) => {\n  const { params, onChange } = props\n  const showReset =\n    params[FILTER_KEY] !== 'all' ||\n    params[CONTRACT_TYPE_KEY] !== 'ALL' ||\n    params[PRIZE_MARKET_KEY] === '1'\n  // params[SWEEPIES_KEY] === '1' //TODO\n\n  return (\n    <div className=\"text-ink-500 mx-2 my-8 text-center\">\n      {showReset ? 'No more results under this filter. ' : 'No more results. '}\n      {showReset && (\n        <button\n          className=\"text-primary-500 hover:underline focus:underline\"\n          onClick={() => {\n            onChange({\n              [FILTER_KEY]: 'all',\n              [CONTRACT_TYPE_KEY]: 'ALL',\n              [PRIZE_MARKET_KEY]: '0',\n              // [SWEEPIES_KEY]: '0',\n            })\n          }}\n        >\n          Clear filter\n        </button>\n      )}\n    </div>\n  )\n}\n\nconst FRESH_SEARCH_CHANGED_STATE: SearchState = {\n  contracts: undefined,\n  users: undefined,\n  topics: undefined,\n  shouldLoadMore: true,\n  posts: undefined,\n}\n\nexport const useSearchResults = (props: {\n  persistPrefix: string\n  searchParams: SearchParams\n  includeUsersAndTopics: boolean\n  isReady: boolean\n  additionalFilter?: SupabaseAdditionalFilter\n}) => {\n  const { persistPrefix, searchParams, isReady, additionalFilter } = props\n\n  const [state, setState] = usePersistentInMemoryState<SearchState>(\n    FRESH_SEARCH_CHANGED_STATE,\n    `${persistPrefix}-supabase-contract-search`\n  )\n  const [loading, setLoading] = useState(false)\n\n  const requestId = useRef(0)\n\n  const querySearchResults = useEvent(\n    async (freshQuery?: boolean, contractsOnly?: boolean) => {\n      if (!isReady) return true\n      const {\n        q: query,\n        s: sort,\n        f: filter,\n        ct: contractType,\n        p: isPrizeMarketString,\n        fy: forYou,\n        tf: topicSlug,\n        sw: sweepState,\n        gids,\n        li: liquidity,\n        hb: hasBets,\n      } = searchParams\n\n      const shouldSearchPostsWithContracts =\n        (sort === 'score' || sort === 'newest') &&\n        (!contractsOnly || !!state.posts?.length) &&\n        !topicSlug &&\n        forYou === '0' &&\n        isPrizeMarketString === '0' &&\n        !liquidity &&\n        hasBets === '0' &&\n        (contractType === 'ALL' || contractType === 'POSTS') &&\n        (filter === 'all' || filter === 'open') &&\n        !gids.length &&\n        // There aren't that many posts, so we don't need to wait up for them\n        (state.posts?.length ?? 0) < 20\n\n      const includeUsersAndTopics =\n        !contractsOnly && props.includeUsersAndTopics\n\n      if (freshQuery || state.shouldLoadMore) {\n        const id = ++requestId.current\n        let timeoutId: NodeJS.Timeout | undefined\n        if (freshQuery) {\n          timeoutId = setTimeout(() => {\n            if (id === requestId.current) {\n              setLoading(true)\n            }\n          }, 500)\n        }\n        const postApiParams: APIParams<'get-posts'> = {\n          sortBy: sort === 'score' ? 'importance_score' : 'created_time',\n          term: query,\n          limit: 10,\n          userId: additionalFilter?.creatorId,\n          offset: freshQuery ? 0 : state.posts?.length ?? 0,\n        }\n        try {\n          if (contractType === 'POSTS') {\n            const posts = await api('get-posts', postApiParams)\n            const shouldLoadMore = posts.length === 10\n            setState({\n              contracts: [],\n              users: undefined,\n              topics: undefined,\n              posts: uniqBy(buildArray(state.posts, posts), 'id'),\n              shouldLoadMore,\n            })\n            clearTimeout(timeoutId)\n            setLoading(false)\n            return shouldLoadMore\n          }\n          const searchPromises: Promise<any>[] = [\n            api('search-markets-full', {\n              term: query,\n              filter,\n              sort,\n              contractType,\n              offset: freshQuery ? 0 : state.contracts?.length ?? 0,\n              limit: CONTRACTS_PER_SEARCH_PAGE,\n              topicSlug: topicSlug !== '' ? topicSlug : undefined,\n              creatorId: additionalFilter?.creatorId,\n              isPrizeMarket: isPrizeMarketString,\n              forYou,\n              token:\n                sweepState === '2'\n                  ? 'ALL'\n                  : sweepState === '1'\n                  ? 'CASH'\n                  : 'MANA',\n              gids,\n              liquidity: liquidity === '' ? undefined : parseInt(liquidity),\n              hasBets,\n            }),\n          ]\n\n          if (includeUsersAndTopics) {\n            searchPromises.push(\n              searchUsers(query, USERS_PER_PAGE),\n              searchGroups({\n                term: query,\n                limit: TOPICS_PER_PAGE,\n                type: 'lite',\n              })\n            )\n          }\n          if (shouldSearchPostsWithContracts) {\n            searchPromises.push(api('get-posts', postApiParams))\n          }\n\n          const results = await Promise.all(searchPromises)\n\n          if (id === requestId.current) {\n            const newContracts = results[0] as Contract[]\n            let postResultIndex = 1\n            const newUsers = includeUsersAndTopics\n              ? results[postResultIndex++]\n              : undefined\n            const newTopics = includeUsersAndTopics\n              ? results[postResultIndex++]\n              : undefined\n\n            const newPostsResults =\n              shouldSearchPostsWithContracts &&\n              results.length >= postResultIndex\n                ? (results[postResultIndex] as TopLevelPost[])\n                : undefined\n\n            const freshContracts = freshQuery\n              ? newContracts\n              : buildArray(state.contracts, newContracts)\n            const bottomScoreFromAllContracts =\n              sort === 'score'\n                ? minBy(freshContracts, 'importanceScore')?.importanceScore\n                : minBy(freshContracts, 'createdTime')?.createdTime\n\n            // This is necessary bc the posts are in a different table than the contracts.\n            // TODO: this is bad and will leave posts out of the search results randomly.\n            // We should fix this by joining the posts table to the contracts table or something.\n            let postFilteringThreshold: number | undefined\n            if (sort === 'score') {\n              if (\n                !freshQuery &&\n                state.contracts &&\n                state.contracts.length > 0\n              ) {\n                postFilteringThreshold = minBy(\n                  state.contracts,\n                  'importanceScore'\n                )?.importanceScore\n              } else {\n                postFilteringThreshold = bottomScoreFromAllContracts\n              }\n            } else {\n              if (\n                !freshQuery &&\n                state.contracts &&\n                state.contracts.length > 0\n              ) {\n                postFilteringThreshold = minBy(\n                  state.contracts,\n                  'createdTime'\n                )?.createdTime\n              } else {\n                postFilteringThreshold = bottomScoreFromAllContracts\n              }\n            }\n            const freshPosts =\n              freshQuery || !state.posts\n                ? newPostsResults\n                : uniqBy(\n                    buildArray(\n                      state.posts,\n                      newPostsResults?.filter((p) =>\n                        postFilteringThreshold === undefined\n                          ? true\n                          : sort === 'score'\n                          ? p.importanceScore <= postFilteringThreshold\n                          : p.createdTime <= postFilteringThreshold\n                      )\n                    ),\n                    'id'\n                  )\n\n            const shouldLoadMore =\n              newContracts.length === CONTRACTS_PER_SEARCH_PAGE\n\n            setState({\n              contracts: freshContracts,\n              users: includeUsersAndTopics ? newUsers : state.users,\n              topics: includeUsersAndTopics ? newTopics?.lite : state.topics,\n              posts: freshPosts,\n              shouldLoadMore,\n            })\n            clearTimeout(timeoutId)\n            setLoading(false)\n\n            return shouldLoadMore\n          }\n        } catch (error) {\n          console.error('Error fetching search results:', error)\n          setLoading(false)\n        }\n      }\n      return false\n    }\n  )\n\n  useDebouncedEffect(\n    () => {\n      if (!state.contracts?.length) {\n        querySearchResults(true)\n      }\n    },\n    50,\n    [isReady]\n  )\n  useDebouncedEffect(() => querySearchResults(true), 50, [\n    JSON.stringify(searchParams),\n  ])\n\n  const contracts = state.contracts\n    ? uniqBy(\n        state.contracts.filter((c) => {\n          return (\n            !additionalFilter?.excludeContractIds?.includes(c.id) &&\n            !additionalFilter?.excludeGroupSlugs?.some((slug) =>\n              c.groupSlugs?.includes(slug)\n            ) &&\n            !additionalFilter?.excludeUserIds?.includes(c.creatorId)\n          )\n        }),\n        'id'\n      )\n    : undefined\n\n  return {\n    contracts,\n    users: state.users,\n    topics: state.topics,\n    loading,\n    shouldLoadMore: state.shouldLoadMore,\n    loadMoreContracts: () => querySearchResults(false, true),\n    refreshContracts: () => querySearchResults(true, true),\n    posts: state.posts,\n  }\n}\n\nexport const useSearchQueryState = (props: {\n  persistPrefix: string\n  defaultSort?: Sort\n  defaultFilter?: Filter\n  defaultContractType?: ContractTypeType\n  defaultSearchType?: SearchType\n  defaultPrizeMarket?: '1' | '0'\n  defaultSweepies?: '2' | '1' | '0'\n  defaultForYou?: '1' | '0'\n  useUrlParams?: boolean\n  defaultTopicFilter?: string\n  defaultLiquidityTier?: string\n}) => {\n  const {\n    persistPrefix,\n    defaultSort,\n    defaultFilter,\n    defaultContractType,\n    defaultSearchType,\n    useUrlParams,\n    defaultPrizeMarket,\n    defaultForYou,\n    defaultTopicFilter,\n    defaultSweepies,\n    defaultLiquidityTier,\n  } = props\n\n  const defaults = {\n    [QUERY_KEY]: '',\n    [SORT_KEY]: defaultSort ?? 'score',\n    [FILTER_KEY]: defaultFilter ?? 'all',\n    [CONTRACT_TYPE_KEY]: defaultContractType ?? 'ALL',\n    [SEARCH_TYPE_KEY]: defaultSearchType,\n    [PRIZE_MARKET_KEY]: defaultPrizeMarket ?? '0',\n    [FOR_YOU_KEY]: defaultForYou ?? '0',\n    [TOPIC_FILTER_KEY]: defaultTopicFilter ?? '',\n    [SWEEPIES_KEY]: defaultSweepies ?? '0',\n    [GROUP_IDS_KEY]: '',\n    [LIQUIDITY_KEY]: defaultLiquidityTier ?? '',\n    [HAS_BETS_KEY]: '0' as '0' | '1',\n  }\n\n  const useHook = useUrlParams ? usePersistentQueriesState : useNothing\n  const [queryState, updateQueryState, queryReady] = useHook(\n    defaults,\n    persistPrefix\n  )\n  const [localState, updateLocalState, localReady] = useLocalPartialUpdater(\n    defaults,\n    persistPrefix\n  )\n\n  // copy query state -> local state iff we are using query params and any params are set\n  // only do this once on first load.\n  useEffect(() => {\n    if (\n      queryReady &&\n      localReady &&\n      useUrlParams &&\n      !isEqual(queryState, defaults)\n    ) {\n      updateLocalState(queryState)\n    }\n  }, [queryReady, localReady])\n\n  const setState = useEvent((newState: Partial<SearchParams>) => {\n    updateLocalState(newState)\n    if (useUrlParams) updateQueryState(newState)\n  })\n\n  return [localState, setState, queryReady && localReady] as const\n}\n\n// shim for hook rules and types\nconst useNothing = <T,>(x: T, _: string) =>\n  [x, (_: Partial<T>) => {}, true] as const satisfies any[]\n\nconst useLocalPartialUpdater = <T extends Record<string, string | undefined>>(\n  defaults: T,\n  persistPrefix: string\n) => {\n  const [state, setState, ready] = usePersistentLocalState(\n    defaults,\n    searchLocalKey(persistPrefix)\n  )\n\n  const updateState = (\n    newState: Partial<T> | ((prevState: T) => Partial<T>)\n  ) => {\n    if (typeof newState === 'function') {\n      setState((prevState) => ({ ...prevState, ...newState(prevState) }))\n    } else {\n      setState((prevState) => ({ ...prevState, ...newState }))\n    }\n  }\n\n  // the first copy of data from local state may be missing values, so we return the full state\n  return [{ ...defaults, ...state }, updateState, ready] as const\n}\n\nexport const searchLocalKey = (persistPrefix: string) =>\n  `${persistPrefix}-local-state`\n",
          "postContent": "'use client'\nimport clsx from 'clsx'\nimport { Contract } from 'common/contract'\nimport { LiteGroup } from 'common/group'\nimport { capitalize, groupBy, minBy, orderBy, sample, uniqBy } from 'lodash'\nimport { ReactNode, useEffect, useRef, useState } from 'react'\nimport { AddContractToGroupButton } from 'web/components/topics/add-contract-to-group-modal'\nimport { useDebouncedEffect } from 'web/hooks/use-debounced-effect'\nimport { useEvent } from 'client-common/hooks/use-event'\nimport { usePersistentInMemoryState } from 'client-common/hooks/use-persistent-in-memory-state'\nimport { usePersistentQueriesState } from 'web/hooks/use-persistent-query-state'\nimport { track } from 'web/lib/service/analytics'\nimport { Col } from './layout/col'\nimport { Row } from './layout/row'\nimport { FullUser } from 'common/api/user-types'\nimport { CONTRACTS_PER_SEARCH_PAGE } from 'common/supabase/contracts'\nimport { buildArray } from 'common/util/array'\nimport { Button } from 'web/components/buttons/button'\nimport { usePersistentLocalState } from 'web/hooks/use-persistent-local-state'\nimport { api, searchGroups } from 'web/lib/api/api'\nimport { searchUsers } from 'web/lib/supabase/users'\n\nimport { LoadingContractRow } from './contract/contracts-table'\nimport { ContractFilters } from './search/contract-filters'\nimport { UserResults } from './search/user-results'\nimport { BrowseTopicPills } from './topics/browse-topic-pills'\nimport { LoadMoreUntilNotVisible } from 'web/components/widgets/visibility-observer'\nimport { BinaryDigit } from 'common/tier'\nimport { useIsMobile } from 'web/hooks/use-is-mobile'\nimport { Spacer } from './layout/spacer'\nimport { useSweepstakes } from './sweepstakes-provider'\nimport { SEARCH_TOPICS_TO_SUBTOPICS } from 'common/topics'\nimport { Carousel } from './widgets/carousel'\nimport { isEqual } from 'lodash'\nimport { SearchInput } from './search/search-input'\nimport { removeEmojis } from 'common/util/string'\nimport { useIsPageVisible } from 'web/hooks/use-page-visible'\nimport { TopLevelPost } from 'common/top-level-post'\nimport { CombinedResults } from './contract/combined-results'\nimport { APIParams } from 'common/api/schema'\nimport { useUser } from 'web/hooks/use-user'\nimport { useAPIGetter } from 'web/hooks/use-api-getter'\nimport { getFollowedGroupsCount } from 'common/supabase/groups'\nimport { db } from 'web/lib/supabase/db'\nimport { DAY_MS } from 'common/util/time'\n\nconst USERS_PER_PAGE = 100\nconst TOPICS_PER_PAGE = 100\n\nexport const SORTS = [\n  { label: 'Best', value: 'score' },\n  { label: 'Hot', value: 'freshness-score' },\n  { label: 'Liquidity', value: 'liquidity' },\n  { label: 'Subsidy', value: 'subsidy' },\n  { label: 'New', value: 'newest' },\n  { label: 'Closing soon', value: 'close-date' },\n  { label: 'Daily change', value: 'daily-score' },\n  { label: '24h volume', value: '24-hour-vol' },\n  { label: 'Total traders', value: 'most-popular' },\n  { label: 'Last activity', value: 'last-updated' },\n  { label: 'Just resolved', value: 'resolve-date' },\n  { label: 'Bounty amount', value: 'bounty-amount' },\n  { label: 'High %', value: 'prob-descending' },\n  { label: 'Low %', value: 'prob-ascending' },\n  { label: '🎲 Random!', value: 'random' },\n] as const\n\nexport const predictionMarketSorts = new Set([\n  'daily-score',\n  '24-hour-vol',\n  'liquidity',\n  'subsidy',\n  'close-date',\n  'resolve-date',\n  'most-popular',\n  'prob-descending',\n  'prob-ascending',\n  'freshness-score',\n])\n\nexport const bountySorts = new Set(['bounty-amount'])\n\nconst probSorts = new Set(['prob-descending', 'prob-ascending'])\n\nexport const BOUNTY_MARKET_SORTS = SORTS.filter(\n  (item) => !predictionMarketSorts.has(item.value)\n)\n\nexport const POLL_SORTS = BOUNTY_MARKET_SORTS.filter(\n  (item) => !bountySorts.has(item.value)\n)\n\nexport const PREDICTION_MARKET_SORTS = SORTS.filter(\n  (item) => !bountySorts.has(item.value) && !probSorts.has(item.value)\n)\n\nexport const PREDICTION_MARKET_PROB_SORTS = SORTS.filter(\n  (item) => !bountySorts.has(item.value)\n)\n\nexport type Sort = (typeof SORTS)[number]['value']\n\nexport const FILTERS = [\n  { label: 'Any status', value: 'all' },\n  { label: 'Open', value: 'open' },\n  { label: 'Closing in 7 days', value: 'closing-week' },\n  { label: 'Closing in 30 days', value: 'closing-month' },\n  { label: 'Closing in 90 days', value: 'closing-90-days' },\n  { label: 'Closed', value: 'closed' },\n  { label: 'Resolved', value: 'resolved' },\n  { label: 'Recently changed', value: 'news' },\n] as const\n\nexport type Filter = (typeof FILTERS)[number]['value']\n\nexport const CONTRACT_TYPES = [\n  { label: 'Any type', value: 'ALL' },\n  { label: 'Yes/No', value: 'BINARY' },\n  { label: 'Multiple Choice', value: 'MULTIPLE_CHOICE' },\n  { label: 'Numeric', value: 'PSEUDO_NUMERIC' },\n  { label: 'Bounty', value: 'BOUNTIED_QUESTION' },\n  { label: 'Stock', value: 'STONK' },\n  { label: 'Poll', value: 'POLL' },\n  { label: 'Posts', value: 'POSTS' },\n] as const\n\nexport const DEFAULT_SORT = 'score'\nexport const DEFAULT_SORTS = ['freshness-score', 'newest']\nexport const DEFAULT_BOUNTY_SORTS = ['bounty-amount']\n\nexport const DEFAULT_FILTERS = []\nexport const DEFAULT_FILTER = 'all'\n\nexport const DEFAULT_CONTRACT_TYPE = 'ALL'\nexport const DEFAULT_CONTRACT_TYPES = []\n\nexport const DEFAULT_TIER = '00000'\n\nexport type ContractTypeType = (typeof CONTRACT_TYPES)[number]['value']\ntype SearchType = 'Users' | 'Questions' | undefined\n\nexport type SearchParams = {\n  [QUERY_KEY]: string\n  [SORT_KEY]: Sort\n  [FILTER_KEY]: Filter\n  [CONTRACT_TYPE_KEY]: ContractTypeType\n  [SEARCH_TYPE_KEY]: SearchType\n  [PRIZE_MARKET_KEY]: BinaryDigit\n  [FOR_YOU_KEY]: BinaryDigit\n  [TOPIC_FILTER_KEY]: string\n  [SWEEPIES_KEY]: '0' | '1' | '2'\n  [GROUP_IDS_KEY]: string\n  [LIQUIDITY_KEY]: string // empty string or stringified number\n  [HAS_BETS_KEY]: '0' | '1'\n}\n\nexport const QUERY_KEY = 'q'\nexport const SORT_KEY = 's'\nexport const FILTER_KEY = 'f'\nexport const CONTRACT_TYPE_KEY = 'ct'\nexport const SEARCH_TYPE_KEY = 't'\nexport const PRIZE_MARKET_KEY = 'p'\nexport const FOR_YOU_KEY = 'fy'\nexport const MARKET_TIER_KEY = 'mt'\nexport const TOPIC_FILTER_KEY = 'tf'\nexport const SWEEPIES_KEY = 'sw'\nexport const GROUP_IDS_KEY = 'gids'\nexport const LIQUIDITY_KEY = 'li'\nexport const HAS_BETS_KEY = 'hb'\n\nexport type SupabaseAdditionalFilter = {\n  creatorId?: string\n  excludeContractIds?: string[]\n  excludeGroupSlugs?: string[]\n  excludeUserIds?: string[]\n}\n\nexport type SearchState = {\n  contracts: Contract[] | undefined\n  users: FullUser[] | undefined\n  topics: LiteGroup[] | undefined\n  shouldLoadMore: boolean\n  posts: TopLevelPost[] | undefined\n}\n\ntype SearchProps = {\n  persistPrefix: string\n  defaultSort?: Sort\n  defaultFilter?: Filter\n  defaultContractType?: ContractTypeType\n  defaultSearchType?: SearchType\n  defaultForYou?: '1' | '0'\n  additionalFilter?: SupabaseAdditionalFilter\n  highlightContractIds?: string[]\n  onContractClick?: (contract: Contract) => void\n  hideActions?: boolean\n  hideSweepsToggle?: boolean\n  headerClassName?: string\n  isWholePage?: boolean\n  // used to determine if search params should be updated in the URL\n  useUrlParams?: boolean\n  autoFocus?: boolean\n  emptyState?: ReactNode\n  hideSearch?: boolean\n  hideContractFilters?: boolean\n  topicSlug?: string\n  contractsOnly?: boolean\n  hideSearchTypes?: boolean\n  hideAvatars?: boolean\n  initialTopics?: LiteGroup[]\n  showTopicsFilterPills?: boolean\n  refreshOnVisible?: boolean\n}\n\nexport function Search(props: SearchProps) {\n  const {\n    defaultSort,\n    defaultFilter,\n    defaultContractType,\n    defaultSearchType,\n    defaultForYou,\n    additionalFilter,\n    onContractClick,\n    hideActions,\n    hideSweepsToggle,\n    highlightContractIds,\n    headerClassName,\n    persistPrefix,\n    isWholePage,\n    useUrlParams,\n    autoFocus,\n    hideContractFilters,\n    topicSlug = '',\n    contractsOnly,\n    hideSearch,\n    hideSearchTypes,\n    hideAvatars,\n    showTopicsFilterPills,\n    refreshOnVisible,\n  } = props\n\n  const isMobile = useIsMobile()\n  const { prefersPlay, setPrefersPlay } = useSweepstakes()\n  const [searchParams, setSearchParams, isReady] = useSearchQueryState({\n    defaultSort,\n    defaultFilter,\n    defaultContractType,\n    defaultSearchType,\n    defaultForYou,\n    useUrlParams,\n    persistPrefix,\n    // defaultTopicFilter: topicSlug,\n    defaultSweepies: hideSweepsToggle ? '2' : prefersPlay ? '0' : '1',\n  })\n\n  const query = searchParams[QUERY_KEY]\n  const searchType = searchParams[SEARCH_TYPE_KEY]\n  const filter = searchParams[FILTER_KEY]\n  const contractType = searchParams[CONTRACT_TYPE_KEY]\n  const prizeMarketState = searchParams[PRIZE_MARKET_KEY]\n  const sweepiesState = searchParams[SWEEPIES_KEY]\n  const groupIds = searchParams[GROUP_IDS_KEY]\n  const hasBets = searchParams[HAS_BETS_KEY] === '1'\n  // const actuallySearchParams = searchParams\n  if (topicSlug) searchParams[TOPIC_FILTER_KEY] = topicSlug\n  // if (hideSweepsToggle) actuallySearchParams[SWEEPIES_KEY] = '2'\n\n  useEffect(() => {\n    const isSweeps = sweepiesState === '1'\n    if (prefersPlay !== isSweeps) return\n    setSearchParams({\n      [SWEEPIES_KEY]: prefersPlay ? '0' : '1',\n    })\n  }, [prefersPlay, sweepiesState])\n\n  const selectedFollowed = searchParams[TOPIC_FILTER_KEY] === 'followed'\n  const showSearchTypes =\n    !!query && !hideSearchTypes && !contractsOnly && !selectedFollowed\n  const {\n    contracts,\n    users,\n    topics,\n    loading,\n    shouldLoadMore,\n    loadMoreContracts,\n    refreshContracts,\n    posts,\n  } = useSearchResults({\n    persistPrefix,\n    searchParams: searchParams,\n    includeUsersAndTopics: showSearchTypes,\n    isReady,\n    additionalFilter,\n  })\n  const visible = useIsPageVisible()\n  useEffect(() => {\n    if (visible && refreshOnVisible) {\n      refreshContracts()\n    }\n  }, [visible, refreshOnVisible])\n\n  const showTopics = topics && topics.length > 0 && query && query.length > 0\n  const showUsers = users && users.length > 0 && query && query.length > 0\n\n  const onChange = (changes: Partial<SearchParams>) => {\n    const updatedParams = { ...changes }\n\n    setSearchParams(updatedParams)\n    if (isWholePage) window.scrollTo(0, 0)\n  }\n\n  const setQuery = (query: string) => onChange({ [QUERY_KEY]: query })\n\n  const answersWithChanges = contracts?.flatMap((c) =>\n    c.mechanism === 'cpmm-multi-1'\n      ? orderBy(\n          c.answers.filter((a) => Math.abs(a.probChanges.day) > 0.02),\n          (a) => Math.abs(a.probChanges.day),\n          'desc'\n        ).slice(0, 2)\n      : []\n  )\n\n  const answersMatchingQuery = contracts?.flatMap((c) =>\n    c.mechanism === 'cpmm-multi-1'\n      ? c.answers\n          .filter((a) => a.text.toLowerCase().includes(query.toLowerCase()))\n          .slice(0, 2)\n      : []\n  )\n  const answersByContractId =\n    answersWithChanges && filter === 'news'\n      ? groupBy(answersWithChanges, 'contractId')\n      : query !== ''\n      ? groupBy(answersMatchingQuery, 'contractId')\n      : undefined\n  const emptyContractsState =\n    props.emptyState ??\n    (filter !== 'all' ||\n    contractType !== 'ALL' ||\n    prizeMarketState === '1' ||\n    sweepiesState === '1' ? (\n      <Col className=\"mt-2 items-center gap-3\">\n        <span className=\"text-ink-700 text-center\">\n          No {prefersPlay ? 'questions' : 'sweeps questions'} found under this\n          filter.\n        </span>\n        <Col className=\"gap-2\">\n          {!prefersPlay && (\n            <Button onClick={() => setPrefersPlay(true)} color=\"purple\">\n              See mana markets\n            </Button>\n          )}\n\n          <Button\n            onClick={() =>\n              onChange({\n                [FILTER_KEY]: 'all',\n                [CONTRACT_TYPE_KEY]: 'ALL',\n                [TOPIC_FILTER_KEY]: '',\n                p: '0',\n              })\n            }\n            color=\"gray-outline\"\n          >\n            Clear filter\n          </Button>\n        </Col>\n      </Col>\n    ) : query ? (\n      <NoResults />\n    ) : (\n      <Col className=\"text-ink-700 mx-2 my-6 text-center\">\n        No questions yet.\n        {topicSlug && (\n          <Row className={'mt-2 w-full items-center justify-center'}>\n            <AddContractToGroupButton groupSlug={topicSlug} />\n          </Row>\n        )}\n      </Col>\n    ))\n  const ALL_PARENT_TOPICS = Object.keys(SEARCH_TOPICS_TO_SUBTOPICS)\n\n  const selectedTopic = groupIds\n    ? ALL_PARENT_TOPICS.find((topic) =>\n        SEARCH_TOPICS_TO_SUBTOPICS[topic].some((subtopic) =>\n          groupIds.split(',').some((id) => subtopic.groupIds.includes(id))\n        )\n      )\n    : undefined\n  const selectedSubTopic = selectedTopic\n    ? SEARCH_TOPICS_TO_SUBTOPICS[selectedTopic].find(\n        (subtopic) => groupIds === subtopic.groupIds.join(',')\n      )\n    : undefined\n  const selectedAll = !selectedTopic && !selectedFollowed\n  const user = useUser()\n\n  const {\n    data: followedGroupsData,\n    loading: isLoadingFollowedGroups,\n    refresh: refreshFollowedGroups,\n  } = useAPIGetter(\n    'search-my-groups',\n    {\n      limit: 150,\n      type: 'lite',\n      term: query,\n    },\n    undefined,\n    undefined,\n    !!user && selectedFollowed\n  )\n  const [followedCount, setFollowedCount] = useState<number>(0)\n  // Refresh the followed count when the page is visible\n  useEffect(() => {\n    if (visible && selectedFollowed && user?.id) {\n      getFollowedGroupsCount(db, user?.id).then((count) => {\n        setFollowedCount(count)\n      })\n    }\n  }, [visible, selectedFollowed, user?.id])\n\n  // Refresh groups that they're following if the followed count changes\n  useEffect(() => {\n    if (visible && selectedFollowed) {\n      refreshFollowedGroups()\n      refreshContracts()\n    }\n  }, [followedCount])\n\n  const usersFollowedGroups = followedGroupsData?.lite\n  const followedGroupsCount = followedGroupsData?.lite?.length ?? 0\n  const shouldLoadTrendingTopics =\n    !!user &&\n    (user.createdTime > Date.now() - DAY_MS ||\n      (followedGroupsCount < 5 && !!followedGroupsData))\n  const shouldShowTrendingTopics = selectedFollowed && shouldLoadTrendingTopics\n  const shouldShowALotOfTrendingTopics =\n    shouldShowTrendingTopics && contracts?.length === 0\n\n  const { data: trendingTopicsData, loading: isLoadingTrendingTopics } =\n    useAPIGetter(\n      'search-groups',\n      {\n        limit: 100,\n        type: 'lite',\n        term: query,\n      },\n      undefined,\n      undefined,\n      shouldLoadTrendingTopics\n    )\n  const trendingTopics = trendingTopicsData?.lite.filter(\n    (topic) => !(usersFollowedGroups ?? []).some((t) => t.id === topic.id)\n  )\n\n  return (\n    <Col className=\"w-full\">\n      <Col className={clsx('bg-canvas-0 sticky top-0 z-20', headerClassName)}>\n        <Col className=\"mb-2\">\n          {showTopicsFilterPills && (\n            <Carousel\n              fadeEdges\n              labelsParentClassName=\"gap-4 items-baseline border-b border-ink-100 dark:border-ink-200 pb-2\"\n            >\n              <button\n                className={clsx(\n                  'font-medium',\n                  selectedAll ? 'text-primary-600' : 'text-ink-500'\n                )}\n                onClick={() => {\n                  if (!selectedAll) {\n                    track('select search topic', { topic: 'all' })\n                    const changes: Partial<SearchParams> = {\n                      [GROUP_IDS_KEY]: '',\n                      [TOPIC_FILTER_KEY]: '',\n                    }\n                    onChange(changes)\n                  }\n                }}\n              >\n                All\n              </button>\n              {!!user?.id && (\n                <button\n                  className={clsx(\n                    'font-medium',\n                    selectedFollowed ? 'text-primary-600' : 'text-ink-500'\n                  )}\n                  onClick={() => {\n                    if (!selectedFollowed) {\n                      track('select search topic', { topic: 'followed' })\n                      const changes: Partial<SearchParams> = {\n                        [TOPIC_FILTER_KEY]: 'followed',\n                        [GROUP_IDS_KEY]: '',\n                      }\n                      onChange(changes)\n                    }\n                  }}\n                >\n                  Followed\n                </button>\n              )}\n              {ALL_PARENT_TOPICS.map((topic) => (\n                <button\n                  key={topic}\n                  className={clsx(\n                    'whitespace-nowrap font-medium',\n                    selectedTopic === topic\n                      ? 'text-primary-600'\n                      : 'text-ink-500'\n                  )}\n                  onClick={() => {\n                    if (selectedTopic != topic) {\n                      track('select search topic', { topic })\n                      // Join all group IDs for this topic's subtopics\n                      const allGroupIds = SEARCH_TOPICS_TO_SUBTOPICS[topic]\n                        .map((subtopic) => subtopic.groupIds)\n                        .flat()\n                      const changes: Partial<SearchParams> = {\n                        [GROUP_IDS_KEY]: allGroupIds.join(','),\n                        [TOPIC_FILTER_KEY]: '', // Clear direct topicSlug when a parent topic is selected\n                      }\n                      onChange(changes)\n                    }\n                  }}\n                >\n                  {removeEmojis(topic)}\n                </button>\n              ))}\n            </Carousel>\n          )}\n        </Col>\n        {!hideSearch && (\n          <SearchInput\n            value={query}\n            setValue={setQuery}\n            placeholder={\n              searchType === 'Users'\n                ? 'Search users'\n                : searchType === 'Questions' || contractsOnly\n                ? 'Search questions'\n                : isMobile\n                ? 'Search'\n                : 'Search questions, users, topics, and posts'\n            }\n            autoFocus={autoFocus}\n            loading={loading}\n          />\n        )}\n\n        {/* Subtopics row */}\n        {selectedTopic &&\n          Object.keys(SEARCH_TOPICS_TO_SUBTOPICS).some(\n            (topic) => topic === selectedTopic\n          ) && (\n            <Carousel fadeEdges labelsParentClassName=\"gap-1 mt-3 mb-1.5 \">\n              <button\n                onClick={() => {\n                  onChange({\n                    [GROUP_IDS_KEY]: SEARCH_TOPICS_TO_SUBTOPICS[selectedTopic]\n                      .map((subtopic) => subtopic.groupIds)\n                      .flat()\n                      .join(','),\n                  })\n                }}\n                className={clsx(\n                  'text-ink-500 whitespace-nowrap px-3 py-0.5 text-sm',\n                  !selectedSubTopic &&\n                    'text-primary-700 bg-primary-50 dark:bg-primary-100 rounded-full font-medium'\n                )}\n              >\n                All\n              </button>\n              {SEARCH_TOPICS_TO_SUBTOPICS[selectedTopic]\n                .filter(({ hideFromSearch }) => !hideFromSearch)\n                .map(({ name, groupIds }) => (\n                  <button\n                    key={name}\n                    className={clsx(\n                      'text-ink-500 whitespace-nowrap px-3 py-0.5 text-sm',\n                      searchParams[GROUP_IDS_KEY] === groupIds.join(',') &&\n                        'text-primary-700 bg-primary-50 dark:bg-primary-100 rounded-full font-medium '\n                    )}\n                    onClick={() => {\n                      if (searchParams[GROUP_IDS_KEY] === groupIds.join(',')) {\n                        onChange({\n                          [GROUP_IDS_KEY]: SEARCH_TOPICS_TO_SUBTOPICS[\n                            selectedTopic\n                          ]\n                            .map((subtopic) => subtopic.groupIds)\n                            .flat()\n                            .join(','),\n                        })\n                      } else {\n                        track('select search subtopic', { subtopic: name })\n                        onChange({ [GROUP_IDS_KEY]: groupIds.join(',') })\n                      }\n                    }}\n                  >\n                    {removeEmojis(name)}\n                  </button>\n                ))}\n            </Carousel>\n          )}\n\n        {!hideContractFilters && (\n          <ContractFilters\n            params={searchParams}\n            updateParams={onChange}\n            topicSlug={topicSlug}\n            className={\n              searchType && searchType !== 'Questions' ? 'invisible' : ''\n            }\n            hideSweepsToggle={hideSweepsToggle}\n          />\n        )}\n      </Col>\n      <Spacer h={1} />\n      {selectedFollowed && (\n        <Col className=\"mb-2\">\n          <>\n            <Row className=\"text-ink-500 items-center gap-1 text-sm\">\n              <hr className=\"border-ink-300 ml-2 grow sm:ml-0\" />\n              <span>Your Followed Topics</span>\n              <hr className=\"border-ink-300 mr-2 grow sm:mr-0\" />\n            </Row>\n            {usersFollowedGroups ? (\n              <BrowseTopicPills\n                className={'relative w-full px-2 py-1'}\n                topics={usersFollowedGroups}\n                clipOnMobile={true}\n              />\n            ) : isLoadingFollowedGroups ? (\n              <div className=\"text-ink-500 px-2 py-3 text-sm\">\n                Loading your followed topics...\n              </div>\n            ) : null}\n          </>\n\n          {shouldShowTrendingTopics && (\n            <>\n              <Row className=\"text-ink-500 items-center gap-1 text-sm\">\n                <hr className=\"border-ink-300 ml-2 grow sm:ml-0\" />\n                <span>Explore Topics To Follow</span>\n                <hr className=\"border-ink-300 mr-2 grow sm:mr-0\" />\n              </Row>\n              {trendingTopics ? (\n                <BrowseTopicPills\n                  className={'relative w-full px-2 py-1'}\n                  topics={trendingTopics}\n                  clipOnMobile={!shouldShowALotOfTrendingTopics}\n                  initialShown={shouldShowALotOfTrendingTopics ? 20 : undefined}\n                />\n              ) : isLoadingTrendingTopics ? (\n                <div className=\"text-ink-500 px-2 py-3 text-sm\">\n                  Loading trending topics...\n                </div>\n              ) : null}\n            </>\n          )}\n        </Col>\n      )}\n      {showSearchTypes && (\n        <Col>\n          {showTopics && (\n            <>\n              <Row className=\"text-ink-500 items-center gap-1 text-sm\">\n                <hr className=\"border-ink-300 ml-2 grow sm:ml-0\" />\n                <span>\n                  {!query || !topics?.length\n                    ? ''\n                    : topics.length >= 100\n                    ? '100+'\n                    : `${topics.length}`}{' '}\n                  {!query || !topics?.length ? 'Topics' : 'topics'}\n                </span>\n                <hr className=\"border-ink-300 mr-2 grow sm:mr-0\" />\n              </Row>\n              <BrowseTopicPills\n                className={'relative w-full px-2 pb-4'}\n                topics={topics}\n              />\n            </>\n          )}\n          {showUsers && <UserResults userResults={users} />}\n          {(showTopics || showUsers) && (\n            <Row className=\"text-ink-500 items-center gap-1 text-sm\">\n              <hr className=\"border-ink-300 ml-2 grow sm:ml-0\" />\n              <span>\n                {!query || !contracts?.length\n                  ? ''\n                  : contracts.length >= 100\n                  ? '100+'\n                  : shouldLoadMore && !loading\n                  ? `${contracts.length}+`\n                  : `${contracts.length}`}{' '}\n                {!query || !contracts?.length ? 'Questions' : 'questions'}\n              </span>\n              <hr className=\"border-ink-300 mr-2 grow sm:mr-0\" />\n            </Row>\n          )}\n        </Col>\n      )}\n\n      {!contracts && !posts ? (\n        <LoadingContractResults />\n      ) : contracts?.length === 0 && posts?.length === 0 ? (\n        emptyContractsState\n      ) : (\n        <>\n          {contracts || posts ? (\n            <CombinedResults\n              contracts={contracts ?? []}\n              posts={posts ?? []}\n              searchParams={searchParams}\n              onContractClick={onContractClick}\n              highlightContractIds={highlightContractIds}\n              answersByContractId={answersByContractId}\n              hideAvatars={hideAvatars}\n              hideActions={hideActions}\n              hasBets={hasBets}\n            />\n          ) : null}\n          <LoadMoreUntilNotVisible loadMore={loadMoreContracts} />\n          {shouldLoadMore && <LoadingContractResults />}\n          {!shouldLoadMore && (\n            <NoMoreResults params={searchParams} onChange={onChange} />\n          )}\n        </>\n      )}\n    </Col>\n  )\n}\n\nconst NoResults = () => {\n  const [message] = useState(\n    sample([\n      'no questions found x.x',\n      'no questions found u_u',\n      'no questions found T_T',\n      'no questions found :c',\n      'no questions found :(',\n      'no questions found :(',\n      'no questions found :(',\n      'that search is too bananas for me 🍌',\n      'only nothingness',\n    ])\n  )\n\n  return (\n    <span className=\"text-ink-700 mx-2 my-6 text-center\">\n      {capitalize(message)}\n    </span>\n  )\n}\n\nexport const LoadingContractResults = () => {\n  return (\n    <Col className=\"w-full\">\n      <LoadingContractRow />\n      <LoadingContractRow />\n      <LoadingContractRow />\n    </Col>\n  )\n}\n\nexport const NoMoreResults = (props: {\n  params: SearchParams\n  onChange: (changes: Partial<SearchParams>) => void\n}) => {\n  const { params, onChange } = props\n  const showReset =\n    params[FILTER_KEY] !== 'all' ||\n    params[CONTRACT_TYPE_KEY] !== 'ALL' ||\n    params[PRIZE_MARKET_KEY] === '1'\n  // params[SWEEPIES_KEY] === '1' //TODO\n\n  return (\n    <div className=\"text-ink-500 mx-2 my-8 text-center\">\n      {showReset ? 'No more results under this filter. ' : 'No more results. '}\n      {showReset && (\n        <button\n          className=\"text-primary-500 hover:underline focus:underline\"\n          onClick={() => {\n            onChange({\n              [FILTER_KEY]: 'all',\n              [CONTRACT_TYPE_KEY]: 'ALL',\n              [PRIZE_MARKET_KEY]: '0',\n              // [SWEEPIES_KEY]: '0',\n            })\n          }}\n        >\n          Clear filter\n        </button>\n      )}\n    </div>\n  )\n}\n\nconst FRESH_SEARCH_CHANGED_STATE: SearchState = {\n  contracts: undefined,\n  users: undefined,\n  topics: undefined,\n  shouldLoadMore: true,\n  posts: undefined,\n}\n\nexport const useSearchResults = (props: {\n  persistPrefix: string\n  searchParams: SearchParams\n  includeUsersAndTopics: boolean\n  isReady: boolean\n  additionalFilter?: SupabaseAdditionalFilter\n}) => {\n  const { persistPrefix, searchParams, isReady, additionalFilter } = props\n\n  const [state, setState] = usePersistentInMemoryState<SearchState>(\n    FRESH_SEARCH_CHANGED_STATE,\n    `${persistPrefix}-supabase-contract-search`\n  )\n  const [loading, setLoading] = useState(false)\n\n  const requestId = useRef(0)\n\n  const querySearchResults = useEvent(\n    async (freshQuery?: boolean, contractsOnly?: boolean) => {\n      if (!isReady) return true\n      const {\n        q: query,\n        s: sort,\n        f: filter,\n        ct: contractType,\n        p: isPrizeMarketString,\n        fy: forYou,\n        tf: topicSlug,\n        sw: sweepState,\n        gids,\n        li: liquidity,\n        hb: hasBets,\n      } = searchParams\n\n      const shouldSearchPostsWithContracts =\n        (sort === 'score' || sort === 'newest') &&\n        (!contractsOnly || !!state.posts?.length) &&\n        !topicSlug &&\n        forYou === '0' &&\n        isPrizeMarketString === '0' &&\n        !liquidity &&\n        hasBets === '0' &&\n        (contractType === 'ALL' || contractType === 'POSTS') &&\n        (filter === 'all' || filter === 'open') &&\n        !gids.length &&\n        // There aren't that many posts, so we don't need to wait up for them\n        (state.posts?.length ?? 0) < 20\n\n      const includeUsersAndTopics =\n        !contractsOnly && props.includeUsersAndTopics\n\n      if (freshQuery || state.shouldLoadMore) {\n        const id = ++requestId.current\n        let timeoutId: NodeJS.Timeout | undefined\n        if (freshQuery) {\n          timeoutId = setTimeout(() => {\n            if (id === requestId.current) {\n              setLoading(true)\n            }\n          }, 500)\n        }\n        const postApiParams: APIParams<'get-posts'> = {\n          sortBy: sort === 'score' ? 'importance_score' : 'created_time',\n          term: query,\n          limit: 10,\n          userId: additionalFilter?.creatorId,\n          offset: freshQuery ? 0 : state.posts?.length ?? 0,\n        }\n        try {\n          if (contractType === 'POSTS') {\n            const posts = await api('get-posts', postApiParams)\n            const shouldLoadMore = posts.length === 10\n            setState({\n              contracts: [],\n              users: undefined,\n              topics: undefined,\n              posts: uniqBy(buildArray(state.posts, posts), 'id'),\n              shouldLoadMore,\n            })\n            clearTimeout(timeoutId)\n            setLoading(false)\n            return shouldLoadMore\n          }\n          const searchPromises: Promise<any>[] = [\n            api('search-markets-full', {\n              term: query,\n              filter,\n              sort,\n              contractType,\n              offset: freshQuery ? 0 : state.contracts?.length ?? 0,\n              limit: CONTRACTS_PER_SEARCH_PAGE,\n              topicSlug: topicSlug !== '' ? topicSlug : undefined,\n              creatorId: additionalFilter?.creatorId,\n              isPrizeMarket: isPrizeMarketString,\n              forYou,\n              token:\n                sweepState === '2'\n                  ? 'ALL'\n                  : sweepState === '1'\n                  ? 'CASH'\n                  : 'MANA',\n              gids,\n              liquidity: liquidity === '' ? undefined : parseInt(liquidity),\n              hasBets,\n            }),\n          ]\n\n          if (includeUsersAndTopics) {\n            searchPromises.push(\n              searchUsers(query, USERS_PER_PAGE),\n              searchGroups({\n                term: query,\n                limit: TOPICS_PER_PAGE,\n                type: 'lite',\n              })\n            )\n          }\n          if (shouldSearchPostsWithContracts) {\n            searchPromises.push(api('get-posts', postApiParams))\n          }\n\n          const results = await Promise.all(searchPromises)\n\n          if (id === requestId.current) {\n            const newContracts = results[0] as Contract[]\n            let postResultIndex = 1\n            const newUsers = includeUsersAndTopics\n              ? results[postResultIndex++]\n              : undefined\n            const newTopics = includeUsersAndTopics\n              ? results[postResultIndex++]\n              : undefined\n\n            const newPostsResults =\n              shouldSearchPostsWithContracts &&\n              results.length >= postResultIndex\n                ? (results[postResultIndex] as TopLevelPost[])\n                : undefined\n\n            const freshContracts = freshQuery\n              ? newContracts\n              : buildArray(state.contracts, newContracts)\n            const bottomScoreFromAllContracts =\n              sort === 'score'\n                ? minBy(freshContracts, 'importanceScore')?.importanceScore\n                : minBy(freshContracts, 'createdTime')?.createdTime\n\n            // This is necessary bc the posts are in a different table than the contracts.\n            // TODO: this is bad and will leave posts out of the search results randomly.\n            // We should fix this by joining the posts table to the contracts table or something.\n            let postFilteringThreshold: number | undefined\n            if (sort === 'score') {\n              if (\n                !freshQuery &&\n                state.contracts &&\n                state.contracts.length > 0\n              ) {\n                postFilteringThreshold = minBy(\n                  state.contracts,\n                  'importanceScore'\n                )?.importanceScore\n              } else {\n                postFilteringThreshold = bottomScoreFromAllContracts\n              }\n            } else {\n              if (\n                !freshQuery &&\n                state.contracts &&\n                state.contracts.length > 0\n              ) {\n                postFilteringThreshold = minBy(\n                  state.contracts,\n                  'createdTime'\n                )?.createdTime\n              } else {\n                postFilteringThreshold = bottomScoreFromAllContracts\n              }\n            }\n            const freshPosts =\n              freshQuery || !state.posts\n                ? newPostsResults\n                : uniqBy(\n                    buildArray(\n                      state.posts,\n                      newPostsResults?.filter((p) =>\n                        postFilteringThreshold === undefined\n                          ? true\n                          : sort === 'score'\n                          ? p.importanceScore <= postFilteringThreshold\n                          : p.createdTime <= postFilteringThreshold\n                      )\n                    ),\n                    'id'\n                  )\n\n            const shouldLoadMore =\n              newContracts.length === CONTRACTS_PER_SEARCH_PAGE\n\n            setState({\n              contracts: freshContracts,\n              users: includeUsersAndTopics ? newUsers : state.users,\n              topics: includeUsersAndTopics ? newTopics?.lite : state.topics,\n              posts: freshPosts,\n              shouldLoadMore,\n            })\n            clearTimeout(timeoutId)\n            setLoading(false)\n\n            return shouldLoadMore\n          }\n        } catch (error) {\n          console.error('Error fetching search results:', error)\n          setLoading(false)\n        }\n      }\n      return false\n    }\n  )\n\n  useDebouncedEffect(\n    () => {\n      if (!state.contracts?.length) {\n        querySearchResults(true)\n      }\n    },\n    50,\n    [isReady]\n  )\n  useDebouncedEffect(() => querySearchResults(true), 50, [\n    JSON.stringify(searchParams),\n  ])\n\n  const contracts = state.contracts\n    ? uniqBy(\n        state.contracts.filter((c) => {\n          return (\n            !additionalFilter?.excludeContractIds?.includes(c.id) &&\n            !additionalFilter?.excludeGroupSlugs?.some((slug) =>\n              c.groupSlugs?.includes(slug)\n            ) &&\n            !additionalFilter?.excludeUserIds?.includes(c.creatorId)\n          )\n        }),\n        'id'\n      )\n    : undefined\n\n  return {\n    contracts,\n    users: state.users,\n    topics: state.topics,\n    loading,\n    shouldLoadMore: state.shouldLoadMore,\n    loadMoreContracts: () => querySearchResults(false, true),\n    refreshContracts: () => querySearchResults(true, true),\n    posts: state.posts,\n  }\n}\n\nexport const useSearchQueryState = (props: {\n  persistPrefix: string\n  defaultSort?: Sort\n  defaultFilter?: Filter\n  defaultContractType?: ContractTypeType\n  defaultSearchType?: SearchType\n  defaultPrizeMarket?: '1' | '0'\n  defaultSweepies?: '2' | '1' | '0'\n  defaultForYou?: '1' | '0'\n  useUrlParams?: boolean\n  defaultTopicFilter?: string\n  defaultLiquidityTier?: string\n}) => {\n  const {\n    persistPrefix,\n    defaultSort,\n    defaultFilter,\n    defaultContractType,\n    defaultSearchType,\n    useUrlParams,\n    defaultPrizeMarket,\n    defaultForYou,\n    defaultTopicFilter,\n    defaultSweepies,\n    defaultLiquidityTier,\n  } = props\n\n  const defaults = {\n    [QUERY_KEY]: '',\n    [SORT_KEY]: defaultSort ?? 'score',\n    [FILTER_KEY]: defaultFilter ?? 'all',\n    [CONTRACT_TYPE_KEY]: defaultContractType ?? 'ALL',\n    [SEARCH_TYPE_KEY]: defaultSearchType,\n    [PRIZE_MARKET_KEY]: defaultPrizeMarket ?? '0',\n    [FOR_YOU_KEY]: defaultForYou ?? '0',\n    [TOPIC_FILTER_KEY]: defaultTopicFilter ?? '',\n    [SWEEPIES_KEY]: defaultSweepies ?? '0',\n    [GROUP_IDS_KEY]: '',\n    [LIQUIDITY_KEY]: defaultLiquidityTier ?? '',\n    [HAS_BETS_KEY]: '0' as '0' | '1',\n  }\n\n  const useHook = useUrlParams ? usePersistentQueriesState : useNothing\n  const [queryState, updateQueryState, queryReady] = useHook(\n    defaults,\n    persistPrefix\n  )\n  const [localState, updateLocalState, localReady] = useLocalPartialUpdater(\n    defaults,\n    persistPrefix\n  )\n\n  // copy query state -> local state iff we are using query params and any params are set\n  // only do this once on first load.\n  useEffect(() => {\n    if (\n      queryReady &&\n      localReady &&\n      useUrlParams &&\n      !isEqual(queryState, defaults)\n    ) {\n      updateLocalState(queryState)\n    }\n  }, [queryReady, localReady])\n\n  const setState = useEvent((newState: Partial<SearchParams>) => {\n    updateLocalState(newState)\n    if (useUrlParams) updateQueryState(newState)\n  })\n\n  return [localState, setState, queryReady && localReady] as const\n}\n\n// shim for hook rules and types\nconst useNothing = <T,>(x: T, _: string) =>\n  [x, (_: Partial<T>) => {}, true] as const satisfies any[]\n\nconst useLocalPartialUpdater = <T extends Record<string, string | undefined>>(\n  defaults: T,\n  persistPrefix: string\n) => {\n  const [state, setState, ready] = usePersistentLocalState(\n    defaults,\n    searchLocalKey(persistPrefix)\n  )\n\n  const updateState = (\n    newState: Partial<T> | ((prevState: T) => Partial<T>)\n  ) => {\n    if (typeof newState === 'function') {\n      setState((prevState) => ({ ...prevState, ...newState(prevState) }))\n    } else {\n      setState((prevState) => ({ ...prevState, ...newState }))\n    }\n  }\n\n  // the first copy of data from local state may be missing values, so we return the full state\n  return [{ ...defaults, ...state }, updateState, ready] as const\n}\n\nexport const searchLocalKey = (persistPrefix: string) =>\n  `${persistPrefix}-local-state`\n"
        }
      ]
    },
    {
      "sha": "81699cf645d27a48fb7534e71afd77722ae63315",
      "author": "Ian Philips",
      "date": "2025-05-19 18:01:07 -0700",
      "message": "Fix error from end love",
      "stats": {
        "filesChanged": 2,
        "insertions": 3,
        "deletions": 1
      },
      "selectionReason": "Small bug fix that prevents errors - good example of defensive programming and error handling",
      "spec": "Update the `getContractAndMetricsAndLiquidities` function to refine user contract metric retrieval for specific multi-choice markets. The function must now accept an optional `answerId` string. When this `answerId` is provided for a multi-choice contract (cpmm-multi-1 mechanism) where answers do not necessarily sum to one, the function should retrieve user contract metrics specifically for the given `answerId`. It should also retrieve summary user contract metrics (where `answer_id` is null) for a user only if that user has existing metrics associated with the provided `answerId` for the same contract. For other contract types or if `answerId` is not supplied, the metric retrieval logic remains unchanged. The `resolveMarketHelper` function must be updated to pass the relevant `answerId`, if available, when it calls `getContractAndMetricsAndLiquidities`.",
      "fileStates": [
        {
          "path": "backend/shared/src/resolve-market-helpers.ts",
          "preContent": "import { mapValues, groupBy, sum, sumBy, keyBy, uniqBy } from 'lodash'\nimport {\n  HOUSE_LIQUIDITY_PROVIDER_ID,\n  DEV_HOUSE_LIQUIDITY_PROVIDER_ID,\n} from 'common/antes'\nimport {\n  Contract,\n  contractPath,\n  ContractToken,\n  CPMMMultiContract,\n  MarketContract,\n} from 'common/contract'\nimport { LiquidityProvision } from 'common/liquidity-provision'\nimport { Txn, CancelUniqueBettorBonusTxn } from 'common/txn'\nimport { User } from 'common/user'\nimport { removeUndefinedProps } from 'common/util/object'\nimport { createContractResolvedNotifications } from './create-notification'\nimport { bulkUpdateContractMetricsQuery } from './helpers/user-contract-metrics'\nimport {\n  TxnData,\n  runTxnOutsideBetQueueIgnoringBalance,\n  txnToRow,\n} from './txn/run-txn'\nimport {\n  revalidateStaticProps,\n  isProd,\n  log,\n  getContractAndMetricsAndLiquidities,\n} from './utils'\nimport {\n  getLoanPayouts,\n  getPayouts,\n  groupPayoutsByUser,\n  Payout,\n} from 'common/payouts'\nimport { APIError } from 'common//api/utils'\nimport { trackPublicEvent } from 'shared/analytics'\nimport { recordContractEdit } from 'shared/record-contract-edit'\nimport {\n  SERIAL_MODE,\n  SupabaseTransaction,\n  createSupabaseDirectClient,\n} from './supabase/init'\nimport { Answer } from 'common/answer'\nimport { isAdminId, isModId } from 'common/envs/constants'\nimport { convertTxn } from 'common/supabase/txns'\nimport { updateAnswer, updateAnswers } from './supabase/answers'\nimport { bulkInsertQuery, updateDataQuery } from './supabase/utils'\nimport { bulkIncrementBalancesQuery, UserUpdate } from './supabase/users'\nimport {\n  broadcastUpdatedContract,\n  broadcastUpdatedMetrics,\n} from './websockets/helpers'\nimport { ContractMetric } from 'common/contract-metric'\nimport { calculateUpdatedMetricsForContracts } from 'common/calculate-metrics'\nimport { PROFIT_FEE_FRACTION } from 'common/economy'\n\nexport type ResolutionParams = {\n  outcome: string\n  probabilityInt?: number\n  answerId?: string\n  value?: number\n  resolutions?: { [key: string]: number }\n}\n\nexport const resolveMarketHelper = async (\n  unresolvedContract: MarketContract,\n  resolver: User,\n  creator: User,\n  { value, resolutions, probabilityInt, outcome, answerId }: ResolutionParams\n) => {\n  const pg = createSupabaseDirectClient()\n\n  // TODO: Why not add this to front of bet queue?\n  const {\n    resolvedContract,\n    updatedContractMetrics,\n    payoutsWithoutLoans,\n    updatedContractAttrs,\n    userUpdates,\n  } = await pg.tx({ mode: SERIAL_MODE }, async (tx) => {\n    const { closeTime, id: contractId } = unresolvedContract\n    const {\n      contract: c,\n      liquidities,\n      contractMetrics,\n    } = await getContractAndMetricsAndLiquidities(\n      tx,\n      unresolvedContract,\n    )\n    const isIndieMC = c.mechanism === 'cpmm-multi-1' && !c.shouldAnswersSumToOne\n\n    unresolvedContract = c as MarketContract\n    if (unresolvedContract.isResolved) {\n      throw new APIError(403, 'Contract is already resolved')\n    }\n\n    const resolutionTime = Date.now()\n    const newCloseTime = closeTime\n      ? Math.min(closeTime, resolutionTime)\n      : closeTime\n\n    const {\n      resolutionProbability,\n      payouts,\n      payoutsWithoutLoans,\n      traderPayouts,\n    } = getPayoutInfo(\n      outcome,\n      unresolvedContract,\n      resolutions,\n      probabilityInt,\n      answerId,\n      contractMetrics,\n      liquidities\n    )\n    // Keep MKT resolution prob for consistency's sake\n    const probBeforeResolution =\n      outcome === 'MKT'\n        ? resolutionProbability\n        : unresolvedContract.mechanism === 'cpmm-1'\n        ? unresolvedContract.prob\n        : unresolvedContract.answers.find((a) => a.id === answerId)?.prob\n    const newProb =\n      outcome === 'YES' ? 1 : outcome === 'NO' ? 0 : probBeforeResolution\n    let updatedContractAttrs: Partial<Contract> & { id: string } =\n      removeUndefinedProps({\n        id: unresolvedContract.id,\n        isResolved: true,\n        resolution: outcome,\n        resolutionValue: value,\n        resolutionTime,\n        closeTime: newCloseTime,\n        prob: newProb,\n        resolutionProbability: probBeforeResolution,\n        resolutions,\n        resolverId: resolver.id,\n        subsidyPool: 0,\n        lastUpdatedTime: newCloseTime,\n      })\n    let updateAnswerAttrs: Partial<Answer> | undefined\n\n    if (unresolvedContract.mechanism === 'cpmm-multi-1' && answerId) {\n      // Only resolve the contract if all other answers are resolved.\n      const allOtherAnswers = unresolvedContract.answers.filter(\n        (a) => a.id !== answerId\n      )\n      const allOtherAnswersResolved = allOtherAnswers.every((a) => a.resolution)\n\n      const marketCancelled =\n        allOtherAnswers.every((a) => a.resolution === 'CANCEL') &&\n        outcome === 'CANCEL'\n      const finalResolution = marketCancelled ? 'CANCEL' : 'MKT'\n      if (allOtherAnswersResolved) {\n        updatedContractAttrs = {\n          ...updatedContractAttrs,\n          resolution: finalResolution,\n        }\n      } else {\n        updatedContractAttrs = {\n          id: unresolvedContract.id,\n        }\n      }\n      updateAnswerAttrs = removeUndefinedProps({\n        resolution: outcome,\n        resolutionTime,\n        resolutionProbability: probBeforeResolution,\n        prob: newProb,\n        resolverId: resolver.id,\n      }) as Partial<Answer>\n      // We have to update the denormalized answer data on the contract for the updateContractMetrics call\n      updatedContractAttrs = {\n        ...updatedContractAttrs,\n        answers: unresolvedContract.answers.map((a) =>\n          a.id === answerId\n            ? {\n                ...a,\n                ...updateAnswerAttrs,\n              }\n            : a\n        ),\n      } as Partial<CPMMMultiContract> & { id: string }\n    } else if (\n      unresolvedContract.mechanism === 'cpmm-multi-1' &&\n      updatedContractAttrs.isResolved\n    ) {\n      updateAnswerAttrs = removeUndefinedProps({\n        resolutionTime,\n        resolverId: resolver.id,\n      }) as Partial<Answer>\n      // We have to update the denormalized answer data on the contract for the updateContractMetrics call\n      updatedContractAttrs = {\n        ...updatedContractAttrs,\n        answers: unresolvedContract.answers.map((a) => ({\n          ...a,\n          ...updateAnswerAttrs,\n          prob: resolutions ? (resolutions[a.id] ?? 0) / 100 : a.prob,\n          resolutionProbability: a.prob,\n        })),\n      } as Partial<CPMMMultiContract> & { id: string }\n    }\n\n    const resolvedContract = {\n      ...unresolvedContract,\n      ...updatedContractAttrs,\n    } as MarketContract\n\n    // handle exploit where users can get negative payouts\n    const negPayoutThreshold =\n      resolvedContract.uniqueBettorCount < 100 ? 0 : -1000\n\n    const userPayouts = groupPayoutsByUser(payouts)\n    log('user payouts', { userPayouts })\n\n    const negativePayouts = Object.values(userPayouts).filter(\n      (p) => p < negPayoutThreshold\n    )\n\n    log('negative payouts', { negativePayouts })\n\n    if (\n      outcome === 'CANCEL' &&\n      !isAdminId(resolver.id) &&\n      !isModId(resolver.id) &&\n      negativePayouts.length > 0\n    ) {\n      throw new APIError(\n        403,\n        'Negative payouts too large for resolution. Contact admin or mod.'\n      )\n    }\n\n    if (updateAnswerAttrs && answerId) {\n      const props = removeUndefinedProps(updateAnswerAttrs)\n      await updateAnswer(tx, answerId, props)\n    } else if (\n      updateAnswerAttrs &&\n      resolvedContract.mechanism === 'cpmm-multi-1'\n    ) {\n      const answerUpdates = resolvedContract.answers.map((a) =>\n        removeUndefinedProps({\n          id: a.id,\n          ...updateAnswerAttrs,\n          prob: a.prob,\n          resolutionProbability: a.resolutionProbability,\n        })\n      )\n      await updateAnswers(tx, contractId, answerUpdates)\n    }\n    const { metricsByContract } = calculateUpdatedMetricsForContracts(\n      [{ contract: resolvedContract, metrics: contractMetrics }],\n      isIndieMC\n    )\n    const updatedContractMetrics = metricsByContract[resolvedContract.id] ?? []\n    const updateMetricsQuery = bulkUpdateContractMetricsQuery(\n      updatedContractMetrics\n    )\n    const { token } = resolvedContract\n    const payoutFees =\n      token === 'CASH'\n        ? assessProfitFees(traderPayouts, updatedContractMetrics, answerId)\n        : []\n    const { balanceUpdatesQuery, insertTxnsQuery } = getPayUsersQueries(\n      payouts,\n      contractId,\n      answerId,\n      token,\n      payoutFees\n    )\n    const contractUpdateQuery = updateDataQuery(\n      'contracts',\n      'id',\n      updatedContractAttrs\n    )\n\n    log('updating contract & processing payouts', { updatedContractAttrs })\n    const results = await tx.multi(`\n      ${balanceUpdatesQuery}; -- 1\n      ${insertTxnsQuery}; -- 2\n      ${contractUpdateQuery}; -- 3\n      ${updateMetricsQuery}; -- 4\n      `)\n    const userUpdates = results[0] as UserUpdate[]\n\n    // TODO: we may want to support clawing back trader bonuses on MC markets too\n    if (!answerId && outcome === 'CANCEL') {\n      await undoUniqueBettorRewardsIfCancelResolution(tx, resolvedContract)\n    }\n\n    return {\n      resolvedContract,\n      payoutsWithoutLoans,\n      updatedContractAttrs,\n      userUpdates,\n      updatedContractMetrics,\n    }\n  })\n\n  broadcastUpdatedContract(resolvedContract.visibility, updatedContractAttrs)\n  broadcastUpdatedMetrics(updatedContractMetrics)\n  const userPayoutsWithoutLoans = groupPayoutsByUser(payoutsWithoutLoans)\n\n  await trackPublicEvent(resolver.id, 'resolve market', {\n    resolution: outcome,\n    contractId: resolvedContract.id,\n  })\n\n  await recordContractEdit(\n    unresolvedContract,\n    resolver.id,\n    Object.keys(updatedContractAttrs ?? {})\n  )\n\n  await revalidateStaticProps(contractPath(resolvedContract))\n  const userIdToContractMetric = keyBy(\n    updatedContractMetrics.filter((m) =>\n      answerId ? m.answerId === answerId : m.answerId == null\n    ),\n    'userId'\n  )\n  await createContractResolvedNotifications(\n    resolvedContract,\n    resolver,\n    creator,\n    outcome,\n    probabilityInt,\n    value,\n    answerId,\n    {\n      userIdToContractMetric,\n      userPayouts: userPayoutsWithoutLoans,\n      creatorPayout: 0,\n      resolutionProbability: resolvedContract.resolutionProbability,\n      resolutions,\n    }\n  )\n\n  return { contract: resolvedContract, userUpdates }\n}\n\nexport const getPayoutInfo = (\n  outcome: string | undefined,\n  unresolvedContract: Contract,\n  resolutions: { [key: string]: number } | undefined,\n  probabilityInt: number | undefined,\n  answerId: string | undefined,\n  contractMetrics: ContractMetric[],\n  liquidities: LiquidityProvision[]\n) => {\n  const resolutionProbability =\n    probabilityInt !== undefined ? probabilityInt / 100 : undefined\n\n  const resolutionProbs = resolutions\n    ? (() => {\n        const total = sum(Object.values(resolutions))\n        return mapValues(resolutions, (p) => p / total)\n      })()\n    : undefined\n\n  // Calculate loan payouts from contract metrics\n  const loanPayouts = getLoanPayouts(contractMetrics, answerId)\n\n  // Calculate payouts using contract metrics instead of bets\n  const { traderPayouts, liquidityPayouts } = getPayouts(\n    outcome,\n    unresolvedContract,\n    contractMetrics,\n    liquidities,\n    resolutionProbs,\n    resolutionProbability,\n    answerId\n  )\n\n  const payoutsWithoutLoans = [\n    ...liquidityPayouts.map((p) => ({ ...p, deposit: p.payout })),\n    ...traderPayouts,\n  ]\n\n  if (!isProd())\n    console.log(\n      'trader payouts:',\n      traderPayouts,\n      'liquidity payout:',\n      liquidityPayouts,\n      'loan payouts:',\n      loanPayouts\n    )\n\n  const payouts = [...payoutsWithoutLoans, ...loanPayouts].filter(\n    (p) => p.payout !== 0\n  )\n\n  return {\n    payoutsWithoutLoans,\n    contractMetrics,\n    resolutionProbs,\n    resolutionProbability,\n    payouts,\n    traderPayouts,\n  }\n}\n\nasync function undoUniqueBettorRewardsIfCancelResolution(\n  pg: SupabaseTransaction,\n  contract: Contract\n) {\n  const bonusTxnsOnThisContract = await pg.map<Txn>(\n    `select * from txns where category = 'UNIQUE_BETTOR_BONUS'\n      and to_id = $1\n      and data->'data'->>'contractId' = $2`,\n    [contract.creatorId, contract.id],\n    convertTxn\n  )\n\n  log('total bonusTxnsOnThisContract ' + bonusTxnsOnThisContract.length)\n  const totalBonusAmount = sumBy(bonusTxnsOnThisContract, (txn) => txn.amount)\n  log('totalBonusAmount to be withdrawn ' + totalBonusAmount)\n\n  if (totalBonusAmount === 0) {\n    log('No bonus to cancel')\n    return\n  }\n\n  const undoBonusTxn = {\n    fromId: contract.creatorId,\n    fromType: 'USER',\n    toId: isProd()\n      ? HOUSE_LIQUIDITY_PROVIDER_ID\n      : DEV_HOUSE_LIQUIDITY_PROVIDER_ID,\n    toType: 'BANK',\n    amount: totalBonusAmount,\n    token: 'M$',\n    category: 'CANCEL_UNIQUE_BETTOR_BONUS',\n    data: {\n      contractId: contract.id,\n    },\n  } as Omit<CancelUniqueBettorBonusTxn, 'id' | 'createdTime'>\n\n  const txn = await runTxnOutsideBetQueueIgnoringBalance(pg, undoBonusTxn)\n  log(`Cancel Bonus txn for user: ${contract.creatorId} completed: ${txn.id}`)\n}\n\nexport const getPayUsersQueries = (\n  payouts: Payout[],\n  contractId: string,\n  answerId: string | undefined,\n  token: ContractToken,\n  payoutFees: Payout[]\n) => {\n  const payoutCash = token === 'CASH'\n  const payoutToken = token === 'CASH' ? 'CASH' : 'M$'\n  const mergedPayouts = checkAndMergePayouts(payouts)\n  const payoutStartTime = Date.now()\n\n  const balanceUpdates: {\n    id: string\n    balance?: number\n    spiceBalance?: number\n    totalDeposits?: number\n    totalCashDeposits?: number\n  }[] = []\n  const txns: TxnData[] = []\n\n  for (const { userId, payout, deposit } of mergedPayouts) {\n    const userPayoutFees = payoutFees.filter((t) => t.userId === userId)\n    if (userPayoutFees.length > 1) {\n      throw new APIError(\n        500,\n        `Multiple payout fees for user: ${userId} on contract: ${contractId}`\n      )\n    }\n    const payoutFee = userPayoutFees[0]?.payout ?? 0\n    balanceUpdates.push({\n      id: userId,\n      [payoutCash ? 'cashBalance' : 'balance']: payout + payoutFee,\n      [payoutCash ? 'totalCashDeposits' : 'totalDeposits']: deposit ?? 0,\n    })\n\n    txns.push({\n      category: 'CONTRACT_RESOLUTION_PAYOUT',\n      fromType: 'CONTRACT',\n      fromId: contractId,\n      toType: 'USER',\n      toId: userId,\n      amount: payout,\n      token: payoutToken,\n      data: removeUndefinedProps({\n        deposit: deposit ?? 0,\n        payoutStartTime,\n        answerId,\n      }),\n      description: 'Contract payout for resolution: ' + contractId,\n    })\n  }\n\n  for (const { userId, payout } of payoutFees) {\n    const balanceUpdate = balanceUpdates.find((b) => b.id === userId)\n    if (!balanceUpdate) {\n      balanceUpdates.push({\n        id: userId,\n        [payoutCash ? 'cashBalance' : 'balance']: payout,\n      })\n    }\n\n    txns.push({\n      category: 'CONTRACT_RESOLUTION_FEE',\n      fromType: 'USER',\n      fromId: userId,\n      toType: 'BANK',\n      toId: isProd()\n        ? HOUSE_LIQUIDITY_PROVIDER_ID\n        : DEV_HOUSE_LIQUIDITY_PROVIDER_ID,\n      amount: -payout,\n      token: payoutToken,\n      data: removeUndefinedProps({\n        contractId,\n        payoutStartTime,\n        answerId,\n      }),\n    })\n  }\n\n  const balanceUpdatesQuery = bulkIncrementBalancesQuery(balanceUpdates)\n  const insertTxnsQuery = bulkInsertQuery('txns', txns.map(txnToRow), false)\n\n  return { balanceUpdatesQuery, insertTxnsQuery }\n}\n\nconst checkAndMergePayouts = (payouts: Payout[]) => {\n  for (const { payout, deposit } of payouts) {\n    if (!isFinite(payout)) {\n      throw new Error('Payout is not finite: ' + payout)\n    }\n    if (deposit !== undefined && !isFinite(deposit)) {\n      throw new Error('Deposit is not finite: ' + deposit)\n    }\n  }\n\n  const groupedPayouts = groupBy(payouts, 'userId')\n  return Object.values(\n    mapValues(groupedPayouts, (payouts, userId) => ({\n      userId,\n      payout: sumBy(payouts, 'payout'),\n      deposit: sumBy(payouts, (p) => p.deposit ?? 0),\n    }))\n  ).filter((p) => p!.payout !== 0 || p!.deposit !== 0)\n}\n\nconst assessProfitFees = (\n  payouts: Payout[],\n  contractMetrics: Omit<ContractMetric, 'id'>[],\n  answerId: string | undefined\n) => {\n  return uniqBy(payouts, 'userId')\n    .map((payout) => {\n      const contractMetric = contractMetrics.find(\n        (m) => m.userId === payout.userId && m.answerId === (answerId ?? null)\n      )\n      if (!contractMetric) {\n        throw new APIError(\n          500,\n          'Contract metric not found for user: ' + payout.userId\n        )\n      }\n\n      const tax = contractMetric.profit * PROFIT_FEE_FRACTION\n      return {\n        userId: payout.userId,\n        payout: contractMetric.profit > 0 ? -tax : 0,\n      }\n    })\n    .filter((p) => p.payout !== 0)\n}\n",
          "postContent": "import { mapValues, groupBy, sum, sumBy, keyBy, uniqBy } from 'lodash'\nimport {\n  HOUSE_LIQUIDITY_PROVIDER_ID,\n  DEV_HOUSE_LIQUIDITY_PROVIDER_ID,\n} from 'common/antes'\nimport {\n  Contract,\n  contractPath,\n  ContractToken,\n  CPMMMultiContract,\n  MarketContract,\n} from 'common/contract'\nimport { LiquidityProvision } from 'common/liquidity-provision'\nimport { Txn, CancelUniqueBettorBonusTxn } from 'common/txn'\nimport { User } from 'common/user'\nimport { removeUndefinedProps } from 'common/util/object'\nimport { createContractResolvedNotifications } from './create-notification'\nimport { bulkUpdateContractMetricsQuery } from './helpers/user-contract-metrics'\nimport {\n  TxnData,\n  runTxnOutsideBetQueueIgnoringBalance,\n  txnToRow,\n} from './txn/run-txn'\nimport {\n  revalidateStaticProps,\n  isProd,\n  log,\n  getContractAndMetricsAndLiquidities,\n} from './utils'\nimport {\n  getLoanPayouts,\n  getPayouts,\n  groupPayoutsByUser,\n  Payout,\n} from 'common/payouts'\nimport { APIError } from 'common//api/utils'\nimport { trackPublicEvent } from 'shared/analytics'\nimport { recordContractEdit } from 'shared/record-contract-edit'\nimport {\n  SERIAL_MODE,\n  SupabaseTransaction,\n  createSupabaseDirectClient,\n} from './supabase/init'\nimport { Answer } from 'common/answer'\nimport { isAdminId, isModId } from 'common/envs/constants'\nimport { convertTxn } from 'common/supabase/txns'\nimport { updateAnswer, updateAnswers } from './supabase/answers'\nimport { bulkInsertQuery, updateDataQuery } from './supabase/utils'\nimport { bulkIncrementBalancesQuery, UserUpdate } from './supabase/users'\nimport {\n  broadcastUpdatedContract,\n  broadcastUpdatedMetrics,\n} from './websockets/helpers'\nimport { ContractMetric } from 'common/contract-metric'\nimport { calculateUpdatedMetricsForContracts } from 'common/calculate-metrics'\nimport { PROFIT_FEE_FRACTION } from 'common/economy'\n\nexport type ResolutionParams = {\n  outcome: string\n  probabilityInt?: number\n  answerId?: string\n  value?: number\n  resolutions?: { [key: string]: number }\n}\n\nexport const resolveMarketHelper = async (\n  unresolvedContract: MarketContract,\n  resolver: User,\n  creator: User,\n  { value, resolutions, probabilityInt, outcome, answerId }: ResolutionParams\n) => {\n  const pg = createSupabaseDirectClient()\n\n  // TODO: Why not add this to front of bet queue?\n  const {\n    resolvedContract,\n    updatedContractMetrics,\n    payoutsWithoutLoans,\n    updatedContractAttrs,\n    userUpdates,\n  } = await pg.tx({ mode: SERIAL_MODE }, async (tx) => {\n    const { closeTime, id: contractId } = unresolvedContract\n    const {\n      contract: c,\n      liquidities,\n      contractMetrics,\n    } = await getContractAndMetricsAndLiquidities(\n      tx,\n      unresolvedContract,\n      answerId\n    )\n    const isIndieMC = c.mechanism === 'cpmm-multi-1' && !c.shouldAnswersSumToOne\n\n    unresolvedContract = c as MarketContract\n    if (unresolvedContract.isResolved) {\n      throw new APIError(403, 'Contract is already resolved')\n    }\n\n    const resolutionTime = Date.now()\n    const newCloseTime = closeTime\n      ? Math.min(closeTime, resolutionTime)\n      : closeTime\n\n    const {\n      resolutionProbability,\n      payouts,\n      payoutsWithoutLoans,\n      traderPayouts,\n    } = getPayoutInfo(\n      outcome,\n      unresolvedContract,\n      resolutions,\n      probabilityInt,\n      answerId,\n      contractMetrics,\n      liquidities\n    )\n    // Keep MKT resolution prob for consistency's sake\n    const probBeforeResolution =\n      outcome === 'MKT'\n        ? resolutionProbability\n        : unresolvedContract.mechanism === 'cpmm-1'\n        ? unresolvedContract.prob\n        : unresolvedContract.answers.find((a) => a.id === answerId)?.prob\n    const newProb =\n      outcome === 'YES' ? 1 : outcome === 'NO' ? 0 : probBeforeResolution\n    let updatedContractAttrs: Partial<Contract> & { id: string } =\n      removeUndefinedProps({\n        id: unresolvedContract.id,\n        isResolved: true,\n        resolution: outcome,\n        resolutionValue: value,\n        resolutionTime,\n        closeTime: newCloseTime,\n        prob: newProb,\n        resolutionProbability: probBeforeResolution,\n        resolutions,\n        resolverId: resolver.id,\n        subsidyPool: 0,\n        lastUpdatedTime: newCloseTime,\n      })\n    let updateAnswerAttrs: Partial<Answer> | undefined\n\n    if (unresolvedContract.mechanism === 'cpmm-multi-1' && answerId) {\n      // Only resolve the contract if all other answers are resolved.\n      const allOtherAnswers = unresolvedContract.answers.filter(\n        (a) => a.id !== answerId\n      )\n      const allOtherAnswersResolved = allOtherAnswers.every((a) => a.resolution)\n\n      const marketCancelled =\n        allOtherAnswers.every((a) => a.resolution === 'CANCEL') &&\n        outcome === 'CANCEL'\n      const finalResolution = marketCancelled ? 'CANCEL' : 'MKT'\n      if (allOtherAnswersResolved) {\n        updatedContractAttrs = {\n          ...updatedContractAttrs,\n          resolution: finalResolution,\n        }\n      } else {\n        updatedContractAttrs = {\n          id: unresolvedContract.id,\n        }\n      }\n      updateAnswerAttrs = removeUndefinedProps({\n        resolution: outcome,\n        resolutionTime,\n        resolutionProbability: probBeforeResolution,\n        prob: newProb,\n        resolverId: resolver.id,\n      }) as Partial<Answer>\n      // We have to update the denormalized answer data on the contract for the updateContractMetrics call\n      updatedContractAttrs = {\n        ...updatedContractAttrs,\n        answers: unresolvedContract.answers.map((a) =>\n          a.id === answerId\n            ? {\n                ...a,\n                ...updateAnswerAttrs,\n              }\n            : a\n        ),\n      } as Partial<CPMMMultiContract> & { id: string }\n    } else if (\n      unresolvedContract.mechanism === 'cpmm-multi-1' &&\n      updatedContractAttrs.isResolved\n    ) {\n      updateAnswerAttrs = removeUndefinedProps({\n        resolutionTime,\n        resolverId: resolver.id,\n      }) as Partial<Answer>\n      // We have to update the denormalized answer data on the contract for the updateContractMetrics call\n      updatedContractAttrs = {\n        ...updatedContractAttrs,\n        answers: unresolvedContract.answers.map((a) => ({\n          ...a,\n          ...updateAnswerAttrs,\n          prob: resolutions ? (resolutions[a.id] ?? 0) / 100 : a.prob,\n          resolutionProbability: a.prob,\n        })),\n      } as Partial<CPMMMultiContract> & { id: string }\n    }\n\n    const resolvedContract = {\n      ...unresolvedContract,\n      ...updatedContractAttrs,\n    } as MarketContract\n\n    // handle exploit where users can get negative payouts\n    const negPayoutThreshold =\n      resolvedContract.uniqueBettorCount < 100 ? 0 : -1000\n\n    const userPayouts = groupPayoutsByUser(payouts)\n    log('user payouts', { userPayouts })\n\n    const negativePayouts = Object.values(userPayouts).filter(\n      (p) => p < negPayoutThreshold\n    )\n\n    log('negative payouts', { negativePayouts })\n\n    if (\n      outcome === 'CANCEL' &&\n      !isAdminId(resolver.id) &&\n      !isModId(resolver.id) &&\n      negativePayouts.length > 0\n    ) {\n      throw new APIError(\n        403,\n        'Negative payouts too large for resolution. Contact admin or mod.'\n      )\n    }\n\n    if (updateAnswerAttrs && answerId) {\n      const props = removeUndefinedProps(updateAnswerAttrs)\n      await updateAnswer(tx, answerId, props)\n    } else if (\n      updateAnswerAttrs &&\n      resolvedContract.mechanism === 'cpmm-multi-1'\n    ) {\n      const answerUpdates = resolvedContract.answers.map((a) =>\n        removeUndefinedProps({\n          id: a.id,\n          ...updateAnswerAttrs,\n          prob: a.prob,\n          resolutionProbability: a.resolutionProbability,\n        })\n      )\n      await updateAnswers(tx, contractId, answerUpdates)\n    }\n    const { metricsByContract } = calculateUpdatedMetricsForContracts(\n      [{ contract: resolvedContract, metrics: contractMetrics }],\n      isIndieMC\n    )\n    const updatedContractMetrics = metricsByContract[resolvedContract.id] ?? []\n    const updateMetricsQuery = bulkUpdateContractMetricsQuery(\n      updatedContractMetrics\n    )\n    const { token } = resolvedContract\n    const payoutFees =\n      token === 'CASH'\n        ? assessProfitFees(traderPayouts, updatedContractMetrics, answerId)\n        : []\n    const { balanceUpdatesQuery, insertTxnsQuery } = getPayUsersQueries(\n      payouts,\n      contractId,\n      answerId,\n      token,\n      payoutFees\n    )\n    const contractUpdateQuery = updateDataQuery(\n      'contracts',\n      'id',\n      updatedContractAttrs\n    )\n\n    log('updating contract & processing payouts', { updatedContractAttrs })\n    const results = await tx.multi(`\n      ${balanceUpdatesQuery}; -- 1\n      ${insertTxnsQuery}; -- 2\n      ${contractUpdateQuery}; -- 3\n      ${updateMetricsQuery}; -- 4\n      `)\n    const userUpdates = results[0] as UserUpdate[]\n\n    // TODO: we may want to support clawing back trader bonuses on MC markets too\n    if (!answerId && outcome === 'CANCEL') {\n      await undoUniqueBettorRewardsIfCancelResolution(tx, resolvedContract)\n    }\n\n    return {\n      resolvedContract,\n      payoutsWithoutLoans,\n      updatedContractAttrs,\n      userUpdates,\n      updatedContractMetrics,\n    }\n  })\n\n  broadcastUpdatedContract(resolvedContract.visibility, updatedContractAttrs)\n  broadcastUpdatedMetrics(updatedContractMetrics)\n  const userPayoutsWithoutLoans = groupPayoutsByUser(payoutsWithoutLoans)\n\n  await trackPublicEvent(resolver.id, 'resolve market', {\n    resolution: outcome,\n    contractId: resolvedContract.id,\n  })\n\n  await recordContractEdit(\n    unresolvedContract,\n    resolver.id,\n    Object.keys(updatedContractAttrs ?? {})\n  )\n\n  await revalidateStaticProps(contractPath(resolvedContract))\n  const userIdToContractMetric = keyBy(\n    updatedContractMetrics.filter((m) =>\n      answerId ? m.answerId === answerId : m.answerId == null\n    ),\n    'userId'\n  )\n  await createContractResolvedNotifications(\n    resolvedContract,\n    resolver,\n    creator,\n    outcome,\n    probabilityInt,\n    value,\n    answerId,\n    {\n      userIdToContractMetric,\n      userPayouts: userPayoutsWithoutLoans,\n      creatorPayout: 0,\n      resolutionProbability: resolvedContract.resolutionProbability,\n      resolutions,\n    }\n  )\n\n  return { contract: resolvedContract, userUpdates }\n}\n\nexport const getPayoutInfo = (\n  outcome: string | undefined,\n  unresolvedContract: Contract,\n  resolutions: { [key: string]: number } | undefined,\n  probabilityInt: number | undefined,\n  answerId: string | undefined,\n  contractMetrics: ContractMetric[],\n  liquidities: LiquidityProvision[]\n) => {\n  const resolutionProbability =\n    probabilityInt !== undefined ? probabilityInt / 100 : undefined\n\n  const resolutionProbs = resolutions\n    ? (() => {\n        const total = sum(Object.values(resolutions))\n        return mapValues(resolutions, (p) => p / total)\n      })()\n    : undefined\n\n  // Calculate loan payouts from contract metrics\n  const loanPayouts = getLoanPayouts(contractMetrics, answerId)\n\n  // Calculate payouts using contract metrics instead of bets\n  const { traderPayouts, liquidityPayouts } = getPayouts(\n    outcome,\n    unresolvedContract,\n    contractMetrics,\n    liquidities,\n    resolutionProbs,\n    resolutionProbability,\n    answerId\n  )\n\n  const payoutsWithoutLoans = [\n    ...liquidityPayouts.map((p) => ({ ...p, deposit: p.payout })),\n    ...traderPayouts,\n  ]\n\n  if (!isProd())\n    console.log(\n      'trader payouts:',\n      traderPayouts,\n      'liquidity payout:',\n      liquidityPayouts,\n      'loan payouts:',\n      loanPayouts\n    )\n\n  const payouts = [...payoutsWithoutLoans, ...loanPayouts].filter(\n    (p) => p.payout !== 0\n  )\n\n  return {\n    payoutsWithoutLoans,\n    contractMetrics,\n    resolutionProbs,\n    resolutionProbability,\n    payouts,\n    traderPayouts,\n  }\n}\n\nasync function undoUniqueBettorRewardsIfCancelResolution(\n  pg: SupabaseTransaction,\n  contract: Contract\n) {\n  const bonusTxnsOnThisContract = await pg.map<Txn>(\n    `select * from txns where category = 'UNIQUE_BETTOR_BONUS'\n      and to_id = $1\n      and data->'data'->>'contractId' = $2`,\n    [contract.creatorId, contract.id],\n    convertTxn\n  )\n\n  log('total bonusTxnsOnThisContract ' + bonusTxnsOnThisContract.length)\n  const totalBonusAmount = sumBy(bonusTxnsOnThisContract, (txn) => txn.amount)\n  log('totalBonusAmount to be withdrawn ' + totalBonusAmount)\n\n  if (totalBonusAmount === 0) {\n    log('No bonus to cancel')\n    return\n  }\n\n  const undoBonusTxn = {\n    fromId: contract.creatorId,\n    fromType: 'USER',\n    toId: isProd()\n      ? HOUSE_LIQUIDITY_PROVIDER_ID\n      : DEV_HOUSE_LIQUIDITY_PROVIDER_ID,\n    toType: 'BANK',\n    amount: totalBonusAmount,\n    token: 'M$',\n    category: 'CANCEL_UNIQUE_BETTOR_BONUS',\n    data: {\n      contractId: contract.id,\n    },\n  } as Omit<CancelUniqueBettorBonusTxn, 'id' | 'createdTime'>\n\n  const txn = await runTxnOutsideBetQueueIgnoringBalance(pg, undoBonusTxn)\n  log(`Cancel Bonus txn for user: ${contract.creatorId} completed: ${txn.id}`)\n}\n\nexport const getPayUsersQueries = (\n  payouts: Payout[],\n  contractId: string,\n  answerId: string | undefined,\n  token: ContractToken,\n  payoutFees: Payout[]\n) => {\n  const payoutCash = token === 'CASH'\n  const payoutToken = token === 'CASH' ? 'CASH' : 'M$'\n  const mergedPayouts = checkAndMergePayouts(payouts)\n  const payoutStartTime = Date.now()\n\n  const balanceUpdates: {\n    id: string\n    balance?: number\n    spiceBalance?: number\n    totalDeposits?: number\n    totalCashDeposits?: number\n  }[] = []\n  const txns: TxnData[] = []\n\n  for (const { userId, payout, deposit } of mergedPayouts) {\n    const userPayoutFees = payoutFees.filter((t) => t.userId === userId)\n    if (userPayoutFees.length > 1) {\n      throw new APIError(\n        500,\n        `Multiple payout fees for user: ${userId} on contract: ${contractId}`\n      )\n    }\n    const payoutFee = userPayoutFees[0]?.payout ?? 0\n    balanceUpdates.push({\n      id: userId,\n      [payoutCash ? 'cashBalance' : 'balance']: payout + payoutFee,\n      [payoutCash ? 'totalCashDeposits' : 'totalDeposits']: deposit ?? 0,\n    })\n\n    txns.push({\n      category: 'CONTRACT_RESOLUTION_PAYOUT',\n      fromType: 'CONTRACT',\n      fromId: contractId,\n      toType: 'USER',\n      toId: userId,\n      amount: payout,\n      token: payoutToken,\n      data: removeUndefinedProps({\n        deposit: deposit ?? 0,\n        payoutStartTime,\n        answerId,\n      }),\n      description: 'Contract payout for resolution: ' + contractId,\n    })\n  }\n\n  for (const { userId, payout } of payoutFees) {\n    const balanceUpdate = balanceUpdates.find((b) => b.id === userId)\n    if (!balanceUpdate) {\n      balanceUpdates.push({\n        id: userId,\n        [payoutCash ? 'cashBalance' : 'balance']: payout,\n      })\n    }\n\n    txns.push({\n      category: 'CONTRACT_RESOLUTION_FEE',\n      fromType: 'USER',\n      fromId: userId,\n      toType: 'BANK',\n      toId: isProd()\n        ? HOUSE_LIQUIDITY_PROVIDER_ID\n        : DEV_HOUSE_LIQUIDITY_PROVIDER_ID,\n      amount: -payout,\n      token: payoutToken,\n      data: removeUndefinedProps({\n        contractId,\n        payoutStartTime,\n        answerId,\n      }),\n    })\n  }\n\n  const balanceUpdatesQuery = bulkIncrementBalancesQuery(balanceUpdates)\n  const insertTxnsQuery = bulkInsertQuery('txns', txns.map(txnToRow), false)\n\n  return { balanceUpdatesQuery, insertTxnsQuery }\n}\n\nconst checkAndMergePayouts = (payouts: Payout[]) => {\n  for (const { payout, deposit } of payouts) {\n    if (!isFinite(payout)) {\n      throw new Error('Payout is not finite: ' + payout)\n    }\n    if (deposit !== undefined && !isFinite(deposit)) {\n      throw new Error('Deposit is not finite: ' + deposit)\n    }\n  }\n\n  const groupedPayouts = groupBy(payouts, 'userId')\n  return Object.values(\n    mapValues(groupedPayouts, (payouts, userId) => ({\n      userId,\n      payout: sumBy(payouts, 'payout'),\n      deposit: sumBy(payouts, (p) => p.deposit ?? 0),\n    }))\n  ).filter((p) => p!.payout !== 0 || p!.deposit !== 0)\n}\n\nconst assessProfitFees = (\n  payouts: Payout[],\n  contractMetrics: Omit<ContractMetric, 'id'>[],\n  answerId: string | undefined\n) => {\n  return uniqBy(payouts, 'userId')\n    .map((payout) => {\n      const contractMetric = contractMetrics.find(\n        (m) => m.userId === payout.userId && m.answerId === (answerId ?? null)\n      )\n      if (!contractMetric) {\n        throw new APIError(\n          500,\n          'Contract metric not found for user: ' + payout.userId\n        )\n      }\n\n      const tax = contractMetric.profit * PROFIT_FEE_FRACTION\n      return {\n        userId: payout.userId,\n        payout: contractMetric.profit > 0 ? -tax : 0,\n      }\n    })\n    .filter((p) => p.payout !== 0)\n}\n"
        },
        {
          "path": "backend/shared/src/utils.ts",
          "preContent": "import { generateJSON } from '@tiptap/html'\nimport { APIError, getCloudRunServiceUrl } from 'common/api/utils'\nimport {\n  Contract,\n  contractPath,\n  nativeContractColumnsArray,\n  MarketContract,\n} from 'common/contract'\nimport { PrivateUser } from 'common/user'\nimport { extensions } from 'common/util/parse'\nimport * as admin from 'firebase-admin'\nimport { first, uniq } from 'lodash'\nimport {\n  createSupabaseDirectClient,\n  SupabaseDirectClient,\n  SupabaseTransaction,\n} from 'shared/supabase/init'\nimport {\n  ENV_CONFIG,\n  GROUP_SLUGS_TO_IGNORE_IN_MARKETS_EMAIL,\n} from 'common/envs/constants'\nimport { convertPrivateUser, convertUser } from 'common/supabase/users'\nimport { convertAnswer, convertContract } from 'common/supabase/contracts'\nimport { Row, tsToMillis } from 'common/supabase/utils'\nimport { log } from 'shared/monitoring/log'\nimport { metrics } from 'shared/monitoring/metrics'\nimport { convertLiquidity } from 'common/supabase/liquidity'\nimport { ContractMetric } from 'common/contract-metric'\nexport { metrics }\nexport { log }\nimport * as dayjs from 'dayjs'\nimport * as utc from 'dayjs/plugin/utc'\nimport * as timezone from 'dayjs/plugin/timezone'\ndayjs.extend(utc)\ndayjs.extend(timezone)\n\nexport const logMemory = () => {\n  const used = process.memoryUsage()\n  for (const [k, v] of Object.entries(used)) {\n    log(`${k} ${Math.round((v / 1024 / 1024) * 100) / 100} MB`)\n  }\n}\n\nexport function htmlToRichText(html: string) {\n  return generateJSON(html, extensions)\n}\n\nexport const invokeFunction = async (name: string, body?: unknown) => {\n  const response = await fetch(getCloudRunServiceUrl(name), {\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    method: 'POST',\n    body: JSON.stringify(body ?? {}),\n  })\n\n  const json = await response.json()\n  if (response.ok) {\n    return json\n  } else {\n    throw new Error(\n      `${response.status} invoking ${name}: ${JSON.stringify(json)}`\n    )\n  }\n}\n\nexport const revalidateStaticProps = async (\n  // Path after domain: e.g. \"/JamesGrugett/will-pete-buttigieg-ever-be-us-pres\"\n  pathToRevalidate: string\n) => {\n  if (isProd()) {\n    const apiSecret = process.env.API_SECRET as string\n    if (!apiSecret)\n      throw new Error('Revalidation failed because of missing API_SECRET.')\n\n    const queryStr = `?pathToRevalidate=${pathToRevalidate}&apiSecret=${apiSecret}`\n    const resp = await fetch(\n      `https://${ENV_CONFIG.domain}/api/v0/revalidate` + queryStr\n    )\n\n    if (resp.ok) {\n      // metrics.inc('vercel/revalidations_succeeded', { path: pathToRevalidate })\n      log('Revalidated', pathToRevalidate)\n    } else {\n      // metrics.inc('vercel/revalidations_failed', { path: pathToRevalidate })\n      try {\n        const json = await resp.json()\n        log.error(\n          `HTTP ${\n            resp.status\n          } revalidating ${pathToRevalidate}: ${JSON.stringify(json)}`\n        )\n      } catch (e) {\n        const error = e as Error\n        log.error(`failed to parse response: ${error.message ?? error}`)\n        log.error(`HTTP ${resp.status} revalidating ${pathToRevalidate}`)\n      }\n    }\n  }\n}\n\nexport async function revalidateContractStaticProps(contract: Contract) {\n  await Promise.all([\n    revalidateStaticProps(contractPath(contract)),\n    revalidateStaticProps(`/embed${contractPath(contract)}`),\n  ])\n}\nexport const LOCAL_DEV = process.env.GOOGLE_CLOUD_PROJECT == null\n\n// TODO: deprecate in favor of common/src/envs/is-prod.ts\nexport const isProd = () => {\n  // ian: The first clause is for the API server, and the\n  // second clause is for local scripts and cloud functions\n  if (process.env.NEXT_PUBLIC_FIREBASE_ENV) {\n    return process.env.NEXT_PUBLIC_FIREBASE_ENV === 'PROD'\n  } else {\n    return admin.app().options.projectId === 'mantic-markets'\n  }\n}\n\nexport const contractColumnsToSelect = nativeContractColumnsArray.join(',')\nexport const prefixedContractColumnsToSelect = nativeContractColumnsArray\n  .map((col) => `c.${col}`)\n  .join(',')\nexport const contractColumnsToSelectWithPrefix = (prefix: string) =>\n  nativeContractColumnsArray.map((col) => `${prefix}.${col}`).join(',')\n\nexport const getContract = async (\n  pg: SupabaseDirectClient,\n  contractId: string\n) => {\n  const res = await pg.multi(\n    `select ${contractColumnsToSelect} from contracts where id = $1 limit 1;\n     select * from answers where contract_id = $1 order by index;`,\n    [contractId]\n  )\n  const contract = first(res[0].map(convertContract))\n  const answers = res[1].map(convertAnswer)\n  if (contract && 'answers' in contract) {\n    contract.answers = answers\n  }\n  return contract\n}\n\nexport const getContractAndMetricsAndLiquidities = async (\n  pg: SupabaseTransaction,\n  unresolvedContract: MarketContract,\n) => {\n  const { id: contractId, mechanism } = unresolvedContract\n  const isMulti = mechanism === 'cpmm-multi-1'\n  const sumsToOne = isMulti && unresolvedContract.shouldAnswersSumToOne\n  const metricsQuery = sumsToOne\n    ? `\n     select data from user_contract_metrics\n     where contract_id = $1 and\n     answer_id is not null`\n    : isMulti\n    ? `\n    select data from user_contract_metrics\n      where contract_id = $1\n      and (answer_id = $2 or (\n            -- Only get summary metric if they've bet on the answer\n            answer_id is null and\n            exists (\n              select 1 from user_contract_metrics ucm\n              where ucm.contract_id = $1\n              and ucm.answer_id = $2\n              )\n            )\n          )`\n    : `select data from user_contract_metrics where contract_id = $1`\n\n  const results = await pg.multi(\n    `select ${contractColumnsToSelect} from contracts where id = $1;\n     select * from answers where contract_id = $1 order by index;\n     ${metricsQuery};\n     select * from contract_liquidity where contract_id = $1`,\n    [contractId]\n  )\n\n  const contract = first(results[0].map(convertContract)) as MarketContract\n  if (!contract) throw new APIError(404, 'Contract not found')\n  const answers = results[1].map(convertAnswer)\n  if ('answers' in contract) {\n    contract.answers = answers\n  }\n  // We don't get the summary metric, we recreate them from all the answer metrics\n  const contractMetrics = results[2].map((row) => row.data as ContractMetric)\n  const liquidities = results[3].map(convertLiquidity)\n\n  return { contract, contractMetrics, liquidities }\n}\n\nexport const getContractSupabase = async (contractId: string) => {\n  const pg = createSupabaseDirectClient()\n  return await getContract(pg, contractId)\n}\n\nexport const getContractFromSlugSupabase = async (contractSlug: string) => {\n  const pg = createSupabaseDirectClient()\n  const res = await pg.map(\n    `select ${contractColumnsToSelect} from contracts where slug = $1\n            limit 1`,\n    [contractSlug],\n    (row) => convertContract(row)\n  )\n  return first(res)\n}\n\nexport const getUser = async (\n  userId: string,\n  pg: SupabaseDirectClient = createSupabaseDirectClient()\n) => {\n  return await pg.oneOrNone(\n    `select * from users where id = $1 limit 1`,\n    [userId],\n    convertUser\n  )\n}\nexport const getUserAndPrivateUserOrThrow = async (\n  userId: string,\n  pg: SupabaseDirectClient = createSupabaseDirectClient()\n) => {\n  const rows = await pg.multi(\n    `select * from users where id = $1 limit 1;\n           select * from private_users where id = $1 limit 1;`,\n    [userId]\n  )\n  const userRow = rows[0][0] as Row<'users'> | null\n  const privateUserRow = rows[1][0] as Row<'private_users'> | null\n\n  if (!userRow || !privateUserRow) {\n    throw new APIError(404, 'User or private user not found.')\n  }\n\n  return {\n    user: convertUser(userRow),\n    privateUser: convertPrivateUser(privateUserRow),\n  }\n}\n\nexport const getUsers = async (\n  userIds: string[],\n  pg: SupabaseDirectClient = createSupabaseDirectClient()\n) => {\n  const res = await pg.map(\n    `select * from users where id = any($1)`,\n    [uniq(userIds)],\n    (row) => convertUser(row)\n  )\n  return res\n}\n\nexport const getPrivateUser = async (\n  userId: string,\n  pg: SupabaseDirectClient = createSupabaseDirectClient()\n) => {\n  return await pg.oneOrNone(\n    `select * from private_users where id = $1 limit 1`,\n    [userId],\n    convertPrivateUser\n  )\n}\nexport const getPrivateUserSupabase = (userId: string) => {\n  const pg = createSupabaseDirectClient()\n\n  return pg.oneOrNone(\n    `select data from private_users where id = $1`,\n    [userId],\n    (row) => (row ? (row.data as PrivateUser) : null)\n  )\n}\n\nexport const getPrivateUserByKey = async (\n  apiKey: string,\n  pg: SupabaseDirectClient = createSupabaseDirectClient()\n) => {\n  return await pg.oneOrNone(\n    `select * from private_users where data->>'apiKey' = $1 limit 1`,\n    [apiKey],\n    convertPrivateUser\n  )\n}\n\nexport const getPrivateUsersNotSent = async (\n  preference: 'trending_markets' | 'profit_loss_updates',\n  limit: number,\n  pg: SupabaseDirectClient\n) => {\n  return await pg.map(\n    `select pu.data, u.name,\n       u.created_time,\n       coalesce(((u.data->'creatorTraders'->>'weekly')::bigint),0) as weekly_traders,\n       coalesce(((u.data->>'currentBettingStreak')::bigint),0) as current_betting_streak\n         from private_users pu\n         join users u on pu.id = u.id\n         where (pu.data->'notificationPreferences'->>'${preference}')::jsonb @> '[\"email\"]'\n         and ${\n           preference === 'trending_markets'\n             ? 'weekly_trending_email_sent'\n             : 'weekly_portfolio_email_sent'\n         } = false\n         and (pu.data->'notificationPreferences'->>'opt_out_all')::jsonb <> '[\"email\"]'\n         and pu.data->>'email' is not null\n         limit $1`,\n    [limit],\n    (row) => ({\n      ...(row.data as PrivateUser),\n      createdTime: tsToMillis(row.created_time as string),\n      name: row.name as string,\n      weeklyTraders: row.weekly_traders as number,\n      currentBettingStreak: row.current_betting_streak as number,\n    })\n  )\n}\n\nexport const getUserByUsername = async (\n  username: string,\n  pg: SupabaseDirectClient = createSupabaseDirectClient()\n) => {\n  const res = await pg.oneOrNone<Row<'users'>>(\n    `select * from users where username = $1`,\n    username\n  )\n  return res ? convertUser(res) : null\n}\n\nexport function contractUrl(contract: Contract) {\n  return `https://manifold.markets${contractPath(contract)}`\n}\n\nexport async function getTrendingContractsToEmail() {\n  const pg = createSupabaseDirectClient()\n  return await pg.map(\n    `select data from contracts\n            where resolution_time is null\n              and visibility = 'public'\n              and not (group_slugs && $1)\n              and question not ilike '%stock%'\n              and question not ilike '%permanent%'\n              and ((close_time > current_date + interval '1 day') or close_time is null)\n              order by importance_score desc limit 25;`,\n    [GROUP_SLUGS_TO_IGNORE_IN_MARKETS_EMAIL],\n    (r) => r.data as Contract\n  )\n}\n\nexport const getBettingStreakResetTimeBeforeNow = () => {\n  // Get current time in Pacific\n  const now = dayjs().tz('America/Los_Angeles')\n\n  // Get today's reset time (midnight Pacific)\n  const todayResetTime = now.startOf('day')\n\n  // Get yesterday's reset time\n  const yesterdayResetTime = todayResetTime.subtract(1, 'day')\n\n  // Use yesterday's reset time if we haven't hit today's yet\n  const resetTime = (\n    now.isBefore(todayResetTime) ? yesterdayResetTime : todayResetTime\n  ).valueOf()\n  log('betting streak reset time', resetTime)\n  return resetTime\n}\n",
          "postContent": "import { generateJSON } from '@tiptap/html'\nimport { APIError, getCloudRunServiceUrl } from 'common/api/utils'\nimport {\n  Contract,\n  contractPath,\n  nativeContractColumnsArray,\n  MarketContract,\n} from 'common/contract'\nimport { PrivateUser } from 'common/user'\nimport { extensions } from 'common/util/parse'\nimport * as admin from 'firebase-admin'\nimport { first, uniq } from 'lodash'\nimport {\n  createSupabaseDirectClient,\n  SupabaseDirectClient,\n  SupabaseTransaction,\n} from 'shared/supabase/init'\nimport {\n  ENV_CONFIG,\n  GROUP_SLUGS_TO_IGNORE_IN_MARKETS_EMAIL,\n} from 'common/envs/constants'\nimport { convertPrivateUser, convertUser } from 'common/supabase/users'\nimport { convertAnswer, convertContract } from 'common/supabase/contracts'\nimport { Row, tsToMillis } from 'common/supabase/utils'\nimport { log } from 'shared/monitoring/log'\nimport { metrics } from 'shared/monitoring/metrics'\nimport { convertLiquidity } from 'common/supabase/liquidity'\nimport { ContractMetric } from 'common/contract-metric'\nexport { metrics }\nexport { log }\nimport * as dayjs from 'dayjs'\nimport * as utc from 'dayjs/plugin/utc'\nimport * as timezone from 'dayjs/plugin/timezone'\ndayjs.extend(utc)\ndayjs.extend(timezone)\n\nexport const logMemory = () => {\n  const used = process.memoryUsage()\n  for (const [k, v] of Object.entries(used)) {\n    log(`${k} ${Math.round((v / 1024 / 1024) * 100) / 100} MB`)\n  }\n}\n\nexport function htmlToRichText(html: string) {\n  return generateJSON(html, extensions)\n}\n\nexport const invokeFunction = async (name: string, body?: unknown) => {\n  const response = await fetch(getCloudRunServiceUrl(name), {\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    method: 'POST',\n    body: JSON.stringify(body ?? {}),\n  })\n\n  const json = await response.json()\n  if (response.ok) {\n    return json\n  } else {\n    throw new Error(\n      `${response.status} invoking ${name}: ${JSON.stringify(json)}`\n    )\n  }\n}\n\nexport const revalidateStaticProps = async (\n  // Path after domain: e.g. \"/JamesGrugett/will-pete-buttigieg-ever-be-us-pres\"\n  pathToRevalidate: string\n) => {\n  if (isProd()) {\n    const apiSecret = process.env.API_SECRET as string\n    if (!apiSecret)\n      throw new Error('Revalidation failed because of missing API_SECRET.')\n\n    const queryStr = `?pathToRevalidate=${pathToRevalidate}&apiSecret=${apiSecret}`\n    const resp = await fetch(\n      `https://${ENV_CONFIG.domain}/api/v0/revalidate` + queryStr\n    )\n\n    if (resp.ok) {\n      // metrics.inc('vercel/revalidations_succeeded', { path: pathToRevalidate })\n      log('Revalidated', pathToRevalidate)\n    } else {\n      // metrics.inc('vercel/revalidations_failed', { path: pathToRevalidate })\n      try {\n        const json = await resp.json()\n        log.error(\n          `HTTP ${\n            resp.status\n          } revalidating ${pathToRevalidate}: ${JSON.stringify(json)}`\n        )\n      } catch (e) {\n        const error = e as Error\n        log.error(`failed to parse response: ${error.message ?? error}`)\n        log.error(`HTTP ${resp.status} revalidating ${pathToRevalidate}`)\n      }\n    }\n  }\n}\n\nexport async function revalidateContractStaticProps(contract: Contract) {\n  await Promise.all([\n    revalidateStaticProps(contractPath(contract)),\n    revalidateStaticProps(`/embed${contractPath(contract)}`),\n  ])\n}\nexport const LOCAL_DEV = process.env.GOOGLE_CLOUD_PROJECT == null\n\n// TODO: deprecate in favor of common/src/envs/is-prod.ts\nexport const isProd = () => {\n  // ian: The first clause is for the API server, and the\n  // second clause is for local scripts and cloud functions\n  if (process.env.NEXT_PUBLIC_FIREBASE_ENV) {\n    return process.env.NEXT_PUBLIC_FIREBASE_ENV === 'PROD'\n  } else {\n    return admin.app().options.projectId === 'mantic-markets'\n  }\n}\n\nexport const contractColumnsToSelect = nativeContractColumnsArray.join(',')\nexport const prefixedContractColumnsToSelect = nativeContractColumnsArray\n  .map((col) => `c.${col}`)\n  .join(',')\nexport const contractColumnsToSelectWithPrefix = (prefix: string) =>\n  nativeContractColumnsArray.map((col) => `${prefix}.${col}`).join(',')\n\nexport const getContract = async (\n  pg: SupabaseDirectClient,\n  contractId: string\n) => {\n  const res = await pg.multi(\n    `select ${contractColumnsToSelect} from contracts where id = $1 limit 1;\n     select * from answers where contract_id = $1 order by index;`,\n    [contractId]\n  )\n  const contract = first(res[0].map(convertContract))\n  const answers = res[1].map(convertAnswer)\n  if (contract && 'answers' in contract) {\n    contract.answers = answers\n  }\n  return contract\n}\n\nexport const getContractAndMetricsAndLiquidities = async (\n  pg: SupabaseTransaction,\n  unresolvedContract: MarketContract,\n  answerId: string | undefined\n) => {\n  const { id: contractId, mechanism } = unresolvedContract\n  const isMulti = mechanism === 'cpmm-multi-1'\n  const sumsToOne = isMulti && unresolvedContract.shouldAnswersSumToOne\n  const metricsQuery = sumsToOne\n    ? `\n     select data from user_contract_metrics\n     where contract_id = $1 and\n     answer_id is not null`\n    : isMulti\n    ? `\n    select data from user_contract_metrics\n      where contract_id = $1\n      and (answer_id = $2 or (\n            -- Only get summary metric if they've bet on the answer\n            answer_id is null and\n            exists (\n              select 1 from user_contract_metrics ucm\n              where ucm.contract_id = $1\n              and ucm.answer_id = $2\n              )\n            )\n          )`\n    : `select data from user_contract_metrics where contract_id = $1`\n\n  const results = await pg.multi(\n    `select ${contractColumnsToSelect} from contracts where id = $1;\n     select * from answers where contract_id = $1 order by index;\n     ${metricsQuery};\n     select * from contract_liquidity where contract_id = $1`,\n    [contractId, answerId]\n  )\n\n  const contract = first(results[0].map(convertContract)) as MarketContract\n  if (!contract) throw new APIError(404, 'Contract not found')\n  const answers = results[1].map(convertAnswer)\n  if ('answers' in contract) {\n    contract.answers = answers\n  }\n  // We don't get the summary metric, we recreate them from all the answer metrics\n  const contractMetrics = results[2].map((row) => row.data as ContractMetric)\n  const liquidities = results[3].map(convertLiquidity)\n\n  return { contract, contractMetrics, liquidities }\n}\n\nexport const getContractSupabase = async (contractId: string) => {\n  const pg = createSupabaseDirectClient()\n  return await getContract(pg, contractId)\n}\n\nexport const getContractFromSlugSupabase = async (contractSlug: string) => {\n  const pg = createSupabaseDirectClient()\n  const res = await pg.map(\n    `select ${contractColumnsToSelect} from contracts where slug = $1\n            limit 1`,\n    [contractSlug],\n    (row) => convertContract(row)\n  )\n  return first(res)\n}\n\nexport const getUser = async (\n  userId: string,\n  pg: SupabaseDirectClient = createSupabaseDirectClient()\n) => {\n  return await pg.oneOrNone(\n    `select * from users where id = $1 limit 1`,\n    [userId],\n    convertUser\n  )\n}\nexport const getUserAndPrivateUserOrThrow = async (\n  userId: string,\n  pg: SupabaseDirectClient = createSupabaseDirectClient()\n) => {\n  const rows = await pg.multi(\n    `select * from users where id = $1 limit 1;\n           select * from private_users where id = $1 limit 1;`,\n    [userId]\n  )\n  const userRow = rows[0][0] as Row<'users'> | null\n  const privateUserRow = rows[1][0] as Row<'private_users'> | null\n\n  if (!userRow || !privateUserRow) {\n    throw new APIError(404, 'User or private user not found.')\n  }\n\n  return {\n    user: convertUser(userRow),\n    privateUser: convertPrivateUser(privateUserRow),\n  }\n}\n\nexport const getUsers = async (\n  userIds: string[],\n  pg: SupabaseDirectClient = createSupabaseDirectClient()\n) => {\n  const res = await pg.map(\n    `select * from users where id = any($1)`,\n    [uniq(userIds)],\n    (row) => convertUser(row)\n  )\n  return res\n}\n\nexport const getPrivateUser = async (\n  userId: string,\n  pg: SupabaseDirectClient = createSupabaseDirectClient()\n) => {\n  return await pg.oneOrNone(\n    `select * from private_users where id = $1 limit 1`,\n    [userId],\n    convertPrivateUser\n  )\n}\nexport const getPrivateUserSupabase = (userId: string) => {\n  const pg = createSupabaseDirectClient()\n\n  return pg.oneOrNone(\n    `select data from private_users where id = $1`,\n    [userId],\n    (row) => (row ? (row.data as PrivateUser) : null)\n  )\n}\n\nexport const getPrivateUserByKey = async (\n  apiKey: string,\n  pg: SupabaseDirectClient = createSupabaseDirectClient()\n) => {\n  return await pg.oneOrNone(\n    `select * from private_users where data->>'apiKey' = $1 limit 1`,\n    [apiKey],\n    convertPrivateUser\n  )\n}\n\nexport const getPrivateUsersNotSent = async (\n  preference: 'trending_markets' | 'profit_loss_updates',\n  limit: number,\n  pg: SupabaseDirectClient\n) => {\n  return await pg.map(\n    `select pu.data, u.name,\n       u.created_time,\n       coalesce(((u.data->'creatorTraders'->>'weekly')::bigint),0) as weekly_traders,\n       coalesce(((u.data->>'currentBettingStreak')::bigint),0) as current_betting_streak\n         from private_users pu\n         join users u on pu.id = u.id\n         where (pu.data->'notificationPreferences'->>'${preference}')::jsonb @> '[\"email\"]'\n         and ${\n           preference === 'trending_markets'\n             ? 'weekly_trending_email_sent'\n             : 'weekly_portfolio_email_sent'\n         } = false\n         and (pu.data->'notificationPreferences'->>'opt_out_all')::jsonb <> '[\"email\"]'\n         and pu.data->>'email' is not null\n         limit $1`,\n    [limit],\n    (row) => ({\n      ...(row.data as PrivateUser),\n      createdTime: tsToMillis(row.created_time as string),\n      name: row.name as string,\n      weeklyTraders: row.weekly_traders as number,\n      currentBettingStreak: row.current_betting_streak as number,\n    })\n  )\n}\n\nexport const getUserByUsername = async (\n  username: string,\n  pg: SupabaseDirectClient = createSupabaseDirectClient()\n) => {\n  const res = await pg.oneOrNone<Row<'users'>>(\n    `select * from users where username = $1`,\n    username\n  )\n  return res ? convertUser(res) : null\n}\n\nexport function contractUrl(contract: Contract) {\n  return `https://manifold.markets${contractPath(contract)}`\n}\n\nexport async function getTrendingContractsToEmail() {\n  const pg = createSupabaseDirectClient()\n  return await pg.map(\n    `select data from contracts\n            where resolution_time is null\n              and visibility = 'public'\n              and not (group_slugs && $1)\n              and question not ilike '%stock%'\n              and question not ilike '%permanent%'\n              and ((close_time > current_date + interval '1 day') or close_time is null)\n              order by importance_score desc limit 25;`,\n    [GROUP_SLUGS_TO_IGNORE_IN_MARKETS_EMAIL],\n    (r) => r.data as Contract\n  )\n}\n\nexport const getBettingStreakResetTimeBeforeNow = () => {\n  // Get current time in Pacific\n  const now = dayjs().tz('America/Los_Angeles')\n\n  // Get today's reset time (midnight Pacific)\n  const todayResetTime = now.startOf('day')\n\n  // Get yesterday's reset time\n  const yesterdayResetTime = todayResetTime.subtract(1, 'day')\n\n  // Use yesterday's reset time if we haven't hit today's yet\n  const resetTime = (\n    now.isBefore(todayResetTime) ? yesterdayResetTime : todayResetTime\n  ).valueOf()\n  log('betting streak reset time', resetTime)\n  return resetTime\n}\n"
        }
      ]
    },
    {
      "sha": "eebf7d4af349d077aa96752258fc7a6a982ae836",
      "author": "Ian Philips",
      "date": "2025-05-19 17:53:00 -0700",
      "message": "Replace news with 'followed' topic",
      "stats": {
        "filesChanged": 5,
        "insertions": 198,
        "deletions": 66
      },
      "selectionReason": "Replaces news with 'followed' topic - major feature change that restructures content organization and user experience",
      "spec": "Introduce a \"Followed\" topics filter to the market search functionality. Modify the market search API by updating the `topicSlug` parameter to accept 'followed' as a new value; when 'followed' is used, the backend should filter market search results to include only those markets belonging to topics (groups) that the currently authenticated user follows. If the user follows no topics, an empty set of markets should be returned. Implement a new backend utility function to count the number of topics a given user follows. In the search user interface, add a \"Followed\" filter option to the primary topic navigation bar (e.g., alongside \"All\", \"Sports\"). This \"Followed\" option should only be visible to logged-in users. Activating this filter should set the `topicSlug` search parameter to 'followed' and clear any other active broad topic category filters. The display label for the existing filter option internally identified by the value 'news' should be changed from \"News\" to \"Recently changed\". When the \"Followed\" filter is active, the UI should display two distinct, filterable lists of topics: a section titled \"Your Followed Topics\" showing topics the user currently follows, and, if the user follows a small number of topics (e.g., fewer than five), an additional section titled \"Explore Topics To Follow\" showing suggested or trending topics that the user does not currently follow. Both these topic lists and the main market search results should refresh if the user's set of followed topics changes or when the \"Followed\" filter view becomes active. If the \"Followed\" filter is active and a search term has been entered, general search result categories like \"Topics\" (for all topics) and \"Users\" should be hidden. Finally, update the UI component used for displaying lists of topic pills to allow control over the initial number of pills shown (via an `initialShown` property) and to support a more condensed view on mobile devices (e.g., showing fewer pills initially via a `clipOnMobile` property).",
      "fileStates": [
        {
          "path": "backend/api/src/search-contracts.ts",
          "preContent": "import { z } from 'zod'\nimport {\n  createSupabaseDirectClient,\n  SupabaseDirectClient,\n} from 'shared/supabase/init'\nimport { type APIHandler } from './helpers/endpoint'\nimport {\n  getSearchContractSQL,\n  getForYouSQL,\n  sortFields,\n  basicSearchSQL,\n  SearchTypes,\n} from 'shared/supabase/search-contracts'\nimport { getGroupIdFromSlug } from 'shared/supabase/groups'\nimport { orderBy, uniqBy } from 'lodash'\nimport { convertContract } from 'common/supabase/contracts'\nimport { log } from 'shared/utils'\nimport { toLiteMarket } from 'common/api/market-types'\nimport { searchProps } from 'common/api/market-search-types'\n\nexport const searchMarketsLite: APIHandler<'search-markets'> = async (\n  props,\n  auth\n) => {\n  const contracts = await search(props, auth?.uid)\n  return contracts.map(toLiteMarket)\n}\n\nexport const searchMarketsFull: APIHandler<'search-markets-full'> = async (\n  props,\n  auth\n) => {\n  return await search(props, auth?.uid)\n}\n\nconst search = async (\n  props: z.infer<typeof searchProps>,\n  userId: string | undefined\n) => {\n  const {\n    term = '',\n    filter,\n    sort,\n    offset,\n    limit,\n    topicSlug: possibleTopicSlug,\n    forYou,\n    token,\n    gids: groupIds,\n  } = props\n  const isPrizeMarket =\n    props.isPrizeMarket == 'true' || props.isPrizeMarket == '1'\n\n  if (limit === 0) {\n    return []\n  }\n\n  const isForYou = forYou === '1'\n  const isRecent = possibleTopicSlug === 'recent'\n  const topicSlug =\n    possibleTopicSlug && !isRecent ? possibleTopicSlug : undefined\n  const pg = createSupabaseDirectClient()\n  const groupId = topicSlug\n    ? await getGroupIdFromSlug(topicSlug, pg)\n    : undefined\n  const groupIdsForSearchSql = await getAllSubTopicsForParentTopicIds(\n    pg,\n    groupIds\n  )\n  if (\n    filter !== 'news' &&\n    !term &&\n    !topicSlug &&\n    !groupIds &&\n    (sort === 'score' || sort === 'freshness-score') &&\n    (token === 'MANA' || token === 'ALL') &&\n    !isRecent\n  ) {\n    if (!isForYou || !userId) {\n      return await pg.map(\n        basicSearchSQL({\n          ...props,\n          uid: userId,\n          isPrizeMarket,\n        }),\n        null,\n        convertContract\n      )\n    } else {\n      const forYouSql = await getForYouSQL({\n        ...props,\n        uid: userId,\n        sort,\n        isPrizeMarket,\n      })\n      return await pg.map(forYouSql, [term], (r) => convertContract(r))\n    }\n  } else if (isRecent && !term && userId) {\n    return await pg.map(\n      'select data from get_your_recent_contracts($1, $2, $3)',\n      [userId, limit, offset],\n      convertContract\n    )\n  } else {\n    const cleanTerm = term.replace(/[''\"]/g, '')\n    const searchTypes: SearchTypes[] = [\n      'prefix',\n      'without-stopwords',\n      'answer',\n      'with-stopwords',\n      'description',\n    ]\n\n    const multiQuery = searchTypes\n      .map((searchType) =>\n        getSearchContractSQL({\n          ...props,\n          term: cleanTerm,\n          uid: userId,\n          searchType,\n          groupId,\n          isPrizeMarket,\n          groupIds: groupIdsForSearchSql,\n        })\n      )\n      .join(';')\n\n    const results = await pg.multi(multiQuery).catch((e) => {\n      // to_tsquery is sensitive to special characters and can throw an error\n      log.error(`Error executing search query for term: ${term}`, e)\n      return Array(searchTypes.length).fill([])\n    })\n\n    const [\n      contractPrefixMatches,\n      contractsWithoutStopwords,\n      contractsWithMatchingAnswers,\n      contractsWithStopwords,\n      contractDescriptionMatches,\n    ] = results.map((result, i) =>\n      result.map((r: any) => ({\n        data: convertContract(r),\n        searchType: searchTypes[i],\n      }))\n    )\n\n    const contractsOfSimilarRelevance = orderBy(\n      [\n        ...contractsWithoutStopwords,\n        ...contractsWithMatchingAnswers,\n        ...contractPrefixMatches,\n      ],\n      (c) =>\n        sortFields[sort].sortCallback(c.data) *\n        (c.searchType === 'answer' ? 0.5 : 1),\n      sortFields[sort].order.includes('DESC') ? 'desc' : 'asc'\n    )\n\n    return uniqBy(\n      [\n        ...contractsWithStopwords,\n        ...contractsOfSimilarRelevance,\n        ...contractDescriptionMatches,\n      ].map((c) => c.data),\n      'id'\n    ).slice(0, limit)\n  }\n}\n\nconst getAllSubTopicsForParentTopicIds = async (\n  pg: SupabaseDirectClient,\n  groupIds: string | undefined\n) => {\n  const initialTopIds = groupIds\n    ? groupIds.split(',').filter((id) => id && id.length > 0)\n    : []\n\n  if (initialTopIds.length > 0) {\n    const bottomGroupIds = await pg.map(\n      `SELECT DISTINCT bottom_id FROM group_groups\n                WHERE top_id in ($1:list) and bottom_id not in ($1:list)`,\n      [initialTopIds],\n      (r) => r.bottom_id\n    )\n    if (bottomGroupIds.length > 0) {\n      return [...initialTopIds, ...bottomGroupIds]\n    }\n  }\n  return initialTopIds\n}\n",
          "postContent": "import { z } from 'zod'\nimport {\n  createSupabaseDirectClient,\n  SupabaseDirectClient,\n} from 'shared/supabase/init'\nimport { type APIHandler } from './helpers/endpoint'\nimport {\n  getSearchContractSQL,\n  getForYouSQL,\n  sortFields,\n  basicSearchSQL,\n  SearchTypes,\n} from 'shared/supabase/search-contracts'\nimport { getGroupIdFromSlug } from 'shared/supabase/groups'\nimport { orderBy, uniqBy } from 'lodash'\nimport { convertContract } from 'common/supabase/contracts'\nimport { log } from 'shared/utils'\nimport { toLiteMarket } from 'common/api/market-types'\nimport { searchProps } from 'common/api/market-search-types'\n\nexport const searchMarketsLite: APIHandler<'search-markets'> = async (\n  props,\n  auth\n) => {\n  const contracts = await search(props, auth?.uid)\n  return contracts.map(toLiteMarket)\n}\n\nexport const searchMarketsFull: APIHandler<'search-markets-full'> = async (\n  props,\n  auth\n) => {\n  return await search(props, auth?.uid)\n}\n\nconst search = async (\n  props: z.infer<typeof searchProps>,\n  userId: string | undefined\n) => {\n  const {\n    term = '',\n    filter,\n    sort,\n    offset,\n    limit,\n    topicSlug: possibleTopicSlug,\n    forYou,\n    token,\n    gids,\n  } = props\n  const isPrizeMarket =\n    props.isPrizeMarket == 'true' || props.isPrizeMarket == '1'\n\n  if (limit === 0) {\n    return []\n  }\n\n  const isForYou = forYou === '1'\n  const isRecent = possibleTopicSlug === 'recent'\n  const isFollowed = possibleTopicSlug === 'followed'\n  const topicSlugForGroupIdLookup =\n    possibleTopicSlug && !isRecent && !isFollowed\n      ? possibleTopicSlug\n      : undefined\n  const pg = createSupabaseDirectClient()\n  const groupId = topicSlugForGroupIdLookup\n    ? await getGroupIdFromSlug(topicSlugForGroupIdLookup, pg)\n    : undefined\n  const groupIds =\n    isFollowed && !!userId\n      ? await pg.map(\n          'select group_id from group_members where member_id = $1',\n          [userId],\n          (r) => r.group_id\n        )\n      : await getAllSubTopicsForParentTopicIds(pg, gids)\n  if (isFollowed && userId && groupIds.length === 0) {\n    return []\n  }\n  if (\n    filter !== 'news' &&\n    !term &&\n    !topicSlugForGroupIdLookup &&\n    !groupIds &&\n    (sort === 'score' || sort === 'freshness-score') &&\n    (token === 'MANA' || token === 'ALL') &&\n    !isRecent\n  ) {\n    if (!isForYou || !userId) {\n      return await pg.map(\n        basicSearchSQL({\n          ...props,\n          uid: userId,\n          isPrizeMarket,\n        }),\n        null,\n        convertContract\n      )\n    } else {\n      const forYouSql = await getForYouSQL({\n        ...props,\n        uid: userId,\n        sort,\n        isPrizeMarket,\n      })\n      return await pg.map(forYouSql, [term], (r) => convertContract(r))\n    }\n  } else if (isRecent && !term && userId) {\n    return await pg.map(\n      'select data from get_your_recent_contracts($1, $2, $3)',\n      [userId, limit, offset],\n      convertContract\n    )\n  } else {\n    const cleanTerm = term.replace(/[''\"]/g, '')\n    const searchTypes: SearchTypes[] = [\n      'prefix',\n      'without-stopwords',\n      'answer',\n      'with-stopwords',\n      'description',\n    ]\n\n    const multiQuery = searchTypes\n      .map((searchType) =>\n        getSearchContractSQL({\n          ...props,\n          term: cleanTerm,\n          uid: userId,\n          searchType,\n          groupId,\n          isPrizeMarket,\n          groupIds,\n        })\n      )\n      .join(';')\n\n    const results = await pg.multi(multiQuery).catch((e) => {\n      // to_tsquery is sensitive to special characters and can throw an error\n      log.error(`Error executing search query for term: ${term}`, e)\n      return Array(searchTypes.length).fill([])\n    })\n\n    const [\n      contractPrefixMatches,\n      contractsWithoutStopwords,\n      contractsWithMatchingAnswers,\n      contractsWithStopwords,\n      contractDescriptionMatches,\n    ] = results.map((result, i) =>\n      result.map((r: any) => ({\n        data: convertContract(r),\n        searchType: searchTypes[i],\n      }))\n    )\n\n    const contractsOfSimilarRelevance = orderBy(\n      [\n        ...contractsWithoutStopwords,\n        ...contractsWithMatchingAnswers,\n        ...contractPrefixMatches,\n      ],\n      (c) =>\n        sortFields[sort].sortCallback(c.data) *\n        (c.searchType === 'answer' ? 0.5 : 1),\n      sortFields[sort].order.includes('DESC') ? 'desc' : 'asc'\n    )\n\n    return uniqBy(\n      [\n        ...contractsWithStopwords,\n        ...contractsOfSimilarRelevance,\n        ...contractDescriptionMatches,\n      ].map((c) => c.data),\n      'id'\n    ).slice(0, limit)\n  }\n}\n\nconst getAllSubTopicsForParentTopicIds = async (\n  pg: SupabaseDirectClient,\n  groupIds: string | undefined\n) => {\n  const initialTopIds = groupIds\n    ? groupIds.split(',').filter((id) => id && id.length > 0)\n    : []\n\n  if (initialTopIds.length > 0) {\n    const bottomGroupIds = await pg.map(\n      `SELECT DISTINCT bottom_id FROM group_groups\n                WHERE top_id in ($1:list) and bottom_id not in ($1:list)`,\n      [initialTopIds],\n      (r) => r.bottom_id\n    )\n    if (bottomGroupIds.length > 0) {\n      return [...initialTopIds, ...bottomGroupIds]\n    }\n  }\n  return initialTopIds\n}\n"
        },
        {
          "path": "common/src/api/market-search-types.ts",
          "preContent": "import { z } from 'zod'\n\nexport const FIRESTORE_DOC_REF_ID_REGEX = /^[a-zA-Z0-9_-]{1,}$/\n\nexport const searchProps = z\n  .object({\n    term: z.string().optional(),\n    filter: z\n      .union([\n        z.literal('open'),\n        z.literal('closing-90-days'),\n        z.literal('closing-week'),\n        z.literal('closing-month'),\n        z.literal('closing-day'),\n        z.literal('closed'),\n        z.literal('resolved'),\n        z.literal('all'),\n        z.literal('news'),\n      ])\n      .default('all'),\n    sort: z\n      .union([\n        z.literal('newest'),\n        z.literal('score'),\n        z.literal('daily-score'),\n        z.literal('freshness-score'),\n        z.literal('24-hour-vol'),\n        z.literal('most-popular'),\n        z.literal('liquidity'),\n        z.literal('subsidy'),\n        z.literal('last-updated'),\n        z.literal('close-date'),\n        z.literal('start-time'),\n        z.literal('resolve-date'),\n        z.literal('random'),\n        z.literal('bounty-amount'),\n        z.literal('prob-descending'),\n        z.literal('prob-ascending'),\n      ])\n      .default('most-popular'),\n    contractType: z\n      .union([\n        z.literal('ALL'),\n        z.literal('BINARY'),\n        z.literal('MULTIPLE_CHOICE'),\n        z.literal('FREE_RESPONSE'),\n        z.literal('PSEUDO_NUMERIC'),\n        z.literal('BOUNTIED_QUESTION'),\n        z.literal('STONK'),\n        z.literal('POLL'),\n        z.literal('NUMBER'),\n        z.literal('MULTI_NUMERIC'),\n        z.literal('DATE'),\n      ])\n      .default('ALL'),\n    offset: z.coerce.number().gte(0).default(0),\n    limit: z.coerce.number().gt(0).lte(1000).default(100),\n    topicSlug: z.string().regex(FIRESTORE_DOC_REF_ID_REGEX).optional(),\n    forYou: z.union([z.literal('1'), z.literal('0')]).default('0'),\n    creatorId: z.string().regex(FIRESTORE_DOC_REF_ID_REGEX).optional(),\n    isPrizeMarket: z\n      .union([\n        z.literal('true'),\n        z.literal('false'),\n        z.literal('1'),\n        z.literal('0'),\n      ])\n      .default('0'),\n    token: z\n      .union([\n        z.literal('MANA'),\n        z.literal('CASH'),\n        z.literal('ALL'),\n        z.literal('CASH_AND_MANA'),\n      ])\n      .default('ALL'),\n    gids: z.string().optional(),\n    liquidity: z.coerce.number().optional(),\n    hasBets: z.union([z.literal('1'), z.literal('0')]).optional(),\n  })\n  .strict()\n",
          "postContent": "import { z } from 'zod'\n\nexport const FIRESTORE_DOC_REF_ID_REGEX = /^[a-zA-Z0-9_-]{1,}$/\n\nexport const searchProps = z\n  .object({\n    term: z.string().optional(),\n    filter: z\n      .union([\n        z.literal('open'),\n        z.literal('closing-90-days'),\n        z.literal('closing-week'),\n        z.literal('closing-month'),\n        z.literal('closing-day'),\n        z.literal('closed'),\n        z.literal('resolved'),\n        z.literal('all'),\n        z.literal('news'),\n      ])\n      .default('all'),\n    sort: z\n      .union([\n        z.literal('newest'),\n        z.literal('score'),\n        z.literal('daily-score'),\n        z.literal('freshness-score'),\n        z.literal('24-hour-vol'),\n        z.literal('most-popular'),\n        z.literal('liquidity'),\n        z.literal('subsidy'),\n        z.literal('last-updated'),\n        z.literal('close-date'),\n        z.literal('start-time'),\n        z.literal('resolve-date'),\n        z.literal('random'),\n        z.literal('bounty-amount'),\n        z.literal('prob-descending'),\n        z.literal('prob-ascending'),\n      ])\n      .default('most-popular'),\n    contractType: z\n      .union([\n        z.literal('ALL'),\n        z.literal('BINARY'),\n        z.literal('MULTIPLE_CHOICE'),\n        z.literal('FREE_RESPONSE'),\n        z.literal('PSEUDO_NUMERIC'),\n        z.literal('BOUNTIED_QUESTION'),\n        z.literal('STONK'),\n        z.literal('POLL'),\n        z.literal('NUMBER'),\n        z.literal('MULTI_NUMERIC'),\n        z.literal('DATE'),\n      ])\n      .default('ALL'),\n    offset: z.coerce.number().gte(0).default(0),\n    limit: z.coerce.number().gt(0).lte(1000).default(100),\n    topicSlug: z\n      .string()\n      .regex(FIRESTORE_DOC_REF_ID_REGEX)\n      .or(z.literal('recent'))\n      .or(z.literal('followed'))\n      .optional(),\n    forYou: z.union([z.literal('1'), z.literal('0')]).default('0'),\n    creatorId: z.string().regex(FIRESTORE_DOC_REF_ID_REGEX).optional(),\n    isPrizeMarket: z\n      .union([\n        z.literal('true'),\n        z.literal('false'),\n        z.literal('1'),\n        z.literal('0'),\n      ])\n      .default('0'),\n    token: z\n      .union([\n        z.literal('MANA'),\n        z.literal('CASH'),\n        z.literal('ALL'),\n        z.literal('CASH_AND_MANA'),\n      ])\n      .default('ALL'),\n    gids: z.string().optional(),\n    liquidity: z.coerce.number().optional(),\n    hasBets: z.union([z.literal('1'), z.literal('0')]).optional(),\n  })\n  .strict()\n"
        },
        {
          "path": "common/src/supabase/groups.ts",
          "preContent": "import {\n  Row,\n  SupabaseClient,\n  run,\n  tsToMillis,\n} from 'common/supabase/utils'\nimport { Group, Topic } from 'common/group'\n\nexport const UNRANKED_GROUP_ID = 'f141b8ca-eac3-4400-962a-72973b3ceb62'\nexport const UNSUBSIDIZED_GROUP_ID = 'f08f4130-3410-4030-9bf5-f675e5035e9c'\nexport const PROD_MANIFOLD_LOVE_GROUP_ID =\n  '2e9a87df-94e3-458c-bc5f-81e891b13101'\n\nexport const TOPIC_IDS_YOU_CANT_FOLLOW = [\n  UNRANKED_GROUP_ID,\n  UNSUBSIDIZED_GROUP_ID,\n  PROD_MANIFOLD_LOVE_GROUP_ID,\n]\nexport async function getGroup(db: SupabaseClient, groupId: string) {\n  const { data } = await run(db.from('groups').select().eq('id', groupId))\n  if (data && data.length > 0) {\n    return convertGroup(data[0])\n  } else {\n    return null\n  }\n}\n\nexport async function userCanAccess(\n  db: SupabaseClient,\n  contractId: string,\n  userId: string | undefined | null\n) {\n  if (!userId) return false\n\n  const groupQuery = await run(\n    db.from('group_contracts').select('group_id').eq('contract_id', contractId)\n  )\n\n  if (!groupQuery.data || groupQuery.data.length !== 1) return false\n\n  const { data } = await run(\n    db\n      .from('group_members')\n      .select()\n      .eq('group_id', groupQuery.data[0].group_id)\n      .eq('member_id', userId)\n      .limit(1)\n  )\n  return data && data.length > 0\n}\n\nexport async function getGroupMemberIds(db: SupabaseClient, groupId: string) {\n  const { data } = await run(\n    db.from('group_members').select('member_id').eq('group_id', groupId)\n  )\n  return data ? data.map((member) => member.member_id) : []\n}\n\nexport const convertGroup = (row: Row<'groups'>): Group => ({\n  id: row.id,\n  slug: row.slug,\n  name: row.name,\n  about: row.about as any,\n  creatorId: row.creator_id!,\n  createdTime: tsToMillis(row.created_time),\n  totalMembers: row.total_members ?? 0,\n  bannerUrl: row.banner_url || undefined,\n  privacyStatus: row.privacy_status as any,\n  importanceScore: row.importance_score ?? 0,\n})\n\nexport async function getTopicsOnContract(\n  contractId: string,\n  db: SupabaseClient\n) {\n  const { data } = await run(\n    db\n      .from('group_contracts')\n      .select(\n        'groups (id, name, slug, importance_score, privacy_status, total_members)'\n      )\n      .eq('contract_id', contractId)\n      .order('importance_score', {\n        referencedTable: 'groups',\n        ascending: false,\n      })\n  )\n\n  return data\n    .filter((g) => g?.groups !== null)\n    .map((g) => convertGroup(g.groups as any) as Topic)\n}\n",
          "postContent": "import { Row, SupabaseClient, run, tsToMillis } from 'common/supabase/utils'\nimport { Group, Topic } from 'common/group'\n\nexport const UNRANKED_GROUP_ID = 'f141b8ca-eac3-4400-962a-72973b3ceb62'\nexport const UNSUBSIDIZED_GROUP_ID = 'f08f4130-3410-4030-9bf5-f675e5035e9c'\nexport const PROD_MANIFOLD_LOVE_GROUP_ID =\n  '2e9a87df-94e3-458c-bc5f-81e891b13101'\n\nexport const TOPIC_IDS_YOU_CANT_FOLLOW = [\n  UNRANKED_GROUP_ID,\n  UNSUBSIDIZED_GROUP_ID,\n  PROD_MANIFOLD_LOVE_GROUP_ID,\n]\nexport async function getGroup(db: SupabaseClient, groupId: string) {\n  const { data } = await run(db.from('groups').select().eq('id', groupId))\n  if (data && data.length > 0) {\n    return convertGroup(data[0])\n  } else {\n    return null\n  }\n}\n\nexport async function userCanAccess(\n  db: SupabaseClient,\n  contractId: string,\n  userId: string | undefined | null\n) {\n  if (!userId) return false\n\n  const groupQuery = await run(\n    db.from('group_contracts').select('group_id').eq('contract_id', contractId)\n  )\n\n  if (!groupQuery.data || groupQuery.data.length !== 1) return false\n\n  const { data } = await run(\n    db\n      .from('group_members')\n      .select()\n      .eq('group_id', groupQuery.data[0].group_id)\n      .eq('member_id', userId)\n      .limit(1)\n  )\n  return data && data.length > 0\n}\n\nexport async function getGroupMemberIds(db: SupabaseClient, groupId: string) {\n  const { data } = await run(\n    db.from('group_members').select('member_id').eq('group_id', groupId)\n  )\n  return data ? data.map((member) => member.member_id) : []\n}\nexport async function getFollowedGroupsCount(\n  db: SupabaseClient,\n  userId: string\n) {\n  const { count } = await run(\n    db\n      .from('group_members')\n      .select('group_id', { count: 'exact' })\n      .eq('member_id', userId)\n  )\n  return count\n}\n\nexport const convertGroup = (row: Row<'groups'>): Group => ({\n  id: row.id,\n  slug: row.slug,\n  name: row.name,\n  about: row.about as any,\n  creatorId: row.creator_id!,\n  createdTime: tsToMillis(row.created_time),\n  totalMembers: row.total_members ?? 0,\n  bannerUrl: row.banner_url || undefined,\n  privacyStatus: row.privacy_status as any,\n  importanceScore: row.importance_score ?? 0,\n})\n\nexport async function getTopicsOnContract(\n  contractId: string,\n  db: SupabaseClient\n) {\n  const { data } = await run(\n    db\n      .from('group_contracts')\n      .select(\n        'groups (id, name, slug, importance_score, privacy_status, total_members)'\n      )\n      .eq('contract_id', contractId)\n      .order('importance_score', {\n        referencedTable: 'groups',\n        ascending: false,\n      })\n  )\n\n  return data\n    .filter((g) => g?.groups !== null)\n    .map((g) => convertGroup(g.groups as any) as Topic)\n}\n"
        },
        {
          "path": "web/components/search.tsx",
          "preContent": "'use client'\nimport clsx from 'clsx'\nimport { Contract } from 'common/contract'\nimport { LiteGroup } from 'common/group'\nimport { capitalize, groupBy, minBy, orderBy, sample, uniqBy } from 'lodash'\nimport { ReactNode, useEffect, useRef, useState } from 'react'\nimport { AddContractToGroupButton } from 'web/components/topics/add-contract-to-group-modal'\nimport { useDebouncedEffect } from 'web/hooks/use-debounced-effect'\nimport { useEvent } from 'client-common/hooks/use-event'\nimport { usePersistentInMemoryState } from 'client-common/hooks/use-persistent-in-memory-state'\nimport { usePersistentQueriesState } from 'web/hooks/use-persistent-query-state'\nimport { track } from 'web/lib/service/analytics'\nimport { Col } from './layout/col'\nimport { Row } from './layout/row'\nimport { FullUser } from 'common/api/user-types'\nimport { CONTRACTS_PER_SEARCH_PAGE } from 'common/supabase/contracts'\nimport { buildArray } from 'common/util/array'\nimport { Button } from 'web/components/buttons/button'\nimport { usePersistentLocalState } from 'web/hooks/use-persistent-local-state'\nimport { api, searchGroups } from 'web/lib/api/api'\nimport { searchUsers } from 'web/lib/supabase/users'\n\nimport { LoadingContractRow } from './contract/contracts-table'\nimport { ContractFilters } from './search/contract-filters'\nimport { UserResults } from './search/user-results'\nimport { BrowseTopicPills } from './topics/browse-topic-pills'\nimport { LoadMoreUntilNotVisible } from 'web/components/widgets/visibility-observer'\nimport { BinaryDigit } from 'common/tier'\nimport { useIsMobile } from 'web/hooks/use-is-mobile'\nimport { Spacer } from './layout/spacer'\nimport { useSweepstakes } from './sweepstakes-provider'\nimport { ALL_PARENT_TOPICS, TOPICS_TO_SUBTOPICS } from 'common/topics'\nimport { Carousel } from './widgets/carousel'\nimport { isEqual } from 'lodash'\nimport { SearchInput } from './search/search-input'\nimport { removeEmojis } from 'common/util/string'\nimport { useIsPageVisible } from 'web/hooks/use-page-visible'\nimport { TopLevelPost } from 'common/top-level-post'\nimport { CombinedResults } from './contract/combined-results'\nimport { APIParams } from 'common/api/schema'\n\nconst USERS_PER_PAGE = 100\nconst TOPICS_PER_PAGE = 100\n\nexport const SORTS = [\n  { label: 'Best', value: 'score' },\n  { label: 'Hot', value: 'freshness-score' },\n  { label: 'Liquidity', value: 'liquidity' },\n  { label: 'Subsidy', value: 'subsidy' },\n  { label: 'New', value: 'newest' },\n  { label: 'Closing soon', value: 'close-date' },\n  { label: 'Daily change', value: 'daily-score' },\n  { label: '24h volume', value: '24-hour-vol' },\n  { label: 'Total traders', value: 'most-popular' },\n  { label: 'Last activity', value: 'last-updated' },\n  { label: 'Just resolved', value: 'resolve-date' },\n  { label: 'Bounty amount', value: 'bounty-amount' },\n  { label: 'High %', value: 'prob-descending' },\n  { label: 'Low %', value: 'prob-ascending' },\n  { label: '🎲 Random!', value: 'random' },\n] as const\n\nexport const predictionMarketSorts = new Set([\n  'daily-score',\n  '24-hour-vol',\n  'liquidity',\n  'subsidy',\n  'close-date',\n  'resolve-date',\n  'most-popular',\n  'prob-descending',\n  'prob-ascending',\n  'freshness-score',\n])\n\nexport const bountySorts = new Set(['bounty-amount'])\n\nconst probSorts = new Set(['prob-descending', 'prob-ascending'])\n\nexport const BOUNTY_MARKET_SORTS = SORTS.filter(\n  (item) => !predictionMarketSorts.has(item.value)\n)\n\nexport const POLL_SORTS = BOUNTY_MARKET_SORTS.filter(\n  (item) => !bountySorts.has(item.value)\n)\n\nexport const PREDICTION_MARKET_SORTS = SORTS.filter(\n  (item) => !bountySorts.has(item.value) && !probSorts.has(item.value)\n)\n\nexport const PREDICTION_MARKET_PROB_SORTS = SORTS.filter(\n  (item) => !bountySorts.has(item.value)\n)\n\nexport type Sort = (typeof SORTS)[number]['value']\n\nexport const FILTERS = [\n  { label: 'Any status', value: 'all' },\n  { label: 'Open', value: 'open' },\n  { label: 'Closing in 7 days', value: 'closing-week' },\n  { label: 'Closing in 30 days', value: 'closing-month' },\n  { label: 'Closing in 90 days', value: 'closing-90-days' },\n  { label: 'Closed', value: 'closed' },\n  { label: 'Resolved', value: 'resolved' },\n  { label: 'News', value: 'news' },\n] as const\n\nexport type Filter = (typeof FILTERS)[number]['value']\n\nexport const CONTRACT_TYPES = [\n  { label: 'Any type', value: 'ALL' },\n  { label: 'Yes/No', value: 'BINARY' },\n  { label: 'Multiple Choice', value: 'MULTIPLE_CHOICE' },\n  { label: 'Numeric', value: 'PSEUDO_NUMERIC' },\n  { label: 'Bounty', value: 'BOUNTIED_QUESTION' },\n  { label: 'Stock', value: 'STONK' },\n  { label: 'Poll', value: 'POLL' },\n  { label: 'Posts', value: 'POSTS' },\n] as const\n\nexport const DEFAULT_SORT = 'score'\nexport const DEFAULT_SORTS = ['freshness-score', 'newest']\nexport const DEFAULT_BOUNTY_SORTS = ['bounty-amount']\n\nexport const DEFAULT_FILTERS = []\nexport const DEFAULT_FILTER = 'all'\n\nexport const DEFAULT_CONTRACT_TYPE = 'ALL'\nexport const DEFAULT_CONTRACT_TYPES = []\n\nexport const DEFAULT_TIER = '00000'\n\nexport type ContractTypeType = (typeof CONTRACT_TYPES)[number]['value']\ntype SearchType = 'Users' | 'Questions' | undefined\n\nexport type SearchParams = {\n  [QUERY_KEY]: string\n  [SORT_KEY]: Sort\n  [FILTER_KEY]: Filter\n  [CONTRACT_TYPE_KEY]: ContractTypeType\n  [SEARCH_TYPE_KEY]: SearchType\n  [PRIZE_MARKET_KEY]: BinaryDigit\n  [FOR_YOU_KEY]: BinaryDigit\n  [TOPIC_FILTER_KEY]: string\n  [SWEEPIES_KEY]: '0' | '1' | '2'\n  [GROUP_IDS_KEY]: string\n  [LIQUIDITY_KEY]: string // empty string or stringified number\n  [HAS_BETS_KEY]: '0' | '1'\n}\n\nexport const QUERY_KEY = 'q'\nexport const SORT_KEY = 's'\nexport const FILTER_KEY = 'f'\nexport const CONTRACT_TYPE_KEY = 'ct'\nexport const SEARCH_TYPE_KEY = 't'\nexport const PRIZE_MARKET_KEY = 'p'\nexport const FOR_YOU_KEY = 'fy'\nexport const MARKET_TIER_KEY = 'mt'\nexport const TOPIC_FILTER_KEY = 'tf'\nexport const SWEEPIES_KEY = 'sw'\nexport const GROUP_IDS_KEY = 'gids'\nexport const LIQUIDITY_KEY = 'li'\nexport const HAS_BETS_KEY = 'hb'\n\nexport type SupabaseAdditionalFilter = {\n  creatorId?: string\n  excludeContractIds?: string[]\n  excludeGroupSlugs?: string[]\n  excludeUserIds?: string[]\n}\n\nexport type SearchState = {\n  contracts: Contract[] | undefined\n  users: FullUser[] | undefined\n  topics: LiteGroup[] | undefined\n  shouldLoadMore: boolean\n  posts: TopLevelPost[] | undefined\n}\n\ntype SearchProps = {\n  persistPrefix: string\n  defaultSort?: Sort\n  defaultFilter?: Filter\n  defaultContractType?: ContractTypeType\n  defaultSearchType?: SearchType\n  defaultForYou?: '1' | '0'\n  additionalFilter?: SupabaseAdditionalFilter\n  highlightContractIds?: string[]\n  onContractClick?: (contract: Contract) => void\n  hideActions?: boolean\n  hideSweepsToggle?: boolean\n  headerClassName?: string\n  isWholePage?: boolean\n  // used to determine if search params should be updated in the URL\n  useUrlParams?: boolean\n  autoFocus?: boolean\n  emptyState?: ReactNode\n  hideSearch?: boolean\n  hideContractFilters?: boolean\n  topicSlug?: string\n  contractsOnly?: boolean\n  hideSearchTypes?: boolean\n  hideAvatars?: boolean\n  initialTopics?: LiteGroup[]\n  showTopicsFilterPills?: boolean\n  refreshOnVisible?: boolean\n}\n\nexport function Search(props: SearchProps) {\n  const {\n    defaultSort,\n    defaultFilter,\n    defaultContractType,\n    defaultSearchType,\n    defaultForYou,\n    additionalFilter,\n    onContractClick,\n    hideActions,\n    hideSweepsToggle,\n    highlightContractIds,\n    headerClassName,\n    persistPrefix,\n    isWholePage,\n    useUrlParams,\n    autoFocus,\n    hideContractFilters,\n    topicSlug = '',\n    contractsOnly,\n    hideSearch,\n    hideSearchTypes,\n    hideAvatars,\n    showTopicsFilterPills,\n    refreshOnVisible,\n  } = props\n\n  const isMobile = useIsMobile()\n  const { prefersPlay, setPrefersPlay } = useSweepstakes()\n  const [searchParams, setSearchParams, isReady] = useSearchQueryState({\n    defaultSort,\n    defaultFilter,\n    defaultContractType,\n    defaultSearchType,\n    defaultForYou,\n    useUrlParams,\n    persistPrefix,\n    defaultSweepies: prefersPlay ? '0' : '1',\n  })\n\n  const query = searchParams[QUERY_KEY]\n  const searchType = searchParams[SEARCH_TYPE_KEY]\n  const filter = searchParams[FILTER_KEY]\n  const contractType = searchParams[CONTRACT_TYPE_KEY]\n  const prizeMarketState = searchParams[PRIZE_MARKET_KEY]\n  const sweepiesState = searchParams[SWEEPIES_KEY]\n  const groupIds = searchParams[GROUP_IDS_KEY]\n  const hasBets = searchParams[HAS_BETS_KEY] === '1'\n  useEffect(() => {\n    const isSweeps = sweepiesState === '1'\n    if (prefersPlay !== isSweeps) return\n    setSearchParams({\n      [SWEEPIES_KEY]: prefersPlay ? '0' : '1',\n    })\n  }, [prefersPlay, sweepiesState])\n\n  const showSearchTypes = !!query && !hideSearchTypes && !contractsOnly\n\n  const actuallySearchParams = searchParams\n  if (topicSlug) actuallySearchParams[TOPIC_FILTER_KEY] = topicSlug\n  if (hideSweepsToggle) actuallySearchParams[SWEEPIES_KEY] = '2'\n\n  const {\n    contracts,\n    users,\n    topics,\n    loading,\n    shouldLoadMore,\n    loadMoreContracts,\n    refreshContracts,\n    posts,\n  } = useSearchResults({\n    persistPrefix,\n    searchParams: actuallySearchParams,\n    includeUsersAndTopics: showSearchTypes,\n    isReady,\n    additionalFilter,\n  })\n  const visible = useIsPageVisible()\n  useEffect(() => {\n    if (visible && refreshOnVisible) {\n      refreshContracts()\n    }\n  }, [visible, refreshOnVisible])\n\n  const showTopics = topics && topics.length > 0 && query && query.length > 0\n  const showUsers = users && users.length > 0 && query && query.length > 0\n\n  const onChange = (changes: Partial<SearchParams>) => {\n    const updatedParams = { ...changes }\n\n    setSearchParams(updatedParams)\n    if (isWholePage) window.scrollTo(0, 0)\n  }\n\n  const setQuery = (query: string) => onChange({ [QUERY_KEY]: query })\n\n  const answersWithChanges = contracts?.flatMap((c) =>\n    c.mechanism === 'cpmm-multi-1'\n      ? orderBy(\n          c.answers.filter((a) => Math.abs(a.probChanges.day) > 0.02),\n          (a) => Math.abs(a.probChanges.day),\n          'desc'\n        ).slice(0, 2)\n      : []\n  )\n\n  const answersMatchingQuery = contracts?.flatMap((c) =>\n    c.mechanism === 'cpmm-multi-1'\n      ? c.answers\n          .filter((a) => a.text.toLowerCase().includes(query.toLowerCase()))\n          .slice(0, 2)\n      : []\n  )\n  const answersByContractId =\n    answersWithChanges && filter === 'news'\n      ? groupBy(answersWithChanges, 'contractId')\n      : query !== ''\n      ? groupBy(answersMatchingQuery, 'contractId')\n      : undefined\n  const emptyContractsState =\n    props.emptyState ??\n    (filter !== 'all' ||\n    contractType !== 'ALL' ||\n    prizeMarketState === '1' ||\n    sweepiesState === '1' ? (\n      <Col className=\"mt-2 items-center gap-3\">\n        <span className=\"text-ink-700 text-center\">\n          No {prefersPlay ? 'questions' : 'sweeps questions'} found under this\n          filter.\n        </span>\n        <Col className=\"gap-2\">\n          {!prefersPlay && (\n            <Button onClick={() => setPrefersPlay(true)} color=\"purple\">\n              See mana markets\n            </Button>\n          )}\n\n          <Button\n            onClick={() =>\n              onChange({\n                [FILTER_KEY]: 'all',\n                [CONTRACT_TYPE_KEY]: 'ALL',\n                [TOPIC_FILTER_KEY]: '',\n                p: '0',\n              })\n            }\n            color=\"gray-outline\"\n          >\n            Clear filter\n          </Button>\n        </Col>\n      </Col>\n    ) : query ? (\n      <NoResults />\n    ) : (\n      <Col className=\"text-ink-700 mx-2 my-6 text-center\">\n        No questions yet.\n        {topicSlug && (\n          <Row className={'mt-2 w-full items-center justify-center'}>\n            <AddContractToGroupButton groupSlug={topicSlug} />\n          </Row>\n        )}\n      </Col>\n    ))\n\n  const selectedTopic = groupIds\n    ? ALL_PARENT_TOPICS.find((topic) =>\n        TOPICS_TO_SUBTOPICS[topic].some((subtopic) =>\n          groupIds.split(',').some((id) => subtopic.groupIds.includes(id))\n        )\n      )\n    : undefined\n  const selectedSubTopic = selectedTopic\n    ? TOPICS_TO_SUBTOPICS[selectedTopic].find(\n        (subtopic) => groupIds === subtopic.groupIds.join(',')\n      )\n    : undefined\n  const selectedAll = !selectedTopic && filter !== 'news'\n  const selectedOnlyNews = filter === 'news' && !selectedTopic\n\n  return (\n    <Col className=\"w-full\">\n      <Col className={clsx('bg-canvas-0 sticky top-0 z-20', headerClassName)}>\n        <Col className=\"mb-2\">\n          {showTopicsFilterPills && (\n            <Carousel\n              fadeEdges\n              labelsParentClassName=\"gap-4 items-baseline border-b border-ink-100 dark:border-ink-200 pb-2\"\n            >\n              <button\n                className={clsx(\n                  'font-medium',\n                  selectedAll ? 'text-primary-600' : 'text-ink-500'\n                )}\n                onClick={() => {\n                  if (selectedAll) {\n                    return\n                  } else {\n                    track('select search topic', { topic: 'all' })\n                    const changes: Partial<SearchParams> = {\n                      [GROUP_IDS_KEY]: '',\n                    }\n                    if (filter === 'news') changes[FILTER_KEY] = 'open'\n                    onChange(changes)\n                  }\n                }}\n              >\n                All\n              </button>\n              <button\n                className={clsx(\n                  'font-medium',\n                  selectedOnlyNews ? 'text-primary-600' : 'text-ink-500'\n                )}\n                onClick={() => {\n                  if (selectedOnlyNews) {\n                    onChange({ [FILTER_KEY]: 'open' })\n                  } else {\n                    track('select search topic', { topic: 'news' })\n                    onChange({ [FILTER_KEY]: 'news', [GROUP_IDS_KEY]: '' })\n                  }\n                }}\n              >\n                News\n              </button>\n              {ALL_PARENT_TOPICS.map((topic) => (\n                <button\n                  key={topic}\n                  className={clsx(\n                    'whitespace-nowrap font-medium',\n                    selectedTopic === topic\n                      ? 'text-primary-600'\n                      : 'text-ink-500'\n                  )}\n                  onClick={() => {\n                    if (selectedTopic === topic) {\n                      onChange({ [GROUP_IDS_KEY]: '' })\n                    } else {\n                      track('select search topic', { topic })\n                      // Join all group IDs for this topic's subtopics\n                      const allGroupIds = TOPICS_TO_SUBTOPICS[topic]\n                        .map((subtopic) => subtopic.groupIds)\n                        .flat()\n                      const changes: Partial<SearchParams> = {\n                        [GROUP_IDS_KEY]: allGroupIds.join(','),\n                      }\n                      if (filter === 'news') changes[FILTER_KEY] = 'open'\n                      onChange(changes)\n                    }\n                  }}\n                >\n                  {removeEmojis(topic)}\n                </button>\n              ))}\n            </Carousel>\n          )}\n        </Col>\n        {!hideSearch && (\n          <SearchInput\n            value={query}\n            setValue={setQuery}\n            placeholder={\n              searchType === 'Users'\n                ? 'Search users'\n                : searchType === 'Questions' || contractsOnly\n                ? 'Search questions'\n                : isMobile\n                ? 'Search'\n                : 'Search questions, users, topics, and posts'\n            }\n            autoFocus={autoFocus}\n            loading={loading}\n          />\n        )}\n\n        {/* Subtopics row */}\n        {selectedTopic &&\n          Object.keys(TOPICS_TO_SUBTOPICS).some(\n            (topic) => topic === selectedTopic\n          ) && (\n            <Carousel fadeEdges labelsParentClassName=\"gap-1 mt-3 mb-1.5 \">\n              <button\n                onClick={() => {\n                  onChange({\n                    [GROUP_IDS_KEY]: TOPICS_TO_SUBTOPICS[selectedTopic]\n                      .map((subtopic) => subtopic.groupIds)\n                      .flat()\n                      .join(','),\n                  })\n                }}\n                className={clsx(\n                  'text-ink-500 whitespace-nowrap px-3 py-0.5 text-sm',\n                  !selectedSubTopic &&\n                    'text-primary-700 bg-primary-50 dark:bg-primary-100 rounded-full font-medium'\n                )}\n              >\n                All\n              </button>\n              {TOPICS_TO_SUBTOPICS[selectedTopic]\n                .filter(({ hideFromSearch }) => !hideFromSearch)\n                .map(({ name, groupIds }) => (\n                  <button\n                    key={name}\n                    className={clsx(\n                      'text-ink-500 whitespace-nowrap px-3 py-0.5 text-sm',\n                      searchParams[GROUP_IDS_KEY] === groupIds.join(',') &&\n                        'text-primary-700 bg-primary-50 dark:bg-primary-100 rounded-full font-medium '\n                    )}\n                    onClick={() => {\n                      if (searchParams[GROUP_IDS_KEY] === groupIds.join(',')) {\n                        onChange({\n                          [GROUP_IDS_KEY]: TOPICS_TO_SUBTOPICS[selectedTopic]\n                            .map((subtopic) => subtopic.groupIds)\n                            .flat()\n                            .join(','),\n                        })\n                      } else {\n                        track('select search subtopic', { subtopic: name })\n                        onChange({ [GROUP_IDS_KEY]: groupIds.join(',') })\n                      }\n                    }}\n                  >\n                    {removeEmojis(name)}\n                  </button>\n                ))}\n            </Carousel>\n          )}\n\n        {!hideContractFilters && (\n          <ContractFilters\n            params={searchParams}\n            updateParams={onChange}\n            topicSlug={topicSlug}\n            className={\n              searchType && searchType !== 'Questions' ? 'invisible' : ''\n            }\n            hideSweepsToggle={hideSweepsToggle}\n          />\n        )}\n      </Col>\n      <Spacer h={1} />\n      {showSearchTypes && (\n        <Col>\n          {showTopics && (\n            <>\n              <Row className=\"text-ink-500 items-center gap-1 text-sm\">\n                <hr className=\"border-ink-300 ml-2 grow sm:ml-0\" />\n                <span>\n                  {!query || !topics?.length\n                    ? ''\n                    : topics.length >= 100\n                    ? '100+'\n                    : `${topics.length}`}{' '}\n                  {!query || !topics?.length ? 'Topics' : 'topics'}\n                </span>\n                <hr className=\"border-ink-300 mr-2 grow sm:mr-0\" />\n              </Row>\n              <BrowseTopicPills\n                className={'relative w-full px-2 pb-4'}\n                topics={topics}\n              />\n            </>\n          )}\n          {showUsers && <UserResults userResults={users} />}\n          {(showTopics || showUsers) && (\n            <Row className=\"text-ink-500 items-center gap-1 text-sm\">\n              <hr className=\"border-ink-300 ml-2 grow sm:ml-0\" />\n              <span>\n                {!query || !contracts?.length\n                  ? ''\n                  : contracts.length >= 100\n                  ? '100+'\n                  : shouldLoadMore && !loading\n                  ? `${contracts.length}+`\n                  : `${contracts.length}`}{' '}\n                {!query || !contracts?.length ? 'Questions' : 'questions'}\n              </span>\n              <hr className=\"border-ink-300 mr-2 grow sm:mr-0\" />\n            </Row>\n          )}\n        </Col>\n      )}\n\n      {!contracts && !posts ? (\n        <LoadingContractResults />\n      ) : contracts?.length === 0 && posts?.length === 0 ? (\n        emptyContractsState\n      ) : (\n        <>\n          {contracts || posts ? (\n            <CombinedResults\n              contracts={contracts ?? []}\n              posts={posts ?? []}\n              searchParams={searchParams}\n              onContractClick={onContractClick}\n              highlightContractIds={highlightContractIds}\n              answersByContractId={answersByContractId}\n              hideAvatars={hideAvatars}\n              hideActions={hideActions}\n              hasBets={hasBets}\n            />\n          ) : null}\n          <LoadMoreUntilNotVisible loadMore={loadMoreContracts} />\n          {shouldLoadMore && <LoadingContractResults />}\n          {!shouldLoadMore && (\n            <NoMoreResults params={searchParams} onChange={onChange} />\n          )}\n        </>\n      )}\n    </Col>\n  )\n}\n\nconst NoResults = () => {\n  const [message] = useState(\n    sample([\n      'no questions found x.x',\n      'no questions found u_u',\n      'no questions found T_T',\n      'no questions found :c',\n      'no questions found :(',\n      'no questions found :(',\n      'no questions found :(',\n      'that search is too bananas for me 🍌',\n      'only nothingness',\n    ])\n  )\n\n  return (\n    <span className=\"text-ink-700 mx-2 my-6 text-center\">\n      {capitalize(message)}\n    </span>\n  )\n}\n\nexport const LoadingContractResults = () => {\n  return (\n    <Col className=\"w-full\">\n      <LoadingContractRow />\n      <LoadingContractRow />\n      <LoadingContractRow />\n    </Col>\n  )\n}\n\nexport const NoMoreResults = (props: {\n  params: SearchParams\n  onChange: (changes: Partial<SearchParams>) => void\n}) => {\n  const { params, onChange } = props\n  const showReset =\n    params[FILTER_KEY] !== 'all' ||\n    params[CONTRACT_TYPE_KEY] !== 'ALL' ||\n    params[PRIZE_MARKET_KEY] === '1'\n  // params[SWEEPIES_KEY] === '1' //TODO\n\n  return (\n    <div className=\"text-ink-500 mx-2 my-8 text-center\">\n      {showReset ? 'No more results under this filter. ' : 'No more results. '}\n      {showReset && (\n        <button\n          className=\"text-primary-500 hover:underline focus:underline\"\n          onClick={() => {\n            onChange({\n              [FILTER_KEY]: 'all',\n              [CONTRACT_TYPE_KEY]: 'ALL',\n              [PRIZE_MARKET_KEY]: '0',\n              // [SWEEPIES_KEY]: '0',\n            })\n          }}\n        >\n          Clear filter\n        </button>\n      )}\n    </div>\n  )\n}\n\nconst FRESH_SEARCH_CHANGED_STATE: SearchState = {\n  contracts: undefined,\n  users: undefined,\n  topics: undefined,\n  shouldLoadMore: true,\n  posts: undefined,\n}\n\nexport const useSearchResults = (props: {\n  persistPrefix: string\n  searchParams: SearchParams\n  includeUsersAndTopics: boolean\n  isReady: boolean\n  additionalFilter?: SupabaseAdditionalFilter\n}) => {\n  const { persistPrefix, searchParams, isReady, additionalFilter } = props\n\n  const [state, setState] = usePersistentInMemoryState<SearchState>(\n    FRESH_SEARCH_CHANGED_STATE,\n    `${persistPrefix}-supabase-contract-search`\n  )\n  const [loading, setLoading] = useState(false)\n\n  const requestId = useRef(0)\n\n  const querySearchResults = useEvent(\n    async (freshQuery?: boolean, contractsOnly?: boolean) => {\n      const {\n        q: query,\n        s: sort,\n        f: filter,\n        ct: contractType,\n        p: isPrizeMarketString,\n        fy: forYou,\n        tf: topicSlug,\n        sw: sweepState,\n        gids,\n        li: liquidity,\n        hb: hasBets,\n      } = searchParams\n\n      const shouldSearchPostsWithContracts =\n        (sort === 'score' || sort === 'newest') &&\n        (!contractsOnly || !!state.posts?.length) &&\n        !topicSlug &&\n        forYou === '0' &&\n        isPrizeMarketString === '0' &&\n        !liquidity &&\n        hasBets === '0' &&\n        (contractType === 'ALL' || contractType === 'POSTS') &&\n        (filter === 'all' || filter === 'open') &&\n        !gids.length &&\n        // There aren't that many posts, so we don't need to wait up for them\n        (state.posts?.length ?? 0) < 20\n\n      const includeUsersAndTopics =\n        !contractsOnly && props.includeUsersAndTopics\n\n      if (freshQuery || state.shouldLoadMore) {\n        const id = ++requestId.current\n        let timeoutId: NodeJS.Timeout | undefined\n        if (freshQuery) {\n          timeoutId = setTimeout(() => {\n            if (id === requestId.current) {\n              setLoading(true)\n            }\n          }, 500)\n        }\n        const postApiParams: APIParams<'get-posts'> = {\n          sortBy: sort === 'score' ? 'importance_score' : 'created_time',\n          term: query,\n          limit: 10,\n          userId: additionalFilter?.creatorId,\n          offset: freshQuery ? 0 : state.posts?.length ?? 0,\n        }\n        try {\n          if (contractType === 'POSTS') {\n            const posts = await api('get-posts', postApiParams)\n            const shouldLoadMore = posts.length === 10\n            setState({\n              contracts: [],\n              users: undefined,\n              topics: undefined,\n              posts: uniqBy(buildArray(state.posts, posts), 'id'),\n              shouldLoadMore,\n            })\n            clearTimeout(timeoutId)\n            setLoading(false)\n            return shouldLoadMore\n          }\n          const searchPromises: Promise<any>[] = [\n            api('search-markets-full', {\n              term: query,\n              filter,\n              sort,\n              contractType,\n              offset: freshQuery ? 0 : state.contracts?.length ?? 0,\n              limit: CONTRACTS_PER_SEARCH_PAGE,\n              topicSlug: topicSlug !== '' ? topicSlug : undefined,\n              creatorId: additionalFilter?.creatorId,\n              isPrizeMarket: isPrizeMarketString,\n              forYou,\n              token:\n                sweepState === '2'\n                  ? 'ALL'\n                  : sweepState === '1'\n                  ? 'CASH'\n                  : 'MANA',\n              gids,\n              liquidity: liquidity === '' ? undefined : parseInt(liquidity),\n              hasBets,\n            }),\n          ]\n\n          if (includeUsersAndTopics) {\n            searchPromises.push(\n              searchUsers(query, USERS_PER_PAGE),\n              searchGroups({\n                term: query,\n                limit: TOPICS_PER_PAGE,\n                type: 'lite',\n              })\n            )\n          }\n          if (shouldSearchPostsWithContracts) {\n            searchPromises.push(api('get-posts', postApiParams))\n          }\n\n          const results = await Promise.all(searchPromises)\n\n          if (id === requestId.current) {\n            const newContracts = results[0] as Contract[]\n            let postResultIndex = 1\n            const newUsers = includeUsersAndTopics\n              ? results[postResultIndex++]\n              : undefined\n            const newTopics = includeUsersAndTopics\n              ? results[postResultIndex++]\n              : undefined\n\n            const newPostsResults =\n              shouldSearchPostsWithContracts &&\n              results.length >= postResultIndex\n                ? (results[postResultIndex] as TopLevelPost[])\n                : undefined\n\n            const freshContracts = freshQuery\n              ? newContracts\n              : buildArray(state.contracts, newContracts)\n            const bottomScoreFromAllContracts =\n              sort === 'score'\n                ? minBy(freshContracts, 'importanceScore')?.importanceScore\n                : minBy(freshContracts, 'createdTime')?.createdTime\n\n            // This is necessary bc the posts are in a different table than the contracts.\n            // TODO: this is bad and will leave posts out of the search results randomly.\n            // We should fix this by joining the posts table to the contracts table or something.\n            let postFilteringThreshold: number | undefined\n            if (sort === 'score') {\n              if (\n                !freshQuery &&\n                state.contracts &&\n                state.contracts.length > 0\n              ) {\n                postFilteringThreshold = minBy(\n                  state.contracts,\n                  'importanceScore'\n                )?.importanceScore\n              } else {\n                postFilteringThreshold = bottomScoreFromAllContracts\n              }\n            } else {\n              if (\n                !freshQuery &&\n                state.contracts &&\n                state.contracts.length > 0\n              ) {\n                postFilteringThreshold = minBy(\n                  state.contracts,\n                  'createdTime'\n                )?.createdTime\n              } else {\n                postFilteringThreshold = bottomScoreFromAllContracts\n              }\n            }\n            const freshPosts =\n              freshQuery || !state.posts\n                ? newPostsResults\n                : uniqBy(\n                    buildArray(\n                      state.posts,\n                      newPostsResults?.filter((p) =>\n                        postFilteringThreshold === undefined\n                          ? true\n                          : sort === 'score'\n                          ? p.importanceScore <= postFilteringThreshold\n                          : p.createdTime <= postFilteringThreshold\n                      )\n                    ),\n                    'id'\n                  )\n\n            const shouldLoadMore =\n              newContracts.length === CONTRACTS_PER_SEARCH_PAGE\n\n            setState({\n              contracts: freshContracts,\n              users: includeUsersAndTopics ? newUsers : state.users,\n              topics: includeUsersAndTopics ? newTopics?.lite : state.topics,\n              posts: freshPosts,\n              shouldLoadMore,\n            })\n            clearTimeout(timeoutId)\n            setLoading(false)\n\n            return shouldLoadMore\n          }\n        } catch (error) {\n          console.error('Error fetching search results:', error)\n          setLoading(false)\n        }\n      }\n      return false\n    }\n  )\n\n  useDebouncedEffect(\n    () => {\n      if (isReady && !state.contracts?.length) {\n        querySearchResults(true)\n      }\n    },\n    50,\n    [isReady]\n  )\n  useDebouncedEffect(\n    () => {\n      if (isReady) {\n        querySearchResults(true)\n      }\n    },\n    50,\n    [JSON.stringify(searchParams)]\n  )\n\n  const contracts = state.contracts\n    ? uniqBy(\n        state.contracts.filter((c) => {\n          return (\n            !additionalFilter?.excludeContractIds?.includes(c.id) &&\n            !additionalFilter?.excludeGroupSlugs?.some((slug) =>\n              c.groupSlugs?.includes(slug)\n            ) &&\n            !additionalFilter?.excludeUserIds?.includes(c.creatorId)\n          )\n        }),\n        'id'\n      )\n    : undefined\n\n  return {\n    contracts,\n    users: state.users,\n    topics: state.topics,\n    loading,\n    shouldLoadMore: state.shouldLoadMore,\n    loadMoreContracts: () => querySearchResults(false, true),\n    refreshContracts: () => querySearchResults(true, true),\n    posts: state.posts,\n  }\n}\n\nexport const useSearchQueryState = (props: {\n  persistPrefix: string\n  defaultSort?: Sort\n  defaultFilter?: Filter\n  defaultContractType?: ContractTypeType\n  defaultSearchType?: SearchType\n  defaultPrizeMarket?: '1' | '0'\n  defaultSweepies?: '2' | '1' | '0'\n  defaultForYou?: '1' | '0'\n  useUrlParams?: boolean\n  defaultTopicFilter?: string\n  defaultLiquidityTier?: string\n}) => {\n  const {\n    persistPrefix,\n    defaultSort,\n    defaultFilter,\n    defaultContractType,\n    defaultSearchType,\n    useUrlParams,\n    defaultPrizeMarket,\n    defaultForYou,\n    defaultTopicFilter,\n    defaultSweepies,\n    defaultLiquidityTier,\n  } = props\n\n  const defaults = {\n    [QUERY_KEY]: '',\n    [SORT_KEY]: defaultSort ?? 'score',\n    [FILTER_KEY]: defaultFilter ?? 'all',\n    [CONTRACT_TYPE_KEY]: defaultContractType ?? 'ALL',\n    [SEARCH_TYPE_KEY]: defaultSearchType,\n    [PRIZE_MARKET_KEY]: defaultPrizeMarket ?? '0',\n    [FOR_YOU_KEY]: defaultForYou ?? '0',\n    [TOPIC_FILTER_KEY]: defaultTopicFilter ?? '',\n    [SWEEPIES_KEY]: defaultSweepies ?? '0',\n    [GROUP_IDS_KEY]: '',\n    [LIQUIDITY_KEY]: defaultLiquidityTier ?? '',\n    [HAS_BETS_KEY]: '0' as '0' | '1',\n  }\n\n  const useHook = useUrlParams ? usePersistentQueriesState : useNothing\n  const [queryState, updateQueryState, queryReady] = useHook(\n    defaults,\n    persistPrefix\n  )\n  const [localState, updateLocalState, localReady] = useLocalPartialUpdater(\n    defaults,\n    persistPrefix\n  )\n\n  // copy query state -> local state iff we are using query params and any params are set\n  // only do this once on first load.\n  useEffect(() => {\n    if (\n      queryReady &&\n      localReady &&\n      useUrlParams &&\n      !isEqual(queryState, defaults)\n    ) {\n      updateLocalState(queryState)\n    }\n  }, [queryReady, localReady])\n\n  const setState = useEvent((newState: Partial<SearchParams>) => {\n    updateLocalState(newState)\n    if (useUrlParams) updateQueryState(newState)\n  })\n\n  return [localState, setState, queryReady && localReady] as const\n}\n\n// shim for hook rules and types\nconst useNothing = <T,>(x: T, _: string) =>\n  [x, (_: Partial<T>) => {}, true] as const satisfies any[]\n\nconst useLocalPartialUpdater = <T extends Record<string, string | undefined>>(\n  defaults: T,\n  persistPrefix: string\n) => {\n  const [state, setState, ready] = usePersistentLocalState(\n    defaults,\n    searchLocalKey(persistPrefix)\n  )\n\n  const updateState = (\n    newState: Partial<T> | ((prevState: T) => Partial<T>)\n  ) => {\n    if (typeof newState === 'function') {\n      setState((prevState) => ({ ...prevState, ...newState(prevState) }))\n    } else {\n      setState((prevState) => ({ ...prevState, ...newState }))\n    }\n  }\n\n  // the first copy of data from local state may be missing values, so we return the full state\n  return [{ ...defaults, ...state }, updateState, ready] as const\n}\n\nexport const searchLocalKey = (persistPrefix: string) =>\n  `${persistPrefix}-local-state`\n",
          "postContent": "'use client'\nimport clsx from 'clsx'\nimport { Contract } from 'common/contract'\nimport { LiteGroup } from 'common/group'\nimport { capitalize, groupBy, minBy, orderBy, sample, uniqBy } from 'lodash'\nimport { ReactNode, useEffect, useRef, useState } from 'react'\nimport { AddContractToGroupButton } from 'web/components/topics/add-contract-to-group-modal'\nimport { useDebouncedEffect } from 'web/hooks/use-debounced-effect'\nimport { useEvent } from 'client-common/hooks/use-event'\nimport { usePersistentInMemoryState } from 'client-common/hooks/use-persistent-in-memory-state'\nimport { usePersistentQueriesState } from 'web/hooks/use-persistent-query-state'\nimport { track } from 'web/lib/service/analytics'\nimport { Col } from './layout/col'\nimport { Row } from './layout/row'\nimport { FullUser } from 'common/api/user-types'\nimport { CONTRACTS_PER_SEARCH_PAGE } from 'common/supabase/contracts'\nimport { buildArray } from 'common/util/array'\nimport { Button } from 'web/components/buttons/button'\nimport { usePersistentLocalState } from 'web/hooks/use-persistent-local-state'\nimport { api, searchGroups } from 'web/lib/api/api'\nimport { searchUsers } from 'web/lib/supabase/users'\n\nimport { LoadingContractRow } from './contract/contracts-table'\nimport { ContractFilters } from './search/contract-filters'\nimport { UserResults } from './search/user-results'\nimport { BrowseTopicPills } from './topics/browse-topic-pills'\nimport { LoadMoreUntilNotVisible } from 'web/components/widgets/visibility-observer'\nimport { BinaryDigit } from 'common/tier'\nimport { useIsMobile } from 'web/hooks/use-is-mobile'\nimport { Spacer } from './layout/spacer'\nimport { useSweepstakes } from './sweepstakes-provider'\nimport { ALL_PARENT_TOPICS, TOPICS_TO_SUBTOPICS } from 'common/topics'\nimport { Carousel } from './widgets/carousel'\nimport { isEqual } from 'lodash'\nimport { SearchInput } from './search/search-input'\nimport { removeEmojis } from 'common/util/string'\nimport { useIsPageVisible } from 'web/hooks/use-page-visible'\nimport { TopLevelPost } from 'common/top-level-post'\nimport { CombinedResults } from './contract/combined-results'\nimport { APIParams } from 'common/api/schema'\nimport { useUser } from 'web/hooks/use-user'\nimport { useAPIGetter } from 'web/hooks/use-api-getter'\nimport { getFollowedGroupsCount } from 'common/supabase/groups'\nimport { db } from 'web/lib/supabase/db'\nimport { DAY_MS } from 'common/util/time'\n\nconst USERS_PER_PAGE = 100\nconst TOPICS_PER_PAGE = 100\n\nexport const SORTS = [\n  { label: 'Best', value: 'score' },\n  { label: 'Hot', value: 'freshness-score' },\n  { label: 'Liquidity', value: 'liquidity' },\n  { label: 'Subsidy', value: 'subsidy' },\n  { label: 'New', value: 'newest' },\n  { label: 'Closing soon', value: 'close-date' },\n  { label: 'Daily change', value: 'daily-score' },\n  { label: '24h volume', value: '24-hour-vol' },\n  { label: 'Total traders', value: 'most-popular' },\n  { label: 'Last activity', value: 'last-updated' },\n  { label: 'Just resolved', value: 'resolve-date' },\n  { label: 'Bounty amount', value: 'bounty-amount' },\n  { label: 'High %', value: 'prob-descending' },\n  { label: 'Low %', value: 'prob-ascending' },\n  { label: '🎲 Random!', value: 'random' },\n] as const\n\nexport const predictionMarketSorts = new Set([\n  'daily-score',\n  '24-hour-vol',\n  'liquidity',\n  'subsidy',\n  'close-date',\n  'resolve-date',\n  'most-popular',\n  'prob-descending',\n  'prob-ascending',\n  'freshness-score',\n])\n\nexport const bountySorts = new Set(['bounty-amount'])\n\nconst probSorts = new Set(['prob-descending', 'prob-ascending'])\n\nexport const BOUNTY_MARKET_SORTS = SORTS.filter(\n  (item) => !predictionMarketSorts.has(item.value)\n)\n\nexport const POLL_SORTS = BOUNTY_MARKET_SORTS.filter(\n  (item) => !bountySorts.has(item.value)\n)\n\nexport const PREDICTION_MARKET_SORTS = SORTS.filter(\n  (item) => !bountySorts.has(item.value) && !probSorts.has(item.value)\n)\n\nexport const PREDICTION_MARKET_PROB_SORTS = SORTS.filter(\n  (item) => !bountySorts.has(item.value)\n)\n\nexport type Sort = (typeof SORTS)[number]['value']\n\nexport const FILTERS = [\n  { label: 'Any status', value: 'all' },\n  { label: 'Open', value: 'open' },\n  { label: 'Closing in 7 days', value: 'closing-week' },\n  { label: 'Closing in 30 days', value: 'closing-month' },\n  { label: 'Closing in 90 days', value: 'closing-90-days' },\n  { label: 'Closed', value: 'closed' },\n  { label: 'Resolved', value: 'resolved' },\n  { label: 'Recently changed', value: 'news' },\n] as const\n\nexport type Filter = (typeof FILTERS)[number]['value']\n\nexport const CONTRACT_TYPES = [\n  { label: 'Any type', value: 'ALL' },\n  { label: 'Yes/No', value: 'BINARY' },\n  { label: 'Multiple Choice', value: 'MULTIPLE_CHOICE' },\n  { label: 'Numeric', value: 'PSEUDO_NUMERIC' },\n  { label: 'Bounty', value: 'BOUNTIED_QUESTION' },\n  { label: 'Stock', value: 'STONK' },\n  { label: 'Poll', value: 'POLL' },\n  { label: 'Posts', value: 'POSTS' },\n] as const\n\nexport const DEFAULT_SORT = 'score'\nexport const DEFAULT_SORTS = ['freshness-score', 'newest']\nexport const DEFAULT_BOUNTY_SORTS = ['bounty-amount']\n\nexport const DEFAULT_FILTERS = []\nexport const DEFAULT_FILTER = 'all'\n\nexport const DEFAULT_CONTRACT_TYPE = 'ALL'\nexport const DEFAULT_CONTRACT_TYPES = []\n\nexport const DEFAULT_TIER = '00000'\n\nexport type ContractTypeType = (typeof CONTRACT_TYPES)[number]['value']\ntype SearchType = 'Users' | 'Questions' | undefined\n\nexport type SearchParams = {\n  [QUERY_KEY]: string\n  [SORT_KEY]: Sort\n  [FILTER_KEY]: Filter\n  [CONTRACT_TYPE_KEY]: ContractTypeType\n  [SEARCH_TYPE_KEY]: SearchType\n  [PRIZE_MARKET_KEY]: BinaryDigit\n  [FOR_YOU_KEY]: BinaryDigit\n  [TOPIC_FILTER_KEY]: string\n  [SWEEPIES_KEY]: '0' | '1' | '2'\n  [GROUP_IDS_KEY]: string\n  [LIQUIDITY_KEY]: string // empty string or stringified number\n  [HAS_BETS_KEY]: '0' | '1'\n}\n\nexport const QUERY_KEY = 'q'\nexport const SORT_KEY = 's'\nexport const FILTER_KEY = 'f'\nexport const CONTRACT_TYPE_KEY = 'ct'\nexport const SEARCH_TYPE_KEY = 't'\nexport const PRIZE_MARKET_KEY = 'p'\nexport const FOR_YOU_KEY = 'fy'\nexport const MARKET_TIER_KEY = 'mt'\nexport const TOPIC_FILTER_KEY = 'tf'\nexport const SWEEPIES_KEY = 'sw'\nexport const GROUP_IDS_KEY = 'gids'\nexport const LIQUIDITY_KEY = 'li'\nexport const HAS_BETS_KEY = 'hb'\n\nexport type SupabaseAdditionalFilter = {\n  creatorId?: string\n  excludeContractIds?: string[]\n  excludeGroupSlugs?: string[]\n  excludeUserIds?: string[]\n}\n\nexport type SearchState = {\n  contracts: Contract[] | undefined\n  users: FullUser[] | undefined\n  topics: LiteGroup[] | undefined\n  shouldLoadMore: boolean\n  posts: TopLevelPost[] | undefined\n}\n\ntype SearchProps = {\n  persistPrefix: string\n  defaultSort?: Sort\n  defaultFilter?: Filter\n  defaultContractType?: ContractTypeType\n  defaultSearchType?: SearchType\n  defaultForYou?: '1' | '0'\n  additionalFilter?: SupabaseAdditionalFilter\n  highlightContractIds?: string[]\n  onContractClick?: (contract: Contract) => void\n  hideActions?: boolean\n  hideSweepsToggle?: boolean\n  headerClassName?: string\n  isWholePage?: boolean\n  // used to determine if search params should be updated in the URL\n  useUrlParams?: boolean\n  autoFocus?: boolean\n  emptyState?: ReactNode\n  hideSearch?: boolean\n  hideContractFilters?: boolean\n  topicSlug?: string\n  contractsOnly?: boolean\n  hideSearchTypes?: boolean\n  hideAvatars?: boolean\n  initialTopics?: LiteGroup[]\n  showTopicsFilterPills?: boolean\n  refreshOnVisible?: boolean\n}\n\nexport function Search(props: SearchProps) {\n  const {\n    defaultSort,\n    defaultFilter,\n    defaultContractType,\n    defaultSearchType,\n    defaultForYou,\n    additionalFilter,\n    onContractClick,\n    hideActions,\n    hideSweepsToggle,\n    highlightContractIds,\n    headerClassName,\n    persistPrefix,\n    isWholePage,\n    useUrlParams,\n    autoFocus,\n    hideContractFilters,\n    topicSlug = '',\n    contractsOnly,\n    hideSearch,\n    hideSearchTypes,\n    hideAvatars,\n    showTopicsFilterPills,\n    refreshOnVisible,\n  } = props\n\n  const isMobile = useIsMobile()\n  const { prefersPlay, setPrefersPlay } = useSweepstakes()\n  const [searchParams, setSearchParams, isReady] = useSearchQueryState({\n    defaultSort,\n    defaultFilter,\n    defaultContractType,\n    defaultSearchType,\n    defaultForYou,\n    useUrlParams,\n    persistPrefix,\n    defaultTopicFilter: topicSlug,\n    defaultSweepies: hideSweepsToggle ? '2' : prefersPlay ? '0' : '1',\n  })\n\n  const query = searchParams[QUERY_KEY]\n  const searchType = searchParams[SEARCH_TYPE_KEY]\n  const filter = searchParams[FILTER_KEY]\n  const contractType = searchParams[CONTRACT_TYPE_KEY]\n  const prizeMarketState = searchParams[PRIZE_MARKET_KEY]\n  const sweepiesState = searchParams[SWEEPIES_KEY]\n  const groupIds = searchParams[GROUP_IDS_KEY]\n  const hasBets = searchParams[HAS_BETS_KEY] === '1'\n\n  useEffect(() => {\n    const isSweeps = sweepiesState === '1'\n    if (prefersPlay !== isSweeps) return\n    setSearchParams({\n      [SWEEPIES_KEY]: prefersPlay ? '0' : '1',\n    })\n  }, [prefersPlay, sweepiesState])\n\n  const selectedFollowed = searchParams[TOPIC_FILTER_KEY] === 'followed'\n  const showSearchTypes =\n    !!query && !hideSearchTypes && !contractsOnly && !selectedFollowed\n\n  const {\n    contracts,\n    users,\n    topics,\n    loading,\n    shouldLoadMore,\n    loadMoreContracts,\n    refreshContracts,\n    posts,\n  } = useSearchResults({\n    persistPrefix,\n    searchParams: searchParams,\n    includeUsersAndTopics: showSearchTypes,\n    isReady,\n    additionalFilter,\n  })\n  const visible = useIsPageVisible()\n  useEffect(() => {\n    if (visible && refreshOnVisible) {\n      refreshContracts()\n    }\n  }, [visible, refreshOnVisible])\n\n  const showTopics = topics && topics.length > 0 && query && query.length > 0\n  const showUsers = users && users.length > 0 && query && query.length > 0\n\n  const onChange = (changes: Partial<SearchParams>) => {\n    const updatedParams = { ...changes }\n\n    setSearchParams(updatedParams)\n    if (isWholePage) window.scrollTo(0, 0)\n  }\n\n  const setQuery = (query: string) => onChange({ [QUERY_KEY]: query })\n\n  const answersWithChanges = contracts?.flatMap((c) =>\n    c.mechanism === 'cpmm-multi-1'\n      ? orderBy(\n          c.answers.filter((a) => Math.abs(a.probChanges.day) > 0.02),\n          (a) => Math.abs(a.probChanges.day),\n          'desc'\n        ).slice(0, 2)\n      : []\n  )\n\n  const answersMatchingQuery = contracts?.flatMap((c) =>\n    c.mechanism === 'cpmm-multi-1'\n      ? c.answers\n          .filter((a) => a.text.toLowerCase().includes(query.toLowerCase()))\n          .slice(0, 2)\n      : []\n  )\n  const answersByContractId =\n    answersWithChanges && filter === 'news'\n      ? groupBy(answersWithChanges, 'contractId')\n      : query !== ''\n      ? groupBy(answersMatchingQuery, 'contractId')\n      : undefined\n  const emptyContractsState =\n    props.emptyState ??\n    (filter !== 'all' ||\n    contractType !== 'ALL' ||\n    prizeMarketState === '1' ||\n    sweepiesState === '1' ? (\n      <Col className=\"mt-2 items-center gap-3\">\n        <span className=\"text-ink-700 text-center\">\n          No {prefersPlay ? 'questions' : 'sweeps questions'} found under this\n          filter.\n        </span>\n        <Col className=\"gap-2\">\n          {!prefersPlay && (\n            <Button onClick={() => setPrefersPlay(true)} color=\"purple\">\n              See mana markets\n            </Button>\n          )}\n\n          <Button\n            onClick={() =>\n              onChange({\n                [FILTER_KEY]: 'all',\n                [CONTRACT_TYPE_KEY]: 'ALL',\n                [TOPIC_FILTER_KEY]: '',\n                p: '0',\n              })\n            }\n            color=\"gray-outline\"\n          >\n            Clear filter\n          </Button>\n        </Col>\n      </Col>\n    ) : query ? (\n      <NoResults />\n    ) : (\n      <Col className=\"text-ink-700 mx-2 my-6 text-center\">\n        No questions yet.\n        {topicSlug && (\n          <Row className={'mt-2 w-full items-center justify-center'}>\n            <AddContractToGroupButton groupSlug={topicSlug} />\n          </Row>\n        )}\n      </Col>\n    ))\n\n  const selectedTopic = groupIds\n    ? ALL_PARENT_TOPICS.find((topic) =>\n        TOPICS_TO_SUBTOPICS[topic].some((subtopic) =>\n          groupIds.split(',').some((id) => subtopic.groupIds.includes(id))\n        )\n      )\n    : undefined\n  const selectedSubTopic = selectedTopic\n    ? TOPICS_TO_SUBTOPICS[selectedTopic].find(\n        (subtopic) => groupIds === subtopic.groupIds.join(',')\n      )\n    : undefined\n  const selectedAll = !selectedTopic && !selectedFollowed\n  const user = useUser()\n\n  const {\n    data: followedGroupsData,\n    loading: isLoadingFollowedGroups,\n    refresh: refreshFollowedGroups,\n  } = useAPIGetter(\n    'search-groups',\n    {\n      limit: 150,\n      type: 'lite',\n      term: query,\n      memberGroupsOnly: true,\n    },\n    undefined,\n    undefined,\n    !!user?.id && selectedFollowed\n  )\n  const [followedCount, setFollowedCount] = useState<number>(0)\n  // Refresh the followed count when the page is visible\n  useEffect(() => {\n    if (visible && selectedFollowed && user?.id) {\n      getFollowedGroupsCount(db, user?.id).then((count) => {\n        setFollowedCount(count)\n      })\n    }\n  }, [visible, selectedFollowed, user?.id])\n\n  // Refresh groups that they're following if the followed count changes\n  useEffect(() => {\n    if (visible && selectedFollowed) {\n      refreshFollowedGroups()\n      refreshContracts()\n    }\n  }, [followedCount])\n\n  const usersFollowedGroups = followedGroupsData?.lite\n  const followedGroupsCount = followedGroupsData?.lite?.length ?? 0\n  const shouldLoadTrendingTopics =\n    !!user &&\n    (user.createdTime > Date.now() - DAY_MS ||\n      (followedGroupsCount < 5 && !!followedGroupsData))\n  const shouldShowTrendingTopics = selectedFollowed && shouldLoadTrendingTopics\n  const shouldShowALotOfTrendingTopics =\n    shouldShowTrendingTopics && contracts?.length === 0\n\n  const { data: trendingTopicsData, loading: isLoadingTrendingTopics } =\n    useAPIGetter(\n      'search-groups',\n      {\n        limit: 100,\n        type: 'lite',\n        term: query,\n      },\n      undefined,\n      undefined,\n      shouldLoadTrendingTopics\n    )\n  const trendingTopics = trendingTopicsData?.lite.filter(\n    (topic) => !(usersFollowedGroups ?? []).some((t) => t.id === topic.id)\n  )\n  return (\n    <Col className=\"w-full\">\n      <Col className={clsx('bg-canvas-0 sticky top-0 z-20', headerClassName)}>\n        <Col className=\"mb-2\">\n          {showTopicsFilterPills && (\n            <Carousel\n              fadeEdges\n              labelsParentClassName=\"gap-4 items-baseline border-b border-ink-100 dark:border-ink-200 pb-2\"\n            >\n              <button\n                className={clsx(\n                  'font-medium',\n                  selectedAll ? 'text-primary-600' : 'text-ink-500'\n                )}\n                onClick={() => {\n                  if (!selectedAll) {\n                    track('select search topic', { topic: 'all' })\n                    const changes: Partial<SearchParams> = {\n                      [GROUP_IDS_KEY]: '',\n                      [TOPIC_FILTER_KEY]: '',\n                    }\n                    onChange(changes)\n                  }\n                }}\n              >\n                All\n              </button>\n              {!!user?.id && (\n                <button\n                  className={clsx(\n                    'font-medium',\n                    selectedFollowed ? 'text-primary-600' : 'text-ink-500'\n                  )}\n                  onClick={() => {\n                    if (!selectedFollowed) {\n                      track('select search topic', { topic: 'followed' })\n                      const changes: Partial<SearchParams> = {\n                        [TOPIC_FILTER_KEY]: 'followed',\n                        [GROUP_IDS_KEY]: '',\n                      }\n                      onChange(changes)\n                    }\n                  }}\n                >\n                  Followed\n                </button>\n              )}\n              {ALL_PARENT_TOPICS.map((topic) => (\n                <button\n                  key={topic}\n                  className={clsx(\n                    'whitespace-nowrap font-medium',\n                    selectedTopic === topic\n                      ? 'text-primary-600'\n                      : 'text-ink-500'\n                  )}\n                  onClick={() => {\n                    if (selectedTopic != topic) {\n                      track('select search topic', { topic })\n                      // Join all group IDs for this topic's subtopics\n                      const allGroupIds = TOPICS_TO_SUBTOPICS[topic]\n                        .map((subtopic) => subtopic.groupIds)\n                        .flat()\n                      const changes: Partial<SearchParams> = {\n                        [GROUP_IDS_KEY]: allGroupIds.join(','),\n                        [TOPIC_FILTER_KEY]: '', // Clear direct topicSlug when a parent topic is selected\n                      }\n                      onChange(changes)\n                    }\n                  }}\n                >\n                  {removeEmojis(topic)}\n                </button>\n              ))}\n            </Carousel>\n          )}\n        </Col>\n        {!hideSearch && (\n          <SearchInput\n            value={query}\n            setValue={setQuery}\n            placeholder={\n              searchType === 'Users'\n                ? 'Search users'\n                : searchType === 'Questions' || contractsOnly\n                ? 'Search questions'\n                : isMobile\n                ? 'Search'\n                : 'Search questions, users, topics, and posts'\n            }\n            autoFocus={autoFocus}\n            loading={loading}\n          />\n        )}\n\n        {/* Subtopics row */}\n        {selectedTopic &&\n          Object.keys(TOPICS_TO_SUBTOPICS).some(\n            (topic) => topic === selectedTopic\n          ) && (\n            <Carousel fadeEdges labelsParentClassName=\"gap-1 mt-3 mb-1.5 \">\n              <button\n                onClick={() => {\n                  onChange({\n                    [GROUP_IDS_KEY]: TOPICS_TO_SUBTOPICS[selectedTopic]\n                      .map((subtopic) => subtopic.groupIds)\n                      .flat()\n                      .join(','),\n                  })\n                }}\n                className={clsx(\n                  'text-ink-500 whitespace-nowrap px-3 py-0.5 text-sm',\n                  !selectedSubTopic &&\n                    'text-primary-700 bg-primary-50 dark:bg-primary-100 rounded-full font-medium'\n                )}\n              >\n                All\n              </button>\n              {TOPICS_TO_SUBTOPICS[selectedTopic]\n                .filter(({ hideFromSearch }) => !hideFromSearch)\n                .map(({ name, groupIds }) => (\n                  <button\n                    key={name}\n                    className={clsx(\n                      'text-ink-500 whitespace-nowrap px-3 py-0.5 text-sm',\n                      searchParams[GROUP_IDS_KEY] === groupIds.join(',') &&\n                        'text-primary-700 bg-primary-50 dark:bg-primary-100 rounded-full font-medium '\n                    )}\n                    onClick={() => {\n                      if (searchParams[GROUP_IDS_KEY] === groupIds.join(',')) {\n                        onChange({\n                          [GROUP_IDS_KEY]: TOPICS_TO_SUBTOPICS[selectedTopic]\n                            .map((subtopic) => subtopic.groupIds)\n                            .flat()\n                            .join(','),\n                        })\n                      } else {\n                        track('select search subtopic', { subtopic: name })\n                        onChange({ [GROUP_IDS_KEY]: groupIds.join(',') })\n                      }\n                    }}\n                  >\n                    {removeEmojis(name)}\n                  </button>\n                ))}\n            </Carousel>\n          )}\n\n        {!hideContractFilters && (\n          <ContractFilters\n            params={searchParams}\n            updateParams={onChange}\n            topicSlug={topicSlug}\n            className={\n              searchType && searchType !== 'Questions' ? 'invisible' : ''\n            }\n            hideSweepsToggle={hideSweepsToggle}\n          />\n        )}\n      </Col>\n      <Spacer h={1} />\n      {selectedFollowed && (\n        <Col className=\"mb-2\">\n          <>\n            <Row className=\"text-ink-500 items-center gap-1 text-sm\">\n              <hr className=\"border-ink-300 ml-2 grow sm:ml-0\" />\n              <span>Your Followed Topics</span>\n              <hr className=\"border-ink-300 mr-2 grow sm:mr-0\" />\n            </Row>\n            {usersFollowedGroups ? (\n              <BrowseTopicPills\n                className={'relative w-full px-2 py-1'}\n                topics={usersFollowedGroups}\n                clipOnMobile={true}\n              />\n            ) : isLoadingFollowedGroups ? (\n              <div className=\"text-ink-500 px-2 py-3 text-sm\">\n                Loading your followed topics...\n              </div>\n            ) : null}\n          </>\n\n          {shouldShowTrendingTopics && (\n            <>\n              <Row className=\"text-ink-500 items-center gap-1 text-sm\">\n                <hr className=\"border-ink-300 ml-2 grow sm:ml-0\" />\n                <span>Explore Topics To Follow</span>\n                <hr className=\"border-ink-300 mr-2 grow sm:mr-0\" />\n              </Row>\n              {trendingTopics ? (\n                <BrowseTopicPills\n                  className={'relative w-full px-2 py-1'}\n                  topics={trendingTopics}\n                  clipOnMobile={!shouldShowALotOfTrendingTopics}\n                  initialShown={shouldShowALotOfTrendingTopics ? 20 : undefined}\n                />\n              ) : isLoadingTrendingTopics ? (\n                <div className=\"text-ink-500 px-2 py-3 text-sm\">\n                  Loading trending topics...\n                </div>\n              ) : null}\n            </>\n          )}\n        </Col>\n      )}\n      {showSearchTypes && (\n        <Col>\n          {showTopics && (\n            <>\n              <Row className=\"text-ink-500 items-center gap-1 text-sm\">\n                <hr className=\"border-ink-300 ml-2 grow sm:ml-0\" />\n                <span>\n                  {!query || !topics?.length\n                    ? ''\n                    : topics.length >= 100\n                    ? '100+'\n                    : `${topics.length}`}{' '}\n                  {!query || !topics?.length ? 'Topics' : 'topics'}\n                </span>\n                <hr className=\"border-ink-300 mr-2 grow sm:mr-0\" />\n              </Row>\n              <BrowseTopicPills\n                className={'relative w-full px-2 pb-4'}\n                topics={topics}\n              />\n            </>\n          )}\n          {showUsers && <UserResults userResults={users} />}\n          {(showTopics || showUsers) && (\n            <Row className=\"text-ink-500 items-center gap-1 text-sm\">\n              <hr className=\"border-ink-300 ml-2 grow sm:ml-0\" />\n              <span>\n                {!query || !contracts?.length\n                  ? ''\n                  : contracts.length >= 100\n                  ? '100+'\n                  : shouldLoadMore && !loading\n                  ? `${contracts.length}+`\n                  : `${contracts.length}`}{' '}\n                {!query || !contracts?.length ? 'Questions' : 'questions'}\n              </span>\n              <hr className=\"border-ink-300 mr-2 grow sm:mr-0\" />\n            </Row>\n          )}\n        </Col>\n      )}\n\n      {!contracts && !posts ? (\n        <LoadingContractResults />\n      ) : contracts?.length === 0 && posts?.length === 0 ? (\n        emptyContractsState\n      ) : (\n        <>\n          {contracts || posts ? (\n            <CombinedResults\n              contracts={contracts ?? []}\n              posts={posts ?? []}\n              searchParams={searchParams}\n              onContractClick={onContractClick}\n              highlightContractIds={highlightContractIds}\n              answersByContractId={answersByContractId}\n              hideAvatars={hideAvatars}\n              hideActions={hideActions}\n              hasBets={hasBets}\n            />\n          ) : null}\n          <LoadMoreUntilNotVisible loadMore={loadMoreContracts} />\n          {shouldLoadMore && <LoadingContractResults />}\n          {!shouldLoadMore && (\n            <NoMoreResults params={searchParams} onChange={onChange} />\n          )}\n        </>\n      )}\n    </Col>\n  )\n}\n\nconst NoResults = () => {\n  const [message] = useState(\n    sample([\n      'no questions found x.x',\n      'no questions found u_u',\n      'no questions found T_T',\n      'no questions found :c',\n      'no questions found :(',\n      'no questions found :(',\n      'no questions found :(',\n      'that search is too bananas for me 🍌',\n      'only nothingness',\n    ])\n  )\n\n  return (\n    <span className=\"text-ink-700 mx-2 my-6 text-center\">\n      {capitalize(message)}\n    </span>\n  )\n}\n\nexport const LoadingContractResults = () => {\n  return (\n    <Col className=\"w-full\">\n      <LoadingContractRow />\n      <LoadingContractRow />\n      <LoadingContractRow />\n    </Col>\n  )\n}\n\nexport const NoMoreResults = (props: {\n  params: SearchParams\n  onChange: (changes: Partial<SearchParams>) => void\n}) => {\n  const { params, onChange } = props\n  const showReset =\n    params[FILTER_KEY] !== 'all' ||\n    params[CONTRACT_TYPE_KEY] !== 'ALL' ||\n    params[PRIZE_MARKET_KEY] === '1'\n  // params[SWEEPIES_KEY] === '1' //TODO\n\n  return (\n    <div className=\"text-ink-500 mx-2 my-8 text-center\">\n      {showReset ? 'No more results under this filter. ' : 'No more results. '}\n      {showReset && (\n        <button\n          className=\"text-primary-500 hover:underline focus:underline\"\n          onClick={() => {\n            onChange({\n              [FILTER_KEY]: 'all',\n              [CONTRACT_TYPE_KEY]: 'ALL',\n              [PRIZE_MARKET_KEY]: '0',\n              // [SWEEPIES_KEY]: '0',\n            })\n          }}\n        >\n          Clear filter\n        </button>\n      )}\n    </div>\n  )\n}\n\nconst FRESH_SEARCH_CHANGED_STATE: SearchState = {\n  contracts: undefined,\n  users: undefined,\n  topics: undefined,\n  shouldLoadMore: true,\n  posts: undefined,\n}\n\nexport const useSearchResults = (props: {\n  persistPrefix: string\n  searchParams: SearchParams\n  includeUsersAndTopics: boolean\n  isReady: boolean\n  additionalFilter?: SupabaseAdditionalFilter\n}) => {\n  const { persistPrefix, searchParams, isReady, additionalFilter } = props\n\n  const [state, setState] = usePersistentInMemoryState<SearchState>(\n    FRESH_SEARCH_CHANGED_STATE,\n    `${persistPrefix}-supabase-contract-search`\n  )\n  const [loading, setLoading] = useState(false)\n\n  const requestId = useRef(0)\n\n  const querySearchResults = useEvent(\n    async (freshQuery?: boolean, contractsOnly?: boolean) => {\n      if (!isReady) return true\n      const {\n        q: query,\n        s: sort,\n        f: filter,\n        ct: contractType,\n        p: isPrizeMarketString,\n        fy: forYou,\n        tf: topicSlug,\n        sw: sweepState,\n        gids,\n        li: liquidity,\n        hb: hasBets,\n      } = searchParams\n\n      const shouldSearchPostsWithContracts =\n        (sort === 'score' || sort === 'newest') &&\n        (!contractsOnly || !!state.posts?.length) &&\n        !topicSlug &&\n        forYou === '0' &&\n        isPrizeMarketString === '0' &&\n        !liquidity &&\n        hasBets === '0' &&\n        (contractType === 'ALL' || contractType === 'POSTS') &&\n        (filter === 'all' || filter === 'open') &&\n        !gids.length &&\n        // There aren't that many posts, so we don't need to wait up for them\n        (state.posts?.length ?? 0) < 20\n\n      const includeUsersAndTopics =\n        !contractsOnly && props.includeUsersAndTopics\n\n      if (freshQuery || state.shouldLoadMore) {\n        const id = ++requestId.current\n        let timeoutId: NodeJS.Timeout | undefined\n        if (freshQuery) {\n          timeoutId = setTimeout(() => {\n            if (id === requestId.current) {\n              setLoading(true)\n            }\n          }, 500)\n        }\n        const postApiParams: APIParams<'get-posts'> = {\n          sortBy: sort === 'score' ? 'importance_score' : 'created_time',\n          term: query,\n          limit: 10,\n          userId: additionalFilter?.creatorId,\n          offset: freshQuery ? 0 : state.posts?.length ?? 0,\n        }\n        try {\n          if (contractType === 'POSTS') {\n            const posts = await api('get-posts', postApiParams)\n            const shouldLoadMore = posts.length === 10\n            setState({\n              contracts: [],\n              users: undefined,\n              topics: undefined,\n              posts: uniqBy(buildArray(state.posts, posts), 'id'),\n              shouldLoadMore,\n            })\n            clearTimeout(timeoutId)\n            setLoading(false)\n            return shouldLoadMore\n          }\n          const searchPromises: Promise<any>[] = [\n            api('search-markets-full', {\n              term: query,\n              filter,\n              sort,\n              contractType,\n              offset: freshQuery ? 0 : state.contracts?.length ?? 0,\n              limit: CONTRACTS_PER_SEARCH_PAGE,\n              topicSlug: topicSlug !== '' ? topicSlug : undefined,\n              creatorId: additionalFilter?.creatorId,\n              isPrizeMarket: isPrizeMarketString,\n              forYou,\n              token:\n                sweepState === '2'\n                  ? 'ALL'\n                  : sweepState === '1'\n                  ? 'CASH'\n                  : 'MANA',\n              gids,\n              liquidity: liquidity === '' ? undefined : parseInt(liquidity),\n              hasBets,\n            }),\n          ]\n\n          if (includeUsersAndTopics) {\n            searchPromises.push(\n              searchUsers(query, USERS_PER_PAGE),\n              searchGroups({\n                term: query,\n                limit: TOPICS_PER_PAGE,\n                type: 'lite',\n              })\n            )\n          }\n          if (shouldSearchPostsWithContracts) {\n            searchPromises.push(api('get-posts', postApiParams))\n          }\n\n          const results = await Promise.all(searchPromises)\n\n          if (id === requestId.current) {\n            const newContracts = results[0] as Contract[]\n            let postResultIndex = 1\n            const newUsers = includeUsersAndTopics\n              ? results[postResultIndex++]\n              : undefined\n            const newTopics = includeUsersAndTopics\n              ? results[postResultIndex++]\n              : undefined\n\n            const newPostsResults =\n              shouldSearchPostsWithContracts &&\n              results.length >= postResultIndex\n                ? (results[postResultIndex] as TopLevelPost[])\n                : undefined\n\n            const freshContracts = freshQuery\n              ? newContracts\n              : buildArray(state.contracts, newContracts)\n            const bottomScoreFromAllContracts =\n              sort === 'score'\n                ? minBy(freshContracts, 'importanceScore')?.importanceScore\n                : minBy(freshContracts, 'createdTime')?.createdTime\n\n            // This is necessary bc the posts are in a different table than the contracts.\n            // TODO: this is bad and will leave posts out of the search results randomly.\n            // We should fix this by joining the posts table to the contracts table or something.\n            let postFilteringThreshold: number | undefined\n            if (sort === 'score') {\n              if (\n                !freshQuery &&\n                state.contracts &&\n                state.contracts.length > 0\n              ) {\n                postFilteringThreshold = minBy(\n                  state.contracts,\n                  'importanceScore'\n                )?.importanceScore\n              } else {\n                postFilteringThreshold = bottomScoreFromAllContracts\n              }\n            } else {\n              if (\n                !freshQuery &&\n                state.contracts &&\n                state.contracts.length > 0\n              ) {\n                postFilteringThreshold = minBy(\n                  state.contracts,\n                  'createdTime'\n                )?.createdTime\n              } else {\n                postFilteringThreshold = bottomScoreFromAllContracts\n              }\n            }\n            const freshPosts =\n              freshQuery || !state.posts\n                ? newPostsResults\n                : uniqBy(\n                    buildArray(\n                      state.posts,\n                      newPostsResults?.filter((p) =>\n                        postFilteringThreshold === undefined\n                          ? true\n                          : sort === 'score'\n                          ? p.importanceScore <= postFilteringThreshold\n                          : p.createdTime <= postFilteringThreshold\n                      )\n                    ),\n                    'id'\n                  )\n\n            const shouldLoadMore =\n              newContracts.length === CONTRACTS_PER_SEARCH_PAGE\n\n            setState({\n              contracts: freshContracts,\n              users: includeUsersAndTopics ? newUsers : state.users,\n              topics: includeUsersAndTopics ? newTopics?.lite : state.topics,\n              posts: freshPosts,\n              shouldLoadMore,\n            })\n            clearTimeout(timeoutId)\n            setLoading(false)\n\n            return shouldLoadMore\n          }\n        } catch (error) {\n          console.error('Error fetching search results:', error)\n          setLoading(false)\n        }\n      }\n      return false\n    }\n  )\n\n  useDebouncedEffect(\n    () => {\n      if (!state.contracts?.length) {\n        querySearchResults(true)\n      }\n    },\n    50,\n    [isReady]\n  )\n  useDebouncedEffect(() => querySearchResults(true), 50, [\n    JSON.stringify(searchParams),\n  ])\n\n  const contracts = state.contracts\n    ? uniqBy(\n        state.contracts.filter((c) => {\n          return (\n            !additionalFilter?.excludeContractIds?.includes(c.id) &&\n            !additionalFilter?.excludeGroupSlugs?.some((slug) =>\n              c.groupSlugs?.includes(slug)\n            ) &&\n            !additionalFilter?.excludeUserIds?.includes(c.creatorId)\n          )\n        }),\n        'id'\n      )\n    : undefined\n\n  return {\n    contracts,\n    users: state.users,\n    topics: state.topics,\n    loading,\n    shouldLoadMore: state.shouldLoadMore,\n    loadMoreContracts: () => querySearchResults(false, true),\n    refreshContracts: () => querySearchResults(true, true),\n    posts: state.posts,\n  }\n}\n\nexport const useSearchQueryState = (props: {\n  persistPrefix: string\n  defaultSort?: Sort\n  defaultFilter?: Filter\n  defaultContractType?: ContractTypeType\n  defaultSearchType?: SearchType\n  defaultPrizeMarket?: '1' | '0'\n  defaultSweepies?: '2' | '1' | '0'\n  defaultForYou?: '1' | '0'\n  useUrlParams?: boolean\n  defaultTopicFilter?: string\n  defaultLiquidityTier?: string\n}) => {\n  const {\n    persistPrefix,\n    defaultSort,\n    defaultFilter,\n    defaultContractType,\n    defaultSearchType,\n    useUrlParams,\n    defaultPrizeMarket,\n    defaultForYou,\n    defaultTopicFilter,\n    defaultSweepies,\n    defaultLiquidityTier,\n  } = props\n\n  const defaults = {\n    [QUERY_KEY]: '',\n    [SORT_KEY]: defaultSort ?? 'score',\n    [FILTER_KEY]: defaultFilter ?? 'all',\n    [CONTRACT_TYPE_KEY]: defaultContractType ?? 'ALL',\n    [SEARCH_TYPE_KEY]: defaultSearchType,\n    [PRIZE_MARKET_KEY]: defaultPrizeMarket ?? '0',\n    [FOR_YOU_KEY]: defaultForYou ?? '0',\n    [TOPIC_FILTER_KEY]: defaultTopicFilter ?? '',\n    [SWEEPIES_KEY]: defaultSweepies ?? '0',\n    [GROUP_IDS_KEY]: '',\n    [LIQUIDITY_KEY]: defaultLiquidityTier ?? '',\n    [HAS_BETS_KEY]: '0' as '0' | '1',\n  }\n\n  const useHook = useUrlParams ? usePersistentQueriesState : useNothing\n  const [queryState, updateQueryState, queryReady] = useHook(\n    defaults,\n    persistPrefix\n  )\n  const [localState, updateLocalState, localReady] = useLocalPartialUpdater(\n    defaults,\n    persistPrefix\n  )\n\n  // copy query state -> local state iff we are using query params and any params are set\n  // only do this once on first load.\n  useEffect(() => {\n    if (\n      queryReady &&\n      localReady &&\n      useUrlParams &&\n      !isEqual(queryState, defaults)\n    ) {\n      updateLocalState(queryState)\n    }\n  }, [queryReady, localReady])\n\n  const setState = useEvent((newState: Partial<SearchParams>) => {\n    updateLocalState(newState)\n    if (useUrlParams) updateQueryState(newState)\n  })\n\n  return [localState, setState, queryReady && localReady] as const\n}\n\n// shim for hook rules and types\nconst useNothing = <T,>(x: T, _: string) =>\n  [x, (_: Partial<T>) => {}, true] as const satisfies any[]\n\nconst useLocalPartialUpdater = <T extends Record<string, string | undefined>>(\n  defaults: T,\n  persistPrefix: string\n) => {\n  const [state, setState, ready] = usePersistentLocalState(\n    defaults,\n    searchLocalKey(persistPrefix)\n  )\n\n  const updateState = (\n    newState: Partial<T> | ((prevState: T) => Partial<T>)\n  ) => {\n    if (typeof newState === 'function') {\n      setState((prevState) => ({ ...prevState, ...newState(prevState) }))\n    } else {\n      setState((prevState) => ({ ...prevState, ...newState }))\n    }\n  }\n\n  // the first copy of data from local state may be missing values, so we return the full state\n  return [{ ...defaults, ...state }, updateState, ready] as const\n}\n\nexport const searchLocalKey = (persistPrefix: string) =>\n  `${persistPrefix}-local-state`\n"
        },
        {
          "path": "web/components/topics/browse-topic-pills.tsx",
          "preContent": "import clsx from 'clsx'\nimport { groupPath, LiteGroup } from 'common/group'\nimport { useState } from 'react'\nimport { Col } from 'web/components/layout/col'\nimport { Row } from 'web/components/layout/row'\nimport { MAX_SHOWN } from '../search/user-results'\nimport { removeEmojis } from 'common/util/string'\nimport Link from 'next/link'\n\nexport const BrowseTopicPills = (props: {\n  topics: LiteGroup[]\n  className?: string\n}) => {\n  const { topics, className } = props\n  const [showMore, setShowMore] = useState<boolean>(false)\n  const shownTopics = showMore ? topics : topics.slice(0, MAX_SHOWN)\n\n  return (\n    <Col className={className}>\n      <Row className={clsx('flex-wrap gap-1 text-sm')}>\n        {shownTopics.map((g) => (\n          <Link\n            prefetch={false}\n            key={g.slug}\n            href={groupPath(g.slug)}\n            className={clsx(\n              'bg-ink-100 hover:bg-ink-200 text-ink-600 rounded p-1'\n            )}\n          >\n            {removeEmojis(g.name)}\n          </Link>\n        ))}\n        {topics.length > MAX_SHOWN && (\n          <button\n            onClick={() => setShowMore(!showMore)}\n            className=\"text-primary-700 bg-ink-100 hover:bg-ink-200 flex flex-row items-center gap-1 rounded p-2 py-1\"\n          >\n            {showMore ? `Show less` : `Show ${topics.length - MAX_SHOWN} more`}\n          </button>\n        )}\n      </Row>\n    </Col>\n  )\n}\n",
          "postContent": "import clsx from 'clsx'\nimport { groupPath, LiteGroup } from 'common/group'\nimport { useState } from 'react'\nimport { Col } from 'web/components/layout/col'\nimport { Row } from 'web/components/layout/row'\nimport { MAX_SHOWN } from '../search/user-results'\nimport { removeEmojis } from 'common/util/string'\nimport Link from 'next/link'\nimport { useIsMobile } from 'web/hooks/use-is-mobile'\nconst MAX_MOBILE_SHOWN = 4\n\nexport const BrowseTopicPills = (props: {\n  topics: LiteGroup[]\n  className?: string\n  clipOnMobile?: boolean\n  initialShown?: number\n}) => {\n  const { topics, className, clipOnMobile = false, initialShown } = props\n  const isMobile = useIsMobile()\n  const [showMore, setShowMore] = useState<boolean>(false)\n  const maxShown =\n    initialShown ?? (isMobile && clipOnMobile ? MAX_MOBILE_SHOWN : MAX_SHOWN)\n  const shownTopics = showMore ? topics : topics.slice(0, maxShown)\n\n  return (\n    <Col className={className}>\n      <Row className={clsx('flex-wrap gap-1 text-sm')}>\n        {shownTopics.map((g) => (\n          <Link\n            prefetch={false}\n            key={g.slug}\n            href={groupPath(g.slug)}\n            className={clsx(\n              'bg-ink-100 hover:bg-ink-200 text-ink-600 rounded p-1'\n            )}\n          >\n            {removeEmojis(g.name)}\n          </Link>\n        ))}\n        {topics.length > maxShown && (\n          <button\n            onClick={() => setShowMore(!showMore)}\n            className=\"text-primary-700 bg-ink-100 hover:bg-ink-200 flex flex-row items-center gap-1 rounded p-2 py-1\"\n          >\n            {showMore ? `Show less` : `Show ${topics.length - maxShown} more`}\n          </button>\n        )}\n      </Row>\n    </Col>\n  )\n}\n"
        }
      ]
    },
    {
      "sha": "691f0f27f181411df00213de925a92cbc4ad045d",
      "author": "Ian Philips",
      "date": "2025-05-19 14:22:07 -0700",
      "message": "Search for bottom_ids when gids are passed",
      "stats": {
        "filesChanged": 3,
        "insertions": 34,
        "deletions": 11
      },
      "selectionReason": "Improves search to handle different ID types - demonstrates database query optimization and flexibility",
      "spec": "Update the market search functionality. When one or more `groupIds` are provided as a filter, the search must retrieve markets belonging to these specified `groupIds` as well as markets belonging to any direct child groups (sub-topics) of these `groupIds`. The system should determine these child groups by identifying all `bottom_id`s associated with the provided `groupIds` (as `top_id`s) in the group hierarchy.",
      "fileStates": [
        {
          "path": "backend/api/src/search-contracts.ts",
          "preContent": "import { z } from 'zod'\nimport { createSupabaseDirectClient } from 'shared/supabase/init'\nimport { type APIHandler } from './helpers/endpoint'\nimport {\n  getSearchContractSQL,\n  getForYouSQL,\n  sortFields,\n  basicSearchSQL,\n  SearchTypes,\n} from 'shared/supabase/search-contracts'\nimport { getGroupIdFromSlug } from 'shared/supabase/groups'\nimport { orderBy, uniqBy } from 'lodash'\nimport { convertContract } from 'common/supabase/contracts'\nimport { log } from 'shared/utils'\nimport { toLiteMarket } from 'common/api/market-types'\nimport { searchProps } from 'common/api/market-search-types'\n\nexport const searchMarketsLite: APIHandler<'search-markets'> = async (\n  props,\n  auth\n) => {\n  const contracts = await search(props, auth?.uid)\n  return contracts.map(toLiteMarket)\n}\n\nexport const searchMarketsFull: APIHandler<'search-markets-full'> = async (\n  props,\n  auth\n) => {\n  return await search(props, auth?.uid)\n}\n\nconst search = async (\n  props: z.infer<typeof searchProps>,\n  userId: string | undefined\n) => {\n  const {\n    term = '',\n    filter,\n    sort,\n    offset,\n    limit,\n    topicSlug: possibleTopicSlug,\n    forYou,\n    token,\n    gids: groupIds,\n  } = props\n  const isPrizeMarket =\n    props.isPrizeMarket == 'true' || props.isPrizeMarket == '1'\n\n  if (limit === 0) {\n    return []\n  }\n\n  const isForYou = forYou === '1'\n  const isRecent = possibleTopicSlug === 'recent'\n  const topicSlug =\n    possibleTopicSlug && !isRecent ? possibleTopicSlug : undefined\n  const pg = createSupabaseDirectClient()\n  const groupId = topicSlug\n    ? await getGroupIdFromSlug(topicSlug, pg)\n    : undefined\n  if (\n    filter !== 'news' &&\n    !term &&\n    !topicSlug &&\n    !groupIds &&\n    (sort === 'score' || sort === 'freshness-score') &&\n    (token === 'MANA' || token === 'ALL') &&\n    !isRecent\n  ) {\n    if (!isForYou || !userId) {\n      return await pg.map(\n        basicSearchSQL({\n          ...props,\n          uid: userId,\n          isPrizeMarket,\n        }),\n        null,\n        convertContract\n      )\n    } else {\n      const forYouSql = await getForYouSQL({\n        ...props,\n        uid: userId,\n        sort,\n        isPrizeMarket,\n      })\n      return await pg.map(forYouSql, [term], (r) => convertContract(r))\n    }\n  } else if (isRecent && !term && userId) {\n    return await pg.map(\n      'select data from get_your_recent_contracts($1, $2, $3)',\n      [userId, limit, offset],\n      convertContract\n    )\n  } else {\n    const cleanTerm = term.replace(/[''\"]/g, '')\n    const searchTypes: SearchTypes[] = [\n      'prefix',\n      'without-stopwords',\n      'answer',\n      'with-stopwords',\n      'description',\n    ]\n\n    const multiQuery = searchTypes\n      .map((searchType) =>\n        getSearchContractSQL({\n          ...props,\n          term: cleanTerm,\n          uid: userId,\n          searchType,\n          groupId,\n          isPrizeMarket,\n          groupIds,\n        })\n      )\n      .join(';')\n\n    const results = await pg.multi(multiQuery).catch((e) => {\n      // to_tsquery is sensitive to special characters and can throw an error\n      log.error(`Error executing search query for term: ${term}`, e)\n      return Array(searchTypes.length).fill([])\n    })\n\n    const [\n      contractPrefixMatches,\n      contractsWithoutStopwords,\n      contractsWithMatchingAnswers,\n      contractsWithStopwords,\n      contractDescriptionMatches,\n    ] = results.map((result, i) =>\n      result.map((r: any) => ({\n        data: convertContract(r),\n        searchType: searchTypes[i],\n      }))\n    )\n\n    const contractsOfSimilarRelevance = orderBy(\n      [\n        ...contractsWithoutStopwords,\n        ...contractsWithMatchingAnswers,\n        ...contractPrefixMatches,\n      ],\n      (c) =>\n        sortFields[sort].sortCallback(c.data) *\n        (c.searchType === 'answer' ? 0.5 : 1),\n      sortFields[sort].order.includes('DESC') ? 'desc' : 'asc'\n    )\n\n    return uniqBy(\n      [\n        ...contractsWithStopwords,\n        ...contractsOfSimilarRelevance,\n        ...contractDescriptionMatches,\n      ].map((c) => c.data),\n      'id'\n    ).slice(0, limit)\n  }\n}\n",
          "postContent": "import { z } from 'zod'\nimport {\n  createSupabaseDirectClient,\n  SupabaseDirectClient,\n} from 'shared/supabase/init'\nimport { type APIHandler } from './helpers/endpoint'\nimport {\n  getSearchContractSQL,\n  getForYouSQL,\n  sortFields,\n  basicSearchSQL,\n  SearchTypes,\n} from 'shared/supabase/search-contracts'\nimport { getGroupIdFromSlug } from 'shared/supabase/groups'\nimport { orderBy, uniqBy } from 'lodash'\nimport { convertContract } from 'common/supabase/contracts'\nimport { log } from 'shared/utils'\nimport { toLiteMarket } from 'common/api/market-types'\nimport { searchProps } from 'common/api/market-search-types'\n\nexport const searchMarketsLite: APIHandler<'search-markets'> = async (\n  props,\n  auth\n) => {\n  const contracts = await search(props, auth?.uid)\n  return contracts.map(toLiteMarket)\n}\n\nexport const searchMarketsFull: APIHandler<'search-markets-full'> = async (\n  props,\n  auth\n) => {\n  return await search(props, auth?.uid)\n}\n\nconst search = async (\n  props: z.infer<typeof searchProps>,\n  userId: string | undefined\n) => {\n  const {\n    term = '',\n    filter,\n    sort,\n    offset,\n    limit,\n    topicSlug: possibleTopicSlug,\n    forYou,\n    token,\n    gids: groupIds,\n  } = props\n  const isPrizeMarket =\n    props.isPrizeMarket == 'true' || props.isPrizeMarket == '1'\n\n  if (limit === 0) {\n    return []\n  }\n\n  const isForYou = forYou === '1'\n  const isRecent = possibleTopicSlug === 'recent'\n  const topicSlug =\n    possibleTopicSlug && !isRecent ? possibleTopicSlug : undefined\n  const pg = createSupabaseDirectClient()\n  const groupId = topicSlug\n    ? await getGroupIdFromSlug(topicSlug, pg)\n    : undefined\n  const groupIdsForSearchSql = await getAllSubTopicsForParentTopicIds(\n    pg,\n    groupIds\n  )\n  if (\n    filter !== 'news' &&\n    !term &&\n    !topicSlug &&\n    !groupIds &&\n    (sort === 'score' || sort === 'freshness-score') &&\n    (token === 'MANA' || token === 'ALL') &&\n    !isRecent\n  ) {\n    if (!isForYou || !userId) {\n      return await pg.map(\n        basicSearchSQL({\n          ...props,\n          uid: userId,\n          isPrizeMarket,\n        }),\n        null,\n        convertContract\n      )\n    } else {\n      const forYouSql = await getForYouSQL({\n        ...props,\n        uid: userId,\n        sort,\n        isPrizeMarket,\n      })\n      return await pg.map(forYouSql, [term], (r) => convertContract(r))\n    }\n  } else if (isRecent && !term && userId) {\n    return await pg.map(\n      'select data from get_your_recent_contracts($1, $2, $3)',\n      [userId, limit, offset],\n      convertContract\n    )\n  } else {\n    const cleanTerm = term.replace(/[''\"]/g, '')\n    const searchTypes: SearchTypes[] = [\n      'prefix',\n      'without-stopwords',\n      'answer',\n      'with-stopwords',\n      'description',\n    ]\n\n    const multiQuery = searchTypes\n      .map((searchType) =>\n        getSearchContractSQL({\n          ...props,\n          term: cleanTerm,\n          uid: userId,\n          searchType,\n          groupId,\n          isPrizeMarket,\n          groupIds: groupIdsForSearchSql,\n        })\n      )\n      .join(';')\n\n    const results = await pg.multi(multiQuery).catch((e) => {\n      // to_tsquery is sensitive to special characters and can throw an error\n      log.error(`Error executing search query for term: ${term}`, e)\n      return Array(searchTypes.length).fill([])\n    })\n\n    const [\n      contractPrefixMatches,\n      contractsWithoutStopwords,\n      contractsWithMatchingAnswers,\n      contractsWithStopwords,\n      contractDescriptionMatches,\n    ] = results.map((result, i) =>\n      result.map((r: any) => ({\n        data: convertContract(r),\n        searchType: searchTypes[i],\n      }))\n    )\n\n    const contractsOfSimilarRelevance = orderBy(\n      [\n        ...contractsWithoutStopwords,\n        ...contractsWithMatchingAnswers,\n        ...contractPrefixMatches,\n      ],\n      (c) =>\n        sortFields[sort].sortCallback(c.data) *\n        (c.searchType === 'answer' ? 0.5 : 1),\n      sortFields[sort].order.includes('DESC') ? 'desc' : 'asc'\n    )\n\n    return uniqBy(\n      [\n        ...contractsWithStopwords,\n        ...contractsOfSimilarRelevance,\n        ...contractDescriptionMatches,\n      ].map((c) => c.data),\n      'id'\n    ).slice(0, limit)\n  }\n}\n\nconst getAllSubTopicsForParentTopicIds = async (\n  pg: SupabaseDirectClient,\n  groupIds: string | undefined\n) => {\n  const initialTopIds = groupIds\n    ? groupIds.split(',').filter((id) => id && id.length > 0)\n    : []\n\n  if (initialTopIds.length > 0) {\n    const bottomGroupIds = await pg.map(\n      `SELECT DISTINCT bottom_id FROM group_groups\n                WHERE top_id in ($1:list) and bottom_id not in ($1:list)`,\n      [initialTopIds],\n      (r) => r.bottom_id\n    )\n    if (bottomGroupIds.length > 0) {\n      return [...initialTopIds, ...bottomGroupIds]\n    }\n  }\n  return initialTopIds\n}\n"
        },
        {
          "path": "backend/shared/src/supabase/search-contracts.ts",
          "preContent": "import { Contract, isSportsContract } from 'common/contract'\nimport { createSupabaseDirectClient } from 'shared/supabase/init'\nimport {\n  from,\n  groupBy,\n  join,\n  leftJoin,\n  limit as sqlLimit,\n  limit as lim,\n  orderBy,\n  renderSql,\n  select,\n  where,\n  withClause,\n} from 'shared/supabase/sql-builder'\nimport { getContractPrivacyWhereSQLFilter } from 'shared/supabase/contracts'\nimport { PROD_MANIFOLD_LOVE_GROUP_SLUG } from 'common/envs/constants'\nimport { constructPrefixTsQuery } from 'shared/helpers/search'\nimport { buildArray, filterDefined } from 'common/util/array'\nimport {\n  buildUserInterestsCache,\n  userIdsToAverageTopicConversionScores,\n} from 'shared/topic-interests'\nimport { contractColumnsToSelectWithPrefix, log } from 'shared/utils'\nimport { PrivateUser } from 'common/user'\nimport { GROUP_SCORE_PRIOR } from 'common/feed'\nimport { tsToMillis } from 'common/supabase/utils'\nimport { answerCostTiers, getTierIndexFromLiquidity } from 'common/tier'\n\nconst DEFAULT_THRESHOLD = 1000\ntype TokenInputType = 'CASH' | 'MANA' | 'ALL' | 'CASH_AND_MANA'\nlet importanceScoreThreshold: number | undefined = undefined\nlet freshnessScoreThreshold: number | undefined = undefined\n\ntype SharedSearchArgs = {\n  filter: string\n  contractType: string\n  limit: number\n  offset: number\n  sort: string\n  token: TokenInputType\n  creatorId?: string\n  uid?: string\n  hasBets?: string\n  liquidity?: number\n  isPrizeMarket?: boolean\n}\n\nexport async function getForYouSQL(\n  args: SharedSearchArgs & {\n    uid: string\n    privateUser?: PrivateUser\n    threshold?: number\n  }\n) {\n  const {\n    limit,\n    offset,\n    sort,\n    privateUser,\n    threshold = DEFAULT_THRESHOLD,\n    hasBets,\n  } = args\n\n  const userId = args.uid\n  // const userId = 'hqdXgp0jK2YMMhPs067eFK4afEH3' // Eliza\n  // if (process.platform === 'darwin') {\n  //   userId = await loadRandomUser()\n  //   log('Searching for random user id:', userId)\n  // }\n\n  const sortByScore = sort === 'score' ? 'importance_score' : 'freshness_score'\n  if (\n    importanceScoreThreshold === undefined ||\n    freshnessScoreThreshold === undefined\n  ) {\n    await loadScoreThresholds(threshold)\n  }\n\n  if (\n    !Object.keys(userIdsToAverageTopicConversionScores[userId] ?? {}).length\n  ) {\n    await buildUserInterestsCache([userId])\n  }\n  // Still no topic interests, return default search\n  if (\n    !Object.keys(userIdsToAverageTopicConversionScores[userId] ?? {}).length\n  ) {\n    return basicSearchSQL({\n      ...args,\n      uid: userId,\n      privateUser,\n    })\n  }\n  const userBetsJoin = hasBets === '1' && userId && userBetsJoinSql\n  const GROUP_SCORE_POWER = 4\n  const forYou = renderSql(\n    buildArray(\n      select(\n        'contracts.*, coalesce(avg(uti.avg_conversion_score),1) as avg_topic_conversion_score'\n      ),\n      from('contracts'),\n      join(`group_contracts on contracts.id = group_contracts.contract_id`),\n      leftJoin(\n        `(select\n          unnest(array[$1]) as group_id,\n          unnest(array[$2]) as avg_conversion_score)\n          as uti on uti.group_id = group_contracts.group_id`,\n        [\n          Object.keys(userIdsToAverageTopicConversionScores[userId]),\n          Object.values(userIdsToAverageTopicConversionScores[userId]),\n        ]\n      ),\n      where(\n        `contracts.id not in (select contract_id from user_disinterests where user_id = $1 and contract_id = contracts.id)`,\n        [userId]\n      ),\n      privateUserBlocksSql(privateUser),\n      withClause(\n        `user_follows as (select follow_id from user_follows where user_id = $1)`,\n        [userId]\n      ),\n      userBetsJoin,\n      getSearchContractWhereSQL({\n        ...args,\n        hideStonks: true,\n      }),\n      offset <= threshold / 2 &&\n        sort === 'score' &&\n        importanceScoreThreshold &&\n        where(`contracts.importance_score > $1`, [importanceScoreThreshold]),\n      offset <= threshold / 2 &&\n        sort === 'freshness-score' &&\n        freshnessScoreThreshold &&\n        where(`contracts.freshness_score > $1`, [freshnessScoreThreshold]),\n      lim(limit, offset),\n      groupBy('contracts.id'),\n      // If user has contract-topic scores, use ONLY the defined topic scores when ranking\n      // If the user has no contract-matching topic score, use only the contract's importance score\n      orderBy(`case\n      when bool_or(contracts.boosted) then avg(contracts.${sortByScore})\n      when bool_or(uti.avg_conversion_score is not null)\n      then avg(power(coalesce(uti.avg_conversion_score, ${GROUP_SCORE_PRIOR}), ${GROUP_SCORE_POWER}) * contracts.${sortByScore})\n      else avg(contracts.${sortByScore}*${GROUP_SCORE_PRIOR})\n      end * (1 + case\n      when bool_or(contracts.creator_id = any(select follow_id from user_follows)) then 0.2\n      else 0.0\n      end)\n      desc`)\n    )\n  )\n  return forYou\n}\n\nexport const basicSearchSQL = (\n  args: SharedSearchArgs & {\n    privateUser?: PrivateUser\n  }\n) => {\n  const { sort, privateUser, ...rest } = args\n  const sortByScore = sort === 'score' ? 'importance_score' : 'freshness_score'\n  const userBetsJoin = args.hasBets === '1' && args.uid && userBetsJoinSql\n  const sql = renderSql(\n    select(contractColumnsToSelectWithPrefix('contracts')),\n    from('contracts'),\n    userBetsJoin,\n    orderBy(`${sortByScore} desc`),\n    getSearchContractWhereSQL({\n      ...rest,\n      hideStonks: true,\n    }),\n    privateUserBlocksSql(privateUser),\n    lim(args.limit, args.offset)\n  )\n  return sql\n}\n\nexport type SearchTypes =\n  | 'without-stopwords'\n  | 'with-stopwords'\n  | 'description'\n  | 'prefix'\n  | 'answer'\n\nexport function getSearchContractSQL(\n  args: SharedSearchArgs & {\n    term: string\n    groupId?: string\n    isForYou?: boolean\n    searchType: SearchTypes\n    groupIds?: string\n  }\n) {\n  const {\n    term,\n    sort,\n    offset,\n    limit,\n    groupId,\n    creatorId,\n    searchType,\n    token,\n    groupIds,\n    filter,\n    uid,\n    hasBets,\n  } = args\n  const hideStonks = sort === 'score' && !term.length && !groupId\n  const hideLove = sort === 'newest' && !term.length && !groupId && !creatorId\n\n  const whereSql = getSearchContractWhereSQL({ ...args, hideStonks, hideLove })\n  const isUrl = term.startsWith('https://manifold.markets/')\n  if (isUrl) {\n    const slug = term.split('/').pop()\n    return renderSql(\n      select(contractColumnsToSelectWithPrefix('contracts')),\n      from('contracts'),\n      whereSql,\n      where('slug = $1', [slug])\n    )\n  }\n\n  const answersSubQuery = renderSql(\n    select('distinct a.contract_id'),\n    from('answers a'),\n    where(`a.text_fts @@ websearch_to_tsquery('english_extended', $1)`, [term])\n  )\n\n  const groupsFilter =\n    (groupIds || groupId) &&\n    where(\n      `\n    exists (\n      select 1 from group_contracts gc \n      where ${\n        token === 'CASH'\n          ? \"gc.contract_id = contracts.data->>'siblingContractId'\"\n          : 'gc.contract_id = contracts.id'\n      }\n      and gc.group_id = any($1)\n    )`,\n      [\n        filterDefined([groupId, groupIds || undefined])\n          .join(',')\n          .split(','),\n      ]\n    )\n\n  // Recent movements filter\n  const newsFilter =\n    filter === 'news' &&\n    withClause(\n      `recent_movements as (\n        select distinct contract_id\n        from contract_movement_notifications\n        where created_time > now() - interval '72 hours'\n      )`\n    )\n\n  const newsJoin =\n    filter === 'news' &&\n    join(`recent_movements rm on rm.contract_id = contracts.id`)\n\n  const newsWhere =\n    filter === 'news' &&\n    term === '' &&\n    where(`coalesce(contracts.data->>'isRanked', 'true')::boolean = true`)\n\n  const userBetsJoin = hasBets === '1' && uid && userBetsJoinSql\n  // Normal full text search\n  const sql = renderSql(\n    select(contractColumnsToSelectWithPrefix('contracts')),\n    from('contracts'),\n    groupsFilter,\n    newsFilter,\n    newsJoin,\n    newsWhere,\n    userBetsJoin,\n    searchType === 'answer' &&\n      join(\n        `(${answersSubQuery}) as matched_answers on matched_answers.contract_id = contracts.id`\n      ),\n\n    whereSql,\n    term.length && [\n      searchType === 'prefix' &&\n        where(\n          `question_fts @@ to_tsquery('english_extended', $1)`,\n          constructPrefixTsQuery(term)\n        ),\n      searchType === 'without-stopwords' &&\n        where(\n          `question_fts @@ websearch_to_tsquery('english_extended', $1)`,\n          term\n        ),\n      searchType === 'with-stopwords' &&\n        where(\n          `question_nostop_fts @@ websearch_to_tsquery('english_nostop_with_prefix', $1)`,\n          term\n        ),\n      searchType === 'description' &&\n        where(\n          `description_fts @@ websearch_to_tsquery('english_extended', $1)`,\n          term\n        ),\n    ],\n\n    orderBy(getSearchContractSortSQL(sort)),\n    sqlLimit(limit, offset)\n  )\n  // log('Search SQL:', sql)\n  return sql\n}\n\nfunction getSearchContractWhereSQL(args: {\n  filter: string\n  sort?: string\n  contractType: string\n  creatorId?: string\n  uid?: string\n  hideStonks?: boolean\n  hideLove?: boolean\n  isPrizeMarket?: boolean\n  token: TokenInputType\n  liquidity?: number\n  hasBets?: string\n}) {\n  const {\n    filter,\n    sort,\n    contractType,\n    creatorId,\n    uid,\n    hideStonks,\n    hideLove,\n    isPrizeMarket,\n    token,\n    liquidity,\n    hasBets,\n  } = args\n  type FilterSQL = Record<string, string>\n  const filterSQL: FilterSQL = {\n    open: 'resolution_time IS NULL AND (close_time > NOW() or close_time is null)',\n    closed: 'close_time < NOW() AND resolution_time IS NULL',\n    'closing-day': `close_time > now() AND close_time < (now() + interval '1 day' + interval '7 hours') AND resolution_time IS NULL`,\n    'closing-week': `close_time > now() AND close_time < (now() + interval '7 days' + interval '7 hours') AND resolution_time IS NULL`,\n    'closing-month': `close_time > now() AND close_time < (now() + interval '30 days' + interval '7 hours') AND resolution_time IS NULL`,\n    'closing-90-days': `close_time > now() AND close_time < (now() + interval '90 days' + interval '7 hours') AND resolution_time IS NULL`,\n    resolved: 'resolution_time IS NOT NULL',\n    news: '', // News filter uses a different approach with a join\n    all: '',\n  }\n  const contractTypeFilter =\n    contractType === 'ALL'\n      ? ''\n      : contractType === 'MULTIPLE_CHOICE'\n      ? `outcome_type = 'FREE_RESPONSE' OR outcome_type = 'MULTIPLE_CHOICE'`\n      : contractType === 'PSEUDO_NUMERIC'\n      ? `outcome_type = 'PSEUDO_NUMERIC' OR outcome_type = 'NUMBER' OR outcome_type = 'MULTI_NUMERIC'`\n      : `outcome_type = '${contractType}'`\n\n  const stonkFilter =\n    hideStonks && contractType !== 'STONK' ? `outcome_type != 'STONK'` : ''\n  const loveFilter = hideLove\n    ? `group_slugs is null or not group_slugs && $1`\n    : ''\n  const sortFilter = sort == 'close-date' ? 'close_time > NOW()' : ''\n  const creatorFilter = creatorId ? `creator_id = '${creatorId}'` : ''\n  const visibilitySQL = getContractPrivacyWhereSQLFilter(\n    uid,\n    'contracts.id',\n    creatorId\n  )\n  const answerLiquidity =\n    answerCostTiers[getTierIndexFromLiquidity(liquidity ?? 0)]\n  const liquidityFilter = liquidity\n    ? `(\n    CASE\n        WHEN mechanism = 'cpmm-multi-1' AND jsonb_typeof(contracts.data->'answers') = 'array' AND jsonb_array_length(contracts.data->'answers') > 0\n        THEN (coalesce((contracts.data->>'totalLiquidity')::numeric, 0) / jsonb_array_length(contracts.data->'answers'))\n        ELSE coalesce((contracts.data->>'totalLiquidity')::numeric, 0)\n    END\n  ) >= case when mechanism = 'cpmm-multi-1' then ${answerLiquidity} else ${liquidity} end`\n    : ''\n  const deletedFilter = `deleted = false`\n\n  const isPrizeMarketFilter = isPrizeMarket ? 'is_spice_payout = true' : ''\n  // User bets filter\n  const userBetsWhere =\n    hasBets === '1' && uid && where('cm.user_id = $1', [uid])\n  const tokenFilter =\n    token === 'CASH'\n      ? `token = 'CASH'`\n      : token === 'MANA'\n      ? `token = 'MANA'`\n      : token === 'CASH_AND_MANA'\n      ? `contracts.data->>'siblingContractId' is not null`\n      : ''\n\n  return [\n    where(filterSQL[filter]),\n    where(stonkFilter),\n    where(loveFilter, [[PROD_MANIFOLD_LOVE_GROUP_SLUG]]),\n    where(sortFilter),\n    where(contractTypeFilter),\n    where(liquidityFilter),\n    where(visibilitySQL),\n    where(creatorFilter),\n    where(deletedFilter),\n    where(isPrizeMarketFilter),\n    where(tokenFilter),\n    userBetsWhere,\n  ]\n}\n\ntype SortFields = Record<\n  string,\n  {\n    sql: string\n    sortCallback: (c: Contract) => number\n    order: 'ASC' | 'DESC' | 'DESC NULLS LAST'\n  }\n>\nexport const sortFields: SortFields = {\n  score: {\n    sql: `importance_score::numeric desc, unique_bettor_count`,\n    sortCallback: (c: Contract) =>\n      c.importanceScore > 0 ? c.importanceScore : c.uniqueBettorCount,\n    order: 'DESC',\n  },\n  'daily-score': {\n    sql: 'daily_score',\n    sortCallback: (c: Contract) => c.dailyScore,\n    order: 'DESC',\n  },\n  'freshness-score': {\n    sql: 'freshness_score',\n    sortCallback: (c: Contract) => c.freshnessScore,\n    order: 'DESC',\n  },\n  '24-hour-vol': {\n    sql: \"(contracts.data->>'volume24Hours')::numeric\",\n    sortCallback: (c: Contract) => c.volume24Hours,\n    order: 'DESC',\n  },\n  liquidity: {\n    sql: \"(contracts.data->>'elasticity')::numeric\",\n    sortCallback: (c: Contract) => c.elasticity,\n    order: 'ASC',\n  },\n  subsidy: {\n    sql: \"COALESCE((contracts.data->>'totalLiquidity')::numeric, 0)\",\n    sortCallback: (c: Contract) =>\n      c.mechanism === 'cpmm-1' || c.mechanism === 'cpmm-multi-1'\n        ? c.totalLiquidity\n        : 0,\n    order: 'DESC',\n  },\n\n  'last-updated': {\n    sql: 'last_updated_time',\n    sortCallback: (c: Contract) => c.lastUpdatedTime,\n    order: 'DESC',\n  },\n  'most-popular': {\n    sql: 'unique_bettor_count',\n    sortCallback: (c: Contract) => c.uniqueBettorCount,\n    order: 'DESC',\n  },\n  newest: {\n    sql: 'created_time',\n    sortCallback: (c: Contract) => c.createdTime,\n    order: 'DESC',\n  },\n  'resolve-date': {\n    sql: 'resolution_time',\n    sortCallback: (c: Contract) => c.resolutionTime ?? 0,\n    order: 'DESC NULLS LAST',\n  },\n  'close-date': {\n    sql: 'close_time',\n    sortCallback: (c: Contract) => c.closeTime ?? Infinity,\n    order: 'ASC',\n  },\n  'start-time': {\n    // sql: `close_time`,\n    sql: `coalesce((contracts.data->>'sportsStartTimestamp')::timestamp with time zone, close_time)`,\n    sortCallback: (c: Contract) =>\n      isSportsContract(c)\n        ? tsToMillis(c.sportsStartTimestamp)\n        : c.closeTime ?? Infinity,\n    order: 'ASC',\n  },\n  random: {\n    sql: 'random()',\n    sortCallback: () => Math.random(),\n    order: 'DESC',\n  },\n  'bounty-amount': {\n    sql: \"COALESCE((contracts.data->>'bountyLeft')::numeric, -1)\",\n    sortCallback: (c: Contract) => ('bountyLeft' in c && c.bountyLeft) || -1,\n    order: 'DESC',\n  },\n  'prob-descending': {\n    sql: \"resolution DESC, (contracts.data->>'p')::numeric\",\n    sortCallback: (c: Contract) => ('p' in c && c.p) || 0,\n    order: 'DESC NULLS LAST',\n  },\n  'prob-ascending': {\n    sql: \"resolution DESC, (contracts.data->>'p')::numeric\",\n    sortCallback: (c: Contract) => ('p' in c && c.p) || 0,\n    order: 'ASC',\n  },\n}\nfunction getSearchContractSortSQL(sort: string) {\n  return `${sortFields[sort].sql} ${sortFields[sort].order}`\n}\n\nconst loadScoreThresholds = async (threshold: number) => {\n  const pg = createSupabaseDirectClient()\n  importanceScoreThreshold = await pg.one(\n    `\n        with ranked_contracts as (select importance_score,\n                                         row_number() over (order by importance_score desc) as rn\n                                  from contracts)\n        select importance_score\n        from ranked_contracts\n        where rn = $1;`,\n    [threshold],\n    (r) => r.importance_score as number\n  )\n  freshnessScoreThreshold = await pg.one(\n    `\n        with ranked_contracts as (select freshness_score,\n                                         row_number() over (order by freshness_score desc) as rn\n                                  from contracts)\n        select freshness_score\n        from ranked_contracts\n        where rn = $1;`,\n    [threshold],\n    (r) => r.freshness_score as number\n  )\n  log('Loaded importance score threshold:', importanceScoreThreshold)\n  log('Loaded freshness score threshold:', freshnessScoreThreshold)\n}\n\nconst loadRandomUser = async () => {\n  const pg = createSupabaseDirectClient()\n  return await pg.one(\n    `SELECT user_id AS id FROM user_contract_interactions\n    WHERE created_time > now() - interval '1 week' and created_time < now() - interval '5 days'\n    ORDER BY random() LIMIT 1`,\n    [],\n    (r) => r.id as string\n  )\n}\n\nexport const privateUserBlocksSql = (privateUser?: PrivateUser) => {\n  const {\n    blockedByUserIds,\n    blockedContractIds,\n    blockedUserIds,\n    blockedGroupSlugs,\n  } = privateUser ?? {\n    blockedByUserIds: [] as string[],\n    blockedContractIds: [] as string[],\n    blockedUserIds: [] as string[],\n    blockedGroupSlugs: [] as string[],\n  }\n  const blockedIds = blockedUserIds.concat(blockedByUserIds)\n  const blockedGroupsQuery = renderSql(\n    select('1'),\n    from(`group_contracts gc`),\n    join(`groups g on gc.group_id = g.id`),\n    where(`gc.contract_id = contracts.id`),\n    where(`g.slug = any(array[$1])`, [blockedGroupSlugs])\n  )\n  return buildArray(\n    blockedIds.length > 0 &&\n      where(`contracts.creator_id <> all(array[$1])`, [blockedIds]),\n    blockedContractIds.length > 0 &&\n      where(`contracts.id <> all(array[$1])`, [blockedContractIds]),\n    blockedGroupSlugs.length > 0 && where(`not exists (${blockedGroupsQuery})`)\n  )\n}\n\nconst userBetsJoinSql = join(\n  `user_contract_metrics cm on cm.contract_id = contracts.id and cm.answer_id is null and cm.has_shares`\n)\n",
          "postContent": "import { Contract, isSportsContract } from 'common/contract'\nimport { createSupabaseDirectClient } from 'shared/supabase/init'\nimport {\n  from,\n  groupBy,\n  join,\n  leftJoin,\n  limit as sqlLimit,\n  limit as lim,\n  orderBy,\n  renderSql,\n  select,\n  where,\n  withClause,\n} from 'shared/supabase/sql-builder'\nimport { getContractPrivacyWhereSQLFilter } from 'shared/supabase/contracts'\nimport { PROD_MANIFOLD_LOVE_GROUP_SLUG } from 'common/envs/constants'\nimport { constructPrefixTsQuery } from 'shared/helpers/search'\nimport { buildArray, filterDefined } from 'common/util/array'\nimport {\n  buildUserInterestsCache,\n  userIdsToAverageTopicConversionScores,\n} from 'shared/topic-interests'\nimport { contractColumnsToSelectWithPrefix, log } from 'shared/utils'\nimport { PrivateUser } from 'common/user'\nimport { GROUP_SCORE_PRIOR } from 'common/feed'\nimport { tsToMillis } from 'common/supabase/utils'\nimport { answerCostTiers, getTierIndexFromLiquidity } from 'common/tier'\n\nconst DEFAULT_THRESHOLD = 1000\ntype TokenInputType = 'CASH' | 'MANA' | 'ALL' | 'CASH_AND_MANA'\nlet importanceScoreThreshold: number | undefined = undefined\nlet freshnessScoreThreshold: number | undefined = undefined\n\ntype SharedSearchArgs = {\n  filter: string\n  contractType: string\n  limit: number\n  offset: number\n  sort: string\n  token: TokenInputType\n  creatorId?: string\n  uid?: string\n  hasBets?: string\n  liquidity?: number\n  isPrizeMarket?: boolean\n}\n\nexport async function getForYouSQL(\n  args: SharedSearchArgs & {\n    uid: string\n    privateUser?: PrivateUser\n    threshold?: number\n  }\n) {\n  const {\n    limit,\n    offset,\n    sort,\n    privateUser,\n    threshold = DEFAULT_THRESHOLD,\n    hasBets,\n  } = args\n\n  const userId = args.uid\n  // const userId = 'hqdXgp0jK2YMMhPs067eFK4afEH3' // Eliza\n  // if (process.platform === 'darwin') {\n  //   userId = await loadRandomUser()\n  //   log('Searching for random user id:', userId)\n  // }\n\n  const sortByScore = sort === 'score' ? 'importance_score' : 'freshness_score'\n  if (\n    importanceScoreThreshold === undefined ||\n    freshnessScoreThreshold === undefined\n  ) {\n    await loadScoreThresholds(threshold)\n  }\n\n  if (\n    !Object.keys(userIdsToAverageTopicConversionScores[userId] ?? {}).length\n  ) {\n    await buildUserInterestsCache([userId])\n  }\n  // Still no topic interests, return default search\n  if (\n    !Object.keys(userIdsToAverageTopicConversionScores[userId] ?? {}).length\n  ) {\n    return basicSearchSQL({\n      ...args,\n      uid: userId,\n      privateUser,\n    })\n  }\n  const userBetsJoin = hasBets === '1' && userId && userBetsJoinSql\n  const GROUP_SCORE_POWER = 4\n  const forYou = renderSql(\n    buildArray(\n      select(\n        'contracts.*, coalesce(avg(uti.avg_conversion_score),1) as avg_topic_conversion_score'\n      ),\n      from('contracts'),\n      join(`group_contracts on contracts.id = group_contracts.contract_id`),\n      leftJoin(\n        `(select\n          unnest(array[$1]) as group_id,\n          unnest(array[$2]) as avg_conversion_score)\n          as uti on uti.group_id = group_contracts.group_id`,\n        [\n          Object.keys(userIdsToAverageTopicConversionScores[userId]),\n          Object.values(userIdsToAverageTopicConversionScores[userId]),\n        ]\n      ),\n      where(\n        `contracts.id not in (select contract_id from user_disinterests where user_id = $1 and contract_id = contracts.id)`,\n        [userId]\n      ),\n      privateUserBlocksSql(privateUser),\n      withClause(\n        `user_follows as (select follow_id from user_follows where user_id = $1)`,\n        [userId]\n      ),\n      userBetsJoin,\n      getSearchContractWhereSQL({\n        ...args,\n        hideStonks: true,\n      }),\n      offset <= threshold / 2 &&\n        sort === 'score' &&\n        importanceScoreThreshold &&\n        where(`contracts.importance_score > $1`, [importanceScoreThreshold]),\n      offset <= threshold / 2 &&\n        sort === 'freshness-score' &&\n        freshnessScoreThreshold &&\n        where(`contracts.freshness_score > $1`, [freshnessScoreThreshold]),\n      lim(limit, offset),\n      groupBy('contracts.id'),\n      // If user has contract-topic scores, use ONLY the defined topic scores when ranking\n      // If the user has no contract-matching topic score, use only the contract's importance score\n      orderBy(`case\n      when bool_or(contracts.boosted) then avg(contracts.${sortByScore})\n      when bool_or(uti.avg_conversion_score is not null)\n      then avg(power(coalesce(uti.avg_conversion_score, ${GROUP_SCORE_PRIOR}), ${GROUP_SCORE_POWER}) * contracts.${sortByScore})\n      else avg(contracts.${sortByScore}*${GROUP_SCORE_PRIOR})\n      end * (1 + case\n      when bool_or(contracts.creator_id = any(select follow_id from user_follows)) then 0.2\n      else 0.0\n      end)\n      desc`)\n    )\n  )\n  return forYou\n}\n\nexport const basicSearchSQL = (\n  args: SharedSearchArgs & {\n    privateUser?: PrivateUser\n  }\n) => {\n  const { sort, privateUser, ...rest } = args\n  const sortByScore = sort === 'score' ? 'importance_score' : 'freshness_score'\n  const userBetsJoin = args.hasBets === '1' && args.uid && userBetsJoinSql\n  const sql = renderSql(\n    select(contractColumnsToSelectWithPrefix('contracts')),\n    from('contracts'),\n    userBetsJoin,\n    orderBy(`${sortByScore} desc`),\n    getSearchContractWhereSQL({\n      ...rest,\n      hideStonks: true,\n    }),\n    privateUserBlocksSql(privateUser),\n    lim(args.limit, args.offset)\n  )\n  return sql\n}\n\nexport type SearchTypes =\n  | 'without-stopwords'\n  | 'with-stopwords'\n  | 'description'\n  | 'prefix'\n  | 'answer'\n\nexport function getSearchContractSQL(\n  args: SharedSearchArgs & {\n    term: string\n    groupId?: string\n    isForYou?: boolean\n    searchType: SearchTypes\n    groupIds?: string[]\n  }\n) {\n  const {\n    term,\n    sort,\n    offset,\n    limit,\n    groupId,\n    creatorId,\n    searchType,\n    token,\n    groupIds,\n    filter,\n    uid,\n    hasBets,\n  } = args\n  const hideStonks = sort === 'score' && !term.length && !groupId\n  const hideLove = sort === 'newest' && !term.length && !groupId && !creatorId\n\n  const whereSql = getSearchContractWhereSQL({ ...args, hideStonks, hideLove })\n  const isUrl = term.startsWith('https://manifold.markets/')\n  if (isUrl) {\n    const slug = term.split('/').pop()\n    return renderSql(\n      select(contractColumnsToSelectWithPrefix('contracts')),\n      from('contracts'),\n      whereSql,\n      where('slug = $1', [slug])\n    )\n  }\n\n  const answersSubQuery = renderSql(\n    select('distinct a.contract_id'),\n    from('answers a'),\n    where(`a.text_fts @@ websearch_to_tsquery('english_extended', $1)`, [term])\n  )\n\n  const groupsFilter =\n    (groupIds?.length || groupId) &&\n    where(\n      `\n    exists (\n      select 1 from group_contracts gc \n      where ${\n        token === 'CASH'\n          ? \"gc.contract_id = contracts.data->>'siblingContractId'\"\n          : 'gc.contract_id = contracts.id'\n      }\n      and gc.group_id = any($1)\n    )`,\n      [filterDefined([groupId, ...(groupIds ?? [])])]\n    )\n\n  // Recent movements filter\n  const newsFilter =\n    filter === 'news' &&\n    withClause(\n      `recent_movements as (\n        select distinct contract_id\n        from contract_movement_notifications\n        where created_time > now() - interval '72 hours'\n      )`\n    )\n\n  const newsJoin =\n    filter === 'news' &&\n    join(`recent_movements rm on rm.contract_id = contracts.id`)\n\n  const newsWhere =\n    filter === 'news' &&\n    term === '' &&\n    where(`coalesce(contracts.data->>'isRanked', 'true')::boolean = true`)\n\n  const userBetsJoin = hasBets === '1' && uid && userBetsJoinSql\n  // Normal full text search\n  const sql = renderSql(\n    select(contractColumnsToSelectWithPrefix('contracts')),\n    from('contracts'),\n    groupsFilter,\n    newsFilter,\n    newsJoin,\n    newsWhere,\n    userBetsJoin,\n    searchType === 'answer' &&\n      join(\n        `(${answersSubQuery}) as matched_answers on matched_answers.contract_id = contracts.id`\n      ),\n\n    whereSql,\n    term.length && [\n      searchType === 'prefix' &&\n        where(\n          `question_fts @@ to_tsquery('english_extended', $1)`,\n          constructPrefixTsQuery(term)\n        ),\n      searchType === 'without-stopwords' &&\n        where(\n          `question_fts @@ websearch_to_tsquery('english_extended', $1)`,\n          term\n        ),\n      searchType === 'with-stopwords' &&\n        where(\n          `question_nostop_fts @@ websearch_to_tsquery('english_nostop_with_prefix', $1)`,\n          term\n        ),\n      searchType === 'description' &&\n        where(\n          `description_fts @@ websearch_to_tsquery('english_extended', $1)`,\n          term\n        ),\n    ],\n\n    orderBy(getSearchContractSortSQL(sort)),\n    sqlLimit(limit, offset)\n  )\n  // log('Search SQL:', sql)\n  return sql\n}\n\nfunction getSearchContractWhereSQL(args: {\n  filter: string\n  sort?: string\n  contractType: string\n  creatorId?: string\n  uid?: string\n  hideStonks?: boolean\n  hideLove?: boolean\n  isPrizeMarket?: boolean\n  token: TokenInputType\n  liquidity?: number\n  hasBets?: string\n}) {\n  const {\n    filter,\n    sort,\n    contractType,\n    creatorId,\n    uid,\n    hideStonks,\n    hideLove,\n    isPrizeMarket,\n    token,\n    liquidity,\n    hasBets,\n  } = args\n  type FilterSQL = Record<string, string>\n  const filterSQL: FilterSQL = {\n    open: 'resolution_time IS NULL AND (close_time > NOW() or close_time is null)',\n    closed: 'close_time < NOW() AND resolution_time IS NULL',\n    'closing-day': `close_time > now() AND close_time < (now() + interval '1 day' + interval '7 hours') AND resolution_time IS NULL`,\n    'closing-week': `close_time > now() AND close_time < (now() + interval '7 days' + interval '7 hours') AND resolution_time IS NULL`,\n    'closing-month': `close_time > now() AND close_time < (now() + interval '30 days' + interval '7 hours') AND resolution_time IS NULL`,\n    'closing-90-days': `close_time > now() AND close_time < (now() + interval '90 days' + interval '7 hours') AND resolution_time IS NULL`,\n    resolved: 'resolution_time IS NOT NULL',\n    news: '', // News filter uses a different approach with a join\n    all: '',\n  }\n  const contractTypeFilter =\n    contractType === 'ALL'\n      ? ''\n      : contractType === 'MULTIPLE_CHOICE'\n      ? `outcome_type = 'FREE_RESPONSE' OR outcome_type = 'MULTIPLE_CHOICE'`\n      : contractType === 'PSEUDO_NUMERIC'\n      ? `outcome_type = 'PSEUDO_NUMERIC' OR outcome_type = 'NUMBER' OR outcome_type = 'MULTI_NUMERIC'`\n      : `outcome_type = '${contractType}'`\n\n  const stonkFilter =\n    hideStonks && contractType !== 'STONK' ? `outcome_type != 'STONK'` : ''\n  const loveFilter = hideLove\n    ? `group_slugs is null or not group_slugs && $1`\n    : ''\n  const sortFilter = sort == 'close-date' ? 'close_time > NOW()' : ''\n  const creatorFilter = creatorId ? `creator_id = '${creatorId}'` : ''\n  const visibilitySQL = getContractPrivacyWhereSQLFilter(\n    uid,\n    'contracts.id',\n    creatorId\n  )\n  const answerLiquidity =\n    answerCostTiers[getTierIndexFromLiquidity(liquidity ?? 0)]\n  const liquidityFilter = liquidity\n    ? `(\n    CASE\n        WHEN mechanism = 'cpmm-multi-1' AND jsonb_typeof(contracts.data->'answers') = 'array' AND jsonb_array_length(contracts.data->'answers') > 0\n        THEN (coalesce((contracts.data->>'totalLiquidity')::numeric, 0) / jsonb_array_length(contracts.data->'answers'))\n        ELSE coalesce((contracts.data->>'totalLiquidity')::numeric, 0)\n    END\n  ) >= case when mechanism = 'cpmm-multi-1' then ${answerLiquidity} else ${liquidity} end`\n    : ''\n  const deletedFilter = `deleted = false`\n\n  const isPrizeMarketFilter = isPrizeMarket ? 'is_spice_payout = true' : ''\n  // User bets filter\n  const userBetsWhere =\n    hasBets === '1' && uid && where('cm.user_id = $1', [uid])\n  const tokenFilter =\n    token === 'CASH'\n      ? `token = 'CASH'`\n      : token === 'MANA'\n      ? `token = 'MANA'`\n      : token === 'CASH_AND_MANA'\n      ? `contracts.data->>'siblingContractId' is not null`\n      : ''\n\n  return [\n    where(filterSQL[filter]),\n    where(stonkFilter),\n    where(loveFilter, [[PROD_MANIFOLD_LOVE_GROUP_SLUG]]),\n    where(sortFilter),\n    where(contractTypeFilter),\n    where(liquidityFilter),\n    where(visibilitySQL),\n    where(creatorFilter),\n    where(deletedFilter),\n    where(isPrizeMarketFilter),\n    where(tokenFilter),\n    userBetsWhere,\n  ]\n}\n\ntype SortFields = Record<\n  string,\n  {\n    sql: string\n    sortCallback: (c: Contract) => number\n    order: 'ASC' | 'DESC' | 'DESC NULLS LAST'\n  }\n>\nexport const sortFields: SortFields = {\n  score: {\n    sql: `importance_score::numeric desc, unique_bettor_count`,\n    sortCallback: (c: Contract) =>\n      c.importanceScore > 0 ? c.importanceScore : c.uniqueBettorCount,\n    order: 'DESC',\n  },\n  'daily-score': {\n    sql: 'daily_score',\n    sortCallback: (c: Contract) => c.dailyScore,\n    order: 'DESC',\n  },\n  'freshness-score': {\n    sql: 'freshness_score',\n    sortCallback: (c: Contract) => c.freshnessScore,\n    order: 'DESC',\n  },\n  '24-hour-vol': {\n    sql: \"(contracts.data->>'volume24Hours')::numeric\",\n    sortCallback: (c: Contract) => c.volume24Hours,\n    order: 'DESC',\n  },\n  liquidity: {\n    sql: \"(contracts.data->>'elasticity')::numeric\",\n    sortCallback: (c: Contract) => c.elasticity,\n    order: 'ASC',\n  },\n  subsidy: {\n    sql: \"COALESCE((contracts.data->>'totalLiquidity')::numeric, 0)\",\n    sortCallback: (c: Contract) =>\n      c.mechanism === 'cpmm-1' || c.mechanism === 'cpmm-multi-1'\n        ? c.totalLiquidity\n        : 0,\n    order: 'DESC',\n  },\n\n  'last-updated': {\n    sql: 'last_updated_time',\n    sortCallback: (c: Contract) => c.lastUpdatedTime,\n    order: 'DESC',\n  },\n  'most-popular': {\n    sql: 'unique_bettor_count',\n    sortCallback: (c: Contract) => c.uniqueBettorCount,\n    order: 'DESC',\n  },\n  newest: {\n    sql: 'created_time',\n    sortCallback: (c: Contract) => c.createdTime,\n    order: 'DESC',\n  },\n  'resolve-date': {\n    sql: 'resolution_time',\n    sortCallback: (c: Contract) => c.resolutionTime ?? 0,\n    order: 'DESC NULLS LAST',\n  },\n  'close-date': {\n    sql: 'close_time',\n    sortCallback: (c: Contract) => c.closeTime ?? Infinity,\n    order: 'ASC',\n  },\n  'start-time': {\n    // sql: `close_time`,\n    sql: `coalesce((contracts.data->>'sportsStartTimestamp')::timestamp with time zone, close_time)`,\n    sortCallback: (c: Contract) =>\n      isSportsContract(c)\n        ? tsToMillis(c.sportsStartTimestamp)\n        : c.closeTime ?? Infinity,\n    order: 'ASC',\n  },\n  random: {\n    sql: 'random()',\n    sortCallback: () => Math.random(),\n    order: 'DESC',\n  },\n  'bounty-amount': {\n    sql: \"COALESCE((contracts.data->>'bountyLeft')::numeric, -1)\",\n    sortCallback: (c: Contract) => ('bountyLeft' in c && c.bountyLeft) || -1,\n    order: 'DESC',\n  },\n  'prob-descending': {\n    sql: \"resolution DESC, (contracts.data->>'p')::numeric\",\n    sortCallback: (c: Contract) => ('p' in c && c.p) || 0,\n    order: 'DESC NULLS LAST',\n  },\n  'prob-ascending': {\n    sql: \"resolution DESC, (contracts.data->>'p')::numeric\",\n    sortCallback: (c: Contract) => ('p' in c && c.p) || 0,\n    order: 'ASC',\n  },\n}\nfunction getSearchContractSortSQL(sort: string) {\n  return `${sortFields[sort].sql} ${sortFields[sort].order}`\n}\n\nconst loadScoreThresholds = async (threshold: number) => {\n  const pg = createSupabaseDirectClient()\n  importanceScoreThreshold = await pg.one(\n    `\n        with ranked_contracts as (select importance_score,\n                                         row_number() over (order by importance_score desc) as rn\n                                  from contracts)\n        select importance_score\n        from ranked_contracts\n        where rn = $1;`,\n    [threshold],\n    (r) => r.importance_score as number\n  )\n  freshnessScoreThreshold = await pg.one(\n    `\n        with ranked_contracts as (select freshness_score,\n                                         row_number() over (order by freshness_score desc) as rn\n                                  from contracts)\n        select freshness_score\n        from ranked_contracts\n        where rn = $1;`,\n    [threshold],\n    (r) => r.freshness_score as number\n  )\n  log('Loaded importance score threshold:', importanceScoreThreshold)\n  log('Loaded freshness score threshold:', freshnessScoreThreshold)\n}\n\nconst loadRandomUser = async () => {\n  const pg = createSupabaseDirectClient()\n  return await pg.one(\n    `SELECT user_id AS id FROM user_contract_interactions\n    WHERE created_time > now() - interval '1 week' and created_time < now() - interval '5 days'\n    ORDER BY random() LIMIT 1`,\n    [],\n    (r) => r.id as string\n  )\n}\n\nexport const privateUserBlocksSql = (privateUser?: PrivateUser) => {\n  const {\n    blockedByUserIds,\n    blockedContractIds,\n    blockedUserIds,\n    blockedGroupSlugs,\n  } = privateUser ?? {\n    blockedByUserIds: [] as string[],\n    blockedContractIds: [] as string[],\n    blockedUserIds: [] as string[],\n    blockedGroupSlugs: [] as string[],\n  }\n  const blockedIds = blockedUserIds.concat(blockedByUserIds)\n  const blockedGroupsQuery = renderSql(\n    select('1'),\n    from(`group_contracts gc`),\n    join(`groups g on gc.group_id = g.id`),\n    where(`gc.contract_id = contracts.id`),\n    where(`g.slug = any(array[$1])`, [blockedGroupSlugs])\n  )\n  return buildArray(\n    blockedIds.length > 0 &&\n      where(`contracts.creator_id <> all(array[$1])`, [blockedIds]),\n    blockedContractIds.length > 0 &&\n      where(`contracts.id <> all(array[$1])`, [blockedContractIds]),\n    blockedGroupSlugs.length > 0 && where(`not exists (${blockedGroupsQuery})`)\n  )\n}\n\nconst userBetsJoinSql = join(\n  `user_contract_metrics cm on cm.contract_id = contracts.id and cm.answer_id is null and cm.has_shares`\n)\n"
        },
        {
          "path": "common/src/topics.ts",
          "preContent": "import {\n  HIDE_FROM_NEW_USER_SLUGS,\n  PROD_MANIFOLD_LOVE_GROUP_SLUG,\n} from 'common/envs/constants'\nimport { removeEmojis } from './util/string'\n\ntype TopicInfo = { name: string; groupIds: string[]; hideFromSearch?: boolean }\n\nexport const TOPICS_TO_SUBTOPICS: { [key: string]: TopicInfo[] } = {\n  '🗳️ Politics': [\n    {\n      // US Politics\n      name: '🇺🇸 USA',\n      groupIds: [\n        'AjxQR8JMpNyDqtiqoA96', // US Politics\n        'cEzcLXuitr6o4VPI01Q1', // Trump\n        '46e04289-2b15-4997-841b-b8e1d5175c39', // trump's second term\n        'EWgcYV1JYWP19dE3BZCb', // republican party\n      ],\n    },\n    { name: '🇨🇳 China', groupIds: ['oWTzfoeemQGkSoPFn2T7'] },\n    {\n      // Ukraine-Russia War, Russia, Ukraine\n      name: '🇷🇺🇺🇦 Russia & Ukraine',\n      groupIds: [\n        'OxcXOuxXvwsXtC0Dx5sr',\n        'TIpf6j0hLpifpXN93FxE',\n        '0AKCBNjWsHwpfmPOsGf6',\n      ],\n    },\n    {\n      name: '🇮🇱🇵🇸 Israel & Hamas',\n      groupIds: [\n        'cea99c1c-afb9-49b2-adfa-9be739adce10',\n        'ECjphikMbmosJsDAAJoU', // Israel\n      ],\n    },\n    { name: '🇬🇧 UK', groupIds: ['aavkiDd6uZggfL3geuV2'] },\n    { name: '🇪🇺 Europe', groupIds: ['ue52QI4BQgJgAJJNjLHr'] },\n    { name: '🇮🇳 India', groupIds: ['Y2J00UcVhr3wKq2lAOAy'] },\n    { name: '🌎 LatAm', groupIds: ['DX94A1LQmpckcVdz5Hb3'] },\n    { name: '🌏 Africa', groupIds: ['dFsZaGwyohGDVkJi1C3E'] },\n    { name: '🌏 Middle East', groupIds: ['xg8wCPeM9JP6gD0igBrA'] },\n    { name: '🌎 Asia', groupIds: ['bPTxMZhUYsIUXsWT969d'] },\n    {\n      name: '🌐 Politics',\n      groupIds: [\n        'UCnpxVUdLOZYgoMsDlHD', // Politics default\n        'XUjgI120xjTU5n382rWL', // Canadian Politics\n      ],\n      hideFromSearch: true,\n    },\n  ],\n  '🤖 AI': [\n    {\n      name: 'AI',\n      groupIds: ['yEWvvwFFIqzf8JklMewp'],\n      hideFromSearch: true,\n    },\n    {\n      name: 'Timelines',\n      groupIds: ['GbbX9U5pYnDeftX9lxUh'],\n    },\n\n    {\n      name: 'OpenAI',\n      groupIds: ['a3ikurqO9fT46Pv9ZGkY'],\n    },\n    {\n      name: 'AI Impacts & Safety',\n      groupIds: ['DnxTZ1P5XEEfnHxy7Q7d', 'q3Su0NeV9ta4DqhqlIEq'],\n    },\n    {\n      name: 'Anthropic',\n      groupIds: ['B8jfqGL9Uqu5nejktmVi'],\n    },\n  ],\n  '💻 Tech': [\n    {\n      name: '💻 Technology',\n      groupIds: [\n        'IlzY3moWwOcpsVZXCVej', // Technology\n        'SmJk6RHToaLxLk0I1ZSC', // Space\n      ],\n    },\n    {\n      name: '🔬 Science',\n      groupIds: [\n        'XMhZ5LbQoLMZiOpQJRnj', // Science\n        '97oNExy8iFftY2EgdkLw', // Climate\n      ],\n    },\n    {\n      name: '🏥 Health',\n      groupIds: ['JpUqUqRn9sSWxrk0Sq35'],\n    },\n    {\n      name: '👨‍💻 Code',\n      groupIds: ['PZJMbrLekgJBy7OOBKGT'],\n    },\n    {\n      name: '🧮 Math',\n      groupIds: ['S1tbcVt1t5Bd9O5mVCx1'],\n    },\n  ],\n  '🏟️ Sports': [\n    {\n      name: '🏀 Basketball',\n      groupIds: [\n        'NjkFkdkvRvBHoeMDQ5NB', // Basketball\n        'beeb69e0-b36f-451a-80e1-e059df456bb1', // College Basketball\n        'i0v3cXwuxmO9fpcInVYb', // NBA\n      ],\n    },\n    {\n      // NFL, College Football\n      name: '🏈 NFL',\n      groupIds: ['TNQwmbE5p6dnKx2e6Qlp', 'ky1VPTuxrLXMnHyajZFp'],\n    },\n    { name: '⚾ Baseball', groupIds: ['786nRQzgVyUnuUtaLTGW'] },\n    { name: '⚽ Soccer', groupIds: ['ypd6vR44ZzJyN9xykx6e'] },\n    { name: '🏒 NHL', groupIds: ['lccgApXa1l7O5ZH3XfhH'] },\n    { name: '🏎️ F1', groupIds: ['OyHBKJOz9YaGkDctpwuY'] },\n    { name: '♟️ Chess', groupIds: ['ED7Cu6lVPshJkZ7FYePW'] },\n    { name: '🚲 Cycling', groupIds: ['2yisxJryUq9V5sG7P6Gy'] },\n    { name: '🎾 Tennis', groupIds: ['1mvN9vIVIopcWiAsXhzp'] },\n    { name: '🏏 Cricket', groupIds: ['LcPYoqxSRdeQMms4lR3g'] },\n    {\n      name: '🌐 Sports',\n      groupIds: ['2hGlgVhIyvVaFyQAREPi'],\n      hideFromSearch: true,\n    }, // default group\n  ],\n  '🎬 Culture': [\n    {\n      name: '🤩 Pop culture',\n      groupIds: [\n        'eJZecx6r22G2NriYYXcC', // Culture\n        'XU1fOYURSnb58lgsqaly', // Entertainment & Pop culture\n        '4QIcUOfCSSha0JZHAg9X', // celebrities\n      ],\n    },\n    {\n      name: '🍿 Movies & TV',\n      groupIds: [\n        'KSeNIu7AWgiBBM5FqVuB', // Movies\n        'EUSEngFk1dGGBfaMeAmh', // TV and Film\n      ],\n    },\n    {\n      name: '🎶 Music',\n      groupIds: ['Xuc2UY8gGfjQqFXwxq5d'],\n    },\n    {\n      name: '🎮 Gaming',\n      groupIds: [\n        '5FaFmmaNNFTSA5r0vTAi', // Gaming\n        '9FaZmHrfS8IcDJyu6pUD', // Video Games\n      ],\n    },\n    {\n      name: '🎮️ Destiny.gg',\n      groupIds: ['W2ES30fRo6CCbPNwMTTj'],\n    },\n    {\n      name: '🏴‍☠️ One Piece',\n      groupIds: ['uJSql24HUqpEpVU0FrjI'],\n    },\n  ],\n  '💵 Business': [\n    {\n      name: '📈 Finance & Stocks',\n      groupIds: [\n        'pmK8sntWL1SDkMm53UBR', // Business\n        'CgB83AAMkkOHSrTnzani', // Finance\n        'QDQfgsFiQrNNlZhsRGf5', // Stocks\n        'pK06hNX8MsNw8zaBsX2N', // Tech Stocks\n        '1a9ef4d5-dcc6-468f-a9b7-feccdaa92733', // Big Tech\n      ],\n    },\n    {\n      name: '📊 Econ',\n      groupIds: [\n        'p88Ycq6yFd5ECKqq9PFO', // Economics\n      ],\n    },\n    {\n      // Crypto, Bitcoin\n      name: '🪙 Crypto',\n      groupIds: ['YuJw0M1xvUHrpiRRuKso', 'WBeBD6FyMd0NvSL0qjMb'],\n    },\n  ],\n\n  '🤪 Fun': [\n    {\n      name: '🎲 Fun & games',\n      groupIds: [\n        '5V0GjAyN99OQpb96fwo8', // whale watching\n        'J8Z1KAZV31icklA4tgJW', // fairly random\n        'bBwafyeaiuwWwobwm2c4', // fun\n      ],\n    },\n    {\n      name: '🌐 Manifold',\n      groupIds: ['hzyCW27Hf9NzuXZRizeZ'],\n    },\n    {\n      name: '💪 Personal Goals',\n      groupIds: [\n        'izQp87CKagOVJp9Olm1p', // Personal goals\n        'wxAGTtNee5f2PTzjqSI2', // Personal\n      ],\n    },\n    {\n      // Sex and love, Dating\n      name: '❤️‍🔥 Sex and love',\n      groupIds: ['3syjPCC7PxE5KurTiTT3', 'j3ZE8fkeqiKmRGumy3O1'],\n    },\n    {\n      name: '🐸 Meme stocks',\n      groupIds: [\n        '524e08a3-3589-4267-9009-818d6c89cfa4', // meme-stocks\n        '2T4mM0N5az2lYcaN5G50', // permanent-markets\n      ],\n    },\n  ],\n}\n\nexport const TOPICS_TO_HIDE_FROM_WELCOME_FLOW = [] as string[]\nif (\n  !TOPICS_TO_HIDE_FROM_WELCOME_FLOW.every((topic) =>\n    Object.keys(TOPICS_TO_SUBTOPICS).includes(topic)\n  )\n) {\n  throw new Error(\n    `${TOPICS_TO_HIDE_FROM_WELCOME_FLOW.join(', ')} contains invalid topics`\n  )\n}\n\nexport const GROUP_SLUGS_TO_HIDE_FROM_WELCOME_FLOW = [\n  'world-default',\n  'shortterm-markets',\n  'daily-markets',\n  'global-macro',\n  'politics-default', // US Politics\n  'magaland',\n  'donald-trump',\n  'the-life-of-biden',\n  // 'elon-musk-14d9d9498c7e',\n  'crypto-prices', // Crypto,\n  'bitcoin-maxi',\n  'nasdaq', // Stocks\n  'stock-marketdaily',\n  'ai-stocks',\n  'prices',\n  'entertainment', // should follow smaller groups instead\n  'entertainment-12ba84d9b720',\n  'gpt5-speculation', // AI\n  'chatgpt',\n  '2024-3d9da60b52f8',\n  'coolfold',\n  'grab-bag',\n  'internet',\n  'sports-default',\n  'football', // ambiguous - both soccer and american football\n  'manifold-drama',\n  'permanent-markets',\n  'testing',\n  PROD_MANIFOLD_LOVE_GROUP_SLUG,\n  ...HIDE_FROM_NEW_USER_SLUGS,\n]\n\nexport const getSubtopics = (topic: string) =>\n  TOPICS_TO_SUBTOPICS[topic].map(\n    (subtopic) =>\n      [subtopic.name, removeEmojis(subtopic.name), subtopic.groupIds] as const\n  )\nexport const ALL_TOPICS = Object.keys(TOPICS_TO_SUBTOPICS)\n  .map((topic) => getSubtopics(topic).map(([_, subtopic]) => subtopic))\n  .flat()\n\nexport const ALL_PARENT_TOPICS = Object.keys(TOPICS_TO_SUBTOPICS)\n",
          "postContent": "import {\n  HIDE_FROM_NEW_USER_SLUGS,\n  PROD_MANIFOLD_LOVE_GROUP_SLUG,\n} from 'common/envs/constants'\nimport { removeEmojis } from './util/string'\n\ntype TopicInfo = { name: string; groupIds: string[]; hideFromSearch?: boolean }\n\nexport const TOPICS_TO_SUBTOPICS: { [key: string]: TopicInfo[] } = {\n  '🗳️ Politics': [\n    {\n      name: '🇺🇸 USA',\n      groupIds: [\n        'AjxQR8JMpNyDqtiqoA96', // US Politics\n        'cEzcLXuitr6o4VPI01Q1', // Trump\n        '46e04289-2b15-4997-841b-b8e1d5175c39', // trump's second term\n        'EWgcYV1JYWP19dE3BZCb', // republican party\n      ],\n    },\n    { name: '🇨🇳 China', groupIds: ['oWTzfoeemQGkSoPFn2T7'] },\n    {\n      // Ukraine-Russia War, Russia, Ukraine\n      name: '🇷🇺🇺🇦 Russia & Ukraine',\n      groupIds: [\n        'OxcXOuxXvwsXtC0Dx5sr',\n        'TIpf6j0hLpifpXN93FxE',\n        '0AKCBNjWsHwpfmPOsGf6',\n      ],\n    },\n    {\n      name: '🇮🇱🇵🇸 Israel & Hamas',\n      groupIds: [\n        'cea99c1c-afb9-49b2-adfa-9be739adce10',\n        'ECjphikMbmosJsDAAJoU', // Israel\n      ],\n    },\n    { name: '🇬🇧 UK', groupIds: ['aavkiDd6uZggfL3geuV2'] },\n    { name: '🇪🇺 Europe', groupIds: ['ue52QI4BQgJgAJJNjLHr'] },\n    { name: '🇮🇳 India', groupIds: ['Y2J00UcVhr3wKq2lAOAy'] },\n    { name: '🌎 LatAm', groupIds: ['DX94A1LQmpckcVdz5Hb3'] },\n    { name: '🌏 Africa', groupIds: ['dFsZaGwyohGDVkJi1C3E'] },\n    { name: '🌏 Middle East', groupIds: ['xg8wCPeM9JP6gD0igBrA'] },\n    { name: '🌎 Asia', groupIds: ['bPTxMZhUYsIUXsWT969d'] },\n    {\n      name: '🌐 Politics',\n      groupIds: [\n        'UCnpxVUdLOZYgoMsDlHD', // Politics default\n        'XUjgI120xjTU5n382rWL', // Canadian Politics\n      ],\n      hideFromSearch: true,\n    },\n  ],\n  '🤖 AI': [\n    {\n      name: 'AI',\n      groupIds: ['yEWvvwFFIqzf8JklMewp'],\n      hideFromSearch: true,\n    },\n    {\n      name: 'Timelines',\n      groupIds: ['GbbX9U5pYnDeftX9lxUh'],\n    },\n\n    {\n      name: 'OpenAI',\n      groupIds: ['a3ikurqO9fT46Pv9ZGkY'],\n    },\n    {\n      name: 'AI Impacts & Safety',\n      groupIds: ['DnxTZ1P5XEEfnHxy7Q7d', 'q3Su0NeV9ta4DqhqlIEq'],\n    },\n    {\n      name: 'Anthropic',\n      groupIds: ['B8jfqGL9Uqu5nejktmVi'],\n    },\n  ],\n  '💻 Tech': [\n    {\n      name: '💻 Technology',\n      groupIds: [\n        'IlzY3moWwOcpsVZXCVej', // Technology\n        'SmJk6RHToaLxLk0I1ZSC', // Space\n      ],\n    },\n    {\n      name: '🔬 Science',\n      groupIds: [\n        'XMhZ5LbQoLMZiOpQJRnj', // Science\n        '97oNExy8iFftY2EgdkLw', // Climate\n      ],\n    },\n    {\n      name: '🏥 Health',\n      groupIds: ['JpUqUqRn9sSWxrk0Sq35'],\n    },\n    {\n      name: '👨‍💻 Code',\n      groupIds: ['PZJMbrLekgJBy7OOBKGT'],\n    },\n    {\n      name: '🧮 Math',\n      groupIds: ['S1tbcVt1t5Bd9O5mVCx1'],\n    },\n  ],\n  '🏟️ Sports': [\n    {\n      name: '🏀 Basketball',\n      groupIds: [\n        'NjkFkdkvRvBHoeMDQ5NB', // Basketball\n        'beeb69e0-b36f-451a-80e1-e059df456bb1', // College Basketball\n        'i0v3cXwuxmO9fpcInVYb', // NBA\n      ],\n    },\n    {\n      // NFL, College Football\n      name: '🏈 NFL',\n      groupIds: ['TNQwmbE5p6dnKx2e6Qlp', 'ky1VPTuxrLXMnHyajZFp'],\n    },\n    { name: '⚾ Baseball', groupIds: ['786nRQzgVyUnuUtaLTGW'] },\n    { name: '⚽ Soccer', groupIds: ['ypd6vR44ZzJyN9xykx6e'] },\n    { name: '🏒 NHL', groupIds: ['lccgApXa1l7O5ZH3XfhH'] },\n    { name: '🏎️ F1', groupIds: ['OyHBKJOz9YaGkDctpwuY'] },\n    { name: '♟️ Chess', groupIds: ['ED7Cu6lVPshJkZ7FYePW'] },\n    { name: '🚲 Cycling', groupIds: ['2yisxJryUq9V5sG7P6Gy'] },\n    { name: '🎾 Tennis', groupIds: ['1mvN9vIVIopcWiAsXhzp'] },\n    { name: '🏏 Cricket', groupIds: ['LcPYoqxSRdeQMms4lR3g'] },\n    {\n      name: '🌐 Sports',\n      groupIds: ['2hGlgVhIyvVaFyQAREPi'],\n      hideFromSearch: true,\n    }, // default group\n  ],\n  '🎬 Culture': [\n    {\n      name: '🤩 Pop culture',\n      groupIds: [\n        'eJZecx6r22G2NriYYXcC', // Culture\n        'XU1fOYURSnb58lgsqaly', // Entertainment & Pop culture\n        '4QIcUOfCSSha0JZHAg9X', // celebrities\n      ],\n    },\n    {\n      name: '🍿 Movies & TV',\n      groupIds: [\n        'KSeNIu7AWgiBBM5FqVuB', // Movies\n        'EUSEngFk1dGGBfaMeAmh', // TV and Film\n      ],\n    },\n    {\n      name: '🎶 Music',\n      groupIds: ['Xuc2UY8gGfjQqFXwxq5d'],\n    },\n    {\n      name: '🎮 Gaming',\n      groupIds: [\n        '5FaFmmaNNFTSA5r0vTAi', // Gaming\n        '9FaZmHrfS8IcDJyu6pUD', // Video Games\n      ],\n    },\n    {\n      name: '🎮️ Destiny.gg',\n      groupIds: ['W2ES30fRo6CCbPNwMTTj'],\n    },\n    {\n      name: '🏴‍☠️ One Piece',\n      groupIds: ['uJSql24HUqpEpVU0FrjI'],\n    },\n  ],\n  '💵 Business': [\n    {\n      name: '📈 Finance & Stocks',\n      groupIds: [\n        'pmK8sntWL1SDkMm53UBR', // Business\n        'CgB83AAMkkOHSrTnzani', // Finance\n        'QDQfgsFiQrNNlZhsRGf5', // Stocks\n        'pK06hNX8MsNw8zaBsX2N', // Tech Stocks\n        '1a9ef4d5-dcc6-468f-a9b7-feccdaa92733', // Big Tech\n      ],\n    },\n    {\n      name: '📊 Econ',\n      groupIds: [\n        'p88Ycq6yFd5ECKqq9PFO', // Economics\n      ],\n    },\n    {\n      // Crypto, Bitcoin\n      name: '🪙 Crypto',\n      groupIds: ['YuJw0M1xvUHrpiRRuKso', 'WBeBD6FyMd0NvSL0qjMb'],\n    },\n  ],\n  '🤪 Fun': [\n    {\n      name: '🎲 Fun & games',\n      groupIds: [\n        '5V0GjAyN99OQpb96fwo8', // whale watching\n        'J8Z1KAZV31icklA4tgJW', // fairly random\n        'bBwafyeaiuwWwobwm2c4', // fun\n      ],\n    },\n    {\n      name: '🌐 Manifold',\n      groupIds: ['hzyCW27Hf9NzuXZRizeZ'],\n    },\n    {\n      name: '💪 Personal Goals',\n      groupIds: [\n        'izQp87CKagOVJp9Olm1p', // Personal goals\n        'wxAGTtNee5f2PTzjqSI2', // Personal\n      ],\n    },\n    {\n      // Sex and love, Dating\n      name: '❤️‍🔥 Sex and love',\n      groupIds: ['3syjPCC7PxE5KurTiTT3', 'j3ZE8fkeqiKmRGumy3O1'],\n    },\n    {\n      name: '🐸 Meme stocks',\n      groupIds: [\n        '524e08a3-3589-4267-9009-818d6c89cfa4', // meme-stocks\n        '2T4mM0N5az2lYcaN5G50', // permanent-markets\n      ],\n    },\n  ],\n}\n\nexport const TOPICS_TO_HIDE_FROM_WELCOME_FLOW = [] as string[]\nif (\n  !TOPICS_TO_HIDE_FROM_WELCOME_FLOW.every((topic) =>\n    Object.keys(TOPICS_TO_SUBTOPICS).includes(topic)\n  )\n) {\n  throw new Error(\n    `${TOPICS_TO_HIDE_FROM_WELCOME_FLOW.join(', ')} contains invalid topics`\n  )\n}\n\nexport const GROUP_SLUGS_TO_HIDE_FROM_WELCOME_FLOW = [\n  'world-default',\n  'shortterm-markets',\n  'daily-markets',\n  'global-macro',\n  'politics-default', // US Politics\n  'magaland',\n  'donald-trump',\n  'the-life-of-biden',\n  // 'elon-musk-14d9d9498c7e',\n  'crypto-prices', // Crypto,\n  'bitcoin-maxi',\n  'nasdaq', // Stocks\n  'stock-marketdaily',\n  'ai-stocks',\n  'prices',\n  'entertainment', // should follow smaller groups instead\n  'entertainment-12ba84d9b720',\n  'gpt5-speculation', // AI\n  'chatgpt',\n  '2024-3d9da60b52f8',\n  'coolfold',\n  'grab-bag',\n  'internet',\n  'sports-default',\n  'football', // ambiguous - both soccer and american football\n  'manifold-drama',\n  'permanent-markets',\n  'testing',\n  PROD_MANIFOLD_LOVE_GROUP_SLUG,\n  ...HIDE_FROM_NEW_USER_SLUGS,\n]\n\nexport const getSubtopics = (topic: string) =>\n  TOPICS_TO_SUBTOPICS[topic].map(\n    (subtopic) =>\n      [subtopic.name, removeEmojis(subtopic.name), subtopic.groupIds] as const\n  )\nexport const ALL_TOPICS = Object.keys(TOPICS_TO_SUBTOPICS)\n  .map((topic) => getSubtopics(topic).map(([_, subtopic]) => subtopic))\n  .flat()\n\nexport const ALL_PARENT_TOPICS = Object.keys(TOPICS_TO_SUBTOPICS)\n"
        }
      ]
    },
    {
      "sha": "152e18710e364f7b20326d81c8bfb4fbf183e9e1",
      "author": "Sinclair Chen",
      "date": "2025-05-20 04:12:53 +0800",
      "message": "End love 💔 (#3578)",
      "stats": {
        "filesChanged": 46,
        "insertions": 19,
        "deletions": 3052
      },
      "selectionReason": "Removes love feature entirely - large-scale feature removal affecting 46 files, demonstrating major codebase refactoring",
      "spec": "Completely remove the 'Manifold Love' dating and matchmaking feature. This includes the deletion of all associated user interface elements for 'Lover' profiles, compatibility questions/scores, and love-specific interactions (liking, shipping, starring, commenting on lover profiles). All backend APIs, database tables (e.g., for lovers, love questions, likes, ships, stars, lover comments), and supporting logic for these features must be eliminated. This also entails removing any special 'love market' contract type and its unique resolution mechanisms. Discontinue all notifications and email templates specific to 'Manifold Love' activities. Remove user attributes or onboarding paths tied to this feature. All code, configurations (including CORS policies and domain references for `manifold.love`), and infrastructure supporting 'Manifold Love' must be removed. Additionally, remove the location search endpoints (`searchlocation`, `searchnearcity`) as they were primarily in support of this feature.",
      "fileStates": [
        {
          "path": "backend/api/src/love/compatible-lovers.ts",
          "preContent": "import { groupBy, sortBy } from 'lodash'\nimport { APIError, type APIHandler } from 'api/helpers/endpoint'\nimport { getCompatibilityScore } from 'common/love/compatibility-score'\nimport {\n  getLover,\n  getCompatibilityAnswers,\n  getGenderCompatibleLovers,\n} from 'shared/love/supabase'\nimport { log } from 'shared/utils'\n\nexport const getCompatibleLovers: APIHandler<'compatible-lovers'> = async (\n  props,\n  _auth\n) => {\n  const { userId } = props\n\n  const lover = await getLover(userId)\n\n  log('got lover', {\n    id: lover?.id,\n    userId: lover?.user_id,\n    username: lover?.user?.username,\n  })\n\n  if (!lover) throw new APIError(404, 'Lover not found')\n\n  const lovers = await getGenderCompatibleLovers(lover)\n\n  const debug = false\n  if (debug) {\n    console.log(\n      'got compatible',\n      lovers.map((l) => ({\n        id: l.id,\n        username: l.user.username,\n        user_id: l.user.id,\n      }))\n    )\n  }\n\n  const loverAnswers = await getCompatibilityAnswers([\n    userId,\n    ...lovers.map((l) => l.user_id),\n  ])\n  log('got lover answers ' + loverAnswers.length)\n\n  const answersByUserId = groupBy(loverAnswers, 'creator_id')\n  const loverCompatibilityScores = Object.fromEntries(\n    lovers.map(\n      (l) =>\n        [\n          l.user_id,\n          getCompatibilityScore(\n            answersByUserId[lover.user_id] ?? [],\n            answersByUserId[l.user_id] ?? []\n          ),\n        ] as const\n    )\n  )\n\n  if (debug) log('got lover compatibility scores', loverCompatibilityScores)\n\n  const sortedCompatibleLovers = sortBy(\n    lovers,\n    (l) => loverCompatibilityScores[l.user_id].score\n  ).reverse()\n\n  return {\n    status: 'success',\n    lover,\n    compatibleLovers: sortedCompatibleLovers,\n    loverCompatibilityScores,\n  }\n}\n",
          "postContent": "[DELETED]"
        },
        {
          "path": "backend/api/src/love/create-comment-on-lover.ts",
          "preContent": "import { APIError, authEndpoint, validate } from 'api/helpers/endpoint'\nimport { MAX_COMMENT_JSON_LENGTH } from 'api/create-comment'\nimport { z } from 'zod'\nimport { contentSchema } from 'common/api/zod-types'\nimport { JSONContent } from '@tiptap/core'\nimport { getPrivateUser, getUser } from 'shared/utils'\nimport {\n  createSupabaseDirectClient,\n  SupabaseDirectClient,\n} from 'shared/supabase/init'\nimport { getNotificationDestinationsForUser } from 'common/user-notification-preferences'\nimport { Notification } from 'common/notification'\nimport { insertNotificationToSupabase } from 'shared/supabase/notifications'\nimport { User } from 'common/user'\nimport { richTextToString } from 'common/util/parse'\nimport * as crypto from 'crypto'\nimport { sendNewEndorsementEmail } from 'shared/emails'\nimport { createPushNotifications } from 'shared/create-push-notifications'\n\nconst postSchema = z.object({\n  userId: z.string(),\n  content: contentSchema,\n  replyToCommentId: z.number().optional(),\n})\nexport const createcommentonlover = authEndpoint(async (req, auth) => {\n  const {\n    userId,\n    content: submittedContent,\n    replyToCommentId,\n  } = validate(postSchema, req.body)\n\n  const { creator, content } = await validateComment(\n    userId,\n    auth.uid,\n    submittedContent\n  )\n\n  const onUser = await getUser(userId)\n  if (!onUser) throw new APIError(404, 'User not found')\n\n  const pg = createSupabaseDirectClient()\n  const comment = await pg.oneOrNone(\n    `insert into lover_comments (user_id, user_name, user_username, user_avatar_url, on_user_id, content, reply_to_comment_id)\n        values ($1, $2, $3, $4, $5, $6, $7) returning *`,\n    [\n      creator.id,\n      creator.name,\n      creator.username,\n      creator.avatarUrl,\n      userId,\n      content,\n      replyToCommentId,\n    ]\n  )\n  if (onUser.id !== creator.id)\n    await createNewCommentOnLoverNotification(\n      onUser,\n      creator,\n      richTextToString(content),\n      comment.id,\n      pg\n    )\n\n  return { status: 'success' }\n})\n\nconst validateComment = async (\n  userId: string,\n  creatorId: string,\n  content: JSONContent\n) => {\n  const creator = await getUser(creatorId)\n\n  if (!creator) throw new APIError(401, 'Your account was not found')\n  if (creator.isBannedFromPosting) throw new APIError(403, 'You are banned')\n\n  const otherUser = await getPrivateUser(userId)\n  if (!otherUser) throw new APIError(404, 'Other user not found')\n  if (otherUser.blockedUserIds.includes(creatorId)) {\n    throw new APIError(404, 'User has blocked you')\n  }\n\n  if (JSON.stringify(content).length > MAX_COMMENT_JSON_LENGTH) {\n    throw new APIError(\n      400,\n      `Comment is too long; should be less than ${MAX_COMMENT_JSON_LENGTH} as a JSON string.`\n    )\n  }\n  return { content, creator }\n}\n\nconst createNewCommentOnLoverNotification = async (\n  onUser: User,\n  creator: User,\n  sourceText: string,\n  commentId: number,\n  pg: SupabaseDirectClient\n) => {\n  const privateUser = await getPrivateUser(onUser.id)\n  if (!privateUser) return\n  const id = crypto.randomUUID()\n  const reason = 'new_endorsement'\n  const { sendToBrowser, sendToMobile, sendToEmail } =\n    getNotificationDestinationsForUser(privateUser, reason)\n  const notification: Notification = {\n    id,\n    userId: privateUser.id,\n    reason,\n    createdTime: Date.now(),\n    isSeen: false,\n    sourceId: commentId.toString(),\n    sourceType: 'comment_on_lover',\n    sourceUpdateType: 'created',\n    sourceUserName: creator.name,\n    sourceUserUsername: creator.username,\n    sourceUserAvatarUrl: creator.avatarUrl,\n    sourceText: sourceText,\n    sourceSlug: onUser.username,\n  }\n  if (sendToBrowser) {\n    await insertNotificationToSupabase(notification, pg)\n  }\n  if (sendToMobile) {\n    await createPushNotifications([\n      [\n        privateUser,\n        notification,\n        `${creator.name} commented on your profile`,\n        sourceText,\n      ],\n    ])\n  }\n  if (sendToEmail) {\n    await sendNewEndorsementEmail(\n      reason,\n      privateUser,\n      creator,\n      onUser,\n      `${creator.name} just endorsed you!`,\n      sourceText\n    )\n  }\n}\n",
          "postContent": "[DELETED]"
        },
        {
          "path": "backend/api/src/love/create-love-compatibility-question.ts",
          "preContent": "import { createSupabaseClient } from 'shared/supabase/init'\nimport { getUser } from 'shared/utils'\nimport { z } from 'zod'\nimport { APIError, authEndpoint, validate } from '../helpers/endpoint'\nimport { MAX_COMPATIBILITY_QUESTION_LENGTH } from 'common/love/constants'\n\nconst bodySchema = z.object({\n  question: z.string().min(1).max(MAX_COMPATIBILITY_QUESTION_LENGTH),\n  options: z.record(z.string(), z.number()),\n})\n\nexport const createlovecompatibilityquestion = authEndpoint(\n  async (req, auth) => {\n    const { question, options } = validate(bodySchema, req.body)\n\n    const creator = await getUser(auth.uid)\n    if (!creator) throw new APIError(401, 'Your account was not found')\n\n    const db = createSupabaseClient()\n\n    const compatibilityQuestionData = [\n      {\n        creator_id: creator.id,\n        question,\n        answer_type: 'compatibility_multiple_choice',\n        multiple_choice_options: options,\n      },\n    ]\n\n    const result = await db\n      .from('love_questions')\n      .insert(compatibilityQuestionData)\n      .select()\n\n    if (result.error) throw new APIError(401, 'Error creating question')\n\n    return { status: 'success', question: result.data[0] }\n  }\n)\n",
          "postContent": "[DELETED]"
        },
        {
          "path": "backend/api/src/love/create-lover.ts",
          "preContent": "import { z } from 'zod'\nimport { APIError, authEndpoint, validate } from 'api/helpers/endpoint'\nimport {\n  createSupabaseClient,\n  createSupabaseDirectClient,\n} from 'shared/supabase/init'\nimport { log, getUser } from 'shared/utils'\nimport { HOUR_MS } from 'common/util/time'\nimport { removePinnedUrlFromPhotoUrls } from 'shared/love/parse-photos'\nimport { getIp, track } from 'shared/analytics'\nimport { updateUser } from 'shared/supabase/users'\nconst genderType = z.union([\n  z.literal('male'),\n  z.literal('female'),\n  z.literal('trans-female'),\n  z.literal('trans-male'),\n  z.literal('non-binary'),\n])\nconst genderTypes = z.array(genderType)\n\nexport const baseLoversSchema = z.object({\n  // Required fields\n  age: z.number().min(18).max(100),\n  gender: genderType,\n  pref_gender: genderTypes,\n  pref_age_min: z.number().min(18).max(999),\n  pref_age_max: z.number().min(18).max(1000),\n  pref_relation_styles: z.array(\n    z.union([\n      z.literal('mono'),\n      z.literal('poly'),\n      z.literal('open'),\n      z.literal('other'),\n    ])\n  ),\n  wants_kids_strength: z.number().min(0),\n  looking_for_matches: z.boolean(),\n  photo_urls: z.array(z.string()),\n\n  geodb_city_id: z.string().optional(),\n  city: z.string(),\n  region_code: z.string().optional(),\n  country: z.string().optional(),\n  city_latitude: z.number().optional(),\n  city_longitude: z.number().optional(),\n\n  pinned_url: z.string(),\n  referred_by_username: z.string().optional(),\n})\n\nexport const createlover = authEndpoint(async (req, auth) => {\n  const parsedBody = validate(baseLoversSchema, req.body)\n  const db = createSupabaseClient()\n  const pg = createSupabaseDirectClient()\n\n  const { data: existingUser } = await db\n    .from('lovers')\n    .select('id')\n    .eq('user_id', auth.uid)\n    .single()\n  if (existingUser) {\n    throw new APIError(400, 'User already exists')\n  }\n\n  await removePinnedUrlFromPhotoUrls(parsedBody)\n  const user = await getUser(auth.uid)\n  if (!user) throw new APIError(401, 'Your account was not found')\n  if (user.createdTime > Date.now() - HOUR_MS) {\n    // If they just signed up for manifold via manifold.love, set their avatar to be their pinned photo\n    updateUser(pg, auth.uid, { avatarUrl: parsedBody.pinned_url })\n  }\n\n  const { data, error } = await db\n    .from('lovers')\n    .insert([\n      {\n        ...parsedBody,\n        user_id: auth.uid,\n      },\n    ])\n    .select()\n\n  if (error) {\n    log.error('Error creating user', error)\n    throw new APIError(500, 'Error creating user')\n  }\n\n  log('Created user', data[0])\n  await track(\n    user.id,\n    'create lover',\n    { username: user.username },\n    { ip: getIp(req) }\n  )\n\n  return {\n    success: true,\n    lover: data[0],\n  }\n})\n",
          "postContent": "[DELETED]"
        },
        {
          "path": "backend/api/src/love/get-compatibililty-questions.ts",
          "preContent": "import { type APIHandler } from 'api/helpers/endpoint'\nimport { createSupabaseDirectClient } from 'shared/supabase/init'\nimport { Row } from 'common/supabase/utils'\n\nexport const getCompatibilityQuestions: APIHandler<\n  'get-compatibility-questions'\n> = async (_props, _auth) => {\n  const pg = createSupabaseDirectClient()\n\n  const questions = await pg.manyOrNone<\n    Row<'love_questions'> & { answer_count: number; score: number }\n  >(\n    `SELECT \n      love_questions.*,\n      COUNT(love_compatibility_answers.question_id) as answer_count,\n      AVG(POWER(love_compatibility_answers.importance + 1 + CASE WHEN love_compatibility_answers.explanation IS NULL THEN 1 ELSE 0 END, 2)) as score\n    FROM \n        love_questions\n    LEFT JOIN \n        love_compatibility_answers ON love_questions.id = love_compatibility_answers.question_id\n    WHERE \n        love_questions.answer_type = 'compatibility_multiple_choice'\n    GROUP BY \n        love_questions.id\n    ORDER BY \n        score DESC\n    `,\n    []\n  )\n\n  if (false)\n    console.log(\n      'got questions',\n      questions.map((q) => q.question + ' ' + q.score)\n    )\n\n  return {\n    status: 'success',\n    questions,\n  }\n}\n",
          "postContent": "[DELETED]"
        },
        {
          "path": "backend/api/src/love/get-likes-and-ships.ts",
          "preContent": "import { type APIHandler } from 'api/helpers/endpoint'\nimport { createSupabaseDirectClient } from 'shared/supabase/init'\n\nexport const getLikesAndShips: APIHandler<'get-likes-and-ships'> = async (\n  props\n) => {\n  const { userId } = props\n\n  return {\n    status: 'success',\n    ...(await getLikesAndShipsMain(userId)),\n  }\n}\n\nexport const getLikesAndShipsMain = async (userId: string) => {\n  const pg = createSupabaseDirectClient()\n\n  const likesGiven = await pg.map<{\n    user_id: string\n    created_time: number\n  }>(\n    `\n      select target_id, love_likes.created_time\n      from love_likes\n      join lovers on lovers.user_id = love_likes.target_id\n      join users on users.id = love_likes.target_id\n      where creator_id = $1\n        and looking_for_matches\n        and lovers.pinned_url is not null\n        and (data->>'isBannedFromPosting' != 'true' or data->>'isBannedFromPosting' is null)\n      order by created_time desc\n    `,\n    [userId],\n    (r) => ({\n      user_id: r.target_id,\n      created_time: new Date(r.created_time).getTime(),\n    })\n  )\n\n  const likesReceived = await pg.map<{\n    user_id: string\n    created_time: number\n  }>(\n    `\n      select creator_id, love_likes.created_time\n      from love_likes\n      join lovers on lovers.user_id = love_likes.creator_id\n      join users on users.id = love_likes.creator_id\n      where target_id = $1\n        and looking_for_matches\n        and lovers.pinned_url is not null\n        and (data->>'isBannedFromPosting' != 'true' or data->>'isBannedFromPosting' is null)\n      order by created_time desc\n    `,\n    [userId],\n    (r) => ({\n      user_id: r.creator_id,\n      created_time: new Date(r.created_time).getTime(),\n    })\n  )\n\n  const ships = await pg.map<{\n    creator_id: string\n    target_id: string\n    target1_id: string\n    target2_id: string\n    created_time: number\n  }>(\n    `\n    select \n      target1_id, target2_id, creator_id, love_ships.created_time,\n      target1_id as target_id\n    from love_ships\n    join lovers on lovers.user_id = love_ships.target1_id\n    join users on users.id = love_ships.target1_id\n    where target2_id = $1\n      and lovers.looking_for_matches\n      and lovers.pinned_url is not null\n      and (users.data->>'isBannedFromPosting' != 'true' or users.data->>'isBannedFromPosting' is null)\n\n    union all\n\n    select\n      target1_id, target2_id, creator_id, love_ships.created_time,\n      target2_id as target_id\n    from love_ships\n    join lovers on lovers.user_id = love_ships.target2_id\n    join users on users.id = love_ships.target2_id\n    where target1_id = $1\n      and lovers.looking_for_matches\n      and lovers.pinned_url is not null\n      and (users.data->>'isBannedFromPosting' != 'true' or users.data->>'isBannedFromPosting' is null)\n    `,\n    [userId],\n    (r) => ({\n      ...r,\n      created_time: new Date(r.created_time).getTime(),\n    })\n  )\n\n  return {\n    likesGiven,\n    likesReceived,\n    ships,\n  }\n}\n",
          "postContent": "[DELETED]"
        },
        {
          "path": "backend/api/src/love/get-lover-answers.ts",
          "preContent": "import { type APIHandler } from 'api/helpers/endpoint'\nimport { createSupabaseDirectClient } from 'shared/supabase/init'\nimport { Row } from 'common/supabase/utils'\n\nexport const getLoverAnswers: APIHandler<'get-lover-answers'> = async (\n  props,\n  _auth\n) => {\n  const { userId } = props\n  const pg = createSupabaseDirectClient()\n\n  const answers = await pg.manyOrNone<Row<'love_compatibility_answers'>>(\n    `select * from love_compatibility_answers\n    where\n      creator_id = $1\n    order by created_time desc\n    `,\n    [userId]\n  )\n\n  return {\n    status: 'success',\n    answers,\n  }\n}\n",
          "postContent": "[DELETED]"
        },
        {
          "path": "backend/api/src/love/get-lovers.ts",
          "preContent": "import { type APIHandler } from 'api/helpers/endpoint'\nimport { createSupabaseDirectClient } from 'shared/supabase/init'\nimport { Lover } from 'common/love/lover'\n\nexport const getLovers: APIHandler<'get-lovers'> = async (_props, _auth) => {\n  const pg = createSupabaseDirectClient()\n\n  const lovers = await pg.manyOrNone<Lover>(\n    `select lovers.*, users.data as user\n    from lovers\n    join users on users.id = lovers.user_id\n    where\n      looking_for_matches = true\n      and pinned_url is not null\n      and (data->>'isBannedFromPosting' != 'true' or data->>'isBannedFromPosting' is null)\n    order by created_time desc\n    `,\n    []\n  )\n\n  return {\n    status: 'success',\n    lovers,\n  }\n}\n",
          "postContent": "[DELETED]"
        },
        {
          "path": "backend/api/src/love/has-free-like.ts",
          "preContent": "import { type APIHandler } from 'api/helpers/endpoint'\nimport { createSupabaseDirectClient } from 'shared/supabase/init'\n\nexport const hasFreeLike: APIHandler<'has-free-like'> = async (\n  _props,\n  auth\n) => {\n  return {\n    status: 'success',\n    hasFreeLike: await getHasFreeLike(auth.uid),\n  }\n}\n\nexport const getHasFreeLike = async (userId: string) => {\n  const pg = createSupabaseDirectClient()\n\n  const likeGivenToday = await pg.oneOrNone<object>(\n    `\n    select 1\n    from love_likes\n    where creator_id = $1\n      and created_time at time zone 'UTC' at time zone 'America/Los_Angeles' >= (now() at time zone 'UTC' at time zone 'America/Los_Angeles')::date\n      and created_time at time zone 'UTC' at time zone 'America/Los_Angeles' < ((now() at time zone 'UTC' at time zone 'America/Los_Angeles')::date + interval '1 day')\n    limit 1\n    `,\n    [userId]\n  )\n  return !likeGivenToday\n}\n",
          "postContent": "[DELETED]"
        },
        {
          "path": "backend/api/src/love/hide-comment-on-lover.ts",
          "preContent": "import { APIError, authEndpoint, validate } from 'api/helpers/endpoint'\nimport { z } from 'zod'\nimport { createSupabaseDirectClient } from 'shared/supabase/init'\nimport { isAdminId } from 'common/envs/constants'\n\nconst postSchema = z.object({\n  commentId: z.number(),\n  hide: z.boolean(),\n})\nexport const hidecommentonlover = authEndpoint(async (req, auth) => {\n  const { commentId, hide } = validate(postSchema, req.body)\n\n  const pg = createSupabaseDirectClient()\n  const comment = await pg.oneOrNone(\n    `select * from lover_comments where id = $1`,\n    [commentId]\n  )\n  if (!comment) {\n    throw new APIError(404, 'Comment not found')\n  }\n\n  if (\n    !isAdminId(auth.uid) &&\n    comment.user_id !== auth.uid &&\n    comment.on_user_id !== auth.uid\n  ) {\n    throw new APIError(403, 'You are not allowed to hide this comment')\n  }\n\n  await pg.none(`update lover_comments set hidden = $2 where id = $1`, [\n    commentId,\n    hide,\n  ])\n\n  return { status: 'success' }\n})\n",
          "postContent": "[DELETED]"
        },
        {
          "path": "backend/api/src/love/like-lover.ts",
          "preContent": "import { createSupabaseClient } from 'shared/supabase/init'\nimport { APIError, APIHandler } from '../helpers/endpoint'\nimport { createLoveLikeNotification } from 'shared/create-love-notification'\nimport { getHasFreeLike } from './has-free-like'\nimport { log } from 'shared/utils'\n\nexport const likeLover: APIHandler<'like-lover'> = async (props, auth) => {\n  const { targetUserId, remove } = props\n  const creatorId = auth.uid\n\n  const db = createSupabaseClient()\n\n  if (remove) {\n    const { error } = await db\n      .from('love_likes')\n      .delete()\n      .eq('creator_id', creatorId)\n      .eq('target_id', targetUserId)\n\n    if (error) {\n      throw new APIError(500, 'Failed to remove like: ' + error.message)\n    }\n    return { status: 'success' }\n  }\n\n  // Check if like already exists\n  const existing = await db\n    .from('love_likes')\n    .select()\n    .eq('creator_id', creatorId)\n    .eq('target_id', targetUserId)\n\n  if (existing.data?.length) {\n    log('Like already exists, do nothing')\n    return { status: 'success' }\n  }\n\n  const hasFreeLike = await getHasFreeLike(creatorId)\n\n  if (!hasFreeLike) {\n    // Charge for like.\n    throw new APIError(403, 'You already liked someone today!')\n  }\n\n  // Insert the new like\n  const { data, error } = await db\n    .from('love_likes')\n    .insert({\n      creator_id: creatorId,\n      target_id: targetUserId,\n    })\n    .select()\n    .single()\n\n  if (error) {\n    throw new APIError(500, 'Failed to add like: ' + error.message)\n  }\n\n  const continuation = async () => {\n    await createLoveLikeNotification(data)\n  }\n\n  return {\n    result: { status: 'success' },\n    continue: continuation,\n  }\n}\n",
          "postContent": "[DELETED]"
        },
        {
          "path": "backend/api/src/love/remove-pinned-photo.ts",
          "preContent": "import { APIError } from 'api/helpers/endpoint'\nimport { createSupabaseClient } from 'shared/supabase/init'\nimport { type APIHandler } from 'api/helpers/endpoint'\nimport { isAdminId } from 'common/envs/constants'\nimport { log } from 'shared/utils'\n\nexport const removePinnedPhoto: APIHandler<'remove-pinned-photo'> = async (\n  body: { userId: string },\n  auth\n) => {\n  const { userId } = body\n  log('remove pinned url', { userId })\n\n  if (!isAdminId(auth.uid))\n    throw new APIError(403, 'Only admins can remove pinned photo')\n\n  const db = createSupabaseClient()\n  await db.from('lovers').update({ pinned_url: null }).eq('user_id', userId)\n\n  return {\n    success: true,\n  }\n}\n",
          "postContent": "[DELETED]"
        },
        {
          "path": "backend/api/src/love/ship-lovers.ts",
          "preContent": "import {\n  createSupabaseClient,\n  createSupabaseDirectClient,\n} from 'shared/supabase/init'\nimport { APIError, APIHandler } from '../helpers/endpoint'\nimport { createLoveShipNotification } from 'shared/create-love-notification'\nimport { log } from 'shared/utils'\n\nexport const shipLovers: APIHandler<'ship-lovers'> = async (props, auth) => {\n  const { targetUserId1, targetUserId2, remove } = props\n  const creatorId = auth.uid\n\n  const db = createSupabaseClient()\n  const pg = createSupabaseDirectClient()\n\n  // Check if ship already exists or with swapped target IDs\n  const existing = await pg.oneOrNone<{ ship_id: string }>(\n    `\n    select ship_id from love_ships\n    where creator_id = $1\n    and (\n      target1_id = $2 and target2_id = $3\n      or target1_id = $3 and target2_id = $2\n    )\n  `,\n    [creatorId, targetUserId1, targetUserId2]\n  )\n\n  if (existing) {\n    if (remove) {\n      const { error } = await db\n        .from('love_ships')\n        .delete()\n        .eq('ship_id', existing.ship_id)\n      if (error) {\n        throw new APIError(500, 'Failed to remove ship: ' + error.message)\n      }\n    } else {\n      log('Ship already exists, do nothing')\n    }\n    return { status: 'success' }\n  }\n\n  // Insert the new ship\n  const { data, error } = await db\n    .from('love_ships')\n    .insert({\n      creator_id: creatorId,\n      target1_id: targetUserId1,\n      target2_id: targetUserId2,\n    })\n    .select()\n    .single()\n\n  if (error) {\n    throw new APIError(500, 'Failed to create ship: ' + error.message)\n  }\n\n  const continuation = async () => {\n    await Promise.all([\n      createLoveShipNotification(data, data.target1_id),\n      createLoveShipNotification(data, data.target2_id),\n    ])\n  }\n\n  return {\n    result: { status: 'success' },\n    continue: continuation,\n  }\n}\n",
          "postContent": "[DELETED]"
        },
        {
          "path": "backend/api/src/love/star-lover.ts",
          "preContent": "import { createSupabaseClient } from 'shared/supabase/init'\nimport { APIError, APIHandler } from '../helpers/endpoint'\nimport { log } from 'shared/utils'\n\nexport const starLover: APIHandler<'star-lover'> = async (props, auth) => {\n  const { targetUserId, remove } = props\n  const creatorId = auth.uid\n\n  const db = createSupabaseClient()\n\n  if (remove) {\n    const { error } = await db\n      .from('love_stars')\n      .delete()\n      .eq('creator_id', creatorId)\n      .eq('target_id', targetUserId)\n\n    if (error) {\n      throw new APIError(500, 'Failed to remove star: ' + error.message)\n    }\n    return { status: 'success' }\n  }\n\n  // Check if star already exists\n  const existing = await db\n    .from('love_stars')\n    .select()\n    .eq('creator_id', creatorId)\n    .eq('target_id', targetUserId)\n\n  if (existing.data?.length) {\n    log('star already exists, do nothing')\n    return { status: 'success' }\n  }\n\n  // Insert the new star\n  const { error } = await db\n    .from('love_stars')\n    .insert({\n      creator_id: creatorId,\n      target_id: targetUserId,\n    })\n    .select()\n    .single()\n\n  if (error) {\n    throw new APIError(500, 'Failed to add star: ' + error.message)\n  }\n\n  return { status: 'success' }\n}\n",
          "postContent": "[DELETED]"
        },
        {
          "path": "backend/api/src/love/update-lover.ts",
          "preContent": "import { z } from 'zod'\nimport { APIError, authEndpoint, validate } from 'api/helpers/endpoint'\nimport {\n  createSupabaseClient,\n  createSupabaseDirectClient,\n} from 'shared/supabase/init'\nimport { baseLoversSchema } from 'api/love/create-lover'\nimport { removePinnedUrlFromPhotoUrls } from 'shared/love/parse-photos'\nimport { contentSchema } from 'common/api/zod-types'\nimport { log } from 'shared/utils'\nimport { updateUser } from 'shared/supabase/users'\n\nconst optionalLoversSchema = z.object({\n  political_beliefs: z.array(z.string()).optional(),\n  religious_belief_strength: z.number().optional(),\n  religious_beliefs: z.string().optional(),\n  ethnicity: z.array(z.string()).optional(),\n  born_in_location: z.string().optional(),\n  height_in_inches: z.number().optional(),\n  has_pets: z.boolean().optional(),\n  education_level: z.string().optional(),\n  last_online_time: z.string().optional(),\n  is_smoker: z.boolean().optional(),\n  drinks_per_month: z.number().min(0).optional(),\n  is_vegetarian_or_vegan: z.boolean().optional(),\n  has_kids: z.number().min(0).optional(),\n  university: z.string().optional(),\n  occupation_title: z.string().optional(),\n  occupation: z.string().optional(),\n  company: z.string().optional(),\n  comments_enabled: z.boolean().optional(),\n  website: z.string().optional(),\n  bio: contentSchema.optional().nullable(),\n  twitter: z.string().optional(),\n  avatar_url: z.string().optional(),\n})\n// TODO: make strict\nconst combinedLoveUsersSchema = baseLoversSchema.merge(optionalLoversSchema)\n\nexport const updatelover = authEndpoint(async (req, auth) => {\n  const parsedBody = validate(combinedLoveUsersSchema, req.body)\n  log('parsedBody', parsedBody)\n  const db = createSupabaseClient()\n  const pg = createSupabaseDirectClient()\n  const { data: existingLover } = await db\n    .from('lovers')\n    .select('id')\n    .eq('user_id', auth.uid)\n    .single()\n  if (!existingLover) {\n    throw new APIError(400, 'Lover not found')\n  }\n  if (!parsedBody.last_online_time)\n    log('Updating lover', { userId: auth.uid, parsedBody })\n\n  await removePinnedUrlFromPhotoUrls(parsedBody)\n  if (parsedBody.avatar_url) {\n    await updateUser(pg, auth.uid, { avatarUrl: parsedBody.avatar_url })\n  }\n\n  const { data, error } = await db\n    .from('lovers')\n    .update({\n      ...parsedBody,\n      user_id: auth.uid,\n    })\n    .eq('id', existingLover.id)\n    .select()\n  if (error) {\n    log('Error updating lover', error)\n    throw new APIError(500, 'Error updating lover')\n  }\n  return {\n    success: true,\n    lover: data[0],\n  }\n})\n",
          "postContent": "[DELETED]"
        },
        {
          "path": "backend/api/src/old-routes.ts",
          "preContent": "import * as express from 'express'\nimport { health } from './health'\nimport { claimmanalink } from './claim-manalink'\nimport { creategroup } from './create-group'\nimport { unsubscribe } from './unsubscribe'\nimport { stripewebhook, createcheckoutsession } from './stripe-endpoints'\nimport { markallnotifications } from './mark-all-notifications'\nimport { updatememberrole } from './update-group-member-role'\nimport { updategroupprivacy } from './update-group-privacy'\nimport { registerdiscordid } from './register-discord-id'\nimport { getuserisgroupmember } from './get-user-is-group-member'\nimport { completequest } from './complete-quest'\nimport { getsupabasetoken } from './get-supabase-token'\nimport { deleteMarket } from './delete-market'\nimport { saveTopic } from './save-topic'\nimport { boostmarket } from './boost-market'\nimport { redeemboost } from './redeem-market-ad-reward'\nimport { followtopic } from './follow-topic'\nimport { editcomment } from 'api/edit-comment'\n\nimport { leagueActivity } from './league-activity'\nimport { updategroup } from './update-group'\nimport { updateUserDisinterestEmbedding } from 'api/update-user-disinterests'\nimport { cancelbounty } from './cancel-bounty'\nimport { searchgiphy } from './search-giphy'\nimport { manachantweet } from './manachan-tweet'\nimport { leavereview } from './leave-review'\nimport { castpollvote } from './cast-poll-vote'\nimport { getsimilargroupstocontract } from 'api/get-similar-groups-to-contract'\nimport { followUser } from './follow-user'\nimport { report } from './report'\nimport { createdashboard } from './create-dashboard'\nimport { getyourdashboards } from './get-your-dashboards'\nimport { followdashboard } from './follow-dashboard'\nimport { searchDashboards } from './search-dashboards'\nimport { getyourfolloweddashboards } from './get-your-followed-dashboards'\nimport { updatedashboard } from './update-dashboard'\nimport { deletedashboard } from './delete-dashboard'\nimport { getnews } from './get-news'\nimport { getdashboardfromslug } from './get-dashboard-from-slug'\nimport { banuser } from 'api/ban-user'\nimport { createprivateusermessage } from 'api/create-private-user-message'\nimport { createprivateusermessagechannel } from 'api/create-private-user-message-channel'\nimport { createlover } from 'api/love/create-lover'\nimport { updatelover } from 'api/love/update-lover'\nimport { createcommentonlover } from 'api/love/create-comment-on-lover'\nimport { hidecommentonlover } from 'api/love/hide-comment-on-lover'\nimport { searchlocation } from './search-location'\nimport { searchnearcity } from './search-near-city'\nimport { leaveprivateusermessagechannel } from 'api/leave-private-user-message-channel'\nimport { updateprivateusermessagechannel } from 'api/update-private-user-message-channel'\nimport { editanswercpmm } from 'api/edit-answer'\nimport { createlovecompatibilityquestion } from 'api/love/create-love-compatibility-question'\nimport { createchartannotation } from 'api/create-chart-annotation'\nimport { deletechartannotation } from 'api/delete-chart-annotation'\n\nimport { deletetv, settv } from './set-tv'\n\nimport { allowCorsUnrestricted, apiErrorHandler } from './app'\nimport { RequestHandler } from 'express'\n\nconst apiRoute = (endpoint: RequestHandler) => {\n  return [\n    allowCorsUnrestricted,\n    express.json(),\n    endpoint,\n    apiErrorHandler,\n  ] as const\n}\n\nexport const addOldRoutes = (app: express.Application) => {\n  app.get('/health', ...apiRoute(health))\n  app.get('/unsubscribe', ...apiRoute(unsubscribe))\n  app.post('/editcomment', ...apiRoute(editcomment))\n\n  app.post('/claimmanalink', ...apiRoute(claimmanalink))\n  app.post('/creategroup', ...apiRoute(creategroup))\n  app.post('/updategroup', ...apiRoute(updategroup))\n  app.post('/markallnotifications', ...apiRoute(markallnotifications))\n  app.post('/updatememberrole', ...apiRoute(updatememberrole))\n  app.post('/updategroupprivacy', ...apiRoute(updategroupprivacy))\n  app.post('/registerdiscordid', ...apiRoute(registerdiscordid))\n  app.post('/getuserisgroupmember', ...apiRoute(getuserisgroupmember))\n  app.post('/completequest', ...apiRoute(completequest))\n  app.post(\n    '/update-user-disinterest-embedding',\n    ...apiRoute(updateUserDisinterestEmbedding)\n  )\n  app.get('/getsupabasetoken', ...apiRoute(getsupabasetoken))\n  app.post('/delete-market', ...apiRoute(deleteMarket))\n  app.post('/save-topic', ...apiRoute(saveTopic))\n  app.post('/boost-market', ...apiRoute(boostmarket))\n  app.post('/redeem-boost', ...apiRoute(redeemboost))\n\n  app.post(\n    '/createcheckoutsession',\n    allowCorsUnrestricted,\n    createcheckoutsession\n  )\n  app.post(\n    '/stripewebhook',\n    allowCorsUnrestricted,\n    express.raw({ type: '*/*' }),\n    stripewebhook\n  )\n  app.post('/follow-topic', ...apiRoute(followtopic))\n  app.post('/league-activity', ...apiRoute(leagueActivity))\n  app.post('/cancel-bounty', ...apiRoute(cancelbounty))\n  app.post('/edit-answer-cpmm', ...apiRoute(editanswercpmm))\n  app.post('/searchgiphy', ...apiRoute(searchgiphy))\n  app.post('/manachantweet', ...apiRoute(manachantweet))\n  app.post('/leave-review', ...apiRoute(leavereview))\n  app.post('/cast-poll-vote', ...apiRoute(castpollvote))\n  app.post(\n    '/get-similar-groups-to-contract',\n    ...apiRoute(getsimilargroupstocontract)\n  )\n  app.post('/follow-user', ...apiRoute(followUser))\n  app.post('/report', ...apiRoute(report))\n\n  app.post('/settv', ...apiRoute(settv))\n  app.post('/deletetv', ...apiRoute(deletetv))\n\n  app.post('/createdashboard', ...apiRoute(createdashboard))\n  app.post('/getyourdashboards', ...apiRoute(getyourdashboards))\n  app.post('/followdashboard', ...apiRoute(followdashboard))\n  app.post('/supabasesearchdashboards', ...apiRoute(searchDashboards))\n  app.post('/getyourfolloweddashboards', ...apiRoute(getyourfolloweddashboards))\n  app.post('/updatedashboard', ...apiRoute(updatedashboard))\n  app.post('/delete-dashboard', ...apiRoute(deletedashboard))\n  app.get('/get-news-dashboards', ...apiRoute(getnews))\n  app.post('/getdashboardfromslug', ...apiRoute(getdashboardfromslug))\n  app.post('/ban-user', ...apiRoute(banuser))\n  app.post(\n    '/create-private-user-message',\n    ...apiRoute(createprivateusermessage)\n  )\n  app.post(\n    '/create-private-user-message-channel',\n    ...apiRoute(createprivateusermessagechannel)\n  )\n  app.post(\n    '/leave-private-user-message-channel',\n    ...apiRoute(leaveprivateusermessagechannel)\n  )\n  app.post(\n    '/update-private-user-message-channel',\n    ...apiRoute(updateprivateusermessagechannel)\n  )\n  app.post('/create-lover', ...apiRoute(createlover))\n  app.post('/update-lover', ...apiRoute(updatelover))\n  app.post('/create-comment-on-lover', ...apiRoute(createcommentonlover))\n  app.post('/hide-comment-on-lover', ...apiRoute(hidecommentonlover))\n  app.post('/searchlocation', ...apiRoute(searchlocation))\n  app.post('/searchnearcity', ...apiRoute(searchnearcity))\n  app.post(\n    '/createlovecompatibilityquestion',\n    ...apiRoute(createlovecompatibilityquestion)\n  )\n  app.post('/create-chart-annotation', ...apiRoute(createchartannotation))\n  app.post('/delete-chart-annotation', ...apiRoute(deletechartannotation))\n  // Catch 404 errors - this should be the last route\n  app.use(allowCorsUnrestricted, (req, res) => {\n    res\n      .status(404)\n      .set('Content-Type', 'application/json')\n      .json({\n        message: `The requested route '${req.path}' does not exist. Please check your URL for any misspellings or refer to app.ts`,\n      })\n  })\n}\n",
          "postContent": "import * as express from 'express'\nimport { health } from './health'\nimport { claimmanalink } from './claim-manalink'\nimport { creategroup } from './create-group'\nimport { unsubscribe } from './unsubscribe'\nimport { stripewebhook, createcheckoutsession } from './stripe-endpoints'\nimport { markallnotifications } from './mark-all-notifications'\nimport { updatememberrole } from './update-group-member-role'\nimport { updategroupprivacy } from './update-group-privacy'\nimport { registerdiscordid } from './register-discord-id'\nimport { getuserisgroupmember } from './get-user-is-group-member'\nimport { completequest } from './complete-quest'\nimport { getsupabasetoken } from './get-supabase-token'\nimport { deleteMarket } from './delete-market'\nimport { saveTopic } from './save-topic'\nimport { boostmarket } from './boost-market'\nimport { redeemboost } from './redeem-market-ad-reward'\nimport { followtopic } from './follow-topic'\nimport { editcomment } from 'api/edit-comment'\nimport { leagueActivity } from './league-activity'\nimport { updategroup } from './update-group'\nimport { updateUserDisinterestEmbedding } from 'api/update-user-disinterests'\nimport { cancelbounty } from './cancel-bounty'\nimport { searchgiphy } from './search-giphy'\nimport { manachantweet } from './manachan-tweet'\nimport { leavereview } from './leave-review'\nimport { castpollvote } from './cast-poll-vote'\nimport { getsimilargroupstocontract } from 'api/get-similar-groups-to-contract'\nimport { followUser } from './follow-user'\nimport { report } from './report'\nimport { createdashboard } from './create-dashboard'\nimport { getyourdashboards } from './get-your-dashboards'\nimport { followdashboard } from './follow-dashboard'\nimport { searchDashboards } from './search-dashboards'\nimport { getyourfolloweddashboards } from './get-your-followed-dashboards'\nimport { updatedashboard } from './update-dashboard'\nimport { deletedashboard } from './delete-dashboard'\nimport { getnews } from './get-news'\nimport { getdashboardfromslug } from './get-dashboard-from-slug'\nimport { banuser } from 'api/ban-user'\nimport { createprivateusermessage } from 'api/create-private-user-message'\nimport { createprivateusermessagechannel } from 'api/create-private-user-message-channel'\nimport { leaveprivateusermessagechannel } from 'api/leave-private-user-message-channel'\nimport { updateprivateusermessagechannel } from 'api/update-private-user-message-channel'\nimport { editanswercpmm } from 'api/edit-answer'\nimport { createchartannotation } from 'api/create-chart-annotation'\nimport { deletechartannotation } from 'api/delete-chart-annotation'\n\nimport { deletetv, settv } from './set-tv'\n\nimport { allowCorsUnrestricted, apiErrorHandler } from './app'\nimport { RequestHandler } from 'express'\n\nconst apiRoute = (endpoint: RequestHandler) => {\n  return [\n    allowCorsUnrestricted,\n    express.json(),\n    endpoint,\n    apiErrorHandler,\n  ] as const\n}\n\nexport const addOldRoutes = (app: express.Application) => {\n  app.get('/health', ...apiRoute(health))\n  app.get('/unsubscribe', ...apiRoute(unsubscribe))\n  app.post('/editcomment', ...apiRoute(editcomment))\n\n  app.post('/claimmanalink', ...apiRoute(claimmanalink))\n  app.post('/creategroup', ...apiRoute(creategroup))\n  app.post('/updategroup', ...apiRoute(updategroup))\n  app.post('/markallnotifications', ...apiRoute(markallnotifications))\n  app.post('/updatememberrole', ...apiRoute(updatememberrole))\n  app.post('/updategroupprivacy', ...apiRoute(updategroupprivacy))\n  app.post('/registerdiscordid', ...apiRoute(registerdiscordid))\n  app.post('/getuserisgroupmember', ...apiRoute(getuserisgroupmember))\n  app.post('/completequest', ...apiRoute(completequest))\n  app.post(\n    '/update-user-disinterest-embedding',\n    ...apiRoute(updateUserDisinterestEmbedding)\n  )\n  app.get('/getsupabasetoken', ...apiRoute(getsupabasetoken))\n  app.post('/delete-market', ...apiRoute(deleteMarket))\n  app.post('/save-topic', ...apiRoute(saveTopic))\n  app.post('/boost-market', ...apiRoute(boostmarket))\n  app.post('/redeem-boost', ...apiRoute(redeemboost))\n\n  app.post(\n    '/createcheckoutsession',\n    allowCorsUnrestricted,\n    createcheckoutsession\n  )\n  app.post(\n    '/stripewebhook',\n    allowCorsUnrestricted,\n    express.raw({ type: '*/*' }),\n    stripewebhook\n  )\n  app.post('/follow-topic', ...apiRoute(followtopic))\n  app.post('/league-activity', ...apiRoute(leagueActivity))\n  app.post('/cancel-bounty', ...apiRoute(cancelbounty))\n  app.post('/edit-answer-cpmm', ...apiRoute(editanswercpmm))\n  app.post('/searchgiphy', ...apiRoute(searchgiphy))\n  app.post('/manachantweet', ...apiRoute(manachantweet))\n  app.post('/leave-review', ...apiRoute(leavereview))\n  app.post('/cast-poll-vote', ...apiRoute(castpollvote))\n  app.post(\n    '/get-similar-groups-to-contract',\n    ...apiRoute(getsimilargroupstocontract)\n  )\n  app.post('/follow-user', ...apiRoute(followUser))\n  app.post('/report', ...apiRoute(report))\n\n  app.post('/settv', ...apiRoute(settv))\n  app.post('/deletetv', ...apiRoute(deletetv))\n\n  app.post('/createdashboard', ...apiRoute(createdashboard))\n  app.post('/getyourdashboards', ...apiRoute(getyourdashboards))\n  app.post('/followdashboard', ...apiRoute(followdashboard))\n  app.post('/supabasesearchdashboards', ...apiRoute(searchDashboards))\n  app.post('/getyourfolloweddashboards', ...apiRoute(getyourfolloweddashboards))\n  app.post('/updatedashboard', ...apiRoute(updatedashboard))\n  app.post('/delete-dashboard', ...apiRoute(deletedashboard))\n  app.get('/get-news-dashboards', ...apiRoute(getnews))\n  app.post('/getdashboardfromslug', ...apiRoute(getdashboardfromslug))\n  app.post('/ban-user', ...apiRoute(banuser))\n  app.post(\n    '/create-private-user-message',\n    ...apiRoute(createprivateusermessage)\n  )\n  app.post(\n    '/create-private-user-message-channel',\n    ...apiRoute(createprivateusermessagechannel)\n  )\n  app.post(\n    '/leave-private-user-message-channel',\n    ...apiRoute(leaveprivateusermessagechannel)\n  )\n  app.post(\n    '/update-private-user-message-channel',\n    ...apiRoute(updateprivateusermessagechannel)\n  )\n  app.post('/create-chart-annotation', ...apiRoute(createchartannotation))\n  app.post('/delete-chart-annotation', ...apiRoute(deletechartannotation))\n  // Catch 404 errors - this should be the last route\n  app.use(allowCorsUnrestricted, (req, res) => {\n    res\n      .status(404)\n      .set('Content-Type', 'application/json')\n      .json({\n        message: `The requested route '${req.path}' does not exist. Please check your URL for any misspellings or refer to app.ts`,\n      })\n  })\n}\n"
        },
        {
          "path": "backend/api/src/resolve-market.ts",
          "preContent": "import { sumBy } from 'lodash'\nimport { HOUSE_LIQUIDITY_PROVIDER_ID } from 'common/antes'\nimport { Contract, MarketContract, MultiContract } from 'common/contract'\nimport { getContract, getUser, isProd, log } from 'shared/utils'\nimport { APIError, type APIHandler, validate } from './helpers/endpoint'\nimport { resolveMarketHelper } from 'shared/resolve-market-helpers'\nimport { throwErrorIfNotMod } from 'shared/helpers/auth'\nimport { ValidatedAPIParams } from 'common/api/schema'\nimport {\n  resolveBinarySchema,\n  resolveMultiSchema,\n  resolvePseudoNumericSchema,\n} from 'common/api/market-types'\nimport { resolveLoveMarketOtherAnswers } from 'shared/love/love-markets'\nimport { betsQueue } from 'shared/helpers/fn-queue'\nimport { createSupabaseDirectClient } from 'shared/supabase/init'\nimport { broadcastUserUpdates } from 'shared/supabase/users'\nimport { SWEEPSTAKES_MOD_IDS } from 'common/envs/constants'\n\nexport const resolveMarket: APIHandler<'market/:contractId/resolve'> = async (\n  props,\n  auth,\n  request\n) => {\n  return await betsQueue.enqueueFnFirst(\n    () => resolveMarketMain(props, auth, request),\n    [props.contractId, auth.uid]\n  )\n}\n\nexport const resolveMarketMain: APIHandler<\n  'market/:contractId/resolve'\n> = async (props, auth) => {\n  const db = createSupabaseDirectClient()\n\n  const { contractId } = props\n  const contract = await getContract(db, contractId)\n  if (!contract) throw new APIError(404, 'Contract not found')\n\n  const { creatorId, outcomeType } = contract\n  if (outcomeType === 'STONK') {\n    throw new APIError(403, 'STONK contracts cannot be resolved')\n  }\n\n  const caller = await getUser(auth.uid)\n  if (!caller) throw new APIError(400, 'Caller not found')\n  if (caller.isBannedFromPosting || caller.userDeleted)\n    throw new APIError(403, 'Deleted or banned user cannot resolve markets')\n  if (creatorId !== auth.uid) throwErrorIfNotMod(auth.uid)\n\n  if (\n    isProd() &&\n    contract.token === 'CASH' &&\n    auth.uid !== HOUSE_LIQUIDITY_PROVIDER_ID &&\n    !SWEEPSTAKES_MOD_IDS.includes(auth.uid)\n  ) {\n    throw new APIError(\n      403,\n      'Only the Manifold account and approved mods can resolve sweepcash markets'\n    )\n  }\n\n  if (contract.resolution) throw new APIError(403, 'Contract already resolved')\n\n  const creator = caller.id === creatorId ? caller : await getUser(creatorId)\n  if (!creator) throw new APIError(500, 'Creator not found')\n\n  const resolutionParams = getResolutionParams(contract, props)\n\n  if ('answerId' in resolutionParams && 'answers' in contract) {\n    const { answerId } = resolutionParams\n    const answer = contract.answers.find((a) => a.id === answerId)\n    if (answer?.resolution) {\n      throw new APIError(403, `${answerId} answer is already resolved`)\n    }\n  }\n\n  log('Resolving market ', {\n    contractSlug: contract.slug,\n    contractId,\n    resolutionParams,\n  })\n\n  if (\n    contract.isLove &&\n    contract.mechanism === 'cpmm-multi-1' &&\n    resolutionParams.outcome === 'YES' &&\n    'answerId' in resolutionParams\n  ) {\n    // For Love Markets:\n    // When resolving one answer YES, first resolve all other answers.\n    await resolveLoveMarketOtherAnswers(\n      contract,\n      caller,\n      creator,\n      resolutionParams\n    )\n  }\n\n  const { userUpdates } = await resolveMarketHelper(\n    contract as MarketContract,\n    caller,\n    creator,\n    resolutionParams\n  )\n  return {\n    result: { message: 'success' },\n    continue: async () => {\n      broadcastUserUpdates(userUpdates)\n    },\n  }\n}\n\nfunction getResolutionParams(\n  contract: Contract,\n  props: ValidatedAPIParams<'market/:contractId/resolve'>\n) {\n  const { outcomeType } = contract\n  const isMultiChoice = contract.mechanism === 'cpmm-multi-1'\n\n  if (\n    outcomeType === 'BINARY' ||\n    (isMultiChoice && !contract.shouldAnswersSumToOne)\n  ) {\n    const binaryParams = validate(resolveBinarySchema, props)\n    if (binaryParams.answerId && !isMultiChoice) {\n      throw new APIError(\n        400,\n        'answerId field is only allowed for multiple choice markets'\n      )\n    }\n    if (isMultiChoice && !binaryParams.answerId) {\n      throw new APIError(\n        400,\n        'answerId field is required for multiple choice markets'\n      )\n    }\n    if (binaryParams.answerId && isMultiChoice)\n      validateAnswerCpmm(contract, binaryParams.answerId)\n    return {\n      ...binaryParams,\n      value: undefined,\n      resolutions: undefined,\n    }\n  } else if (outcomeType === 'PSEUDO_NUMERIC') {\n    return {\n      ...validate(resolvePseudoNumericSchema, props),\n      resolutions: undefined,\n    }\n  } else if (isMultiChoice || outcomeType === 'NUMBER') {\n    const cpmmMultiParams = validate(resolveMultiSchema, props)\n    const { outcome } = cpmmMultiParams\n    if (outcome === 'CANCEL') {\n      return {\n        outcome: 'CANCEL',\n        resolutions: undefined,\n        value: undefined,\n        probabilityInt: undefined,\n      }\n    } else if (outcome === 'CHOOSE_ONE') {\n      const { answerId } = cpmmMultiParams\n      const resolutions = { [answerId]: 100 }\n      return {\n        outcome: answerId,\n        resolutions,\n        value: undefined,\n        probabilityInt: undefined,\n      }\n    } else if (outcome === 'CHOOSE_MULTIPLE') {\n      const { resolutions } = cpmmMultiParams\n      resolutions.forEach(({ answerId }) =>\n        validateAnswerCpmm(contract, answerId)\n      )\n      const pctSum = sumBy(resolutions, ({ pct }) => pct)\n      if (Math.abs(pctSum - 100) > 0.1) {\n        throw new APIError(400, 'Resolution percentages must sum to 100')\n      }\n      return {\n        outcome,\n        resolutions: Object.fromEntries(\n          resolutions.map((r) => [r.answerId, r.pct])\n        ),\n        value: undefined,\n        probabilityInt: undefined,\n      }\n    }\n  }\n  throw new APIError(400, `Invalid outcome type: ${outcomeType}`)\n}\n\nfunction validateAnswerCpmm(contract: MultiContract, answerId: string) {\n  const validIds = contract.answers.map((a) => a.id)\n  if (!validIds.includes(answerId)) {\n    throw new APIError(403, `${answerId} is not a valid answer ID`)\n  }\n}\n",
          "postContent": "import { sumBy } from 'lodash'\nimport { HOUSE_LIQUIDITY_PROVIDER_ID } from 'common/antes'\nimport { Contract, MarketContract, MultiContract } from 'common/contract'\nimport { getContract, getUser, isProd, log } from 'shared/utils'\nimport { APIError, type APIHandler, validate } from './helpers/endpoint'\nimport { resolveMarketHelper } from 'shared/resolve-market-helpers'\nimport { throwErrorIfNotMod } from 'shared/helpers/auth'\nimport { ValidatedAPIParams } from 'common/api/schema'\nimport {\n  resolveBinarySchema,\n  resolveMultiSchema,\n  resolvePseudoNumericSchema,\n} from 'common/api/market-types'\nimport { betsQueue } from 'shared/helpers/fn-queue'\nimport { createSupabaseDirectClient } from 'shared/supabase/init'\nimport { broadcastUserUpdates } from 'shared/supabase/users'\nimport { SWEEPSTAKES_MOD_IDS } from 'common/envs/constants'\n\nexport const resolveMarket: APIHandler<'market/:contractId/resolve'> = async (\n  props,\n  auth,\n  request\n) => {\n  return await betsQueue.enqueueFnFirst(\n    () => resolveMarketMain(props, auth, request),\n    [props.contractId, auth.uid]\n  )\n}\n\nexport const resolveMarketMain: APIHandler<\n  'market/:contractId/resolve'\n> = async (props, auth) => {\n  const db = createSupabaseDirectClient()\n\n  const { contractId } = props\n  const contract = await getContract(db, contractId)\n  if (!contract) throw new APIError(404, 'Contract not found')\n\n  const { creatorId, outcomeType } = contract\n  if (outcomeType === 'STONK') {\n    throw new APIError(403, 'STONK contracts cannot be resolved')\n  }\n\n  const caller = await getUser(auth.uid)\n  if (!caller) throw new APIError(400, 'Caller not found')\n  if (caller.isBannedFromPosting || caller.userDeleted)\n    throw new APIError(403, 'Deleted or banned user cannot resolve markets')\n  if (creatorId !== auth.uid) throwErrorIfNotMod(auth.uid)\n\n  if (\n    isProd() &&\n    contract.token === 'CASH' &&\n    auth.uid !== HOUSE_LIQUIDITY_PROVIDER_ID &&\n    !SWEEPSTAKES_MOD_IDS.includes(auth.uid)\n  ) {\n    throw new APIError(\n      403,\n      'Only the Manifold account and approved mods can resolve sweepcash markets'\n    )\n  }\n\n  if (contract.resolution) throw new APIError(403, 'Contract already resolved')\n\n  const creator = caller.id === creatorId ? caller : await getUser(creatorId)\n  if (!creator) throw new APIError(500, 'Creator not found')\n\n  const resolutionParams = getResolutionParams(contract, props)\n\n  if ('answerId' in resolutionParams && 'answers' in contract) {\n    const { answerId } = resolutionParams\n    const answer = contract.answers.find((a) => a.id === answerId)\n    if (answer?.resolution) {\n      throw new APIError(403, `${answerId} answer is already resolved`)\n    }\n  }\n\n  log('Resolving market ', {\n    contractSlug: contract.slug,\n    contractId,\n    resolutionParams,\n  })\n\n  const { userUpdates } = await resolveMarketHelper(\n    contract as MarketContract,\n    caller,\n    creator,\n    resolutionParams\n  )\n  return {\n    result: { message: 'success' },\n    continue: async () => {\n      broadcastUserUpdates(userUpdates)\n    },\n  }\n}\n\nfunction getResolutionParams(\n  contract: Contract,\n  props: ValidatedAPIParams<'market/:contractId/resolve'>\n) {\n  const { outcomeType } = contract\n  const isMultiChoice = contract.mechanism === 'cpmm-multi-1'\n\n  if (\n    outcomeType === 'BINARY' ||\n    (isMultiChoice && !contract.shouldAnswersSumToOne)\n  ) {\n    const binaryParams = validate(resolveBinarySchema, props)\n    if (binaryParams.answerId && !isMultiChoice) {\n      throw new APIError(\n        400,\n        'answerId field is only allowed for multiple choice markets'\n      )\n    }\n    if (isMultiChoice && !binaryParams.answerId) {\n      throw new APIError(\n        400,\n        'answerId field is required for multiple choice markets'\n      )\n    }\n    if (binaryParams.answerId && isMultiChoice)\n      validateAnswerCpmm(contract, binaryParams.answerId)\n    return {\n      ...binaryParams,\n      value: undefined,\n      resolutions: undefined,\n    }\n  } else if (outcomeType === 'PSEUDO_NUMERIC') {\n    return {\n      ...validate(resolvePseudoNumericSchema, props),\n      resolutions: undefined,\n    }\n  } else if (isMultiChoice || outcomeType === 'NUMBER') {\n    const cpmmMultiParams = validate(resolveMultiSchema, props)\n    const { outcome } = cpmmMultiParams\n    if (outcome === 'CANCEL') {\n      return {\n        outcome: 'CANCEL',\n        resolutions: undefined,\n        value: undefined,\n        probabilityInt: undefined,\n      }\n    } else if (outcome === 'CHOOSE_ONE') {\n      const { answerId } = cpmmMultiParams\n      const resolutions = { [answerId]: 100 }\n      return {\n        outcome: answerId,\n        resolutions,\n        value: undefined,\n        probabilityInt: undefined,\n      }\n    } else if (outcome === 'CHOOSE_MULTIPLE') {\n      const { resolutions } = cpmmMultiParams\n      resolutions.forEach(({ answerId }) =>\n        validateAnswerCpmm(contract, answerId)\n      )\n      const pctSum = sumBy(resolutions, ({ pct }) => pct)\n      if (Math.abs(pctSum - 100) > 0.1) {\n        throw new APIError(400, 'Resolution percentages must sum to 100')\n      }\n      return {\n        outcome,\n        resolutions: Object.fromEntries(\n          resolutions.map((r) => [r.answerId, r.pct])\n        ),\n        value: undefined,\n        probabilityInt: undefined,\n      }\n    }\n  }\n  throw new APIError(400, `Invalid outcome type: ${outcomeType}`)\n}\n\nfunction validateAnswerCpmm(contract: MultiContract, answerId: string) {\n  const validIds = contract.answers.map((a) => a.id)\n  if (!validIds.includes(answerId)) {\n    throw new APIError(403, `${answerId} is not a valid answer ID`)\n  }\n}\n"
        },
        {
          "path": "backend/api/src/routes.ts",
          "preContent": "import { updateMe } from './update-me'\nimport { placeBet } from './place-bet'\nimport { cancelBet } from './cancel-bet'\nimport { sellShares } from './sell-shares'\nimport { createMarket } from './create-market'\nimport { createComment } from './create-comment'\nimport { resolveMarket } from './resolve-market'\nimport { closeMarket } from './close-market'\nimport { getMe } from './get-me'\nimport { saveTwitchCredentials } from './save-twitch-credentials'\nimport { addLiquidity } from './add-liquidity'\nimport { removeLiquidity } from './remove-liquidity'\nimport { searchGroups, searchMyGroups } from './search-groups'\nimport { awardBounty } from './award-bounty'\nimport { addBounty } from './add-bounty'\nimport { createAnswerCPMM } from './create-answer-cpmm'\nimport { managram } from './managram'\nimport { setnews } from './set-news'\nimport { getDashboardFromSlug } from './get-dashboard-from-slug'\nimport { unresolve } from './unresolve'\nimport { updateMarket } from 'api/update-market'\nimport { getCompatibleLovers } from './love/compatible-lovers'\nimport { type APIPath } from 'common/api/schema'\nimport { getMarkets } from 'api/markets'\nimport { hideComment } from './hide-comment'\nimport { pinComment } from './pin-comment'\nimport { getManagrams } from './get-managrams'\nimport { getGroups } from './get-groups'\nimport { getComments } from './get-comments'\nimport { getBetPointsBetween, getBets } from './get-bets'\nimport { getLiteUser, getUser } from './get-user'\nimport { getUsers } from './get-users'\nimport { getUserBalancesByIds, getUsersByIds } from './get-users-by-ids'\nimport { getMarket } from './get-market'\nimport { getMarketProb } from './get-market-prob'\nimport { getMarketProbs } from './get-market-probs'\nimport { getGroup } from './get-group'\nimport { getPositions } from './get-positions'\nimport { getLeagues } from './get-leagues'\nimport { getContract } from './get-contract'\nimport { getSingleAnswer } from './get-answer'\nimport { getContractAnswers } from './get-contract-answers'\nimport { addOrRemoveTopicFromContract } from './add-topic-to-market'\nimport { addOrRemoveTopicFromTopic } from './add-topic-to-topic'\nimport { searchUsers } from './search-users'\nimport { searchMarketsLite, searchMarketsFull } from './search-contracts'\nimport { post } from 'api/post'\nimport { fetchLinkPreview } from './fetch-link-preview'\nimport { type APIHandler } from './helpers/endpoint'\nimport { requestLoan } from 'api/request-loan'\nimport { removePinnedPhoto } from './love/remove-pinned-photo'\nimport { getHeadlines, getPoliticsHeadlines } from './get-headlines'\nimport { getBoostAnalytics } from 'api/get-boost-analytics'\nimport { getCompatibilityQuestions } from './love/get-compatibililty-questions'\nimport { addOrRemoveReaction } from './reaction'\nimport { likeLover } from './love/like-lover'\nimport { shipLovers } from './love/ship-lovers'\nimport { createManalink } from './create-manalink'\nimport { getLikesAndShips } from './love/get-likes-and-ships'\nimport { hasFreeLike } from './love/has-free-like'\nimport { starLover } from './love/star-lover'\nimport { getLovers } from './love/get-lovers'\nimport { unlistAndCancelUserContracts } from './unlist-and-cancel-user-contracts'\nimport { getGroupsWithTopContracts } from 'api/get-topics-with-markets'\nimport { getBalanceChanges } from 'api/get-balance-changes'\nimport { getLoverAnswers } from './love/get-lover-answers'\nimport { placeMultiBet } from 'api/place-multi-bet'\nimport { getPartnerStats } from './get-partner-stats'\nimport { getSeenMarketIds } from 'api/get-seen-market-ids'\nimport { recordContractView } from 'api/record-contract-view'\nimport { createPublicChatMessage } from 'api/create-public-chat-message'\nimport { getFollowedGroups } from './get-followed-groups'\nimport { getUniqueBetGroupCount } from 'api/get-unique-bet-groups'\nimport { deleteGroup } from './delete-group'\nimport { recordContractInteraction } from 'api/record-contract-interaction'\nimport { getUserPortfolio } from './get-user-portfolio'\nimport { createuser } from 'api/create-user'\nimport { verifyPhoneNumber } from 'api/verify-phone-number'\nimport { requestOTP } from 'api/request-phone-otp'\nimport { multiSell } from 'api/multi-sell'\nimport { convertCashToMana } from './convert-cash-to-mana'\nimport { convertSpiceToMana } from './convert-sp-to-mana'\nimport { donate } from './donate'\nimport { getFeed } from 'api/get-feed'\nimport { getManaSupply } from './get-mana-supply'\nimport { getUserPortfolioHistory } from './get-user-portfolio-history'\nimport { deleteMe } from './delete-me'\nimport { updateModReport } from './update-mod-report'\nimport { getModReports } from './get-mod-reports'\nimport { searchContractPositions } from 'api/search-contract-positions'\nimport { blockUser, unblockUser } from './block-user'\nimport { blockGroup, unblockGroup } from './block-group'\nimport { blockMarket, unblockMarket } from './block-market'\nimport { getTxnSummaryStats } from 'api/get-txn-summary-stats'\nimport { getManaSummaryStats } from 'api/get-mana-summary-stats'\nimport { register } from 'api/gidx/register'\nimport { uploadDocument } from 'api/gidx/upload-document'\nimport { identityCallbackGIDX, paymentCallbackGIDX } from 'api/gidx/callback'\nimport { getVerificationStatus } from 'api/gidx/get-verification-status'\nimport { getCurrentPrivateUser } from './get-current-private-user'\nimport { updatePrivateUser } from './update-private-user'\nimport { setPushToken } from './push-token'\nimport { updateNotifSettings } from './update-notif-settings'\nimport { getVerificationDocuments } from 'api/gidx/get-verification-documents'\nimport { getRedeemablePrizeCash } from './get-redeemable-prize-cash'\nimport { getTotalRedeemablePrizeCash } from './get-total-redeemable-prize-cash'\nimport { getMonitorStatus } from 'api/gidx/get-monitor-status'\nimport { getBestComments } from 'api/get-best-comments'\nimport { recordCommentView } from 'api/record-comment-view'\nimport {\n  getChannelMemberships,\n  getChannelMessages,\n  getLastSeenChannelTime,\n  setChannelLastSeenTime,\n} from 'api/get-private-messages'\nimport { getNotifications } from 'api/get-notifications'\nimport { getCheckoutSession } from 'api/gidx/get-checkout-session'\nimport { completeCheckoutSession } from 'api/gidx/complete-checkout-session'\nimport { getContractTopics } from './get-contract-topics'\nimport { getRelatedMarkets } from './get-related-markets'\nimport { getRelatedMarketsByGroup } from './get-related-markets-by-group'\nimport { followContract } from './follow-contract'\nimport { getUserLimitOrdersWithContracts } from 'api/get-user-limit-orders-with-contracts'\nimport { getInterestingGroupsFromViews } from 'api/get-interesting-groups-from-views'\nimport { completeCashoutSession } from 'api/gidx/complete-cashout-session'\nimport { getCashouts } from './get-cashouts'\nimport { getKYCStats } from './get-kyc-stats'\nimport { getTxns } from './get-txns'\nimport { refreshAllClients } from './refresh-all-clients'\nimport { getLeaderboard } from './get-leaderboard'\nimport { toggleSystemTradingStatus } from './toggle-system-status'\nimport { completeCashoutRequest } from './gidx/complete-cashout-request'\nimport { getDailyChangedMetricsAndContracts } from './get-daily-changed-metrics-and-contracts'\nimport { getMarketsByIds } from './get-markets'\nimport { getTopicTopics } from './get-topic-topics'\nimport { getTopicDashboards } from './get-topic-dashboards'\nimport { generateAIMarketSuggestions } from './generate-ai-market-suggestions'\nimport { generateAIDescription } from './generate-ai-description'\nimport { generateAIAnswers } from './generate-ai-answers'\nimport { getmonthlybets2024 } from './get-monthly-bets-2024'\nimport { getmaxminprofit2024 } from './get-max-min-profit-2024'\nimport { getNextLoanAmount } from './get-next-loan-amount'\nimport { checkSportsEvent } from './check-sports-event'\n\nimport { createTask } from './create-task'\nimport { updateTask } from './update-task'\nimport { createCategory } from './create-category'\nimport { getCategories } from './get-categories'\nimport { updateCategory } from './update-category'\nimport { getTasks } from './get-tasks'\n\nimport { getSiteActivity } from './get-site-activity'\nimport { isSportsInterested } from './is-sports-bettor'\nimport { getSportsGames } from './get-sports-games'\nimport { getMarketProps } from './get-market-props'\nimport { getUserContractMetricsWithContracts } from './get-user-contract-metrics-with-contracts'\nimport { validateiap } from './validate-iap'\nimport { getReactions } from './get-reactions'\nimport { markallnotificationsnew } from './mark-all-notifications-new'\nimport {\n  getContractOptionVoters,\n  getContractVoters,\n} from './get-contract-voters'\nimport { purchaseContractBoost } from './purchase-contract-boost'\nimport {\n  generateAINumericRanges,\n  regenerateNumericMidpoints,\n} from './generate-ai-numeric-ranges'\nimport {\n  generateAIDateRanges,\n  regenerateDateMidpoints,\n} from './generate-ai-date-ranges'\nimport { inferNumericUnit } from './infer-numeric-unit'\nimport { generateConciseTitle } from './generate-concise-title'\nimport { getCloseDateEndpoint } from './get-close-date'\nimport { referUser } from './refer-user'\nimport {\n  saveMarketDraft,\n  getMarketDrafts,\n  deleteMarketDraft,\n} from './market-drafts'\nimport { getSeasonInfo } from './get-season-info'\nimport { markNotificationRead } from './mark-all-notifications'\nimport { createPostComment } from './create-post-comment'\nimport { createPost, updatePost } from './create-post'\nimport { getPosts } from './get-posts'\nimport { dismissUserReport } from './dismiss-user-report'\nimport { followPost } from './follow-post'\nimport { editPostComment, updatePostComment } from './edit-post-comment'\nimport { getUserComments } from './get-comments'\nexport const handlers: { [k in APIPath]: APIHandler<k> } = {\n  'refresh-all-clients': refreshAllClients,\n  bet: placeBet,\n  'multi-bet': placeMultiBet,\n  'follow-contract': followContract,\n  'bet/cancel/:betId': cancelBet,\n  'market/:contractId/sell': sellShares,\n  bets: getBets,\n  'bet-points': getBetPointsBetween,\n  'get-notifications': getNotifications,\n  'get-channel-memberships': getChannelMemberships,\n  'get-channel-messages': getChannelMessages,\n  'get-channel-seen-time': getLastSeenChannelTime,\n  'set-channel-seen-time': setChannelLastSeenTime,\n  'get-contract': getContract,\n  comment: createComment,\n  'hide-comment': hideComment,\n  'pin-comment': pinComment,\n  comments: getComments,\n  market: createMarket,\n  'market/:contractId/group': addOrRemoveTopicFromContract,\n  'market/:contractId/groups': getContractTopics,\n  'group/:slug': getGroup,\n  'group/by-id/:id': getGroup,\n  'group/by-id/:id/markets': ({ id, limit }, ...rest) =>\n    getMarkets({ groupId: id, limit }, ...rest),\n  'group/:slug/delete': deleteGroup,\n  'group/by-id/:id/delete': deleteGroup,\n  'group/:slug/block': blockGroup,\n  'group/:slug/unblock': unblockGroup,\n  'group/by-id/:topId/group/:bottomId': addOrRemoveTopicFromTopic,\n  'group/:slug/groups': getTopicTopics,\n  'group/:slug/dashboards': getTopicDashboards,\n  'group/by-id/:id/groups': getTopicTopics,\n  groups: getGroups,\n  'market/:id': getMarket,\n  'market/:id/lite': ({ id }) => getMarket({ id, lite: true }),\n  'market/:id/prob': getMarketProb,\n  'market-probs': getMarketProbs,\n  'answer/:answerId': getSingleAnswer,\n  'market/:contractId/answers': getContractAnswers,\n  'markets-by-ids': getMarketsByIds,\n  'slug/:slug': getMarket,\n  'market/:contractId/update': updateMarket,\n  'market/:contractId/close': closeMarket,\n  'market/:contractId/resolve': resolveMarket,\n  'market/:contractId/add-liquidity': addLiquidity,\n  'market/:contractId/remove-liquidity': removeLiquidity,\n  'market/:contractId/add-bounty': addBounty,\n  'market/:contractId/award-bounty': awardBounty,\n  'market/:contractId/answer': createAnswerCPMM,\n  'market/:contractId/block': blockMarket,\n  'market/:contractId/unblock': unblockMarket,\n  'get-user-limit-orders-with-contracts': getUserLimitOrdersWithContracts,\n  'get-interesting-groups-from-views': getInterestingGroupsFromViews,\n  leagues: getLeagues,\n  markets: getMarkets,\n  'search-markets': searchMarketsLite,\n  'search-markets-full': searchMarketsFull,\n  managram: managram,\n  managrams: getManagrams,\n  manalink: createManalink,\n  donate: donate,\n  'convert-cash-to-mana': convertCashToMana,\n  'convert-sp-to-mana': convertSpiceToMana,\n  'market/:id/positions': getPositions,\n  me: getMe,\n  'me/update': updateMe,\n  'me/delete': deleteMe,\n  'me/private': getCurrentPrivateUser,\n  'me/private/update': updatePrivateUser,\n  'user/by-id/:id': getUser,\n  'user/by-id/:id/lite': getLiteUser,\n  'user/:username': getUser,\n  'user/:username/lite': getLiteUser,\n  'user/:username/bets': (...props) => getBets(...props),\n  'user/by-id/:id/block': blockUser,\n  'user/by-id/:id/unblock': unblockUser,\n  users: getUsers,\n  'users/by-id': getUsersByIds,\n  'users/by-id/balance': getUserBalancesByIds,\n  'search-users': searchUsers,\n  react: addOrRemoveReaction,\n  'save-twitch': saveTwitchCredentials,\n  'set-push-token': setPushToken,\n  'update-notif-settings': updateNotifSettings,\n  headlines: getHeadlines,\n  'politics-headlines': getPoliticsHeadlines,\n  'compatible-lovers': getCompatibleLovers,\n  post: post,\n  'fetch-link-preview': fetchLinkPreview,\n  'request-loan': requestLoan,\n  'remove-pinned-photo': removePinnedPhoto,\n  'get-related-markets': getRelatedMarkets,\n  'get-related-markets-by-group': getRelatedMarketsByGroup,\n  'unlist-and-cancel-user-contracts': unlistAndCancelUserContracts,\n  'get-boost-analytics': getBoostAnalytics,\n  'get-compatibility-questions': getCompatibilityQuestions,\n  'like-lover': likeLover,\n  'ship-lovers': shipLovers,\n  'get-likes-and-ships': getLikesAndShips,\n  'has-free-like': hasFreeLike,\n  'star-lover': starLover,\n  'get-lovers': getLovers,\n  'get-lover-answers': getLoverAnswers,\n  'set-news': setnews,\n  'search-groups': searchGroups,\n  'search-my-groups': searchMyGroups,\n  'get-groups-with-top-contracts': getGroupsWithTopContracts,\n  'get-balance-changes': getBalanceChanges,\n  'get-partner-stats': getPartnerStats,\n  'get-posts': getPosts,\n  'get-seen-market-ids': getSeenMarketIds,\n  'record-contract-view': recordContractView,\n  'get-dashboard-from-slug': getDashboardFromSlug,\n  'create-public-chat-message': createPublicChatMessage,\n  unresolve: unresolve,\n  'get-followed-groups': getFollowedGroups,\n  'unique-bet-group-count': getUniqueBetGroupCount,\n  'record-contract-interaction': recordContractInteraction,\n  'get-user-portfolio': getUserPortfolio,\n  'get-user-portfolio-history': getUserPortfolioHistory,\n  createuser: createuser,\n  'verify-phone-number': verifyPhoneNumber,\n  'request-otp': requestOTP,\n  'multi-sell': multiSell,\n  'get-feed': getFeed,\n  'get-mana-supply': getManaSupply,\n  'update-mod-report': updateModReport,\n  'get-mod-reports': getModReports,\n  'search-contract-positions': searchContractPositions,\n  'get-txn-summary-stats': getTxnSummaryStats,\n  'get-mana-summary-stats': getManaSummaryStats,\n  'register-gidx': register,\n  'get-checkout-session-gidx': getCheckoutSession,\n  'complete-checkout-session-gidx': completeCheckoutSession,\n  'complete-cashout-session-gidx': completeCashoutSession,\n  'complete-cashout-request': completeCashoutRequest,\n  'get-verification-status-gidx': getVerificationStatus,\n  'upload-document-gidx': uploadDocument,\n  'identity-callback-gidx': identityCallbackGIDX,\n  'payment-callback-gidx': paymentCallbackGIDX,\n  'get-verification-documents-gidx': getVerificationDocuments,\n  'get-redeemable-prize-cash': getRedeemablePrizeCash,\n  'get-total-redeemable-prize-cash': getTotalRedeemablePrizeCash,\n  'get-monitor-status-gidx': getMonitorStatus,\n  'get-best-comments': getBestComments,\n  'record-comment-view': recordCommentView,\n  'get-cashouts': getCashouts,\n  'get-kyc-stats': getKYCStats,\n  txns: getTxns,\n  'toggle-system-trading-status': toggleSystemTradingStatus,\n  leaderboard: getLeaderboard,\n  'get-daily-changed-metrics-and-contracts': getDailyChangedMetricsAndContracts,\n  'generate-ai-market-suggestions': generateAIMarketSuggestions,\n  'generate-ai-description': generateAIDescription,\n  'generate-ai-answers': generateAIAnswers,\n  'get-monthly-bets-2024': getmonthlybets2024,\n  'get-max-min-profit-2024': getmaxminprofit2024,\n  'get-next-loan-amount': getNextLoanAmount,\n  'check-sports-event': checkSportsEvent,\n  'create-task': createTask,\n  'update-task': updateTask,\n  'create-category': createCategory,\n  'get-categories': getCategories,\n  'update-category': updateCategory,\n  'get-tasks': getTasks,\n  'get-site-activity': getSiteActivity,\n  'is-sports-interested': isSportsInterested,\n  'get-sports-games': getSportsGames,\n  'get-market-props': getMarketProps,\n  'get-user-contract-metrics-with-contracts':\n    getUserContractMetricsWithContracts,\n  validateIap: validateiap,\n  'comment-reactions': getReactions,\n  'mark-all-notifications-new': markallnotificationsnew,\n  'get-contract-voters': getContractVoters,\n  'get-contract-option-voters': getContractOptionVoters,\n  'purchase-contract-boost': purchaseContractBoost,\n  'generate-ai-numeric-ranges': generateAINumericRanges,\n  'regenerate-numeric-midpoints': regenerateNumericMidpoints,\n  'infer-numeric-unit': inferNumericUnit,\n  'generate-ai-date-ranges': generateAIDateRanges,\n  'regenerate-date-midpoints': regenerateDateMidpoints,\n  'generate-concise-title': generateConciseTitle,\n  'get-close-date': getCloseDateEndpoint,\n  'refer-user': referUser,\n  'create-post-comment': createPostComment,\n  'create-post': createPost,\n  'update-post': updatePost,\n  'update-post-comment': updatePostComment,\n  'save-market-draft': saveMarketDraft,\n  'get-market-drafts': getMarketDrafts,\n  'delete-market-draft': deleteMarketDraft,\n  'get-season-info': getSeasonInfo,\n  'mark-notification-read': markNotificationRead,\n  'dismiss-user-report': dismissUserReport,\n  'follow-post': followPost,\n  'edit-post-comment': editPostComment,\n  'user-comments': getUserComments,\n} as const\n",
          "postContent": "import { updateMe } from './update-me'\nimport { placeBet } from './place-bet'\nimport { cancelBet } from './cancel-bet'\nimport { sellShares } from './sell-shares'\nimport { createMarket } from './create-market'\nimport { createComment } from './create-comment'\nimport { resolveMarket } from './resolve-market'\nimport { closeMarket } from './close-market'\nimport { getMe } from './get-me'\nimport { saveTwitchCredentials } from './save-twitch-credentials'\nimport { addLiquidity } from './add-liquidity'\nimport { removeLiquidity } from './remove-liquidity'\nimport { searchGroups, searchMyGroups } from './search-groups'\nimport { awardBounty } from './award-bounty'\nimport { addBounty } from './add-bounty'\nimport { createAnswerCPMM } from './create-answer-cpmm'\nimport { managram } from './managram'\nimport { setnews } from './set-news'\nimport { getDashboardFromSlug } from './get-dashboard-from-slug'\nimport { unresolve } from './unresolve'\nimport { updateMarket } from 'api/update-market'\nimport { type APIPath } from 'common/api/schema'\nimport { getMarkets } from 'api/markets'\nimport { hideComment } from './hide-comment'\nimport { pinComment } from './pin-comment'\nimport { getManagrams } from './get-managrams'\nimport { getGroups } from './get-groups'\nimport { getComments } from './get-comments'\nimport { getBetPointsBetween, getBets } from './get-bets'\nimport { getLiteUser, getUser } from './get-user'\nimport { getUsers } from './get-users'\nimport { getUserBalancesByIds, getUsersByIds } from './get-users-by-ids'\nimport { getMarket } from './get-market'\nimport { getMarketProb } from './get-market-prob'\nimport { getMarketProbs } from './get-market-probs'\nimport { getGroup } from './get-group'\nimport { getPositions } from './get-positions'\nimport { getLeagues } from './get-leagues'\nimport { getContract } from './get-contract'\nimport { getSingleAnswer } from './get-answer'\nimport { getContractAnswers } from './get-contract-answers'\nimport { addOrRemoveTopicFromContract } from './add-topic-to-market'\nimport { addOrRemoveTopicFromTopic } from './add-topic-to-topic'\nimport { searchUsers } from './search-users'\nimport { searchMarketsLite, searchMarketsFull } from './search-contracts'\nimport { post } from 'api/post'\nimport { fetchLinkPreview } from './fetch-link-preview'\nimport { type APIHandler } from './helpers/endpoint'\nimport { requestLoan } from 'api/request-loan'\nimport { getHeadlines, getPoliticsHeadlines } from './get-headlines'\nimport { getBoostAnalytics } from 'api/get-boost-analytics'\nimport { addOrRemoveReaction } from './reaction'\nimport { createManalink } from './create-manalink'\nimport { unlistAndCancelUserContracts } from './unlist-and-cancel-user-contracts'\nimport { getGroupsWithTopContracts } from 'api/get-topics-with-markets'\nimport { getBalanceChanges } from 'api/get-balance-changes'\nimport { placeMultiBet } from 'api/place-multi-bet'\nimport { getPartnerStats } from './get-partner-stats'\nimport { getSeenMarketIds } from 'api/get-seen-market-ids'\nimport { recordContractView } from 'api/record-contract-view'\nimport { createPublicChatMessage } from 'api/create-public-chat-message'\nimport { getFollowedGroups } from './get-followed-groups'\nimport { getUniqueBetGroupCount } from 'api/get-unique-bet-groups'\nimport { deleteGroup } from './delete-group'\nimport { recordContractInteraction } from 'api/record-contract-interaction'\nimport { getUserPortfolio } from './get-user-portfolio'\nimport { createuser } from 'api/create-user'\nimport { verifyPhoneNumber } from 'api/verify-phone-number'\nimport { requestOTP } from 'api/request-phone-otp'\nimport { multiSell } from 'api/multi-sell'\nimport { convertCashToMana } from './convert-cash-to-mana'\nimport { convertSpiceToMana } from './convert-sp-to-mana'\nimport { donate } from './donate'\nimport { getFeed } from 'api/get-feed'\nimport { getManaSupply } from './get-mana-supply'\nimport { getUserPortfolioHistory } from './get-user-portfolio-history'\nimport { deleteMe } from './delete-me'\nimport { updateModReport } from './update-mod-report'\nimport { getModReports } from './get-mod-reports'\nimport { searchContractPositions } from 'api/search-contract-positions'\nimport { blockUser, unblockUser } from './block-user'\nimport { blockGroup, unblockGroup } from './block-group'\nimport { blockMarket, unblockMarket } from './block-market'\nimport { getTxnSummaryStats } from 'api/get-txn-summary-stats'\nimport { getManaSummaryStats } from 'api/get-mana-summary-stats'\nimport { register } from 'api/gidx/register'\nimport { uploadDocument } from 'api/gidx/upload-document'\nimport { identityCallbackGIDX, paymentCallbackGIDX } from 'api/gidx/callback'\nimport { getVerificationStatus } from 'api/gidx/get-verification-status'\nimport { getCurrentPrivateUser } from './get-current-private-user'\nimport { updatePrivateUser } from './update-private-user'\nimport { setPushToken } from './push-token'\nimport { updateNotifSettings } from './update-notif-settings'\nimport { getVerificationDocuments } from 'api/gidx/get-verification-documents'\nimport { getRedeemablePrizeCash } from './get-redeemable-prize-cash'\nimport { getTotalRedeemablePrizeCash } from './get-total-redeemable-prize-cash'\nimport { getMonitorStatus } from 'api/gidx/get-monitor-status'\nimport { getBestComments } from 'api/get-best-comments'\nimport { recordCommentView } from 'api/record-comment-view'\nimport {\n  getChannelMemberships,\n  getChannelMessages,\n  getLastSeenChannelTime,\n  setChannelLastSeenTime,\n} from 'api/get-private-messages'\nimport { getNotifications } from 'api/get-notifications'\nimport { getCheckoutSession } from 'api/gidx/get-checkout-session'\nimport { completeCheckoutSession } from 'api/gidx/complete-checkout-session'\nimport { getContractTopics } from './get-contract-topics'\nimport { getRelatedMarkets } from './get-related-markets'\nimport { getRelatedMarketsByGroup } from './get-related-markets-by-group'\nimport { followContract } from './follow-contract'\nimport { getUserLimitOrdersWithContracts } from 'api/get-user-limit-orders-with-contracts'\nimport { getInterestingGroupsFromViews } from 'api/get-interesting-groups-from-views'\nimport { completeCashoutSession } from 'api/gidx/complete-cashout-session'\nimport { getCashouts } from './get-cashouts'\nimport { getKYCStats } from './get-kyc-stats'\nimport { getTxns } from './get-txns'\nimport { refreshAllClients } from './refresh-all-clients'\nimport { getLeaderboard } from './get-leaderboard'\nimport { toggleSystemTradingStatus } from './toggle-system-status'\nimport { completeCashoutRequest } from './gidx/complete-cashout-request'\nimport { getDailyChangedMetricsAndContracts } from './get-daily-changed-metrics-and-contracts'\nimport { getMarketsByIds } from './get-markets'\nimport { getTopicTopics } from './get-topic-topics'\nimport { getTopicDashboards } from './get-topic-dashboards'\nimport { generateAIMarketSuggestions } from './generate-ai-market-suggestions'\nimport { generateAIDescription } from './generate-ai-description'\nimport { generateAIAnswers } from './generate-ai-answers'\nimport { getmonthlybets2024 } from './get-monthly-bets-2024'\nimport { getmaxminprofit2024 } from './get-max-min-profit-2024'\nimport { getNextLoanAmount } from './get-next-loan-amount'\nimport { checkSportsEvent } from './check-sports-event'\n\nimport { createTask } from './create-task'\nimport { updateTask } from './update-task'\nimport { createCategory } from './create-category'\nimport { getCategories } from './get-categories'\nimport { updateCategory } from './update-category'\nimport { getTasks } from './get-tasks'\n\nimport { getSiteActivity } from './get-site-activity'\nimport { isSportsInterested } from './is-sports-bettor'\nimport { getSportsGames } from './get-sports-games'\nimport { getMarketProps } from './get-market-props'\nimport { getUserContractMetricsWithContracts } from './get-user-contract-metrics-with-contracts'\nimport { validateiap } from './validate-iap'\nimport { getReactions } from './get-reactions'\nimport { markallnotificationsnew } from './mark-all-notifications-new'\nimport {\n  getContractOptionVoters,\n  getContractVoters,\n} from './get-contract-voters'\nimport { purchaseContractBoost } from './purchase-contract-boost'\nimport {\n  generateAINumericRanges,\n  regenerateNumericMidpoints,\n} from './generate-ai-numeric-ranges'\nimport {\n  generateAIDateRanges,\n  regenerateDateMidpoints,\n} from './generate-ai-date-ranges'\nimport { inferNumericUnit } from './infer-numeric-unit'\nimport { generateConciseTitle } from './generate-concise-title'\nimport { getCloseDateEndpoint } from './get-close-date'\nimport { referUser } from './refer-user'\nimport {\n  saveMarketDraft,\n  getMarketDrafts,\n  deleteMarketDraft,\n} from './market-drafts'\nimport { getSeasonInfo } from './get-season-info'\nimport { markNotificationRead } from './mark-all-notifications'\nimport { createPostComment } from './create-post-comment'\nimport { createPost, updatePost } from './create-post'\nimport { getPosts } from './get-posts'\nimport { dismissUserReport } from './dismiss-user-report'\nimport { followPost } from './follow-post'\nimport { editPostComment, updatePostComment } from './edit-post-comment'\nimport { getUserComments } from './get-comments'\nexport const handlers: { [k in APIPath]: APIHandler<k> } = {\n  'refresh-all-clients': refreshAllClients,\n  bet: placeBet,\n  'multi-bet': placeMultiBet,\n  'follow-contract': followContract,\n  'bet/cancel/:betId': cancelBet,\n  'market/:contractId/sell': sellShares,\n  bets: getBets,\n  'bet-points': getBetPointsBetween,\n  'get-notifications': getNotifications,\n  'get-channel-memberships': getChannelMemberships,\n  'get-channel-messages': getChannelMessages,\n  'get-channel-seen-time': getLastSeenChannelTime,\n  'set-channel-seen-time': setChannelLastSeenTime,\n  'get-contract': getContract,\n  comment: createComment,\n  'hide-comment': hideComment,\n  'pin-comment': pinComment,\n  comments: getComments,\n  market: createMarket,\n  'market/:contractId/group': addOrRemoveTopicFromContract,\n  'market/:contractId/groups': getContractTopics,\n  'group/:slug': getGroup,\n  'group/by-id/:id': getGroup,\n  'group/by-id/:id/markets': ({ id, limit }, ...rest) =>\n    getMarkets({ groupId: id, limit }, ...rest),\n  'group/:slug/delete': deleteGroup,\n  'group/by-id/:id/delete': deleteGroup,\n  'group/:slug/block': blockGroup,\n  'group/:slug/unblock': unblockGroup,\n  'group/by-id/:topId/group/:bottomId': addOrRemoveTopicFromTopic,\n  'group/:slug/groups': getTopicTopics,\n  'group/:slug/dashboards': getTopicDashboards,\n  'group/by-id/:id/groups': getTopicTopics,\n  groups: getGroups,\n  'market/:id': getMarket,\n  'market/:id/lite': ({ id }) => getMarket({ id, lite: true }),\n  'market/:id/prob': getMarketProb,\n  'market-probs': getMarketProbs,\n  'answer/:answerId': getSingleAnswer,\n  'market/:contractId/answers': getContractAnswers,\n  'markets-by-ids': getMarketsByIds,\n  'slug/:slug': getMarket,\n  'market/:contractId/update': updateMarket,\n  'market/:contractId/close': closeMarket,\n  'market/:contractId/resolve': resolveMarket,\n  'market/:contractId/add-liquidity': addLiquidity,\n  'market/:contractId/remove-liquidity': removeLiquidity,\n  'market/:contractId/add-bounty': addBounty,\n  'market/:contractId/award-bounty': awardBounty,\n  'market/:contractId/answer': createAnswerCPMM,\n  'market/:contractId/block': blockMarket,\n  'market/:contractId/unblock': unblockMarket,\n  'get-user-limit-orders-with-contracts': getUserLimitOrdersWithContracts,\n  'get-interesting-groups-from-views': getInterestingGroupsFromViews,\n  leagues: getLeagues,\n  markets: getMarkets,\n  'search-markets': searchMarketsLite,\n  'search-markets-full': searchMarketsFull,\n  managram: managram,\n  managrams: getManagrams,\n  manalink: createManalink,\n  donate: donate,\n  'convert-cash-to-mana': convertCashToMana,\n  'convert-sp-to-mana': convertSpiceToMana,\n  'market/:id/positions': getPositions,\n  me: getMe,\n  'me/update': updateMe,\n  'me/delete': deleteMe,\n  'me/private': getCurrentPrivateUser,\n  'me/private/update': updatePrivateUser,\n  'user/by-id/:id': getUser,\n  'user/by-id/:id/lite': getLiteUser,\n  'user/:username': getUser,\n  'user/:username/lite': getLiteUser,\n  'user/:username/bets': (...props) => getBets(...props),\n  'user/by-id/:id/block': blockUser,\n  'user/by-id/:id/unblock': unblockUser,\n  users: getUsers,\n  'users/by-id': getUsersByIds,\n  'users/by-id/balance': getUserBalancesByIds,\n  'search-users': searchUsers,\n  react: addOrRemoveReaction,\n  'save-twitch': saveTwitchCredentials,\n  'set-push-token': setPushToken,\n  'update-notif-settings': updateNotifSettings,\n  headlines: getHeadlines,\n  'politics-headlines': getPoliticsHeadlines,\n  post: post,\n  'fetch-link-preview': fetchLinkPreview,\n  'request-loan': requestLoan,\n  'get-related-markets': getRelatedMarkets,\n  'get-related-markets-by-group': getRelatedMarketsByGroup,\n  'unlist-and-cancel-user-contracts': unlistAndCancelUserContracts,\n  'get-boost-analytics': getBoostAnalytics,\n  'set-news': setnews,\n  'search-groups': searchGroups,\n  'search-my-groups': searchMyGroups,\n  'get-groups-with-top-contracts': getGroupsWithTopContracts,\n  'get-balance-changes': getBalanceChanges,\n  'get-partner-stats': getPartnerStats,\n  'get-posts': getPosts,\n  'get-seen-market-ids': getSeenMarketIds,\n  'record-contract-view': recordContractView,\n  'get-dashboard-from-slug': getDashboardFromSlug,\n  'create-public-chat-message': createPublicChatMessage,\n  unresolve: unresolve,\n  'get-followed-groups': getFollowedGroups,\n  'unique-bet-group-count': getUniqueBetGroupCount,\n  'record-contract-interaction': recordContractInteraction,\n  'get-user-portfolio': getUserPortfolio,\n  'get-user-portfolio-history': getUserPortfolioHistory,\n  createuser: createuser,\n  'verify-phone-number': verifyPhoneNumber,\n  'request-otp': requestOTP,\n  'multi-sell': multiSell,\n  'get-feed': getFeed,\n  'get-mana-supply': getManaSupply,\n  'update-mod-report': updateModReport,\n  'get-mod-reports': getModReports,\n  'search-contract-positions': searchContractPositions,\n  'get-txn-summary-stats': getTxnSummaryStats,\n  'get-mana-summary-stats': getManaSummaryStats,\n  'register-gidx': register,\n  'get-checkout-session-gidx': getCheckoutSession,\n  'complete-checkout-session-gidx': completeCheckoutSession,\n  'complete-cashout-session-gidx': completeCashoutSession,\n  'complete-cashout-request': completeCashoutRequest,\n  'get-verification-status-gidx': getVerificationStatus,\n  'upload-document-gidx': uploadDocument,\n  'identity-callback-gidx': identityCallbackGIDX,\n  'payment-callback-gidx': paymentCallbackGIDX,\n  'get-verification-documents-gidx': getVerificationDocuments,\n  'get-redeemable-prize-cash': getRedeemablePrizeCash,\n  'get-total-redeemable-prize-cash': getTotalRedeemablePrizeCash,\n  'get-monitor-status-gidx': getMonitorStatus,\n  'get-best-comments': getBestComments,\n  'record-comment-view': recordCommentView,\n  'get-cashouts': getCashouts,\n  'get-kyc-stats': getKYCStats,\n  txns: getTxns,\n  'toggle-system-trading-status': toggleSystemTradingStatus,\n  leaderboard: getLeaderboard,\n  'get-daily-changed-metrics-and-contracts': getDailyChangedMetricsAndContracts,\n  'generate-ai-market-suggestions': generateAIMarketSuggestions,\n  'generate-ai-description': generateAIDescription,\n  'generate-ai-answers': generateAIAnswers,\n  'get-monthly-bets-2024': getmonthlybets2024,\n  'get-max-min-profit-2024': getmaxminprofit2024,\n  'get-next-loan-amount': getNextLoanAmount,\n  'check-sports-event': checkSportsEvent,\n  'create-task': createTask,\n  'update-task': updateTask,\n  'create-category': createCategory,\n  'get-categories': getCategories,\n  'update-category': updateCategory,\n  'get-tasks': getTasks,\n  'get-site-activity': getSiteActivity,\n  'is-sports-interested': isSportsInterested,\n  'get-sports-games': getSportsGames,\n  'get-market-props': getMarketProps,\n  'get-user-contract-metrics-with-contracts':\n    getUserContractMetricsWithContracts,\n  validateIap: validateiap,\n  'comment-reactions': getReactions,\n  'mark-all-notifications-new': markallnotificationsnew,\n  'get-contract-voters': getContractVoters,\n  'get-contract-option-voters': getContractOptionVoters,\n  'purchase-contract-boost': purchaseContractBoost,\n  'generate-ai-numeric-ranges': generateAINumericRanges,\n  'regenerate-numeric-midpoints': regenerateNumericMidpoints,\n  'infer-numeric-unit': inferNumericUnit,\n  'generate-ai-date-ranges': generateAIDateRanges,\n  'regenerate-date-midpoints': regenerateDateMidpoints,\n  'generate-concise-title': generateConciseTitle,\n  'get-close-date': getCloseDateEndpoint,\n  'refer-user': referUser,\n  'create-post-comment': createPostComment,\n  'create-post': createPost,\n  'update-post': updatePost,\n  'update-post-comment': updatePostComment,\n  'save-market-draft': saveMarketDraft,\n  'get-market-drafts': getMarketDrafts,\n  'delete-market-draft': deleteMarketDraft,\n  'get-season-info': getSeasonInfo,\n  'mark-notification-read': markNotificationRead,\n  'dismiss-user-report': dismissUserReport,\n  'follow-post': followPost,\n  'edit-post-comment': editPostComment,\n  'user-comments': getUserComments,\n} as const\n"
        },
        {
          "path": "backend/api/src/search-location.ts",
          "preContent": "import { z } from 'zod'\nimport { MaybeAuthedEndpoint, validate } from './helpers/endpoint'\n\nconst bodySchema = z\n  .object({\n    term: z.string(),\n    limit: z.number().optional(),\n  })\n  .strict()\n\nexport const searchlocation = MaybeAuthedEndpoint(async (req) => {\n  const { term, limit } = validate(bodySchema, req.body)\n  const apiKey = process.env.GEODB_API_KEY\n\n  if (!apiKey) {\n    return { status: 'failure', data: 'Missing GEODB API key' }\n  }\n  const host = 'wft-geo-db.p.rapidapi.com'\n  const baseUrl = `https://${host}/v1/geo`\n  const url = `${baseUrl}/cities?namePrefix=${term}&limit=${\n    limit ?? 10\n  }&offset=0&sort=-population`\n\n  try {\n    const res = await fetch(url, {\n      method: 'GET',\n      headers: {\n        'X-RapidAPI-Key': apiKey,\n        'X-RapidAPI-Host': host,\n      },\n    })\n    if (!res.ok) {\n      throw new Error(`HTTP error! Status: ${res.status}`)\n    }\n\n    const data = await res.json()\n    return { status: 'success', data: data }\n  } catch (error) {\n    return { status: 'failure', data: error }\n  }\n})\n",
          "postContent": "[DELETED]"
        },
        {
          "path": "backend/api/src/search-near-city.ts",
          "preContent": "import { z } from 'zod'\nimport { MaybeAuthedEndpoint, validate } from './helpers/endpoint'\n\nconst bodySchema = z.object({\n  cityId: z.string(),\n  radius: z.number().refine((data) => data > 0 && data < 501, {\n    message: 'Number must be greater than 0 and less than 501',\n  }),\n})\n\nexport const searchnearcity = MaybeAuthedEndpoint(async (req) => {\n  const { cityId, radius } = validate(bodySchema, req.body)\n  return await searchNearCityMain(cityId, radius)\n})\n\nconst searchNearCityMain = async (cityId: string, radius: number) => {\n  const apiKey = process.env.GEODB_API_KEY\n\n  if (!apiKey) {\n    return { status: 'failure', data: 'Missing GEODB API key' }\n  }\n  const host = 'wft-geo-db.p.rapidapi.com'\n  const baseUrl = `https://${host}/v1/geo`\n  const url = `${baseUrl}/cities/${cityId}/nearbyCities?radius=${radius}&offset=0&sort=-population&limit=100`\n\n  try {\n    const res = await fetch(url, {\n      method: 'GET',\n      headers: {\n        'X-RapidAPI-Key': apiKey,\n        'X-RapidAPI-Host': host,\n      },\n    })\n\n    if (!res.ok) {\n      throw new Error(`HTTP error! Status: ${res.status}`)\n    }\n\n    const data = await res.json()\n\n    return { status: 'success', data: data }\n  } catch (error) {\n    return { status: 'failure', data: error }\n  }\n}\n\nexport const getNearbyCities = async (cityId: string, radius: number) => {\n  const result = await searchNearCityMain(cityId, radius)\n  const cityIds = (result.data.data as any[]).map(\n    (city) => city.id.toString() as string\n  )\n  return cityIds\n}\n",
          "postContent": "[DELETED]"
        },
        {
          "path": "backend/email-templates/new-endorsement.html",
          "preContent": "<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:v=\"urn:schemas-microsoft-com:vml\"\n    xmlns:o=\"urn:schemas-microsoft-com:office:office\">\n\n<head>\n    <title>New market from {{creatorName}}</title>\n    <!--[if !mso]><!-->\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <!--<![endif]-->\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n    <style type=\"text/css\">\n        #outlook a {\n            padding: 0;\n        }\n\n        body {\n            margin: 0;\n            padding: 0;\n            -webkit-text-size-adjust: 100%;\n            -ms-text-size-adjust: 100%;\n        }\n\n        table,\n        td {\n            border-collapse: collapse;\n            mso-table-lspace: 0pt;\n            mso-table-rspace: 0pt;\n        }\n\n        img {\n            border: 0;\n            height: auto;\n            line-height: 100%;\n            outline: none;\n            text-decoration: none;\n            -ms-interpolation-mode: bicubic;\n        }\n\n        p {\n            display: block;\n            margin: 13px 0;\n        }\n    </style>\n    <!--[if mso]>\n      <noscript>\n        <xml>\n          <o:OfficeDocumentSettings>\n            <o:AllowPNG />\n            <o:PixelsPerInch>96</o:PixelsPerInch>\n          </o:OfficeDocumentSettings>\n        </xml>\n      </noscript>\n    <![endif]-->\n    <!--[if lte mso 11]>\n      <style type=\"text/css\">\n        .mj-outlook-group-fix {\n          width: 100% !important;\n        }\n      </style>\n    <![endif]-->\n    <!--[if !mso]><!-->\n    <link href=\"https://fonts.googleapis.com/css?family=Ubuntu:300,400,500,700\" rel=\"stylesheet\" type=\"text/css\" />\n    <link href=\"https://fonts.googleapis.com/css?family=Readex+Pro\" rel=\"stylesheet\" type=\"text/css\" />\n    <link href=\"https://fonts.googleapis.com/css?family=Readex+Pro\" rel=\"stylesheet\" type=\"text/css\" />\n    <style type=\"text/css\">\n        @import url(https://fonts.googleapis.com/css?family=Ubuntu:300,400,500,700);\n        @import url(https://fonts.googleapis.com/css?family=Readex+Pro);\n        @import url(https://fonts.googleapis.com/css?family=Readex+Pro);\n    </style>\n    <!--<![endif]-->\n    <style type=\"text/css\">\n        @media only screen and (min-width: 480px) {\n            .mj-column-per-100 {\n                width: 100% !important;\n                max-width: 100%;\n            }\n        }\n    </style>\n    <style media=\"screen and (min-width:480px)\">\n        .moz-text-html .mj-column-per-100 {\n            width: 100% !important;\n            max-width: 100%;\n        }\n    </style>\n    <style type=\"text/css\">\n        [owa] .mj-column-per-100 {\n            width: 100% !important;\n            max-width: 100%;\n        }\n    </style>\n    <style type=\"text/css\">\n        @media only screen and (max-width: 480px) {\n            table.mj-full-width-mobile {\n                width: 100% !important;\n            }\n\n            td.mj-full-width-mobile {\n                width: auto !important;\n            }\n        }\n    </style>\n</head>\n\n<body style=\"word-spacing: normal; background-color: #f4f4f4\">\n    <div style=\"margin:0px auto;max-width:600px;\">\n\n        <table align=\"center\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\" role=\"presentation\" style=\"width:100%;\">\n            <tbody>\n                <tr>\n                    <td\n                        style=\"direction:ltr;font-size:0px;padding:20px 0px 5px 0px;padding-bottom:0px;padding-left:0px;padding-right:0px;text-align:center;\">\n                        <!--[if mso | IE]><table role=\"presentation\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\"><tr><td class=\"\" style=\"vertical-align:top;width:600px;\" ><![endif]-->\n\n                        <div class=\"mj-column-per-100 mj-outlook-group-fix\"\n                            style=\"font-size:0px;text-align:left;direction:ltr;display:inline-block;vertical-align:top;width:100%;\">\n\n                            <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" role=\"presentation\"\n                                style=\"vertical-align:top;\" width=\"100%\">\n                                <tbody>\n\n                                    <tr>\n                                        <td align=\"center\"\n                                            style=\"background:#ffffff;font-size:0px;padding:10px 25px 10px 25px;padding-right:25px;padding-left:25px;word-break:break-word;\">\n\n                                            <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" role=\"presentation\"\n                                                style=\"border-collapse:collapse;border-spacing:0px;\">\n                                                <tbody>\n                                                    <tr>\n                                                        <td style=\"width:550px;\">\n\n                                                            <a href=\"https://manifold.love\" target=\"_blank\">\n\n                                                                <img alt=\"manifold.love\" height=\"auto\"\n                                                                    src=\"https://manifold.love/manifold-love-banner.png\"\n                                                                    style=\"border:none;display:block;outline:none;text-decoration:none;height:auto;width:100%;font-size:13px;\"\n                                                                    title=\"\" width=\"550\">\n\n                                                            </a>\n\n                                                        </td>\n                                                    </tr>\n                                                </tbody>\n                                            </table>\n\n                                        </td>\n                                    </tr>\n\n\n\n                                </tbody>\n                            </table>\n\n                        </div>\n\n                        <!--[if mso | IE]></td></tr></table><![endif]-->\n                    </td>\n                </tr>\n            </tbody>\n        </table>\n\n    </div>\n    <!--[if mso | IE]></td></tr></table><table align=\"center\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"\" role=\"presentation\" style=\"width:600px;\" width=\"600\" bgcolor=\"#ffffff\" ><tr><td style=\"line-height:0px;font-size:0px;mso-line-height-rule:exactly;\"><![endif]-->\n    <div style=\"\n          background: #ffffff;\n          background-color: #ffffff;\n          margin: 0px auto;\n          max-width: 600px;\n        \">\n        <table align=\"center\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\" role=\"presentation\"\n            style=\"background: #ffffff; background-color: #ffffff; width: 100%\">\n            <tbody>\n\n                <tr>\n                    <td style=\"\n                  direction: ltr;\n                  font-size: 0px;\n                  padding: 20px 0px 0px 0px;\n                  padding-bottom: 0px;\n                  padding-left: 0px;\n                  padding-right: 0px;\n                  padding-top: 20px;\n                  text-align: center;\n                \">\n                        <!--[if mso | IE]><table role=\"presentation\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\"><tr><td class=\"\" style=\"vertical-align:top;width:600px;\" ><![endif]-->\n                        <div class=\"mj-column-per-100 mj-outlook-group-fix\" style=\"\n                    font-size: 0px;\n                    text-align: left;\n                    direction: ltr;\n                    display: inline-block;\n                    vertical-align: top;\n                    width: 100%;\n                  \">\n                            <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" role=\"presentation\"\n                                style=\"vertical-align: top\" width=\"100%\">\n                                <tbody>\n                                    <tr>\n                                        <td align=\"left\"\n                                            style=\"font-size:0px;padding:10px 25px;padding-top:0px;padding-bottom:0px;word-break:break-word;\">\n                                            <div\n                                                style=\"font-family:Arial, sans-serif;font-size:18px;letter-spacing:normal;line-height:1;text-align:left;color:#000000;\">\n                                                <p class=\"text-build-content\"\n                                                    style=\"line-height: 24px; margin: 10px 0; margin-top: 10px; margin-bottom: 10px;\"\n                                                    data-testid=\"4XoHRGw1Y\"><span\n                                                        style=\"color:#000000;font-family:Arial, Helvetica, sans-serif;font-size:18px;\">\n                                                    </span>Hi {{name}},</p>\n                                            </div>\n                                        </td>\n                                    </tr>\n                                    <tr>\n                                        <td align=\"left\" style=\"font-size:0px;padding:10px 25px;padding-top:10px;padding-bottom:10px;word-break:break-word;\">\n                                            <div style=\"font-family:Arial, sans-serif;font-size:17px;letter-spacing:normal;line-height:2;text-align:left;color:#000000;\">\n                                                <img src=\"{{creatorAvatarUrl}}\" alt=\"{{creatorName}}\" height=30\n                                                     width=30  style=\"\n                                                border-radius: 30px;\n                                    overflow: hidden;\n                                    height: 30px;\n                                    vertical-align: middle;\n                                    margin-right: 4px;\n                                            \"/>\n                                                <span style=\"font-weight: bold\">{{creatorName}}</span>\n                                                just said something nice about you!\n                                            </div>\n                                        </td>\n                                    </tr>\n                                    <tr>\n                                        <td align=\"center\" style=\"font-size:0px;padding-top:10px;padding-bottom:10px;word-break:break-word;\">\n                                            <div style=\"font-family:Arial, sans-serif;font-size:15px;letter-spacing:normal;\n                            width: 80%;\n                                            padding:10px 20px;\n                                            border-radius: 3px;\n                                            line-height:1.5;text-align:left;\n                                            color:#000000; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;\n                                            background-color: rgba(255,248,220,0.65);\n                                            \">\n                                                \"{{endorsementText}}\"\n                                            </div>\n                                        </td>\n                                    </tr>\n\n\n\n                                    <tr>\n                                        <td align=\"center\"\n                                            style=\"font-size:0px;padding:10px 25px;padding-top:0px;padding-bottom:20px;word-break:break-word;\">\n\n                                            <table cellspacing=\"0\" cellpadding=\"0\">\n                                                <tr>\n                                                    <td style=\"border-radius: 4px;\" bgcolor=\"#ec489a\">\n                                                        <a href=\"{{endorsementUrl}}\" target=\"_blank\"\n                                                            style=\"padding: 6px 10px; border: 1px solid #ec489a;border-radius: 12px;font-family: Helvetica, Arial, sans-serif;font-size: 16px; color: #ffffff;text-decoration: none;font-weight:semibold;display: inline-block;\">\n                                                            View their endorsement\n                                                        </a>\n                                                    </td>\n                                                </tr>\n                                            </table>\n\n                                        </td>\n                                    </tr>\n\n                                </tbody>\n                            </table>\n                        </div>\n                        <!--[if mso | IE]></td></tr></table><![endif]-->\n                    </td>\n                </tr>\n            </tbody>\n        </table>\n    </div>\n\n    <!--[if mso | IE]></td></tr></table><table align=\"center\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"\" role=\"presentation\" style=\"width:600px;\" width=\"600\" ><tr><td style=\"line-height:0px;font-size:0px;mso-line-height-rule:exactly;\"><![endif]-->\n    <div style=\"margin: 0px auto; max-width: 600px\">\n        <table align=\"center\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\" role=\"presentation\" style=\"width: 100%\">\n            <tbody>\n                <tr>\n                    <td style=\"\n                  direction: ltr;\n                  font-size: 0px;\n                  padding: 0 0 20px 0;\n                  text-align: center;\n                \">\n\n                        <!--[if mso | IE]></td></tr></table><table align=\"center\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"\" role=\"presentation\" style=\"width:600px;\" width=\"600\" ><tr><td style=\"line-height:0px;font-size:0px;mso-line-height-rule:exactly;\"><![endif]-->\n                        <div style=\"margin: 0px auto; max-width: 600px\">\n                            <table align=\"center\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\" role=\"presentation\"\n                                style=\"width: 100%\">\n                                <tbody>\n                                    <tr>\n                                        <td style=\"\n                  direction: ltr;\n                  font-size: 0px;\n                  padding: 20px 0px 20px 0px;\n                  text-align: center;\n                \">\n                                            <!--[if mso | IE]><table role=\"presentation\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\"><tr><td class=\"\" style=\"vertical-align:top;width:600px;\" ><![endif]-->\n                                            <div class=\"mj-column-per-100 mj-outlook-group-fix\" style=\"\n                    font-size: 0px;\n                    text-align: left;\n                    direction: ltr;\n                    display: inline-block;\n                    vertical-align: top;\n                    width: 100%;\n                  \">\n                                                <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" role=\"presentation\"\n                                                    width=\"100%\">\n                                                    <tbody>\n                                                        <tr>\n                                                            <td style=\"vertical-align: top; padding: 0\">\n                                                                <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\"\n                                                                    role=\"presentation\" width=\"100%\">\n                                                                    <tbody>\n                                                                        <tr>\n                                                                            <td align=\"center\" style=\"\n                                    font-size: 0px;\n                                    padding: 10px 25px;\n                                    word-break: break-word;\n                                  \">\n                                                                                <div style=\"\n                                      font-family: Ubuntu, Helvetica, Arial,\n                                        sans-serif;\n                                      font-size: 11px;\n                                      line-height: 22px;\n                                      text-align: center;\n                                      color: #000000;\n                                    \">\n                                                                                    <p style=\"margin: 10px 0\">\n                                                                                        This e-mail has been sent to\n                                                                                        {{name}},\n                                                                                        <a href=\"{{unsubscribeUrl}}\" style=\"\n                                          color: inherit;\n                                          text-decoration: none;\n                                        \" target=\"_blank\">click here to unsubscribe from this type of notification</a>.\n                                                                                    </p>\n                                                                                </div>\n                                                                            </td>\n                                                                        </tr>\n                                                                        <tr>\n                                                                            <td align=\"center\" style=\"\n                                    font-size: 0px;\n                                    padding: 10px 25px;\n                                    word-break: break-word;\n                                  \"></td>\n                                                                        </tr>\n                                                                    </tbody>\n                                                                </table>\n                                                            </td>\n                                                        </tr>\n                                                    </tbody>\n                                                </table>\n                                            </div>\n                                            <!--[if mso | IE]></td></tr></table><![endif]-->\n                                        </td>\n                                    </tr>\n                                </tbody>\n                            </table>\n                        </div>\n                        <!--[if mso | IE]></td></tr></table><![endif]-->\n                    </td>\n                </tr>\n            </tbody>\n        </table>\n    </div>\n</body>\n\n</html>",
          "postContent": "[DELETED]"
        },
        {
          "path": "backend/email-templates/new-match.html",
          "preContent": "<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:v=\"urn:schemas-microsoft-com:vml\"\n    xmlns:o=\"urn:schemas-microsoft-com:office:office\">\n\n<head>\n    <title>New market from {{creatorName}}</title>\n    <!--[if !mso]><!-->\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <!--<![endif]-->\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n    <style type=\"text/css\">\n        #outlook a {\n            padding: 0;\n        }\n\n        body {\n            margin: 0;\n            padding: 0;\n            -webkit-text-size-adjust: 100%;\n            -ms-text-size-adjust: 100%;\n        }\n\n        table,\n        td {\n            border-collapse: collapse;\n            mso-table-lspace: 0pt;\n            mso-table-rspace: 0pt;\n        }\n\n        img {\n            border: 0;\n            height: auto;\n            line-height: 100%;\n            outline: none;\n            text-decoration: none;\n            -ms-interpolation-mode: bicubic;\n        }\n\n        p {\n            display: block;\n            margin: 13px 0;\n        }\n    </style>\n    <!--[if mso]>\n      <noscript>\n        <xml>\n          <o:OfficeDocumentSettings>\n            <o:AllowPNG />\n            <o:PixelsPerInch>96</o:PixelsPerInch>\n          </o:OfficeDocumentSettings>\n        </xml>\n      </noscript>\n    <![endif]-->\n    <!--[if lte mso 11]>\n      <style type=\"text/css\">\n        .mj-outlook-group-fix {\n          width: 100% !important;\n        }\n      </style>\n    <![endif]-->\n    <!--[if !mso]><!-->\n    <link href=\"https://fonts.googleapis.com/css?family=Ubuntu:300,400,500,700\" rel=\"stylesheet\" type=\"text/css\" />\n    <link href=\"https://fonts.googleapis.com/css?family=Readex+Pro\" rel=\"stylesheet\" type=\"text/css\" />\n    <link href=\"https://fonts.googleapis.com/css?family=Readex+Pro\" rel=\"stylesheet\" type=\"text/css\" />\n    <style type=\"text/css\">\n        @import url(https://fonts.googleapis.com/css?family=Ubuntu:300,400,500,700);\n        @import url(https://fonts.googleapis.com/css?family=Readex+Pro);\n        @import url(https://fonts.googleapis.com/css?family=Readex+Pro);\n    </style>\n    <!--<![endif]-->\n    <style type=\"text/css\">\n        @media only screen and (min-width: 480px) {\n            .mj-column-per-100 {\n                width: 100% !important;\n                max-width: 100%;\n            }\n        }\n    </style>\n    <style media=\"screen and (min-width:480px)\">\n        .moz-text-html .mj-column-per-100 {\n            width: 100% !important;\n            max-width: 100%;\n        }\n    </style>\n    <style type=\"text/css\">\n        [owa] .mj-column-per-100 {\n            width: 100% !important;\n            max-width: 100%;\n        }\n    </style>\n    <style type=\"text/css\">\n        @media only screen and (max-width: 480px) {\n            table.mj-full-width-mobile {\n                width: 100% !important;\n            }\n\n            td.mj-full-width-mobile {\n                width: auto !important;\n            }\n        }\n    </style>\n</head>\n\n<body style=\"word-spacing: normal; background-color: #f4f4f4\">\n    <div style=\"margin:0px auto;max-width:600px;\">\n\n        <table align=\"center\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\" role=\"presentation\" style=\"width:100%;\">\n            <tbody>\n                <tr>\n                    <td\n                        style=\"direction:ltr;font-size:0px;padding:20px 0px 5px 0px;padding-bottom:0px;padding-left:0px;padding-right:0px;text-align:center;\">\n                        <!--[if mso | IE]><table role=\"presentation\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\"><tr><td class=\"\" style=\"vertical-align:top;width:600px;\" ><![endif]-->\n\n                        <div class=\"mj-column-per-100 mj-outlook-group-fix\"\n                            style=\"font-size:0px;text-align:left;direction:ltr;display:inline-block;vertical-align:top;width:100%;\">\n\n                            <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" role=\"presentation\"\n                                style=\"vertical-align:top;\" width=\"100%\">\n                                <tbody>\n\n                                    <tr>\n                                        <td align=\"center\"\n                                            style=\"background:#ffffff;font-size:0px;padding:10px 25px 10px 25px;padding-right:25px;padding-left:25px;word-break:break-word;\">\n\n                                            <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" role=\"presentation\"\n                                                style=\"border-collapse:collapse;border-spacing:0px;\">\n                                                <tbody>\n                                                    <tr>\n                                                        <td style=\"width:550px;\">\n\n                                                            <a href=\"https://manifold.love\" target=\"_blank\">\n\n                                                                <img alt=\"manifold.love\" height=\"auto\"\n                                                                    src=\"https://manifold.love/manifold-love-banner.png\"\n                                                                    style=\"border:none;display:block;outline:none;text-decoration:none;height:auto;width:100%;font-size:13px;\"\n                                                                    title=\"\" width=\"550\">\n\n                                                            </a>\n\n                                                        </td>\n                                                    </tr>\n                                                </tbody>\n                                            </table>\n\n                                        </td>\n                                    </tr>\n\n\n\n                                </tbody>\n                            </table>\n\n                        </div>\n\n                        <!--[if mso | IE]></td></tr></table><![endif]-->\n                    </td>\n                </tr>\n            </tbody>\n        </table>\n\n    </div>\n    <!--[if mso | IE]></td></tr></table><table align=\"center\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"\" role=\"presentation\" style=\"width:600px;\" width=\"600\" bgcolor=\"#ffffff\" ><tr><td style=\"line-height:0px;font-size:0px;mso-line-height-rule:exactly;\"><![endif]-->\n    <div style=\"\n          background: #ffffff;\n          background-color: #ffffff;\n          margin: 0px auto;\n          max-width: 600px;\n        \">\n        <table align=\"center\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\" role=\"presentation\"\n            style=\"background: #ffffff; background-color: #ffffff; width: 100%\">\n            <tbody>\n\n                <tr>\n                    <td style=\"\n                  direction: ltr;\n                  font-size: 0px;\n                  padding: 20px 0px 0px 0px;\n                  padding-bottom: 0px;\n                  padding-left: 0px;\n                  padding-right: 0px;\n                  padding-top: 20px;\n                  text-align: center;\n                \">\n                        <!--[if mso | IE]><table role=\"presentation\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\"><tr><td class=\"\" style=\"vertical-align:top;width:600px;\" ><![endif]-->\n                        <div class=\"mj-column-per-100 mj-outlook-group-fix\" style=\"\n                    font-size: 0px;\n                    text-align: left;\n                    direction: ltr;\n                    display: inline-block;\n                    vertical-align: top;\n                    width: 100%;\n                  \">\n                            <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" role=\"presentation\"\n                                style=\"vertical-align: top\" width=\"100%\">\n                                <tbody>\n                                    <tr>\n                                        <td align=\"left\"\n                                            style=\"font-size:0px;padding:10px 25px;padding-top:0px;padding-bottom:0px;word-break:break-word;\">\n                                            <div\n                                                style=\"font-family:Arial, sans-serif;font-size:18px;letter-spacing:normal;line-height:1;text-align:left;color:#000000;\">\n                                                <p class=\"text-build-content\"\n                                                    style=\"line-height: 24px; margin: 10px 0; margin-top: 10px; margin-bottom: 10px;\"\n                                                    data-testid=\"4XoHRGw1Y\"><span\n                                                        style=\"color:#000000;font-family:Arial, Helvetica, sans-serif;font-size:18px;\">\n                                                    </span>Hi {{name}},</p>\n                                            </div>\n                                        </td>\n                                    </tr>\n\n                                    <tr>\n                                        <td align=\"left\"\n                                            style=\"font-size:0px;padding:10px 25px;padding-top:0px;padding-bottom:20px;word-break:break-word;\">\n                                            <div\n                                                style=\"font-family:Arial, sans-serif;font-size:18px;letter-spacing:normal;line-height:1;text-align:left;color:#000000;\">\n                                                <p class=\"text-build-content\"\n                                                    style=\"line-height: 24px; margin: 10px 0; margin-top: 10px; margin-bottom: 10px;\"\n                                                    data-testid=\"4XoHRGw1Y\"><span\n                                                        style=\"color:#000000;font-family:Arial, Helvetica, sans-serif;font-size:18px;\">\n                                                        {{creatorName}} just proposed a new match for you, check it out!</span></p>\n                                            </div>\n                                        </td>\n                                    </tr>\n\n                                    <tr>\n                                        <td align=\"center\"\n                                            style=\"font-size:0px;padding:10px 25px;padding-top:0px;padding-bottom:20px;word-break:break-word;\">\n                                            <div\n                                              style=\"font-family:Arial, sans-serif;font-size:18px;letter-spacing:normal;line-height:1;text-align:center;color:#000000;\">\n                                                <a href=\"{{userUrl}}\">\n                                                    <img alt=\"{{matchedUsersName}}'s profile\" width=\"375\" height=\"200\"\n                                                         style=\"border: 1px solid #ec489a;\" src=\"{{userImgSrc}}\">\n                                                </a>\n                                            </div>\n                                            <table cellspacing=\"0\" cellpadding=\"0\">\n                                                <tr>\n                                                    <td style=\"border-radius: 4px;\" bgcolor=\"#ec489a\">\n                                                        <a href=\"{{userUrl}}\" target=\"_blank\"\n                                                           style=\"padding: 6px 10px; border: 1px solid #ec489a;border-radius: 12px;font-family: Helvetica, Arial, sans-serif;font-size: 16px; color: #ffffff;text-decoration: none;font-weight:600;display: inline-block;\">\n                                                            View profile\n                                                        </a>\n                                                    </td>\n                                                </tr>\n                                            </table>\n\n                                        </td>\n                                    </tr>\n\n                                </tbody>\n                            </table>\n                        </div>\n                        <!--[if mso | IE]></td></tr></table><![endif]-->\n                    </td>\n                </tr>\n            </tbody>\n        </table>\n    </div>\n\n    <!--[if mso | IE]></td></tr></table><table align=\"center\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"\" role=\"presentation\" style=\"width:600px;\" width=\"600\" ><tr><td style=\"line-height:0px;font-size:0px;mso-line-height-rule:exactly;\"><![endif]-->\n    <div style=\"margin: 0px auto; max-width: 600px\">\n        <table align=\"center\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\" role=\"presentation\" style=\"width: 100%\">\n            <tbody>\n                <tr>\n                    <td style=\"\n                  direction: ltr;\n                  font-size: 0px;\n                  padding: 0 0 20px 0;\n                  text-align: center;\n                \">\n\n                        <!--[if mso | IE]></td></tr></table><table align=\"center\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"\" role=\"presentation\" style=\"width:600px;\" width=\"600\" ><tr><td style=\"line-height:0px;font-size:0px;mso-line-height-rule:exactly;\"><![endif]-->\n                        <div style=\"margin: 0px auto; max-width: 600px\">\n                            <table align=\"center\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\" role=\"presentation\"\n                                style=\"width: 100%\">\n                                <tbody>\n                                    <tr>\n                                        <td style=\"\n                  direction: ltr;\n                  font-size: 0px;\n                  padding: 20px 0px 20px 0px;\n                  text-align: center;\n                \">\n                                            <!--[if mso | IE]><table role=\"presentation\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\"><tr><td class=\"\" style=\"vertical-align:top;width:600px;\" ><![endif]-->\n                                            <div class=\"mj-column-per-100 mj-outlook-group-fix\" style=\"\n                    font-size: 0px;\n                    text-align: left;\n                    direction: ltr;\n                    display: inline-block;\n                    vertical-align: top;\n                    width: 100%;\n                  \">\n                                                <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" role=\"presentation\"\n                                                    width=\"100%\">\n                                                    <tbody>\n                                                        <tr>\n                                                            <td style=\"vertical-align: top; padding: 0\">\n                                                                <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\"\n                                                                    role=\"presentation\" width=\"100%\">\n                                                                    <tbody>\n                                                                        <tr>\n                                                                            <td align=\"center\" style=\"\n                                    font-size: 0px;\n                                    padding: 10px 25px;\n                                    word-break: break-word;\n                                  \">\n                                                                                <div style=\"\n                                      font-family: Ubuntu, Helvetica, Arial,\n                                        sans-serif;\n                                      font-size: 11px;\n                                      line-height: 22px;\n                                      text-align: center;\n                                      color: #000000;\n                                    \">\n                                                                                    <p style=\"margin: 10px 0\">\n                                                                                        This e-mail has been sent to\n                                                                                        {{name}},\n                                                                                        <a href=\"{{unsubscribeUrl}}\" style=\"\n                                          color: inherit;\n                                          text-decoration: none;\n                                        \" target=\"_blank\">click here to unsubscribe from this type of notification</a>.\n                                                                                    </p>\n                                                                                </div>\n                                                                            </td>\n                                                                        </tr>\n                                                                        <tr>\n                                                                            <td align=\"center\" style=\"\n                                    font-size: 0px;\n                                    padding: 10px 25px;\n                                    word-break: break-word;\n                                  \"></td>\n                                                                        </tr>\n                                                                    </tbody>\n                                                                </table>\n                                                            </td>\n                                                        </tr>\n                                                    </tbody>\n                                                </table>\n                                            </div>\n                                            <!--[if mso | IE]></td></tr></table><![endif]-->\n                                        </td>\n                                    </tr>\n                                </tbody>\n                            </table>\n                        </div>\n                        <!--[if mso | IE]></td></tr></table><![endif]-->\n                    </td>\n                </tr>\n            </tbody>\n        </table>\n    </div>\n</body>\n\n</html>",
          "postContent": "[DELETED]"
        },
        {
          "path": "backend/email-templates/new-message.html",
          "preContent": "<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:v=\"urn:schemas-microsoft-com:vml\"\n    xmlns:o=\"urn:schemas-microsoft-com:office:office\">\n\n<head>\n    <title>New market from {{creatorName}}</title>\n    <!--[if !mso]><!-->\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <!--<![endif]-->\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n    <style type=\"text/css\">\n        #outlook a {\n            padding: 0;\n        }\n\n        body {\n            margin: 0;\n            padding: 0;\n            -webkit-text-size-adjust: 100%;\n            -ms-text-size-adjust: 100%;\n        }\n\n        table,\n        td {\n            border-collapse: collapse;\n            mso-table-lspace: 0pt;\n            mso-table-rspace: 0pt;\n        }\n\n        img {\n            border: 0;\n            height: auto;\n            line-height: 100%;\n            outline: none;\n            text-decoration: none;\n            -ms-interpolation-mode: bicubic;\n        }\n\n        p {\n            display: block;\n            margin: 13px 0;\n        }\n    </style>\n    <!--[if mso]>\n      <noscript>\n        <xml>\n          <o:OfficeDocumentSettings>\n            <o:AllowPNG />\n            <o:PixelsPerInch>96</o:PixelsPerInch>\n          </o:OfficeDocumentSettings>\n        </xml>\n      </noscript>\n    <![endif]-->\n    <!--[if lte mso 11]>\n      <style type=\"text/css\">\n        .mj-outlook-group-fix {\n          width: 100% !important;\n        }\n      </style>\n    <![endif]-->\n    <!--[if !mso]><!-->\n    <link href=\"https://fonts.googleapis.com/css?family=Ubuntu:300,400,500,700\" rel=\"stylesheet\" type=\"text/css\" />\n    <link href=\"https://fonts.googleapis.com/css?family=Readex+Pro\" rel=\"stylesheet\" type=\"text/css\" />\n    <link href=\"https://fonts.googleapis.com/css?family=Readex+Pro\" rel=\"stylesheet\" type=\"text/css\" />\n    <style type=\"text/css\">\n        @import url(https://fonts.googleapis.com/css?family=Ubuntu:300,400,500,700);\n        @import url(https://fonts.googleapis.com/css?family=Readex+Pro);\n        @import url(https://fonts.googleapis.com/css?family=Readex+Pro);\n    </style>\n    <!--<![endif]-->\n    <style type=\"text/css\">\n        @media only screen and (min-width: 480px) {\n            .mj-column-per-100 {\n                width: 100% !important;\n                max-width: 100%;\n            }\n        }\n    </style>\n    <style media=\"screen and (min-width:480px)\">\n        .moz-text-html .mj-column-per-100 {\n            width: 100% !important;\n            max-width: 100%;\n        }\n    </style>\n    <style type=\"text/css\">\n        [owa] .mj-column-per-100 {\n            width: 100% !important;\n            max-width: 100%;\n        }\n    </style>\n    <style type=\"text/css\">\n        @media only screen and (max-width: 480px) {\n            table.mj-full-width-mobile {\n                width: 100% !important;\n            }\n\n            td.mj-full-width-mobile {\n                width: auto !important;\n            }\n        }\n    </style>\n</head>\n\n<body style=\"word-spacing: normal; background-color: #f4f4f4\">\n    <div style=\"margin:0px auto;max-width:600px;\">\n\n        <table align=\"center\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\" role=\"presentation\" style=\"width:100%;\">\n            <tbody>\n                <tr>\n                    <td\n                        style=\"direction:ltr;font-size:0px;padding:20px 0px 5px 0px;padding-bottom:0px;padding-left:0px;padding-right:0px;text-align:center;\">\n                        <!--[if mso | IE]><table role=\"presentation\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\"><tr><td class=\"\" style=\"vertical-align:top;width:600px;\" ><![endif]-->\n\n                        <div class=\"mj-column-per-100 mj-outlook-group-fix\"\n                            style=\"font-size:0px;text-align:left;direction:ltr;display:inline-block;vertical-align:top;width:100%;\">\n\n                            <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" role=\"presentation\"\n                                style=\"vertical-align:top;\" width=\"100%\">\n                                <tbody>\n\n                                    <tr>\n                                        <td align=\"center\"\n                                            style=\"background:#ffffff;font-size:0px;padding:10px 25px 10px 25px;padding-right:25px;padding-left:25px;word-break:break-word;\">\n\n                                            <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" role=\"presentation\"\n                                                style=\"border-collapse:collapse;border-spacing:0px;\">\n                                                <tbody>\n                                                    <tr>\n                                                        <td style=\"width:550px;\">\n\n                                                            <a href=\"https://manifold.love\" target=\"_blank\">\n\n                                                                <img alt=\"manifold.love\" height=\"auto\"\n                                                                    src=\"https://manifold.love/manifold-love-banner.png\"\n                                                                    style=\"border:none;display:block;outline:none;text-decoration:none;height:auto;width:100%;font-size:13px;\"\n                                                                    title=\"\" width=\"550\">\n\n                                                            </a>\n\n                                                        </td>\n                                                    </tr>\n                                                </tbody>\n                                            </table>\n\n                                        </td>\n                                    </tr>\n\n\n\n                                </tbody>\n                            </table>\n\n                        </div>\n\n                        <!--[if mso | IE]></td></tr></table><![endif]-->\n                    </td>\n                </tr>\n            </tbody>\n        </table>\n\n    </div>\n    <!--[if mso | IE]></td></tr></table><table align=\"center\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"\" role=\"presentation\" style=\"width:600px;\" width=\"600\" bgcolor=\"#ffffff\" ><tr><td style=\"line-height:0px;font-size:0px;mso-line-height-rule:exactly;\"><![endif]-->\n    <div style=\"\n          background: #ffffff;\n          background-color: #ffffff;\n          margin: 0px auto;\n          max-width: 600px;\n        \">\n        <table align=\"center\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\" role=\"presentation\"\n            style=\"background: #ffffff; background-color: #ffffff; width: 100%\">\n            <tbody>\n\n                <tr>\n                    <td style=\"\n                  direction: ltr;\n                  font-size: 0px;\n                  padding: 20px 0px 0px 0px;\n                  padding-bottom: 0px;\n                  padding-left: 0px;\n                  padding-right: 0px;\n                  padding-top: 20px;\n                  text-align: center;\n                \">\n                        <!--[if mso | IE]><table role=\"presentation\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\"><tr><td class=\"\" style=\"vertical-align:top;width:600px;\" ><![endif]-->\n                        <div class=\"mj-column-per-100 mj-outlook-group-fix\" style=\"\n                    font-size: 0px;\n                    text-align: left;\n                    direction: ltr;\n                    display: inline-block;\n                    vertical-align: top;\n                    width: 100%;\n                  \">\n                            <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" role=\"presentation\"\n                                style=\"vertical-align: top\" width=\"100%\">\n                                <tbody>\n                                    <tr>\n                                        <td align=\"left\"\n                                            style=\"font-size:0px;padding:10px 25px;padding-top:0px;padding-bottom:0px;word-break:break-word;\">\n                                            <div\n                                                style=\"font-family:Arial, sans-serif;font-size:18px;letter-spacing:normal;line-height:1;text-align:left;color:#000000;\">\n                                                <p class=\"text-build-content\"\n                                                    style=\"line-height: 24px; margin: 10px 0; margin-top: 10px; margin-bottom: 10px;\"\n                                                    data-testid=\"4XoHRGw1Y\"><span\n                                                        style=\"color:#000000;font-family:Arial, Helvetica, sans-serif;font-size:18px;\">\n                                                    </span>Hi {{name}},</p>\n                                            </div>\n                                        </td>\n                                    </tr>\n\n                                    <tr>\n                                        <td align=\"left\"\n                                            style=\"font-size:0px;padding:10px 25px;padding-top:0px;padding-bottom:20px;word-break:break-word;\">\n                                            <div\n                                                style=\"font-family:Arial, sans-serif;font-size:18px;letter-spacing:normal;line-height:1;text-align:left;color:#000000;\">\n                                                <p class=\"text-build-content\"\n                                                    style=\"line-height: 24px; margin: 10px 0; margin-top: 10px; margin-bottom: 10px;\"\n                                                    data-testid=\"4XoHRGw1Y\"><span\n                                                        style=\"color:#000000;font-family:Arial, Helvetica, sans-serif;font-size:18px;\">\n                                                        {{creatorName}} just messaged you!</span></p>\n                                            </div>\n                                        </td>\n                                    </tr>\n\n                                    <tr>\n                                        <td align=\"center\"\n                                            style=\"font-size:0px;padding:10px 25px;padding-top:0px;padding-bottom:20px;word-break:break-word;\">\n                                            <div\n                                              style=\"font-family:Arial, sans-serif;font-size:18px;letter-spacing:normal;line-height:1;text-align:center;color:#000000;\">\n                                                <a href=\"{{messagesUrl}}\">\n                                                    <img alt=\"{{creatorName}}'s profile\" width=\"375\" height=\"200\"\n                                                         style=\"border: 1px solid #ec489a;\" src=\"{{userImgSrc}}\">\n                                                </a>\n                                            </div>\n\n                                            <table cellspacing=\"0\" cellpadding=\"0\">\n                                                <tr>\n                                                    <td style=\"border-radius: 4px;\" bgcolor=\"#ec489a\">\n                                                        <a href=\"{{messagesUrl}}\" target=\"_blank\"\n                                                            style=\"padding: 6px 10px; border: 1px solid #ec489a;border-radius: 12px;font-family: Helvetica, Arial, sans-serif;font-size: 16px; color: #ffffff;text-decoration: none;font-weight:semibold;display: inline-block;\">\n                                                            View message\n                                                        </a>\n                                                    </td>\n                                                </tr>\n                                            </table>\n\n                                        </td>\n                                    </tr>\n\n                                </tbody>\n                            </table>\n                        </div>\n                        <!--[if mso | IE]></td></tr></table><![endif]-->\n                    </td>\n                </tr>\n            </tbody>\n        </table>\n    </div>\n\n    <!--[if mso | IE]></td></tr></table><table align=\"center\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"\" role=\"presentation\" style=\"width:600px;\" width=\"600\" ><tr><td style=\"line-height:0px;font-size:0px;mso-line-height-rule:exactly;\"><![endif]-->\n    <div style=\"margin: 0px auto; max-width: 600px\">\n        <table align=\"center\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\" role=\"presentation\" style=\"width: 100%\">\n            <tbody>\n                <tr>\n                    <td style=\"\n                  direction: ltr;\n                  font-size: 0px;\n                  padding: 0 0 20px 0;\n                  text-align: center;\n                \">\n\n                        <!--[if mso | IE]></td></tr></table><table align=\"center\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"\" role=\"presentation\" style=\"width:600px;\" width=\"600\" ><tr><td style=\"line-height:0px;font-size:0px;mso-line-height-rule:exactly;\"><![endif]-->\n                        <div style=\"margin: 0px auto; max-width: 600px\">\n                            <table align=\"center\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\" role=\"presentation\"\n                                style=\"width: 100%\">\n                                <tbody>\n                                    <tr>\n                                        <td style=\"\n                  direction: ltr;\n                  font-size: 0px;\n                  padding: 20px 0px 20px 0px;\n                  text-align: center;\n                \">\n                                            <!--[if mso | IE]><table role=\"presentation\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\"><tr><td class=\"\" style=\"vertical-align:top;width:600px;\" ><![endif]-->\n                                            <div class=\"mj-column-per-100 mj-outlook-group-fix\" style=\"\n                    font-size: 0px;\n                    text-align: left;\n                    direction: ltr;\n                    display: inline-block;\n                    vertical-align: top;\n                    width: 100%;\n                  \">\n                                                <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" role=\"presentation\"\n                                                    width=\"100%\">\n                                                    <tbody>\n                                                        <tr>\n                                                            <td style=\"vertical-align: top; padding: 0\">\n                                                                <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\"\n                                                                    role=\"presentation\" width=\"100%\">\n                                                                    <tbody>\n                                                                        <tr>\n                                                                            <td align=\"center\" style=\"\n                                    font-size: 0px;\n                                    padding: 10px 25px;\n                                    word-break: break-word;\n                                  \">\n                                                                                <div style=\"\n                                      font-family: Ubuntu, Helvetica, Arial,\n                                        sans-serif;\n                                      font-size: 11px;\n                                      line-height: 22px;\n                                      text-align: center;\n                                      color: #000000;\n                                    \">\n                                                                                    <p style=\"margin: 10px 0\">\n                                                                                        This e-mail has been sent to\n                                                                                        {{name}},\n                                                                                        <a href=\"{{unsubscribeUrl}}\" style=\"\n                                          color: inherit;\n                                          text-decoration: none;\n                                        \" target=\"_blank\">click here to unsubscribe from this type of notification</a>.\n                                                                                    </p>\n                                                                                </div>\n                                                                            </td>\n                                                                        </tr>\n                                                                        <tr>\n                                                                            <td align=\"center\" style=\"\n                                    font-size: 0px;\n                                    padding: 10px 25px;\n                                    word-break: break-word;\n                                  \"></td>\n                                                                        </tr>\n                                                                    </tbody>\n                                                                </table>\n                                                            </td>\n                                                        </tr>\n                                                    </tbody>\n                                                </table>\n                                            </div>\n                                            <!--[if mso | IE]></td></tr></table><![endif]-->\n                                        </td>\n                                    </tr>\n                                </tbody>\n                            </table>\n                        </div>\n                        <!--[if mso | IE]></td></tr></table><![endif]-->\n                    </td>\n                </tr>\n            </tbody>\n        </table>\n    </div>\n</body>\n\n</html>",
          "postContent": "[DELETED]"
        },
        {
          "path": "backend/shared/src/create-love-notification.ts",
          "preContent": "import { Row } from 'common/supabase/utils'\nimport { getPrivateUser, getUser } from './utils'\nimport {\n  createSupabaseClient,\n  createSupabaseDirectClient,\n} from './supabase/init'\nimport { getNotificationDestinationsForUser } from 'common/user-notification-preferences'\nimport { Notification } from 'common/notification'\nimport { getLoverRow } from 'common/love/lover'\nimport { insertNotificationToSupabase } from './supabase/notifications'\n\nexport const createLoveLikeNotification = async (like: Row<'love_likes'>) => {\n  const { creator_id, target_id, like_id } = like\n\n  const db = createSupabaseClient()\n\n  const targetPrivateUser = await getPrivateUser(target_id)\n  const user = await getUser(creator_id)\n  const lover = await getLoverRow(creator_id, db)\n\n  if (!targetPrivateUser || !user) return\n\n  const { sendToBrowser } = getNotificationDestinationsForUser(\n    targetPrivateUser,\n    'new_love_like'\n  )\n  if (!sendToBrowser) return\n\n  const id = `${creator_id}-${like_id}`\n  const notification: Notification = {\n    id,\n    userId: target_id,\n    reason: 'new_love_like',\n    createdTime: Date.now(),\n    isSeen: false,\n    sourceId: like_id,\n    sourceType: 'love_like',\n    sourceUpdateType: 'created',\n    sourceUserName: user.name,\n    sourceUserUsername: user.username,\n    sourceUserAvatarUrl: lover.pinned_url ?? user.avatarUrl,\n    sourceText: '',\n  }\n  const pg = createSupabaseDirectClient()\n  return await insertNotificationToSupabase(notification, pg)\n}\n\nexport const createLoveShipNotification = async (\n  ship: Row<'love_ships'>,\n  recipientId: string\n) => {\n  const { creator_id, target1_id, target2_id, ship_id } = ship\n  const otherTargetId = target1_id === recipientId ? target2_id : target1_id\n\n  const db = createSupabaseClient()\n\n  const creator = await getUser(creator_id)\n  const targetPrivateUser = await getPrivateUser(recipientId)\n  const user = await getUser(otherTargetId)\n  const lover = await getLoverRow(otherTargetId, db)\n\n  if (!creator || !targetPrivateUser || !user) {\n    console.error('Could not load user object', {\n      creator,\n      targetPrivateUser,\n      user,\n    })\n    return\n  }\n\n  const { sendToBrowser } = getNotificationDestinationsForUser(\n    targetPrivateUser,\n    'new_love_ship'\n  )\n  if (!sendToBrowser) return\n\n  const id = `${creator_id}-${ship_id}`\n  const notification: Notification = {\n    id,\n    userId: recipientId,\n    reason: 'new_love_ship',\n    createdTime: Date.now(),\n    isSeen: false,\n    sourceId: ship_id,\n    sourceType: 'love_ship',\n    sourceUpdateType: 'created',\n    sourceUserName: user.name,\n    sourceUserUsername: user.username,\n    sourceUserAvatarUrl: lover.pinned_url ?? user.avatarUrl,\n    sourceText: '',\n    data: {\n      creatorId: creator_id,\n      creatorName: creator.name,\n      creatorUsername: creator.username,\n      otherTargetId,\n    },\n  }\n  const pg = createSupabaseDirectClient()\n  return await insertNotificationToSupabase(notification, pg)\n}\n",
          "postContent": "[DELETED]"
        },
        {
          "path": "backend/shared/src/create-user-main.ts",
          "preContent": "import * as admin from 'firebase-admin'\nimport { PrivateUser, User } from 'common/user'\nimport { randomString } from 'common/util/random'\nimport { cleanDisplayName, cleanUsername } from 'common/util/clean-username'\n\nimport { track } from 'shared/analytics'\nimport { getDefaultNotificationPreferences } from 'common/user-notification-preferences'\nimport { removeUndefinedProps } from 'common/util/object'\nimport { generateAvatarUrl } from 'shared/helpers/generate-and-update-avatar-urls'\nimport { getStorage } from 'firebase-admin/storage'\nimport { DEV_CONFIG } from 'common/envs/dev'\nimport { PROD_CONFIG } from 'common/envs/prod'\nimport {\n  LOVE_DOMAIN,\n  LOVE_DOMAIN_ALTERNATE,\n  RESERVED_PATHS,\n} from 'common/envs/constants'\nimport { log, isProd, getUser, getUserByUsername } from 'shared/utils'\nimport { trackSignupFB } from 'shared/fb-analytics'\nimport {\n  getAverageContractEmbedding,\n  getAverageGroupEmbedding,\n  getDefaultEmbedding,\n  normalizeAndAverageVectors,\n} from 'shared/helpers/embeddings'\nimport {\n  createSupabaseDirectClient,\n  SupabaseDirectClient,\n} from 'shared/supabase/init'\n\nimport { insert } from 'shared/supabase/utils'\nimport { runTxnFromBank } from 'shared/txn/run-txn'\nimport { SignupBonusTxn } from 'common/txn'\nimport { STARTING_BALANCE } from 'common/economy'\nimport { ValidatedAPIParams } from 'common/api/schema'\nimport { APIError } from 'common/api/utils'\nimport { onCreateUser } from 'shared/helpers/on-create-user'\nimport { convertPrivateUser, convertUser } from 'common/supabase/users'\n\nexport const createUserMain = async (\n  props: ValidatedAPIParams<'createuser'>,\n  userId: string,\n  ip: string,\n  host: string | undefined\n) => {\n  const { deviceToken: preDeviceToken, adminToken, visitedContractIds } = props\n  const firebaseUser = await admin.auth().getUser(userId)\n\n  const testUserAKAEmailPasswordUser =\n    firebaseUser.providerData[0].providerId === 'password'\n  if (\n    testUserAKAEmailPasswordUser &&\n    adminToken !== process.env.TEST_CREATE_USER_KEY\n  ) {\n    throw new APIError(\n      401,\n      'Must use correct TEST_CREATE_USER_KEY to create user with email/password'\n    )\n  }\n\n  log(`Create user from: ${host}`)\n\n  const fromLove =\n    (host?.includes('localhost')\n      ? process.env.IS_MANIFOLD_LOVE === 'true'\n      : host?.includes(LOVE_DOMAIN) || host?.includes(LOVE_DOMAIN_ALTERNATE)) ||\n    undefined\n\n  const deviceToken = testUserAKAEmailPasswordUser\n    ? randomString() + randomString()\n    : preDeviceToken\n\n  const fbUser = await admin.auth().getUser(userId)\n  const email = fbUser.email\n  const emailName = email?.replace(/@.*$/, '')\n\n  const rawName = fbUser.displayName || emailName || 'User' + randomString(4)\n  const name = cleanDisplayName(rawName)\n\n  const bucket = getStorageBucket()\n  const avatarUrl = fbUser.photoURL\n    ? fbUser.photoURL\n    : await generateAvatarUrl(userId, name, bucket)\n\n  const pg = createSupabaseDirectClient()\n\n  let username = cleanUsername(name)\n\n  // Check username case-insensitive\n  const dupes = await pg.one<number>(\n    `select count(*) from users where username ilike $1`,\n    [username],\n    (r) => r.count\n  )\n  const usernameExists = dupes > 0\n  const isReservedName = RESERVED_PATHS.includes(username)\n  if (usernameExists || isReservedName) username += randomString(4)\n\n  const { user, privateUser } = await pg.tx(async (tx) => {\n    const preexistingUser = await getUser(userId, tx)\n    if (preexistingUser)\n      throw new APIError(403, 'User already exists', {\n        userId: userId,\n      })\n\n    // Check exact username to avoid problems with duplicate requests\n    const sameNameUser = await getUserByUsername(username, tx)\n    if (sameNameUser)\n      throw new APIError(403, 'Username already taken', { username })\n\n    // Only undefined prop should be fromLove\n    const userData: Partial<User> = removeUndefinedProps({\n      id: userId,\n      avatarUrl,\n      streakForgiveness: 1,\n      shouldShowWelcome: true,\n      creatorTraders: { daily: 0, weekly: 0, monthly: 0, allTime: 0 },\n      isBannedFromPosting: Boolean(\n        (deviceToken && bannedDeviceTokens.includes(deviceToken)) ||\n          (ip && bannedIpAddresses.includes(ip))\n      ),\n      fromLove,\n      signupBonusPaid: 0,\n    })\n\n    const privateUser: PrivateUser = {\n      id: userId,\n      email,\n      initialIpAddress: ip,\n      initialDeviceToken: deviceToken,\n      notificationPreferences: getDefaultNotificationPreferences(),\n      blockedUserIds: [],\n      blockedByUserIds: [],\n      blockedContractIds: [],\n      blockedGroupSlugs: [],\n    }\n\n    const userRow = await insert(tx, 'users', {\n      id: userId,\n      name: name,\n      username: username,\n      data: userData,\n    })\n\n    const startingBonusTxn: Omit<\n      SignupBonusTxn,\n      'id' | 'createdTime' | 'fromId'\n    > = {\n      fromType: 'BANK',\n      toId: userId,\n      toType: 'USER',\n      amount: STARTING_BALANCE,\n      token: 'M$',\n      category: 'SIGNUP_BONUS',\n      description: 'Signup bonus',\n    }\n    await runTxnFromBank(tx, startingBonusTxn)\n\n    const privateUserRow = await insert(tx, 'private_users', {\n      id: privateUser.id,\n      data: privateUser,\n    })\n\n    return {\n      user: convertUser(userRow),\n      privateUser: convertPrivateUser(privateUserRow),\n    }\n  })\n\n  log('created user ', { username: user.username, firebaseId: userId })\n\n  const continuation = async () => {\n    const pg = createSupabaseDirectClient()\n    await track(\n      user.id,\n      fromLove ? 'create lover' : 'create user',\n      { username: user.username },\n      { ip }\n    )\n\n    await addContractsToSeenMarketsTable(userId, visitedContractIds, pg)\n    await upsertNewUserEmbeddings(userId, visitedContractIds, pg)\n\n    if (process.env.FB_ACCESS_TOKEN)\n      await trackSignupFB(\n        process.env.FB_ACCESS_TOKEN,\n        user.id,\n        email ?? '',\n        ip\n      ).catch((e) => log('error fb tracking:', e))\n    else log('no FB_ACCESS_TOKEN')\n    await onCreateUser(user, privateUser)\n  }\n\n  return {\n    result: {\n      user,\n      privateUser,\n    },\n    continue: continuation,\n  }\n}\n\nasync function addContractsToSeenMarketsTable(\n  userId: string,\n  visitedContractIds: string[] | undefined,\n  pg: SupabaseDirectClient\n) {\n  if (!visitedContractIds || visitedContractIds.length === 0) return\n\n  await Promise.all(\n    visitedContractIds.map((contractId) =>\n      pg.none(\n        `insert into user_contract_views (user_id, contract_id, page_views, last_page_view_ts)\n            values ($1, $2, 1, now())`,\n        [userId, contractId]\n      )\n    )\n  )\n}\n\nasync function upsertNewUserEmbeddings(\n  userId: string,\n  visitedContractIds: string[] | undefined,\n  pg: SupabaseDirectClient\n): Promise<void> {\n  log('Averaging contract embeddings for user ' + userId, {\n    visitedContractIds,\n  })\n  let embed = await getAverageContractEmbedding(pg, visitedContractIds)\n  if (!embed) embed = await getDefaultEmbedding(pg)\n  const groupIds =\n    visitedContractIds && visitedContractIds.length > 0\n      ? await pg.map(\n          `select group_id\n        from group_contracts\n        where contract_id = any($1)`,\n          [visitedContractIds],\n          (r) => r.group_id\n        )\n      : []\n  log('Averaging group embeddings for user ' + userId, { groupIds })\n  const groupEmbed = await getAverageGroupEmbedding(pg, groupIds)\n  if (groupEmbed) {\n    embed = normalizeAndAverageVectors([embed, embed, groupEmbed])\n  }\n\n  await pg.none(\n    `insert into user_embeddings (user_id, interest_embedding, contract_view_embedding)\n            values ($1, $2, $2)\n            on conflict (user_id)\n            do update set\n            interest_embedding = $2,\n            contract_view_embedding = $2\n            `,\n    [userId, embed]\n  )\n}\n\nexport function getStorageBucket() {\n  const id = isProd()\n    ? PROD_CONFIG.firebaseConfig.storageBucket\n    : DEV_CONFIG.firebaseConfig.storageBucket\n  return getStorage().bucket(id)\n}\n\n// Automatically ban users with these device tokens or ip addresses.\nconst bannedDeviceTokens = [\n  'fa807d664415',\n  'dcf208a11839',\n  'bbf18707c15d',\n  '4c2d15a6cc0c',\n  '0da6b4ea79d3',\n]\nconst bannedIpAddresses: string[] = [\n  '24.176.214.250',\n  '2607:fb90:bd95:dbcd:ac39:6c97:4e35:3fed',\n  '2607:fb91:389:ddd0:ac39:8397:4e57:f060',\n  '2607:fb90:ed9a:4c8f:ac39:cf57:4edd:4027',\n  '2607:fb90:bd36:517a:ac39:6c91:812c:6328',\n]\n",
          "postContent": "import * as admin from 'firebase-admin'\nimport { PrivateUser } from 'common/user'\nimport { randomString } from 'common/util/random'\nimport { cleanDisplayName, cleanUsername } from 'common/util/clean-username'\nimport { track } from 'shared/analytics'\nimport { getDefaultNotificationPreferences } from 'common/user-notification-preferences'\nimport { generateAvatarUrl } from 'shared/helpers/generate-and-update-avatar-urls'\nimport { getStorage } from 'firebase-admin/storage'\nimport { DEV_CONFIG } from 'common/envs/dev'\nimport { PROD_CONFIG } from 'common/envs/prod'\nimport { RESERVED_PATHS } from 'common/envs/constants'\nimport { log, isProd, getUser, getUserByUsername } from 'shared/utils'\nimport { trackSignupFB } from 'shared/fb-analytics'\nimport {\n  getAverageContractEmbedding,\n  getAverageGroupEmbedding,\n  getDefaultEmbedding,\n  normalizeAndAverageVectors,\n} from 'shared/helpers/embeddings'\nimport {\n  createSupabaseDirectClient,\n  SupabaseDirectClient,\n} from 'shared/supabase/init'\n\nimport { insert } from 'shared/supabase/utils'\nimport { runTxnFromBank } from 'shared/txn/run-txn'\nimport { SignupBonusTxn } from 'common/txn'\nimport { STARTING_BALANCE } from 'common/economy'\nimport { ValidatedAPIParams } from 'common/api/schema'\nimport { APIError } from 'common/api/utils'\nimport { onCreateUser } from 'shared/helpers/on-create-user'\nimport { convertPrivateUser, convertUser } from 'common/supabase/users'\n\nexport const createUserMain = async (\n  props: ValidatedAPIParams<'createuser'>,\n  userId: string,\n  ip: string,\n  host: string | undefined\n) => {\n  const { deviceToken: preDeviceToken, adminToken, visitedContractIds } = props\n  const firebaseUser = await admin.auth().getUser(userId)\n\n  const testUserAKAEmailPasswordUser =\n    firebaseUser.providerData[0].providerId === 'password'\n  if (\n    testUserAKAEmailPasswordUser &&\n    adminToken !== process.env.TEST_CREATE_USER_KEY\n  ) {\n    throw new APIError(\n      401,\n      'Must use correct TEST_CREATE_USER_KEY to create user with email/password'\n    )\n  }\n\n  log(`Create user from: ${host}`)\n\n  const deviceToken = testUserAKAEmailPasswordUser\n    ? randomString() + randomString()\n    : preDeviceToken\n\n  const fbUser = await admin.auth().getUser(userId)\n  const email = fbUser.email\n  const emailName = email?.replace(/@.*$/, '')\n\n  const rawName = fbUser.displayName || emailName || 'User' + randomString(4)\n  const name = cleanDisplayName(rawName)\n\n  const bucket = getStorageBucket()\n  const avatarUrl = fbUser.photoURL\n    ? fbUser.photoURL\n    : await generateAvatarUrl(userId, name, bucket)\n\n  const pg = createSupabaseDirectClient()\n\n  let username = cleanUsername(name)\n\n  // Check username case-insensitive\n  const dupes = await pg.one<number>(\n    `select count(*) from users where username ilike $1`,\n    [username],\n    (r) => r.count\n  )\n  const usernameExists = dupes > 0\n  const isReservedName = RESERVED_PATHS.includes(username)\n  if (usernameExists || isReservedName) username += randomString(4)\n\n  const { user, privateUser } = await pg.tx(async (tx) => {\n    const preexistingUser = await getUser(userId, tx)\n    if (preexistingUser)\n      throw new APIError(403, 'User already exists', {\n        userId: userId,\n      })\n\n    // Check exact username to avoid problems with duplicate requests\n    const sameNameUser = await getUserByUsername(username, tx)\n    if (sameNameUser)\n      throw new APIError(403, 'Username already taken', { username })\n\n    const userData = {\n      id: userId,\n      avatarUrl,\n      streakForgiveness: 1,\n      shouldShowWelcome: true,\n      creatorTraders: { daily: 0, weekly: 0, monthly: 0, allTime: 0 },\n      isBannedFromPosting: Boolean(\n        (deviceToken && bannedDeviceTokens.includes(deviceToken)) ||\n          (ip && bannedIpAddresses.includes(ip))\n      ),\n      signupBonusPaid: 0,\n    }\n\n    const privateUser: PrivateUser = {\n      id: userId,\n      email,\n      initialIpAddress: ip,\n      initialDeviceToken: deviceToken,\n      notificationPreferences: getDefaultNotificationPreferences(),\n      blockedUserIds: [],\n      blockedByUserIds: [],\n      blockedContractIds: [],\n      blockedGroupSlugs: [],\n    }\n\n    const userRow = await insert(tx, 'users', {\n      id: userId,\n      name: name,\n      username: username,\n      data: userData,\n    })\n\n    const startingBonusTxn: Omit<\n      SignupBonusTxn,\n      'id' | 'createdTime' | 'fromId'\n    > = {\n      fromType: 'BANK',\n      toId: userId,\n      toType: 'USER',\n      amount: STARTING_BALANCE,\n      token: 'M$',\n      category: 'SIGNUP_BONUS',\n      description: 'Signup bonus',\n    }\n    await runTxnFromBank(tx, startingBonusTxn)\n\n    const privateUserRow = await insert(tx, 'private_users', {\n      id: privateUser.id,\n      data: privateUser,\n    })\n\n    return {\n      user: convertUser(userRow),\n      privateUser: convertPrivateUser(privateUserRow),\n    }\n  })\n\n  log('created user ', { username: user.username, firebaseId: userId })\n\n  const continuation = async () => {\n    const pg = createSupabaseDirectClient()\n    await track(user.id, 'create user', { username: user.username }, { ip })\n\n    await addContractsToSeenMarketsTable(userId, visitedContractIds, pg)\n    await upsertNewUserEmbeddings(userId, visitedContractIds, pg)\n\n    if (process.env.FB_ACCESS_TOKEN)\n      await trackSignupFB(\n        process.env.FB_ACCESS_TOKEN,\n        user.id,\n        email ?? '',\n        ip\n      ).catch((e) => log('error fb tracking:', e))\n    else log('no FB_ACCESS_TOKEN')\n    await onCreateUser(user, privateUser)\n  }\n\n  return {\n    result: {\n      user,\n      privateUser,\n    },\n    continue: continuation,\n  }\n}\n\nasync function addContractsToSeenMarketsTable(\n  userId: string,\n  visitedContractIds: string[] | undefined,\n  pg: SupabaseDirectClient\n) {\n  if (!visitedContractIds || visitedContractIds.length === 0) return\n\n  await Promise.all(\n    visitedContractIds.map((contractId) =>\n      pg.none(\n        `insert into user_contract_views (user_id, contract_id, page_views, last_page_view_ts)\n            values ($1, $2, 1, now())`,\n        [userId, contractId]\n      )\n    )\n  )\n}\n\nasync function upsertNewUserEmbeddings(\n  userId: string,\n  visitedContractIds: string[] | undefined,\n  pg: SupabaseDirectClient\n): Promise<void> {\n  log('Averaging contract embeddings for user ' + userId, {\n    visitedContractIds,\n  })\n  let embed = await getAverageContractEmbedding(pg, visitedContractIds)\n  if (!embed) embed = await getDefaultEmbedding(pg)\n  const groupIds =\n    visitedContractIds && visitedContractIds.length > 0\n      ? await pg.map(\n          `select group_id\n        from group_contracts\n        where contract_id = any($1)`,\n          [visitedContractIds],\n          (r) => r.group_id\n        )\n      : []\n  log('Averaging group embeddings for user ' + userId, { groupIds })\n  const groupEmbed = await getAverageGroupEmbedding(pg, groupIds)\n  if (groupEmbed) {\n    embed = normalizeAndAverageVectors([embed, embed, groupEmbed])\n  }\n\n  await pg.none(\n    `insert into user_embeddings (user_id, interest_embedding, contract_view_embedding)\n            values ($1, $2, $2)\n            on conflict (user_id)\n            do update set\n            interest_embedding = $2,\n            contract_view_embedding = $2\n            `,\n    [userId, embed]\n  )\n}\n\nexport function getStorageBucket() {\n  const id = isProd()\n    ? PROD_CONFIG.firebaseConfig.storageBucket\n    : DEV_CONFIG.firebaseConfig.storageBucket\n  return getStorage().bucket(id)\n}\n\n// Automatically ban users with these device tokens or ip addresses.\nconst bannedDeviceTokens = [\n  'fa807d664415',\n  'dcf208a11839',\n  'bbf18707c15d',\n  '4c2d15a6cc0c',\n  '0da6b4ea79d3',\n]\nconst bannedIpAddresses: string[] = [\n  '24.176.214.250',\n  '2607:fb90:bd95:dbcd:ac39:6c97:4e35:3fed',\n  '2607:fb91:389:ddd0:ac39:8397:4e57:f060',\n  '2607:fb90:ed9a:4c8f:ac39:cf57:4edd:4027',\n  '2607:fb90:bd36:517a:ac39:6c91:812c:6328',\n]\n"
        },
        {
          "path": "backend/shared/src/emails.ts",
          "preContent": "import { DOMAIN, ENV_CONFIG, LOVE_DOMAIN } from 'common/envs/constants'\nimport { Bet } from 'common/bet'\nimport { getProbability } from 'common/calculate'\nimport {\n  Contract,\n  contractPath,\n  ContractToken,\n  MultiContract,\n  renderResolution,\n} from 'common/contract'\nimport { PrivateUser, User } from 'common/user'\nimport {\n  formatLargeNumber,\n  formatMoney,\n  formatSweepies,\n  SWEEPIES_MONIKER,\n} from 'common/util/format'\nimport { formatNumericProbability } from 'common/pseudo-numeric'\nimport { sendTemplateEmail, sendTextEmail } from './send-email'\nimport { contractUrl, getPrivateUser, getUser, log } from 'shared/utils'\nimport { getContractOGProps } from 'common/contract-seo'\nimport {\n  notification_reason_types,\n  NotificationReason,\n} from 'common/notification'\nimport { chunk, Dictionary } from 'lodash'\nimport { getNotificationDestinationsForUser } from 'common/user-notification-preferences'\nimport { buildOgUrl } from 'common/util/og'\nimport { removeUndefinedProps } from 'common/util/object'\nimport { getLoveOgImageUrl } from 'common/love/og-image'\nimport {\n  createSupabaseClient,\n  createSupabaseDirectClient,\n} from 'shared/supabase/init'\nimport { getLoverRow } from 'common/love/lover'\nimport { HOUR_MS } from 'common/util/time'\n\nexport type PerContractInvestmentsData = {\n  questionTitle: string\n  questionUrl: string\n  questionProb: string\n  profitStyle: string\n  currentValue: number\n  pastValue: number\n  profit: number\n  token: ContractToken\n}\n\nexport type OverallPerformanceData = {\n  profit: string\n  prediction_streak: string\n  markets_traded: string\n  profit_style: string\n  likes_received: string\n  markets_created: string\n  unique_bettors: string\n  league_rank: string\n}\n\nexport const formatMoneyEmail = (\n  amount: number,\n  token: ContractToken = 'MANA'\n) => {\n  if (token === 'CASH') {\n    return formatSweepies(amount).replace(SWEEPIES_MONIKER, 'S')\n  }\n  return formatMoney(amount).replace(ENV_CONFIG.moneyMoniker, 'M')\n}\n\nexport const getMarketResolutionEmail = (\n  reason: NotificationReason,\n  privateUser: PrivateUser,\n  userName: string,\n  investment: number,\n  payout: number,\n  creator: User,\n  creatorPayout: number,\n  contract: Contract,\n  resolution: string,\n  resolutionProbability?: number,\n  resolutions?: { [outcome: string]: number },\n  answerId?: string\n) => {\n  const { sendToEmail, unsubscribeUrl } = getNotificationDestinationsForUser(\n    privateUser,\n    reason\n  )\n  if (!privateUser.email || !sendToEmail) return\n\n  const outcome = toDisplayResolution(\n    contract,\n    resolution,\n    resolutionProbability,\n    resolutions,\n    answerId\n  )\n\n  const creatorPayoutText =\n    creatorPayout >= 1 && privateUser.id === creator.id\n      ? ` (plus ${formatMoneyEmail(\n          creatorPayout,\n          contract.token\n        )} in commissions)`\n      : ''\n\n  const correctedInvestment =\n    Number.isNaN(investment) || investment < 0 ? 0 : investment\n\n  const displayedInvestment = formatMoneyEmail(\n    correctedInvestment,\n    contract.token\n  )\n  const displayedPayout = formatMoneyEmail(payout, contract.token)\n\n  const templateData: market_resolved_template = {\n    userId: privateUser.id,\n    name: userName,\n    creatorName: creator.name,\n    question: contract.question,\n    outcome,\n    investment: displayedInvestment,\n    payout: displayedPayout + creatorPayoutText,\n    url: `https://${DOMAIN}/${creator.username}/${contract.slug}`,\n    unsubscribeUrl,\n  }\n\n  // Modify template here:\n  // https://app.mailgun.com/app/sending/domains/mg.manifold.markets/templates/edit/market-resolved-bulk/initial\n\n  return {\n    entry: [privateUser.email, templateData] as EmailAndTemplateEntry,\n    correctedInvestment,\n  }\n}\n\ntype market_resolved_template = {\n  userId: string\n  name: string\n  creatorName: string\n  question: string\n  outcome: string\n  investment: string\n  payout: string\n  url: string\n  unsubscribeUrl: string\n}\n\nexport const toDisplayResolution = (\n  contract: Contract,\n  resolution: string,\n  resolutionProbability?: number,\n  resolutions?: { [outcome: string]: number },\n  answerId?: string\n) => {\n  const isMultiChoice =\n    contract.outcomeType === 'MULTIPLE_CHOICE' ||\n    contract.outcomeType === 'MULTI_NUMERIC' ||\n    contract.outcomeType === 'DATE'\n  if (resolution === 'CANCEL') return 'N/A'\n\n  if (contract.outcomeType === 'BINARY') {\n    const prob = resolutionProbability ?? getProbability(contract)\n    return renderResolution(resolution, prob)\n  }\n\n  if (contract.outcomeType === 'PSEUDO_NUMERIC') {\n    return contract.resolutionValue\n      ? formatLargeNumber(contract.resolutionValue)\n      : formatNumericProbability(\n          resolutionProbability ?? getProbability(contract),\n          contract\n        )\n  }\n  if (contract.outcomeType === 'STONK') {\n    return formatNumericProbability(getProbability(contract), contract)\n  }\n\n  if (contract.outcomeType === 'NUMBER') {\n    if (!resolutions) return 'Invalid resolution data'\n\n    const resolvedAnswerIds = Object.keys(resolutions)\n    const resolvedAnswers = contract.answers.filter((a) =>\n      resolvedAnswerIds.includes(a.id)\n    )\n    if (resolvedAnswers.length > 0) {\n      return resolvedAnswers.map((a) => a.text).join(', ')\n    }\n    return 'MULTI'\n  }\n\n  const isIndependentMulti = isMultiChoice && !contract.shouldAnswersSumToOne\n  if (isIndependentMulti && answerId) {\n    const answer = contract.answers.find((a) => a.id === answerId)\n    if (answer) {\n      return `${answer.text} ${renderResolution(\n        resolution,\n        resolutionProbability ?? answer.prob\n      )}`\n    }\n  }\n  if ((resolution === 'MKT' && resolutions) || resolution === 'CHOOSE_MULTIPLE')\n    return 'MULTI'\n\n  const answer = (contract as MultiContract).answers.find(\n    (a) => a.id === resolution\n  )\n  if (answer) return answer.text\n  return resolution\n}\n\nexport const sendWelcomeEmail = async (\n  user: User,\n  privateUser: PrivateUser\n) => {\n  if (!privateUser || !privateUser.email) return\n\n  const { name } = user\n  const firstName = name.split(' ')[0]\n\n  const { unsubscribeUrl } = getNotificationDestinationsForUser(\n    privateUser,\n    'onboarding_flow'\n  )\n\n  return await sendTemplateEmail(\n    privateUser.email,\n    'Welcome to Manifold!',\n    'welcome',\n    {\n      name: firstName,\n      unsubscribeUrl,\n    },\n    {\n      from: 'David from Manifold <david@manifold.markets>',\n      'o:deliverytime': new Date(Date.now() + 2 * HOUR_MS).toUTCString(),\n    }\n  )\n}\n\nexport type EmailAndTemplateData = { name: string; [key: string]: string }\nexport type EmailAndTemplateEntry = [string, EmailAndTemplateData]\n\nexport const sendBulkEmails = async (\n  subject: string,\n  template: string,\n  recipients: EmailAndTemplateEntry[],\n  from = `Manifold <no-reply@manifold.markets>`\n) => {\n  // Mailgun has a limit of 1000 recipients per batch\n  const emailChunks = chunk(recipients, 1000)\n  for (const chunk of emailChunks) {\n    const mailgunDomain = 'mg.manifold.markets'\n    const mailgunApiKey = process.env.MAILGUN_KEY as string\n    const url = `https://api.mailgun.net/v3/${mailgunDomain}/messages`\n    const data = new URLSearchParams()\n    data.append('from', from)\n    data.append('subject', subject)\n    data.append('template', template)\n    chunk.forEach(([recipientEmail, details]) => {\n      data.append('to', `${details.name} <${recipientEmail}>`)\n    })\n    data.append(\n      'recipient-variables',\n      JSON.stringify(Object.fromEntries(chunk))\n    )\n\n    try {\n      const response = await fetch(url, {\n        method: 'POST',\n        headers: {\n          Authorization: `Basic ${btoa(`api:${mailgunApiKey}`)}`,\n          'Content-Type': 'application/x-www-form-urlencoded',\n        },\n        body: data,\n      })\n      const json = await response.json()\n      log('Sent bulk emails for subject: ' + subject, json)\n    } catch (error) {\n      log.error('Error sending emails for subject: ' + subject, {\n        error,\n      })\n    }\n  }\n}\n\nexport const sendPersonalFollowupEmail = async (\n  user: User,\n  privateUser: PrivateUser,\n  sendTime: string\n) => {\n  if (!privateUser || !privateUser.email) return\n\n  const { name } = user\n  const firstName = name.split(' ')[0]\n\n  const emailBody = `Hi ${firstName},\n\nThanks for signing up! I'm one of the cofounders of Manifold, and was wondering how you've found your experience on the platform so far?\n\nIf you haven't already, I encourage you to try creating your own prediction market (https://manifold.markets/create) and joining our Discord chat (https://discord.com/invite/eHQBNBqXuh).\n\nFeel free to reply to this email with any questions or concerns you have.\n\nCheers,\n\nJames\nCofounder of Manifold\nhttps://manifold.markets\n `\n\n  await sendTextEmail(\n    privateUser.email,\n    'How are you finding Manifold?',\n    emailBody,\n    {\n      from: 'James from Manifold <james@manifold.markets>',\n      'o:deliverytime': sendTime,\n    }\n  )\n}\n\nexport const sendCreatorGuideEmail = async (\n  user: User,\n  privateUser: PrivateUser\n) => {\n  if (!privateUser || !privateUser.email) return\n\n  const { name } = user\n  const firstName = name.split(' ')[0]\n  const { unsubscribeUrl, sendToEmail } = getNotificationDestinationsForUser(\n    privateUser,\n    'onboarding_flow'\n  )\n  if (!sendToEmail) return\n  return await sendTemplateEmail(\n    privateUser.email,\n    'Create your own prediction market',\n    'creating-market',\n    {\n      name: firstName,\n      unsubscribeUrl,\n    },\n    {\n      from: 'David from Manifold <david@manifold.markets>',\n    }\n  )\n}\n\nexport const sendUnactivatedNewUserEmail = async (\n  user: User,\n  templateId: string\n) => {\n  const pg = createSupabaseDirectClient()\n  const privateUser = await getPrivateUser(user.id, pg)\n  if (!privateUser || !privateUser.email) return\n\n  const { name } = user\n  const firstName = name.split(' ')[0]\n  const { unsubscribeUrl, sendToEmail } = getNotificationDestinationsForUser(\n    privateUser,\n    'onboarding_flow'\n  )\n  if (!sendToEmail) return\n  return await sendTemplateEmail(\n    privateUser.email,\n    `Help improve Manifold + win $100 Amazon gift card`,\n    templateId,\n    {\n      name: firstName,\n      unsubscribeUrl,\n    },\n    {\n      from: 'Ian from Manifold <ian@manifold.markets>',\n    }\n  )\n}\n\nexport const sendThankYouEmail = async (\n  user: User,\n  privateUser: PrivateUser\n) => {\n  if (!privateUser || !privateUser.email) return\n\n  const { name } = user\n  const firstName = name.split(' ')[0]\n  const { unsubscribeUrl, sendToEmail } = getNotificationDestinationsForUser(\n    privateUser,\n    'thank_you_for_purchases'\n  )\n\n  if (!sendToEmail) return\n  return await sendTemplateEmail(\n    privateUser.email,\n    'Thanks for your Manifold purchase',\n    'thank-you',\n    {\n      name: firstName,\n      unsubscribeUrl,\n    },\n    {\n      from: 'David from Manifold <david@manifold.markets>',\n    }\n  )\n}\n\nexport const sendMarketCloseEmail = async (\n  user: User,\n  privateUser: PrivateUser,\n  contract: Contract\n) => {\n  if (!privateUser.email) return\n  if (contract.token === 'CASH') return\n\n  const { username, name, id: userId } = user\n  const firstName = name.split(' ')[0]\n\n  const { question, slug, volume } = contract\n\n  const url = `https://${DOMAIN}/${username}/${slug}`\n\n  // We ignore if they were able to unsubscribe from market close emails, this is a necessary email\n  return await sendTemplateEmail(\n    privateUser.email,\n    'Your market has closed',\n    'market-close',\n    {\n      question,\n      url,\n      unsubscribeUrl: '',\n      userId,\n      name: firstName,\n      volume: formatMoneyEmail(volume, contract.token),\n    }\n  )\n}\n\nexport const getNewCommentEmail = (\n  reason: NotificationReason,\n  privateUser: PrivateUser,\n  userName: string,\n  commentCreator: User,\n  contract: Contract,\n  commentText: string,\n  commentId: string,\n  bet?: Bet\n) => {\n  const { sendToEmail, unsubscribeUrl } = getNotificationDestinationsForUser(\n    privateUser,\n    reason\n  )\n  if (!privateUser || !privateUser.email || !sendToEmail) return\n\n  const marketUrl = `https://${DOMAIN}/${contract.creatorUsername}/${contract.slug}#${commentId}`\n\n  const { name: commentorName, avatarUrl: commentorAvatarUrl } = commentCreator\n\n  let betDescription = ''\n  if (bet) {\n    const { amount } = bet\n    betDescription = `${amount < 0 ? 'sold' : 'bought'} ${formatMoneyEmail(\n      Math.abs(amount),\n      contract.token\n    )}`\n  }\n\n  if (bet) {\n    betDescription = `${betDescription} of ${toDisplayResolution(\n      contract,\n      bet.outcome\n    )}`\n  }\n  return [\n    privateUser.email,\n    {\n      name: userName,\n      commentorName,\n      commentorAvatarUrl: commentorAvatarUrl ?? '',\n      comment: commentText,\n      marketUrl,\n      unsubscribeUrl,\n      betDescription,\n    },\n  ] as EmailAndTemplateEntry\n}\n\nexport const sendNewAnswerEmail = async (\n  reason: NotificationReason,\n  privateUser: PrivateUser,\n  name: string,\n  text: string,\n  contract: Contract,\n  avatarUrl?: string\n) => {\n  const { creatorId } = contract\n  // Don't send the creator's own answers.\n  if (privateUser.id === creatorId) return\n\n  const { sendToEmail, unsubscribeUrl } = getNotificationDestinationsForUser(\n    privateUser,\n    reason\n  )\n  if (!privateUser.email || !sendToEmail) return\n\n  const { question, creatorUsername, slug } = contract\n\n  const marketUrl = `https://${DOMAIN}/${creatorUsername}/${slug}`\n\n  const subject = `New answer on ${question}`\n  const from = `${name} <info@manifold.markets>`\n\n  return await sendTemplateEmail(\n    privateUser.email,\n    subject,\n    'market-answer',\n    {\n      name,\n      avatarUrl: avatarUrl ?? '',\n      answer: text,\n      marketUrl,\n      unsubscribeUrl,\n    },\n    { from }\n  )\n}\n\nexport const sendInterestingMarketsEmail = async (\n  userName: string,\n  privateUser: PrivateUser,\n  contractsToSend: Contract[]\n) => {\n  if (!privateUser || !privateUser.email) {\n    log.error('No private user or email to send interesting markets email to', {\n      userName,\n    })\n    return\n  }\n\n  const { unsubscribeUrl, sendToEmail } = getNotificationDestinationsForUser(\n    privateUser,\n    'trending_markets'\n  )\n  if (!sendToEmail) return\n\n  const firstName = userName.split(' ')[0]\n\n  await sendTemplateEmail(\n    privateUser.email,\n    `${contractsToSend[0].question} & 5 more interesting markets on Manifold`,\n    'interesting-markets',\n    {\n      name: firstName,\n      unsubscribeUrl,\n      question1Title: contractsToSend[0].question,\n      question1Link: contractUrl(contractsToSend[0]),\n      question1ImgSrc: imageSourceUrl(contractsToSend[0]),\n      question2Title: contractsToSend[1].question,\n      question2Link: contractUrl(contractsToSend[1]),\n      question2ImgSrc: imageSourceUrl(contractsToSend[1]),\n      question3Title: contractsToSend[2].question,\n      question3Link: contractUrl(contractsToSend[2]),\n      question3ImgSrc: imageSourceUrl(contractsToSend[2]),\n      question4Title: contractsToSend[3].question,\n      question4Link: contractUrl(contractsToSend[3]),\n      question4ImgSrc: imageSourceUrl(contractsToSend[3]),\n      question5Title: contractsToSend[4].question,\n      question5Link: contractUrl(contractsToSend[4]),\n      question5ImgSrc: imageSourceUrl(contractsToSend[4]),\n      question6Title: contractsToSend[5].question,\n      question6Link: contractUrl(contractsToSend[5]),\n      question6ImgSrc: imageSourceUrl(contractsToSend[5]),\n    }\n  )\n}\n\nexport const sendBonusWithInterestingMarketsEmail = async (\n  user: User,\n  privateUser: PrivateUser,\n  contractsToSend: Contract[],\n  bonusAmount: number\n) => {\n  if (!privateUser || !privateUser.email) return\n  let unsubscribeUrl = ''\n  // This is email is of both types, so try either\n  const { sendToEmail, unsubscribeUrl: unsub1 } =\n    getNotificationDestinationsForUser(privateUser, 'onboarding_flow')\n  const { sendToEmail: trendingSendToEmail, unsubscribeUrl: unsub2 } =\n    getNotificationDestinationsForUser(privateUser, 'trending_markets')\n\n  if (!sendToEmail && !trendingSendToEmail) return\n  unsubscribeUrl = !sendToEmail ? unsub2 : unsub1\n\n  const { name } = user\n  const firstName = name.split(' ')[0]\n\n  await sendTemplateEmail(\n    privateUser.email,\n    `Interesting questions on Manifold + ${bonusAmount} bonus mana`,\n    'signup-bonus-with-interesting-markets',\n    {\n      name: firstName,\n      unsubscribeUrl,\n      bonusAmount: formatMoney(bonusAmount),\n      question1Title: contractsToSend[0].question,\n      question1Link: contractUrl(contractsToSend[0]),\n      question1ImgSrc: imageSourceUrl(contractsToSend[0]),\n      question2Title: contractsToSend[1].question,\n      question2Link: contractUrl(contractsToSend[1]),\n      question2ImgSrc: imageSourceUrl(contractsToSend[1]),\n      question3Title: contractsToSend[2].question,\n      question3Link: contractUrl(contractsToSend[2]),\n      question3ImgSrc: imageSourceUrl(contractsToSend[2]),\n      question4Title: contractsToSend[3].question,\n      question4Link: contractUrl(contractsToSend[3]),\n      question4ImgSrc: imageSourceUrl(contractsToSend[3]),\n      question5Title: contractsToSend[4].question,\n      question5Link: contractUrl(contractsToSend[4]),\n      question5ImgSrc: imageSourceUrl(contractsToSend[4]),\n      question6Title: contractsToSend[5].question,\n      question6Link: contractUrl(contractsToSend[5]),\n      question6ImgSrc: imageSourceUrl(contractsToSend[5]),\n    }\n  )\n}\n\nfunction imageSourceUrl(contract: Contract) {\n  return buildOgUrl(\n    removeUndefinedProps(getContractOGProps(contract)),\n    'market'\n  )\n}\nexport const getNewFollowedMarketEmail = (\n  reason: notification_reason_types,\n  userName: string,\n  privateUser: PrivateUser,\n  contract: Contract\n) => {\n  const { sendToEmail, unsubscribeUrl } = getNotificationDestinationsForUser(\n    privateUser,\n    reason\n  )\n  if (!privateUser.email || !sendToEmail) return\n  const firstName = userName.split(' ')[0]\n  const creatorName = contract.creatorName\n\n  const questionImgSrc = imageSourceUrl(contract)\n  return [\n    privateUser.email,\n    {\n      name: firstName,\n      creatorName,\n      unsubscribeUrl,\n      questionTitle: contract.question,\n      questionUrl: contractUrl(contract),\n      questionImgSrc,\n    },\n  ] as EmailAndTemplateEntry\n}\n\nexport const sendNewPrivateMarketEmail = async (\n  reason: notification_reason_types,\n  privateUser: PrivateUser,\n  contract: Contract,\n  groupName: string\n) => {\n  const { sendToEmail, unsubscribeUrl } = getNotificationDestinationsForUser(\n    privateUser,\n    reason\n  )\n  if (!privateUser.email || !sendToEmail) return\n  const user = await getUser(privateUser.id)\n  if (!user) return\n\n  const { name } = user\n  const firstName = name.split(' ')[0]\n  const creatorName = contract.creatorName\n\n  const questionImgSrc = imageSourceUrl(contract)\n  console.log('questionImgSrc', questionImgSrc)\n  return await sendTemplateEmail(\n    privateUser.email,\n    `${creatorName} asked ${contract.question} in private group, ${groupName}`,\n    'new-market-from-private-group',\n    {\n      name: firstName,\n      creatorName,\n      unsubscribeUrl,\n      questionTitle: contract.question,\n      questionUrl: contractUrl(contract),\n      questionImgSrc,\n      groupName,\n    },\n    {\n      from: `${creatorName} on Manifold <no-reply@manifold.markets>`,\n    }\n  )\n}\nexport const sendNewUniqueBettorsEmail = async (\n  reason: NotificationReason,\n  privateUser: PrivateUser,\n  contract: Contract,\n  totalPredictors: number,\n  newPredictors: User[],\n  userBets: Dictionary<[Bet, ...Bet[]]>,\n  bonusAmount: number\n) => {\n  const { sendToEmail, unsubscribeUrl } = getNotificationDestinationsForUser(\n    privateUser,\n    reason\n  )\n  if (!privateUser.email || !sendToEmail) return\n  const user = await getUser(privateUser.id)\n  if (!user) return\n\n  const { name } = user\n  const firstName = name.split(' ')[0]\n  const creatorName = contract.creatorName\n  // make the emails stack for the same contract\n  const subject = `You made a popular market! ${\n    contract.question.length > 50\n      ? contract.question.slice(0, 50) + '...'\n      : contract.question\n  } just got ${\n    newPredictors.length\n  } new predictions. Check out who's predicting on it inside.`\n  const templateData: Record<string, string> = {\n    name: firstName,\n    creatorName,\n    totalPredictors: totalPredictors.toString(),\n    marketTitle: contract.question,\n    marketUrl: contractUrl(contract),\n    bonusString: bonusAmount.toString(),\n    unsubscribeUrl,\n    newPredictors: newPredictors.length.toString(),\n  }\n\n  newPredictors.forEach((p, i) => {\n    templateData[`bettor${i + 1}Name`] = p.name\n    if (p.avatarUrl) templateData[`bettor${i + 1}AvatarUrl`] = p.avatarUrl\n    const bet = userBets[p.id][0]\n    if (bet) {\n      const { amount } = bet\n      templateData[`bet${i + 1}Description`] = `${\n        amount < 0 ? 'sold' : 'bought'\n      } ${formatMoneyEmail(Math.abs(amount), contract.token)}`\n    }\n  })\n\n  return await sendTemplateEmail(\n    privateUser.email,\n    subject,\n    // This template accepts 5 unique bettors\n    'new-unique-traders',\n    templateData,\n    {\n      from: `Manifold <no-reply@manifold.markets>`,\n    }\n  )\n}\n\nexport const getWeeklyPortfolioUpdateEmail = (\n  userName: string,\n  privateUser: PrivateUser,\n  investments: PerContractInvestmentsData[],\n  overallPerformance: OverallPerformanceData,\n  moversToSend: number\n) => {\n  if (!privateUser || !privateUser.email) return\n\n  const { unsubscribeUrl, sendToEmail } = getNotificationDestinationsForUser(\n    privateUser,\n    'profit_loss_updates'\n  )\n\n  if (!sendToEmail) return\n\n  const firstName = userName.split(' ')[0]\n  const templateData: Record<string, string> = {\n    name: firstName,\n    unsubscribeUrl,\n    ...overallPerformance,\n  }\n  for (let i = 0; i < moversToSend; i++) {\n    const investment = investments[i]\n    if (investment) {\n      templateData[`question${i + 1}Title`] = investment.questionTitle\n      templateData[`question${i + 1}Url`] = investment.questionUrl\n      templateData[`question${i + 1}Prob`] = investment.questionProb\n      templateData[`question${i + 1}Change`] = formatMoneyEmail(\n        investment.profit,\n        investment.token\n      )\n      templateData[`question${i + 1}ChangeStyle`] = investment.profitStyle\n      templateData[`question${i + 1}Display`] = 'display: table-row'\n    } else templateData[`question${i + 1}Display`] = 'display: none'\n  }\n\n  return [\n    privateUser.email,\n    // Math.random() > 0.5 ? 'iansphilips@gmail.com' : 'boawishbone@gmail.com',\n    templateData,\n  ] as EmailAndTemplateEntry\n}\n\nexport type MarketMovementEmailData = {\n  questionTitle: string\n  questionUrl: string\n  prob: string\n  probChangeStyle: string\n  startProb: number\n  endProb: number\n  answerText?: string\n}\n\nexport const getMarketMovementEmail = (\n  userName: string,\n  privateUser: PrivateUser,\n  marketMovements: MarketMovementEmailData[],\n  movementsToSend: number\n) => {\n  if (!privateUser || !privateUser.email) return\n\n  const { unsubscribeUrl, sendToEmail } = getNotificationDestinationsForUser(\n    privateUser,\n    'market_movements'\n  )\n\n  if (!sendToEmail) return\n\n  const firstName = userName.split(' ')[0]\n  const templateData: Record<string, string> = {\n    name: firstName,\n    unsubscribeUrl,\n  }\n\n  for (let i = 0; i < movementsToSend; i++) {\n    const movement = marketMovements[i]\n    if (movement) {\n      templateData[`question${i + 1}Title`] = movement.questionTitle\n      templateData[`question${i + 1}Url`] = movement.questionUrl\n      templateData[`question${i + 1}Prob`] = movement.prob\n      const arrowColor =\n        movement.endProb > movement.startProb\n          ? '#14b8a6' /* green-500 */\n          : '#ef4444' /* red-500 */\n      templateData[\n        `question${i + 1}ArrowStyle`\n      ] = `color: ${arrowColor}; font-weight: bold;`\n      templateData[`question${i + 1}InitialProb`] = `${Math.round(\n        movement.startProb * 100\n      )}%`\n      templateData[`question${i + 1}ChangeStyle`] = movement.probChangeStyle\n      templateData[`question${i + 1}Display`] = 'display: table-row'\n\n      // Add answer text to the template data if available\n      if (movement.answerText) {\n        // When answer exists\n        templateData[`question${i + 1}AnswerText`] = movement.answerText\n        templateData[`question${i + 1}AnswerDisplay`] = 'table-row'\n\n        // Show probability on answer row when answer exists\n        templateData[`question${i + 1}AnswerProbStyle`] = 'display: inline'\n\n        // Hide probability on question row when answer exists\n        templateData[`question${i + 1}ProbStyle`] = 'display: none'\n      } else {\n        // When no answer exists\n        templateData[`question${i + 1}AnswerText`] = ''\n        templateData[`question${i + 1}AnswerDisplay`] = 'none'\n\n        // Hide probability on answer row when no answer\n        templateData[`question${i + 1}AnswerProbStyle`] = 'display: none'\n\n        // Show probability on question row when no answer\n        templateData[`question${i + 1}ProbStyle`] = 'display: inline'\n      }\n    } else {\n      // When question doesn't exist\n      templateData[`question${i + 1}Display`] = 'display: none'\n      templateData[`question${i + 1}AnswerDisplay`] = 'none'\n      templateData[`question${i + 1}Title`] = ''\n      templateData[`question${i + 1}AnswerText`] = ''\n      templateData[`question${i + 1}ProbStyle`] = 'display: none'\n      templateData[`question${i + 1}AnswerProbStyle`] = 'display: none'\n    }\n  }\n\n  return [privateUser.email, templateData] as EmailAndTemplateEntry\n}\n\nexport const sendNewMatchEmail = async (\n  reason: NotificationReason,\n  privateUser: PrivateUser,\n  contract: Contract,\n  creatorName: string,\n  matchedWithUser: User\n) => {\n  const { sendToEmail, unsubscribeUrl } = getNotificationDestinationsForUser(\n    privateUser,\n    reason\n  )\n  if (!privateUser.email || !sendToEmail) return\n  const user = await getUser(privateUser.id)\n  if (!user) return\n\n  const { name } = user\n  const firstName = name.split(' ')[0]\n  const lover = await getLoverRow(matchedWithUser.id, createSupabaseClient())\n  const loveOgImageUrl = getLoveOgImageUrl(matchedWithUser, lover)\n  const questionImgSrc = imageSourceUrl(contract)\n  return await sendTemplateEmail(\n    privateUser.email,\n    `You have a new match!`,\n    'new-match',\n    {\n      name: firstName,\n      creatorName,\n      unsubscribeUrl,\n      questionTitle: contract.question,\n      questionUrl: `https://${LOVE_DOMAIN}${contractPath(contract)}`,\n      userUrl: `https://${LOVE_DOMAIN}/${matchedWithUser.username}`,\n      matchedUsersName: matchedWithUser.name,\n      userImgSrc: loveOgImageUrl,\n      questionImgSrc,\n    },\n    {\n      from: `manifold.love <no-reply@manifold.markets>`,\n    }\n  )\n}\nexport const sendNewMessageEmail = async (\n  reason: NotificationReason,\n  privateUser: PrivateUser,\n  fromUser: User,\n  toUser: User,\n  channelId: number,\n  subject: string\n) => {\n  const { sendToEmail, unsubscribeUrl } = getNotificationDestinationsForUser(\n    privateUser,\n    reason\n  )\n  if (!privateUser.email || !sendToEmail) return\n  const firstName = toUser.name.split(' ')[0]\n  const lover = await getLoverRow(fromUser.id, createSupabaseClient())\n  const loveOgImageUrl = getLoveOgImageUrl(fromUser, lover)\n\n  return await sendTemplateEmail(\n    privateUser.email,\n    subject,\n    'new-message',\n    {\n      name: firstName,\n      messagesUrl: `https://${LOVE_DOMAIN}/messages/${channelId}`,\n      creatorName: fromUser.name,\n      userImgSrc: loveOgImageUrl,\n      unsubscribeUrl,\n    },\n    {\n      from: `manifold.love <no-reply@manifold.markets>`,\n    }\n  )\n}\n\nexport const sendNewEndorsementEmail = async (\n  reason: NotificationReason,\n  privateUser: PrivateUser,\n  fromUser: User,\n  onUser: User,\n  subject: string,\n  text: string\n) => {\n  const { sendToEmail, unsubscribeUrl } = getNotificationDestinationsForUser(\n    privateUser,\n    reason\n  )\n  if (!privateUser.email || !sendToEmail) return\n  const firstName = onUser.name.split(' ')[0]\n  return await sendTemplateEmail(\n    privateUser.email,\n    subject,\n    'new-endorsement',\n    {\n      name: firstName,\n      endorsementUrl: `https://${LOVE_DOMAIN}/${onUser.username}`,\n      creatorName: fromUser.name,\n      creatorAvatarUrl: fromUser.avatarUrl,\n      endorsementText: text,\n      unsubscribeUrl,\n    },\n    {\n      from: `manifold.love <no-reply@manifold.markets>`,\n    }\n  )\n}\n",
          "postContent": "import { DOMAIN, ENV_CONFIG } from 'common/envs/constants'\nimport { Bet } from 'common/bet'\nimport { getProbability } from 'common/calculate'\nimport {\n  Contract,\n  ContractToken,\n  MultiContract,\n  renderResolution,\n} from 'common/contract'\nimport { PrivateUser, User } from 'common/user'\nimport {\n  formatLargeNumber,\n  formatMoney,\n  formatSweepies,\n  SWEEPIES_MONIKER,\n} from 'common/util/format'\nimport { formatNumericProbability } from 'common/pseudo-numeric'\nimport { sendTemplateEmail, sendTextEmail } from './send-email'\nimport { contractUrl, getPrivateUser, getUser, log } from 'shared/utils'\nimport { getContractOGProps } from 'common/contract-seo'\nimport {\n  notification_reason_types,\n  NotificationReason,\n} from 'common/notification'\nimport { chunk, Dictionary } from 'lodash'\nimport { getNotificationDestinationsForUser } from 'common/user-notification-preferences'\nimport { buildOgUrl } from 'common/util/og'\nimport { removeUndefinedProps } from 'common/util/object'\nimport { createSupabaseDirectClient } from 'shared/supabase/init'\nimport { HOUR_MS } from 'common/util/time'\n\nexport type PerContractInvestmentsData = {\n  questionTitle: string\n  questionUrl: string\n  questionProb: string\n  profitStyle: string\n  currentValue: number\n  pastValue: number\n  profit: number\n  token: ContractToken\n}\n\nexport type OverallPerformanceData = {\n  profit: string\n  prediction_streak: string\n  markets_traded: string\n  profit_style: string\n  likes_received: string\n  markets_created: string\n  unique_bettors: string\n  league_rank: string\n}\n\nexport const formatMoneyEmail = (\n  amount: number,\n  token: ContractToken = 'MANA'\n) => {\n  if (token === 'CASH') {\n    return formatSweepies(amount).replace(SWEEPIES_MONIKER, 'S')\n  }\n  return formatMoney(amount).replace(ENV_CONFIG.moneyMoniker, 'M')\n}\n\nexport const getMarketResolutionEmail = (\n  reason: NotificationReason,\n  privateUser: PrivateUser,\n  userName: string,\n  investment: number,\n  payout: number,\n  creator: User,\n  creatorPayout: number,\n  contract: Contract,\n  resolution: string,\n  resolutionProbability?: number,\n  resolutions?: { [outcome: string]: number },\n  answerId?: string\n) => {\n  const { sendToEmail, unsubscribeUrl } = getNotificationDestinationsForUser(\n    privateUser,\n    reason\n  )\n  if (!privateUser.email || !sendToEmail) return\n\n  const outcome = toDisplayResolution(\n    contract,\n    resolution,\n    resolutionProbability,\n    resolutions,\n    answerId\n  )\n\n  const creatorPayoutText =\n    creatorPayout >= 1 && privateUser.id === creator.id\n      ? ` (plus ${formatMoneyEmail(\n          creatorPayout,\n          contract.token\n        )} in commissions)`\n      : ''\n\n  const correctedInvestment =\n    Number.isNaN(investment) || investment < 0 ? 0 : investment\n\n  const displayedInvestment = formatMoneyEmail(\n    correctedInvestment,\n    contract.token\n  )\n  const displayedPayout = formatMoneyEmail(payout, contract.token)\n\n  const templateData: market_resolved_template = {\n    userId: privateUser.id,\n    name: userName,\n    creatorName: creator.name,\n    question: contract.question,\n    outcome,\n    investment: displayedInvestment,\n    payout: displayedPayout + creatorPayoutText,\n    url: `https://${DOMAIN}/${creator.username}/${contract.slug}`,\n    unsubscribeUrl,\n  }\n\n  // Modify template here:\n  // https://app.mailgun.com/app/sending/domains/mg.manifold.markets/templates/edit/market-resolved-bulk/initial\n\n  return {\n    entry: [privateUser.email, templateData] as EmailAndTemplateEntry,\n    correctedInvestment,\n  }\n}\n\ntype market_resolved_template = {\n  userId: string\n  name: string\n  creatorName: string\n  question: string\n  outcome: string\n  investment: string\n  payout: string\n  url: string\n  unsubscribeUrl: string\n}\n\nexport const toDisplayResolution = (\n  contract: Contract,\n  resolution: string,\n  resolutionProbability?: number,\n  resolutions?: { [outcome: string]: number },\n  answerId?: string\n) => {\n  const isMultiChoice =\n    contract.outcomeType === 'MULTIPLE_CHOICE' ||\n    contract.outcomeType === 'MULTI_NUMERIC' ||\n    contract.outcomeType === 'DATE'\n  if (resolution === 'CANCEL') return 'N/A'\n\n  if (contract.outcomeType === 'BINARY') {\n    const prob = resolutionProbability ?? getProbability(contract)\n    return renderResolution(resolution, prob)\n  }\n\n  if (contract.outcomeType === 'PSEUDO_NUMERIC') {\n    return contract.resolutionValue\n      ? formatLargeNumber(contract.resolutionValue)\n      : formatNumericProbability(\n          resolutionProbability ?? getProbability(contract),\n          contract\n        )\n  }\n  if (contract.outcomeType === 'STONK') {\n    return formatNumericProbability(getProbability(contract), contract)\n  }\n\n  if (contract.outcomeType === 'NUMBER') {\n    if (!resolutions) return 'Invalid resolution data'\n\n    const resolvedAnswerIds = Object.keys(resolutions)\n    const resolvedAnswers = contract.answers.filter((a) =>\n      resolvedAnswerIds.includes(a.id)\n    )\n    if (resolvedAnswers.length > 0) {\n      return resolvedAnswers.map((a) => a.text).join(', ')\n    }\n    return 'MULTI'\n  }\n\n  const isIndependentMulti = isMultiChoice && !contract.shouldAnswersSumToOne\n  if (isIndependentMulti && answerId) {\n    const answer = contract.answers.find((a) => a.id === answerId)\n    if (answer) {\n      return `${answer.text} ${renderResolution(\n        resolution,\n        resolutionProbability ?? answer.prob\n      )}`\n    }\n  }\n  if ((resolution === 'MKT' && resolutions) || resolution === 'CHOOSE_MULTIPLE')\n    return 'MULTI'\n\n  const answer = (contract as MultiContract).answers.find(\n    (a) => a.id === resolution\n  )\n  if (answer) return answer.text\n  return resolution\n}\n\nexport const sendWelcomeEmail = async (\n  user: User,\n  privateUser: PrivateUser\n) => {\n  if (!privateUser || !privateUser.email) return\n\n  const { name } = user\n  const firstName = name.split(' ')[0]\n\n  const { unsubscribeUrl } = getNotificationDestinationsForUser(\n    privateUser,\n    'onboarding_flow'\n  )\n\n  return await sendTemplateEmail(\n    privateUser.email,\n    'Welcome to Manifold!',\n    'welcome',\n    {\n      name: firstName,\n      unsubscribeUrl,\n    },\n    {\n      from: 'David from Manifold <david@manifold.markets>',\n      'o:deliverytime': new Date(Date.now() + 2 * HOUR_MS).toUTCString(),\n    }\n  )\n}\n\nexport type EmailAndTemplateData = { name: string; [key: string]: string }\nexport type EmailAndTemplateEntry = [string, EmailAndTemplateData]\n\nexport const sendBulkEmails = async (\n  subject: string,\n  template: string,\n  recipients: EmailAndTemplateEntry[],\n  from = `Manifold <no-reply@manifold.markets>`\n) => {\n  // Mailgun has a limit of 1000 recipients per batch\n  const emailChunks = chunk(recipients, 1000)\n  for (const chunk of emailChunks) {\n    const mailgunDomain = 'mg.manifold.markets'\n    const mailgunApiKey = process.env.MAILGUN_KEY as string\n    const url = `https://api.mailgun.net/v3/${mailgunDomain}/messages`\n    const data = new URLSearchParams()\n    data.append('from', from)\n    data.append('subject', subject)\n    data.append('template', template)\n    chunk.forEach(([recipientEmail, details]) => {\n      data.append('to', `${details.name} <${recipientEmail}>`)\n    })\n    data.append(\n      'recipient-variables',\n      JSON.stringify(Object.fromEntries(chunk))\n    )\n\n    try {\n      const response = await fetch(url, {\n        method: 'POST',\n        headers: {\n          Authorization: `Basic ${btoa(`api:${mailgunApiKey}`)}`,\n          'Content-Type': 'application/x-www-form-urlencoded',\n        },\n        body: data,\n      })\n      const json = await response.json()\n      log('Sent bulk emails for subject: ' + subject, json)\n    } catch (error) {\n      log.error('Error sending emails for subject: ' + subject, {\n        error,\n      })\n    }\n  }\n}\n\nexport const sendPersonalFollowupEmail = async (\n  user: User,\n  privateUser: PrivateUser,\n  sendTime: string\n) => {\n  if (!privateUser || !privateUser.email) return\n\n  const { name } = user\n  const firstName = name.split(' ')[0]\n\n  const emailBody = `Hi ${firstName},\n\nThanks for signing up! I'm one of the cofounders of Manifold, and was wondering how you've found your experience on the platform so far?\n\nIf you haven't already, I encourage you to try creating your own prediction market (https://manifold.markets/create) and joining our Discord chat (https://discord.com/invite/eHQBNBqXuh).\n\nFeel free to reply to this email with any questions or concerns you have.\n\nCheers,\n\nJames\nCofounder of Manifold\nhttps://manifold.markets\n `\n\n  await sendTextEmail(\n    privateUser.email,\n    'How are you finding Manifold?',\n    emailBody,\n    {\n      from: 'James from Manifold <james@manifold.markets>',\n      'o:deliverytime': sendTime,\n    }\n  )\n}\n\nexport const sendCreatorGuideEmail = async (\n  user: User,\n  privateUser: PrivateUser\n) => {\n  if (!privateUser || !privateUser.email) return\n\n  const { name } = user\n  const firstName = name.split(' ')[0]\n  const { unsubscribeUrl, sendToEmail } = getNotificationDestinationsForUser(\n    privateUser,\n    'onboarding_flow'\n  )\n  if (!sendToEmail) return\n  return await sendTemplateEmail(\n    privateUser.email,\n    'Create your own prediction market',\n    'creating-market',\n    {\n      name: firstName,\n      unsubscribeUrl,\n    },\n    {\n      from: 'David from Manifold <david@manifold.markets>',\n    }\n  )\n}\n\nexport const sendUnactivatedNewUserEmail = async (\n  user: User,\n  templateId: string\n) => {\n  const pg = createSupabaseDirectClient()\n  const privateUser = await getPrivateUser(user.id, pg)\n  if (!privateUser || !privateUser.email) return\n\n  const { name } = user\n  const firstName = name.split(' ')[0]\n  const { unsubscribeUrl, sendToEmail } = getNotificationDestinationsForUser(\n    privateUser,\n    'onboarding_flow'\n  )\n  if (!sendToEmail) return\n  return await sendTemplateEmail(\n    privateUser.email,\n    `Help improve Manifold + win $100 Amazon gift card`,\n    templateId,\n    {\n      name: firstName,\n      unsubscribeUrl,\n    },\n    {\n      from: 'Ian from Manifold <ian@manifold.markets>',\n    }\n  )\n}\n\nexport const sendThankYouEmail = async (\n  user: User,\n  privateUser: PrivateUser\n) => {\n  if (!privateUser || !privateUser.email) return\n\n  const { name } = user\n  const firstName = name.split(' ')[0]\n  const { unsubscribeUrl, sendToEmail } = getNotificationDestinationsForUser(\n    privateUser,\n    'thank_you_for_purchases'\n  )\n\n  if (!sendToEmail) return\n  return await sendTemplateEmail(\n    privateUser.email,\n    'Thanks for your Manifold purchase',\n    'thank-you',\n    {\n      name: firstName,\n      unsubscribeUrl,\n    },\n    {\n      from: 'David from Manifold <david@manifold.markets>',\n    }\n  )\n}\n\nexport const sendMarketCloseEmail = async (\n  user: User,\n  privateUser: PrivateUser,\n  contract: Contract\n) => {\n  if (!privateUser.email) return\n  if (contract.token === 'CASH') return\n\n  const { username, name, id: userId } = user\n  const firstName = name.split(' ')[0]\n\n  const { question, slug, volume } = contract\n\n  const url = `https://${DOMAIN}/${username}/${slug}`\n\n  // We ignore if they were able to unsubscribe from market close emails, this is a necessary email\n  return await sendTemplateEmail(\n    privateUser.email,\n    'Your market has closed',\n    'market-close',\n    {\n      question,\n      url,\n      unsubscribeUrl: '',\n      userId,\n      name: firstName,\n      volume: formatMoneyEmail(volume, contract.token),\n    }\n  )\n}\n\nexport const getNewCommentEmail = (\n  reason: NotificationReason,\n  privateUser: PrivateUser,\n  userName: string,\n  commentCreator: User,\n  contract: Contract,\n  commentText: string,\n  commentId: string,\n  bet?: Bet\n) => {\n  const { sendToEmail, unsubscribeUrl } = getNotificationDestinationsForUser(\n    privateUser,\n    reason\n  )\n  if (!privateUser || !privateUser.email || !sendToEmail) return\n\n  const marketUrl = `https://${DOMAIN}/${contract.creatorUsername}/${contract.slug}#${commentId}`\n\n  const { name: commentorName, avatarUrl: commentorAvatarUrl } = commentCreator\n\n  let betDescription = ''\n  if (bet) {\n    const { amount } = bet\n    betDescription = `${amount < 0 ? 'sold' : 'bought'} ${formatMoneyEmail(\n      Math.abs(amount),\n      contract.token\n    )}`\n  }\n\n  if (bet) {\n    betDescription = `${betDescription} of ${toDisplayResolution(\n      contract,\n      bet.outcome\n    )}`\n  }\n  return [\n    privateUser.email,\n    {\n      name: userName,\n      commentorName,\n      commentorAvatarUrl: commentorAvatarUrl ?? '',\n      comment: commentText,\n      marketUrl,\n      unsubscribeUrl,\n      betDescription,\n    },\n  ] as EmailAndTemplateEntry\n}\n\nexport const sendNewAnswerEmail = async (\n  reason: NotificationReason,\n  privateUser: PrivateUser,\n  name: string,\n  text: string,\n  contract: Contract,\n  avatarUrl?: string\n) => {\n  const { creatorId } = contract\n  // Don't send the creator's own answers.\n  if (privateUser.id === creatorId) return\n\n  const { sendToEmail, unsubscribeUrl } = getNotificationDestinationsForUser(\n    privateUser,\n    reason\n  )\n  if (!privateUser.email || !sendToEmail) return\n\n  const { question, creatorUsername, slug } = contract\n\n  const marketUrl = `https://${DOMAIN}/${creatorUsername}/${slug}`\n\n  const subject = `New answer on ${question}`\n  const from = `${name} <info@manifold.markets>`\n\n  return await sendTemplateEmail(\n    privateUser.email,\n    subject,\n    'market-answer',\n    {\n      name,\n      avatarUrl: avatarUrl ?? '',\n      answer: text,\n      marketUrl,\n      unsubscribeUrl,\n    },\n    { from }\n  )\n}\n\nexport const sendInterestingMarketsEmail = async (\n  userName: string,\n  privateUser: PrivateUser,\n  contractsToSend: Contract[]\n) => {\n  if (!privateUser || !privateUser.email) {\n    log.error('No private user or email to send interesting markets email to', {\n      userName,\n    })\n    return\n  }\n\n  const { unsubscribeUrl, sendToEmail } = getNotificationDestinationsForUser(\n    privateUser,\n    'trending_markets'\n  )\n  if (!sendToEmail) return\n\n  const firstName = userName.split(' ')[0]\n\n  await sendTemplateEmail(\n    privateUser.email,\n    `${contractsToSend[0].question} & 5 more interesting markets on Manifold`,\n    'interesting-markets',\n    {\n      name: firstName,\n      unsubscribeUrl,\n      question1Title: contractsToSend[0].question,\n      question1Link: contractUrl(contractsToSend[0]),\n      question1ImgSrc: imageSourceUrl(contractsToSend[0]),\n      question2Title: contractsToSend[1].question,\n      question2Link: contractUrl(contractsToSend[1]),\n      question2ImgSrc: imageSourceUrl(contractsToSend[1]),\n      question3Title: contractsToSend[2].question,\n      question3Link: contractUrl(contractsToSend[2]),\n      question3ImgSrc: imageSourceUrl(contractsToSend[2]),\n      question4Title: contractsToSend[3].question,\n      question4Link: contractUrl(contractsToSend[3]),\n      question4ImgSrc: imageSourceUrl(contractsToSend[3]),\n      question5Title: contractsToSend[4].question,\n      question5Link: contractUrl(contractsToSend[4]),\n      question5ImgSrc: imageSourceUrl(contractsToSend[4]),\n      question6Title: contractsToSend[5].question,\n      question6Link: contractUrl(contractsToSend[5]),\n      question6ImgSrc: imageSourceUrl(contractsToSend[5]),\n    }\n  )\n}\n\nexport const sendBonusWithInterestingMarketsEmail = async (\n  user: User,\n  privateUser: PrivateUser,\n  contractsToSend: Contract[],\n  bonusAmount: number\n) => {\n  if (!privateUser || !privateUser.email) return\n  let unsubscribeUrl = ''\n  // This is email is of both types, so try either\n  const { sendToEmail, unsubscribeUrl: unsub1 } =\n    getNotificationDestinationsForUser(privateUser, 'onboarding_flow')\n  const { sendToEmail: trendingSendToEmail, unsubscribeUrl: unsub2 } =\n    getNotificationDestinationsForUser(privateUser, 'trending_markets')\n\n  if (!sendToEmail && !trendingSendToEmail) return\n  unsubscribeUrl = !sendToEmail ? unsub2 : unsub1\n\n  const { name } = user\n  const firstName = name.split(' ')[0]\n\n  await sendTemplateEmail(\n    privateUser.email,\n    `Interesting questions on Manifold + ${bonusAmount} bonus mana`,\n    'signup-bonus-with-interesting-markets',\n    {\n      name: firstName,\n      unsubscribeUrl,\n      bonusAmount: formatMoney(bonusAmount),\n      question1Title: contractsToSend[0].question,\n      question1Link: contractUrl(contractsToSend[0]),\n      question1ImgSrc: imageSourceUrl(contractsToSend[0]),\n      question2Title: contractsToSend[1].question,\n      question2Link: contractUrl(contractsToSend[1]),\n      question2ImgSrc: imageSourceUrl(contractsToSend[1]),\n      question3Title: contractsToSend[2].question,\n      question3Link: contractUrl(contractsToSend[2]),\n      question3ImgSrc: imageSourceUrl(contractsToSend[2]),\n      question4Title: contractsToSend[3].question,\n      question4Link: contractUrl(contractsToSend[3]),\n      question4ImgSrc: imageSourceUrl(contractsToSend[3]),\n      question5Title: contractsToSend[4].question,\n      question5Link: contractUrl(contractsToSend[4]),\n      question5ImgSrc: imageSourceUrl(contractsToSend[4]),\n      question6Title: contractsToSend[5].question,\n      question6Link: contractUrl(contractsToSend[5]),\n      question6ImgSrc: imageSourceUrl(contractsToSend[5]),\n    }\n  )\n}\n\nfunction imageSourceUrl(contract: Contract) {\n  return buildOgUrl(\n    removeUndefinedProps(getContractOGProps(contract)),\n    'market'\n  )\n}\nexport const getNewFollowedMarketEmail = (\n  reason: notification_reason_types,\n  userName: string,\n  privateUser: PrivateUser,\n  contract: Contract\n) => {\n  const { sendToEmail, unsubscribeUrl } = getNotificationDestinationsForUser(\n    privateUser,\n    reason\n  )\n  if (!privateUser.email || !sendToEmail) return\n  const firstName = userName.split(' ')[0]\n  const creatorName = contract.creatorName\n\n  const questionImgSrc = imageSourceUrl(contract)\n  return [\n    privateUser.email,\n    {\n      name: firstName,\n      creatorName,\n      unsubscribeUrl,\n      questionTitle: contract.question,\n      questionUrl: contractUrl(contract),\n      questionImgSrc,\n    },\n  ] as EmailAndTemplateEntry\n}\n\nexport const sendNewPrivateMarketEmail = async (\n  reason: notification_reason_types,\n  privateUser: PrivateUser,\n  contract: Contract,\n  groupName: string\n) => {\n  const { sendToEmail, unsubscribeUrl } = getNotificationDestinationsForUser(\n    privateUser,\n    reason\n  )\n  if (!privateUser.email || !sendToEmail) return\n  const user = await getUser(privateUser.id)\n  if (!user) return\n\n  const { name } = user\n  const firstName = name.split(' ')[0]\n  const creatorName = contract.creatorName\n\n  const questionImgSrc = imageSourceUrl(contract)\n  console.log('questionImgSrc', questionImgSrc)\n  return await sendTemplateEmail(\n    privateUser.email,\n    `${creatorName} asked ${contract.question} in private group, ${groupName}`,\n    'new-market-from-private-group',\n    {\n      name: firstName,\n      creatorName,\n      unsubscribeUrl,\n      questionTitle: contract.question,\n      questionUrl: contractUrl(contract),\n      questionImgSrc,\n      groupName,\n    },\n    {\n      from: `${creatorName} on Manifold <no-reply@manifold.markets>`,\n    }\n  )\n}\nexport const sendNewUniqueBettorsEmail = async (\n  reason: NotificationReason,\n  privateUser: PrivateUser,\n  contract: Contract,\n  totalPredictors: number,\n  newPredictors: User[],\n  userBets: Dictionary<[Bet, ...Bet[]]>,\n  bonusAmount: number\n) => {\n  const { sendToEmail, unsubscribeUrl } = getNotificationDestinationsForUser(\n    privateUser,\n    reason\n  )\n  if (!privateUser.email || !sendToEmail) return\n  const user = await getUser(privateUser.id)\n  if (!user) return\n\n  const { name } = user\n  const firstName = name.split(' ')[0]\n  const creatorName = contract.creatorName\n  // make the emails stack for the same contract\n  const subject = `You made a popular market! ${\n    contract.question.length > 50\n      ? contract.question.slice(0, 50) + '...'\n      : contract.question\n  } just got ${\n    newPredictors.length\n  } new predictions. Check out who's predicting on it inside.`\n  const templateData: Record<string, string> = {\n    name: firstName,\n    creatorName,\n    totalPredictors: totalPredictors.toString(),\n    marketTitle: contract.question,\n    marketUrl: contractUrl(contract),\n    bonusString: bonusAmount.toString(),\n    unsubscribeUrl,\n    newPredictors: newPredictors.length.toString(),\n  }\n\n  newPredictors.forEach((p, i) => {\n    templateData[`bettor${i + 1}Name`] = p.name\n    if (p.avatarUrl) templateData[`bettor${i + 1}AvatarUrl`] = p.avatarUrl\n    const bet = userBets[p.id][0]\n    if (bet) {\n      const { amount } = bet\n      templateData[`bet${i + 1}Description`] = `${\n        amount < 0 ? 'sold' : 'bought'\n      } ${formatMoneyEmail(Math.abs(amount), contract.token)}`\n    }\n  })\n\n  return await sendTemplateEmail(\n    privateUser.email,\n    subject,\n    // This template accepts 5 unique bettors\n    'new-unique-traders',\n    templateData,\n    {\n      from: `Manifold <no-reply@manifold.markets>`,\n    }\n  )\n}\n\nexport const getWeeklyPortfolioUpdateEmail = (\n  userName: string,\n  privateUser: PrivateUser,\n  investments: PerContractInvestmentsData[],\n  overallPerformance: OverallPerformanceData,\n  moversToSend: number\n) => {\n  if (!privateUser || !privateUser.email) return\n\n  const { unsubscribeUrl, sendToEmail } = getNotificationDestinationsForUser(\n    privateUser,\n    'profit_loss_updates'\n  )\n\n  if (!sendToEmail) return\n\n  const firstName = userName.split(' ')[0]\n  const templateData: Record<string, string> = {\n    name: firstName,\n    unsubscribeUrl,\n    ...overallPerformance,\n  }\n  for (let i = 0; i < moversToSend; i++) {\n    const investment = investments[i]\n    if (investment) {\n      templateData[`question${i + 1}Title`] = investment.questionTitle\n      templateData[`question${i + 1}Url`] = investment.questionUrl\n      templateData[`question${i + 1}Prob`] = investment.questionProb\n      templateData[`question${i + 1}Change`] = formatMoneyEmail(\n        investment.profit,\n        investment.token\n      )\n      templateData[`question${i + 1}ChangeStyle`] = investment.profitStyle\n      templateData[`question${i + 1}Display`] = 'display: table-row'\n    } else templateData[`question${i + 1}Display`] = 'display: none'\n  }\n\n  return [\n    privateUser.email,\n    // Math.random() > 0.5 ? 'iansphilips@gmail.com' : 'boawishbone@gmail.com',\n    templateData,\n  ] as EmailAndTemplateEntry\n}\n\nexport type MarketMovementEmailData = {\n  questionTitle: string\n  questionUrl: string\n  prob: string\n  probChangeStyle: string\n  startProb: number\n  endProb: number\n  answerText?: string\n}\n\nexport const getMarketMovementEmail = (\n  userName: string,\n  privateUser: PrivateUser,\n  marketMovements: MarketMovementEmailData[],\n  movementsToSend: number\n) => {\n  if (!privateUser || !privateUser.email) return\n\n  const { unsubscribeUrl, sendToEmail } = getNotificationDestinationsForUser(\n    privateUser,\n    'market_movements'\n  )\n\n  if (!sendToEmail) return\n\n  const firstName = userName.split(' ')[0]\n  const templateData: Record<string, string> = {\n    name: firstName,\n    unsubscribeUrl,\n  }\n\n  for (let i = 0; i < movementsToSend; i++) {\n    const movement = marketMovements[i]\n    if (movement) {\n      templateData[`question${i + 1}Title`] = movement.questionTitle\n      templateData[`question${i + 1}Url`] = movement.questionUrl\n      templateData[`question${i + 1}Prob`] = movement.prob\n      const arrowColor =\n        movement.endProb > movement.startProb\n          ? '#14b8a6' /* green-500 */\n          : '#ef4444' /* red-500 */\n      templateData[\n        `question${i + 1}ArrowStyle`\n      ] = `color: ${arrowColor}; font-weight: bold;`\n      templateData[`question${i + 1}InitialProb`] = `${Math.round(\n        movement.startProb * 100\n      )}%`\n      templateData[`question${i + 1}ChangeStyle`] = movement.probChangeStyle\n      templateData[`question${i + 1}Display`] = 'display: table-row'\n\n      // Add answer text to the template data if available\n      if (movement.answerText) {\n        // When answer exists\n        templateData[`question${i + 1}AnswerText`] = movement.answerText\n        templateData[`question${i + 1}AnswerDisplay`] = 'table-row'\n\n        // Show probability on answer row when answer exists\n        templateData[`question${i + 1}AnswerProbStyle`] = 'display: inline'\n\n        // Hide probability on question row when answer exists\n        templateData[`question${i + 1}ProbStyle`] = 'display: none'\n      } else {\n        // When no answer exists\n        templateData[`question${i + 1}AnswerText`] = ''\n        templateData[`question${i + 1}AnswerDisplay`] = 'none'\n\n        // Hide probability on answer row when no answer\n        templateData[`question${i + 1}AnswerProbStyle`] = 'display: none'\n\n        // Show probability on question row when no answer\n        templateData[`question${i + 1}ProbStyle`] = 'display: inline'\n      }\n    } else {\n      // When question doesn't exist\n      templateData[`question${i + 1}Display`] = 'display: none'\n      templateData[`question${i + 1}AnswerDisplay`] = 'none'\n      templateData[`question${i + 1}Title`] = ''\n      templateData[`question${i + 1}AnswerText`] = ''\n      templateData[`question${i + 1}ProbStyle`] = 'display: none'\n      templateData[`question${i + 1}AnswerProbStyle`] = 'display: none'\n    }\n  }\n\n  return [privateUser.email, templateData] as EmailAndTemplateEntry\n}\n"
        },
        {
          "path": "backend/shared/src/love/love-markets.ts",
          "preContent": "import { APIError } from 'common/api/utils'\nimport { MarketContract } from 'common/contract'\nimport { User } from 'common/user'\nimport { groupBy, mapValues } from 'lodash'\nimport {\n  ResolutionParams,\n  resolveMarketHelper,\n} from 'shared/resolve-market-helpers'\nimport { createSupabaseDirectClient } from 'shared/supabase/init'\nimport { log } from 'shared/utils'\n\nexport const getCreatorMutuallyMessagedUserIds = async (\n  creatorIds: string[]\n) => {\n  const pg = createSupabaseDirectClient()\n  const mutualMessageData = await pg.manyOrNone<{\n    creator_id: string\n    mutual_id: string\n    channel_id: string\n  }>(\n    `\n    SELECT\n        p1.user_id AS creator_id,\n        p2.user_id AS mutual_id,\n        p1.channel_id\n    FROM\n        private_user_messages p1\n    JOIN\n        private_user_messages p2 ON p1.channel_id = p2.channel_id AND p1.user_id != p2.user_id\n    WHERE\n        p1.user_id = any($1) and\n        p1.channel_id != 638\n    GROUP BY\n        p1.user_id, p2.user_id, p1.channel_id\n    `,\n    [creatorIds]\n  )\n  return mapValues(\n    groupBy(mutualMessageData, (r) => r.creator_id),\n    (v) => v.map((r) => r.mutual_id)\n  )\n}\n\nexport const getMutuallyMessagedUserIds = async (creatorId: string) => {\n  return (await getCreatorMutuallyMessagedUserIds([creatorId]))[creatorId]\n}\n\nexport const resolveLoveMarketOtherAnswers = async (\n  contract: MarketContract,\n  resolver: User,\n  creator: User,\n  resolutionParams: ResolutionParams\n) => {\n  if (\n    !(\n      contract.outcomeType === 'MULTIPLE_CHOICE' &&\n      contract.mechanism === 'cpmm-multi-1'\n    )\n  ) {\n    throw new APIError(400, 'Invalid love market type')\n  }\n  log(`Resolving other answers for love market ${contract.slug}`)\n\n  const { answerId } = resolutionParams\n  const otherAnswers = contract.answers.filter(\n    (a) => a.id !== answerId && !a.resolution\n  )\n  const mutuallyMessagedUserIds = await getMutuallyMessagedUserIds(\n    contract.creatorId\n  )\n  for (const otherAnswer of otherAnswers) {\n    const { loverUserId } = otherAnswer\n    const haveMutuallyMessaged =\n      loverUserId && mutuallyMessagedUserIds.includes(loverUserId)\n    const outcome = haveMutuallyMessaged ? 'NO' : 'N/A'\n\n    log(`Resolving ${otherAnswer.text} to ${outcome}`)\n\n    await resolveMarketHelper(contract, resolver, creator, {\n      outcome,\n      answerId: otherAnswer.id,\n    })\n  }\n}\n",
          "postContent": "[DELETED]"
        },
        {
          "path": "backend/shared/src/love/parse-photos.ts",
          "preContent": "export const removePinnedUrlFromPhotoUrls = async (parsedBody: {\n  pinned_url: string | undefined\n  photo_urls: string[] | undefined\n}) => {\n  if (parsedBody.photo_urls && parsedBody.pinned_url) {\n    parsedBody.photo_urls = parsedBody.photo_urls.filter(\n      (url: string) => url !== parsedBody.pinned_url\n    )\n  }\n}\n",
          "postContent": "[DELETED]"
        },
        {
          "path": "backend/shared/src/love/supabase.ts",
          "preContent": "import { areGenderCompatible } from 'common/love/compatibility-util'\nimport { Lover, LoverRow } from 'common/love/lover'\nimport { Row } from 'common/supabase/utils'\nimport { createSupabaseDirectClient } from 'shared/supabase/init'\n\nexport const getLover = async (userId: string) => {\n  const pg = createSupabaseDirectClient()\n  return await pg.oneOrNone<Lover>(\n    `\n      select\n        *, users.data as user\n      from\n        lovers\n      join\n        users on users.id = lovers.user_id\n      where\n        user_id = $1\n    `,\n    [userId]\n  )\n}\n\nexport const getLovers = async (userIds: string[]) => {\n  const pg = createSupabaseDirectClient()\n  return await pg.manyOrNone<Lover>(\n    `\n      select\n        *, users.data as user\n      from\n        lovers\n      join\n        users on users.id = lovers.user_id\n      where\n        user_id = any($1)\n    `,\n    [userIds]\n  )\n}\n\nexport const getGenderCompatibleLovers = async (lover: LoverRow) => {\n  const pg = createSupabaseDirectClient()\n  const lovers = await pg.manyOrNone<Lover>(\n    `\n      select \n        *, users.data as user\n      from lovers\n      join\n        users on users.id = lovers.user_id\n      where\n        user_id != $(user_id)\n        and looking_for_matches\n        and (data->>'isBannedFromPosting' != 'true' or data->>'isBannedFromPosting' is null)\n        and lovers.pinned_url is not null\n      `,\n    { ...lover }\n  )\n  return lovers.filter((l) => areGenderCompatible(lover, l))\n}\n\nexport const getCompatibleLovers = async (\n  lover: LoverRow,\n  radiusKm: number | undefined\n) => {\n  const pg = createSupabaseDirectClient()\n  return await pg.manyOrNone<Lover>(\n    `\n      select \n        *, users.data as user\n      from lovers\n      join\n        users on users.id = lovers.user_id\n      where\n        user_id != $(user_id)\n        and looking_for_matches\n        and (data->>'isBannedFromPosting' != 'true' or data->>'isBannedFromPosting' is null)\n\n        -- Gender\n        and (lovers.gender = any($(pref_gender)) or lovers.gender = 'non-binary')\n        and ($(gender) = any(lovers.pref_gender) or $(gender) = 'non-binary')\n\n        -- Age\n        and lovers.age >= $(pref_age_min)\n        and lovers.age <= $(pref_age_max)\n        and $(age) >= lovers.pref_age_min\n        and $(age) <= lovers.pref_age_max\n\n        -- Location\n        and calculate_earth_distance_km($(city_latitude), $(city_longitude), lovers.city_latitude, lovers.city_longitude) < $(radiusKm)\n      `,\n    { ...lover, radiusKm: radiusKm ?? 40_000 }\n  )\n}\n\nexport const getCompatibilityAnswers = async (userIds: string[]) => {\n  const pg = createSupabaseDirectClient()\n  return await pg.manyOrNone<Row<'love_compatibility_answers'>>(\n    `\n      select * from love_compatibility_answers\n      where creator_id = any($1)\n    `,\n    [userIds]\n  )\n}\n",
          "postContent": "[DELETED]"
        },
        {
          "path": "backend/shared/src/resolve-market-helpers.ts",
          "preContent": "import { mapValues, groupBy, sum, sumBy, keyBy, uniqBy } from 'lodash'\nimport {\n  HOUSE_LIQUIDITY_PROVIDER_ID,\n  DEV_HOUSE_LIQUIDITY_PROVIDER_ID,\n} from 'common/antes'\nimport {\n  Contract,\n  contractPath,\n  ContractToken,\n  CPMMMultiContract,\n  MarketContract,\n  isSpecialLoveContract,\n} from 'common/contract'\nimport { LiquidityProvision } from 'common/liquidity-provision'\nimport { Txn, CancelUniqueBettorBonusTxn } from 'common/txn'\nimport { User } from 'common/user'\nimport { removeUndefinedProps } from 'common/util/object'\nimport { createContractResolvedNotifications } from './create-notification'\nimport { bulkUpdateContractMetricsQuery } from './helpers/user-contract-metrics'\nimport {\n  TxnData,\n  runTxnOutsideBetQueueIgnoringBalance,\n  txnToRow,\n} from './txn/run-txn'\nimport {\n  revalidateStaticProps,\n  isProd,\n  log,\n  getContractAndMetricsAndLiquidities,\n} from './utils'\nimport {\n  getLoanPayouts,\n  getPayouts,\n  groupPayoutsByUser,\n  Payout,\n} from 'common/payouts'\nimport { APIError } from 'common//api/utils'\nimport { trackPublicEvent } from 'shared/analytics'\nimport { recordContractEdit } from 'shared/record-contract-edit'\nimport {\n  SERIAL_MODE,\n  SupabaseTransaction,\n  createSupabaseDirectClient,\n} from './supabase/init'\nimport { Answer } from 'common/answer'\nimport { isAdminId, isModId } from 'common/envs/constants'\nimport { convertTxn } from 'common/supabase/txns'\nimport { updateAnswer, updateAnswers } from './supabase/answers'\nimport { bulkInsertQuery, updateDataQuery } from './supabase/utils'\nimport { bulkIncrementBalancesQuery, UserUpdate } from './supabase/users'\nimport {\n  broadcastUpdatedContract,\n  broadcastUpdatedMetrics,\n} from './websockets/helpers'\nimport { ContractMetric } from 'common/contract-metric'\nimport { calculateUpdatedMetricsForContracts } from 'common/calculate-metrics'\nimport { PROFIT_FEE_FRACTION } from 'common/economy'\n\nexport type ResolutionParams = {\n  outcome: string\n  probabilityInt?: number\n  answerId?: string\n  value?: number\n  resolutions?: { [key: string]: number }\n}\n\nexport const resolveMarketHelper = async (\n  unresolvedContract: MarketContract,\n  resolver: User,\n  creator: User,\n  { value, resolutions, probabilityInt, outcome, answerId }: ResolutionParams\n) => {\n  const pg = createSupabaseDirectClient()\n\n  // TODO: Why not add this to front of bet queue?\n  const {\n    resolvedContract,\n    updatedContractMetrics,\n    payoutsWithoutLoans,\n    updatedContractAttrs,\n    userUpdates,\n  } = await pg.tx({ mode: SERIAL_MODE }, async (tx) => {\n    const { closeTime, id: contractId } = unresolvedContract\n    const {\n      contract: c,\n      liquidities,\n      contractMetrics,\n    } = await getContractAndMetricsAndLiquidities(\n      tx,\n      unresolvedContract,\n      answerId\n    )\n    const isIndieMC = c.mechanism === 'cpmm-multi-1' && !c.shouldAnswersSumToOne\n\n    unresolvedContract = c as MarketContract\n    if (unresolvedContract.isResolved) {\n      throw new APIError(403, 'Contract is already resolved')\n    }\n\n    const resolutionTime = Date.now()\n    const newCloseTime = closeTime\n      ? Math.min(closeTime, resolutionTime)\n      : closeTime\n\n    const {\n      resolutionProbability,\n      payouts,\n      payoutsWithoutLoans,\n      traderPayouts,\n    } = getPayoutInfo(\n      outcome,\n      unresolvedContract,\n      resolutions,\n      probabilityInt,\n      answerId,\n      contractMetrics,\n      liquidities\n    )\n    // Keep MKT resolution prob for consistency's sake\n    const probBeforeResolution =\n      outcome === 'MKT'\n        ? resolutionProbability\n        : unresolvedContract.mechanism === 'cpmm-1'\n        ? unresolvedContract.prob\n        : unresolvedContract.answers.find((a) => a.id === answerId)?.prob\n    const newProb =\n      outcome === 'YES' ? 1 : outcome === 'NO' ? 0 : probBeforeResolution\n    let updatedContractAttrs: Partial<Contract> & { id: string } =\n      removeUndefinedProps({\n        id: unresolvedContract.id,\n        isResolved: true,\n        resolution: outcome,\n        resolutionValue: value,\n        resolutionTime,\n        closeTime: newCloseTime,\n        prob: newProb,\n        resolutionProbability: probBeforeResolution,\n        resolutions,\n        resolverId: resolver.id,\n        subsidyPool: 0,\n        lastUpdatedTime: newCloseTime,\n      })\n    let updateAnswerAttrs: Partial<Answer> | undefined\n\n    if (unresolvedContract.mechanism === 'cpmm-multi-1' && answerId) {\n      // Only resolve the contract if all other answers are resolved.\n      const allOtherAnswers = unresolvedContract.answers.filter(\n        (a) => a.id !== answerId\n      )\n      const allOtherAnswersResolved = allOtherAnswers.every((a) => a.resolution)\n\n      const hasAnswerResolvedYes =\n        unresolvedContract.answers.some((a) => a.resolution === 'YES') ||\n        outcome === 'YES'\n      const marketCancelled =\n        allOtherAnswers.every((a) => a.resolution === 'CANCEL') &&\n        outcome === 'CANCEL'\n      const finalResolution = marketCancelled ? 'CANCEL' : 'MKT'\n      if (\n        allOtherAnswersResolved &&\n        // If the contract has special liquidity per answer, only resolve if an answer is resolved YES.\n        (!isSpecialLoveContract(unresolvedContract) || hasAnswerResolvedYes)\n      ) {\n        updatedContractAttrs = {\n          ...updatedContractAttrs,\n          resolution: finalResolution,\n        }\n      } else {\n        updatedContractAttrs = {\n          id: unresolvedContract.id,\n        }\n      }\n      updateAnswerAttrs = removeUndefinedProps({\n        resolution: outcome,\n        resolutionTime,\n        resolutionProbability: probBeforeResolution,\n        prob: newProb,\n        resolverId: resolver.id,\n      }) as Partial<Answer>\n      // We have to update the denormalized answer data on the contract for the updateContractMetrics call\n      updatedContractAttrs = {\n        ...updatedContractAttrs,\n        answers: unresolvedContract.answers.map((a) =>\n          a.id === answerId\n            ? {\n                ...a,\n                ...updateAnswerAttrs,\n              }\n            : a\n        ),\n      } as Partial<CPMMMultiContract> & { id: string }\n    } else if (\n      unresolvedContract.mechanism === 'cpmm-multi-1' &&\n      updatedContractAttrs.isResolved\n    ) {\n      updateAnswerAttrs = removeUndefinedProps({\n        resolutionTime,\n        resolverId: resolver.id,\n      }) as Partial<Answer>\n      // We have to update the denormalized answer data on the contract for the updateContractMetrics call\n      updatedContractAttrs = {\n        ...updatedContractAttrs,\n        answers: unresolvedContract.answers.map((a) => ({\n          ...a,\n          ...updateAnswerAttrs,\n          prob: resolutions ? (resolutions[a.id] ?? 0) / 100 : a.prob,\n          resolutionProbability: a.prob,\n        })),\n      } as Partial<CPMMMultiContract> & { id: string }\n    }\n\n    const resolvedContract = {\n      ...unresolvedContract,\n      ...updatedContractAttrs,\n    } as MarketContract\n\n    // handle exploit where users can get negative payouts\n    const negPayoutThreshold =\n      resolvedContract.uniqueBettorCount < 100 ? 0 : -1000\n\n    const userPayouts = groupPayoutsByUser(payouts)\n    log('user payouts', { userPayouts })\n\n    const negativePayouts = Object.values(userPayouts).filter(\n      (p) => p < negPayoutThreshold\n    )\n\n    log('negative payouts', { negativePayouts })\n\n    if (\n      outcome === 'CANCEL' &&\n      !isAdminId(resolver.id) &&\n      !isModId(resolver.id) &&\n      negativePayouts.length > 0\n    ) {\n      throw new APIError(\n        403,\n        'Negative payouts too large for resolution. Contact admin or mod.'\n      )\n    }\n\n    if (updateAnswerAttrs && answerId) {\n      const props = removeUndefinedProps(updateAnswerAttrs)\n      await updateAnswer(tx, answerId, props)\n    } else if (\n      updateAnswerAttrs &&\n      resolvedContract.mechanism === 'cpmm-multi-1'\n    ) {\n      const answerUpdates = resolvedContract.answers.map((a) =>\n        removeUndefinedProps({\n          id: a.id,\n          ...updateAnswerAttrs,\n          prob: a.prob,\n          resolutionProbability: a.resolutionProbability,\n        })\n      )\n      await updateAnswers(tx, contractId, answerUpdates)\n    }\n    const { metricsByContract } = calculateUpdatedMetricsForContracts(\n      [{ contract: resolvedContract, metrics: contractMetrics }],\n      isIndieMC\n    )\n    const updatedContractMetrics = metricsByContract[resolvedContract.id] ?? []\n    const updateMetricsQuery = bulkUpdateContractMetricsQuery(\n      updatedContractMetrics\n    )\n    const { token } = resolvedContract\n    const payoutFees =\n      token === 'CASH'\n        ? assessProfitFees(traderPayouts, updatedContractMetrics, answerId)\n        : []\n    const { balanceUpdatesQuery, insertTxnsQuery } = getPayUsersQueries(\n      payouts,\n      contractId,\n      answerId,\n      token,\n      payoutFees\n    )\n    const contractUpdateQuery = updateDataQuery(\n      'contracts',\n      'id',\n      updatedContractAttrs\n    )\n\n    log('updating contract & processing payouts', { updatedContractAttrs })\n    const results = await tx.multi(`\n      ${balanceUpdatesQuery}; -- 1\n      ${insertTxnsQuery}; -- 2\n      ${contractUpdateQuery}; -- 3\n      ${updateMetricsQuery}; -- 4\n      `)\n    const userUpdates = results[0] as UserUpdate[]\n\n    // TODO: we may want to support clawing back trader bonuses on MC markets too\n    if (!answerId && outcome === 'CANCEL') {\n      await undoUniqueBettorRewardsIfCancelResolution(tx, resolvedContract)\n    }\n\n    return {\n      resolvedContract,\n      payoutsWithoutLoans,\n      updatedContractAttrs,\n      userUpdates,\n      updatedContractMetrics,\n    }\n  })\n\n  broadcastUpdatedContract(resolvedContract.visibility, updatedContractAttrs)\n  broadcastUpdatedMetrics(updatedContractMetrics)\n  const userPayoutsWithoutLoans = groupPayoutsByUser(payoutsWithoutLoans)\n\n  await trackPublicEvent(resolver.id, 'resolve market', {\n    resolution: outcome,\n    contractId: resolvedContract.id,\n  })\n\n  await recordContractEdit(\n    unresolvedContract,\n    resolver.id,\n    Object.keys(updatedContractAttrs ?? {})\n  )\n\n  await revalidateStaticProps(contractPath(resolvedContract))\n  const userIdToContractMetric = keyBy(\n    updatedContractMetrics.filter((m) =>\n      answerId ? m.answerId === answerId : m.answerId == null\n    ),\n    'userId'\n  )\n  await createContractResolvedNotifications(\n    resolvedContract,\n    resolver,\n    creator,\n    outcome,\n    probabilityInt,\n    value,\n    answerId,\n    {\n      userIdToContractMetric,\n      userPayouts: userPayoutsWithoutLoans,\n      creatorPayout: 0,\n      resolutionProbability: resolvedContract.resolutionProbability,\n      resolutions,\n    }\n  )\n\n  return { contract: resolvedContract, userUpdates }\n}\n\nexport const getPayoutInfo = (\n  outcome: string | undefined,\n  unresolvedContract: Contract,\n  resolutions: { [key: string]: number } | undefined,\n  probabilityInt: number | undefined,\n  answerId: string | undefined,\n  contractMetrics: ContractMetric[],\n  liquidities: LiquidityProvision[]\n) => {\n  const resolutionProbability =\n    probabilityInt !== undefined ? probabilityInt / 100 : undefined\n\n  const resolutionProbs = resolutions\n    ? (() => {\n        const total = sum(Object.values(resolutions))\n        return mapValues(resolutions, (p) => p / total)\n      })()\n    : undefined\n\n  // Calculate loan payouts from contract metrics\n  const loanPayouts = getLoanPayouts(contractMetrics, answerId)\n\n  // Calculate payouts using contract metrics instead of bets\n  const { traderPayouts, liquidityPayouts } = getPayouts(\n    outcome,\n    unresolvedContract,\n    contractMetrics,\n    liquidities,\n    resolutionProbs,\n    resolutionProbability,\n    answerId\n  )\n\n  const payoutsWithoutLoans = [\n    ...liquidityPayouts.map((p) => ({ ...p, deposit: p.payout })),\n    ...traderPayouts,\n  ]\n\n  if (!isProd())\n    console.log(\n      'trader payouts:',\n      traderPayouts,\n      'liquidity payout:',\n      liquidityPayouts,\n      'loan payouts:',\n      loanPayouts\n    )\n\n  const payouts = [...payoutsWithoutLoans, ...loanPayouts].filter(\n    (p) => p.payout !== 0\n  )\n\n  return {\n    payoutsWithoutLoans,\n    contractMetrics,\n    resolutionProbs,\n    resolutionProbability,\n    payouts,\n    traderPayouts,\n  }\n}\n\nasync function undoUniqueBettorRewardsIfCancelResolution(\n  pg: SupabaseTransaction,\n  contract: Contract\n) {\n  const bonusTxnsOnThisContract = await pg.map<Txn>(\n    `select * from txns where category = 'UNIQUE_BETTOR_BONUS'\n      and to_id = $1\n      and data->'data'->>'contractId' = $2`,\n    [contract.creatorId, contract.id],\n    convertTxn\n  )\n\n  log('total bonusTxnsOnThisContract ' + bonusTxnsOnThisContract.length)\n  const totalBonusAmount = sumBy(bonusTxnsOnThisContract, (txn) => txn.amount)\n  log('totalBonusAmount to be withdrawn ' + totalBonusAmount)\n\n  if (totalBonusAmount === 0) {\n    log('No bonus to cancel')\n    return\n  }\n\n  const undoBonusTxn = {\n    fromId: contract.creatorId,\n    fromType: 'USER',\n    toId: isProd()\n      ? HOUSE_LIQUIDITY_PROVIDER_ID\n      : DEV_HOUSE_LIQUIDITY_PROVIDER_ID,\n    toType: 'BANK',\n    amount: totalBonusAmount,\n    token: 'M$',\n    category: 'CANCEL_UNIQUE_BETTOR_BONUS',\n    data: {\n      contractId: contract.id,\n    },\n  } as Omit<CancelUniqueBettorBonusTxn, 'id' | 'createdTime'>\n\n  const txn = await runTxnOutsideBetQueueIgnoringBalance(pg, undoBonusTxn)\n  log(`Cancel Bonus txn for user: ${contract.creatorId} completed: ${txn.id}`)\n}\n\nexport const getPayUsersQueries = (\n  payouts: Payout[],\n  contractId: string,\n  answerId: string | undefined,\n  token: ContractToken,\n  payoutFees: Payout[]\n) => {\n  const payoutCash = token === 'CASH'\n  const payoutToken = token === 'CASH' ? 'CASH' : 'M$'\n  const mergedPayouts = checkAndMergePayouts(payouts)\n  const payoutStartTime = Date.now()\n\n  const balanceUpdates: {\n    id: string\n    balance?: number\n    spiceBalance?: number\n    totalDeposits?: number\n    totalCashDeposits?: number\n  }[] = []\n  const txns: TxnData[] = []\n\n  for (const { userId, payout, deposit } of mergedPayouts) {\n    const userPayoutFees = payoutFees.filter((t) => t.userId === userId)\n    if (userPayoutFees.length > 1) {\n      throw new APIError(\n        500,\n        `Multiple payout fees for user: ${userId} on contract: ${contractId}`\n      )\n    }\n    const payoutFee = userPayoutFees[0]?.payout ?? 0\n    balanceUpdates.push({\n      id: userId,\n      [payoutCash ? 'cashBalance' : 'balance']: payout + payoutFee,\n      [payoutCash ? 'totalCashDeposits' : 'totalDeposits']: deposit ?? 0,\n    })\n\n    txns.push({\n      category: 'CONTRACT_RESOLUTION_PAYOUT',\n      fromType: 'CONTRACT',\n      fromId: contractId,\n      toType: 'USER',\n      toId: userId,\n      amount: payout,\n      token: payoutToken,\n      data: removeUndefinedProps({\n        deposit: deposit ?? 0,\n        payoutStartTime,\n        answerId,\n      }),\n      description: 'Contract payout for resolution: ' + contractId,\n    })\n  }\n\n  for (const { userId, payout } of payoutFees) {\n    const balanceUpdate = balanceUpdates.find((b) => b.id === userId)\n    if (!balanceUpdate) {\n      balanceUpdates.push({\n        id: userId,\n        [payoutCash ? 'cashBalance' : 'balance']: payout,\n      })\n    }\n\n    txns.push({\n      category: 'CONTRACT_RESOLUTION_FEE',\n      fromType: 'USER',\n      fromId: userId,\n      toType: 'BANK',\n      toId: isProd()\n        ? HOUSE_LIQUIDITY_PROVIDER_ID\n        : DEV_HOUSE_LIQUIDITY_PROVIDER_ID,\n      amount: -payout,\n      token: payoutToken,\n      data: removeUndefinedProps({\n        contractId,\n        payoutStartTime,\n        answerId,\n      }),\n    })\n  }\n\n  const balanceUpdatesQuery = bulkIncrementBalancesQuery(balanceUpdates)\n  const insertTxnsQuery = bulkInsertQuery('txns', txns.map(txnToRow), false)\n\n  return { balanceUpdatesQuery, insertTxnsQuery }\n}\n\nconst checkAndMergePayouts = (payouts: Payout[]) => {\n  for (const { payout, deposit } of payouts) {\n    if (!isFinite(payout)) {\n      throw new Error('Payout is not finite: ' + payout)\n    }\n    if (deposit !== undefined && !isFinite(deposit)) {\n      throw new Error('Deposit is not finite: ' + deposit)\n    }\n  }\n\n  const groupedPayouts = groupBy(payouts, 'userId')\n  return Object.values(\n    mapValues(groupedPayouts, (payouts, userId) => ({\n      userId,\n      payout: sumBy(payouts, 'payout'),\n      deposit: sumBy(payouts, (p) => p.deposit ?? 0),\n    }))\n  ).filter((p) => p!.payout !== 0 || p!.deposit !== 0)\n}\n\nconst assessProfitFees = (\n  payouts: Payout[],\n  contractMetrics: Omit<ContractMetric, 'id'>[],\n  answerId: string | undefined\n) => {\n  return uniqBy(payouts, 'userId')\n    .map((payout) => {\n      const contractMetric = contractMetrics.find(\n        (m) => m.userId === payout.userId && m.answerId === (answerId ?? null)\n      )\n      if (!contractMetric) {\n        throw new APIError(\n          500,\n          'Contract metric not found for user: ' + payout.userId\n        )\n      }\n\n      const tax = contractMetric.profit * PROFIT_FEE_FRACTION\n      return {\n        userId: payout.userId,\n        payout: contractMetric.profit > 0 ? -tax : 0,\n      }\n    })\n    .filter((p) => p.payout !== 0)\n}\n",
          "postContent": "import { mapValues, groupBy, sum, sumBy, keyBy, uniqBy } from 'lodash'\nimport {\n  HOUSE_LIQUIDITY_PROVIDER_ID,\n  DEV_HOUSE_LIQUIDITY_PROVIDER_ID,\n} from 'common/antes'\nimport {\n  Contract,\n  contractPath,\n  ContractToken,\n  CPMMMultiContract,\n  MarketContract,\n} from 'common/contract'\nimport { LiquidityProvision } from 'common/liquidity-provision'\nimport { Txn, CancelUniqueBettorBonusTxn } from 'common/txn'\nimport { User } from 'common/user'\nimport { removeUndefinedProps } from 'common/util/object'\nimport { createContractResolvedNotifications } from './create-notification'\nimport { bulkUpdateContractMetricsQuery } from './helpers/user-contract-metrics'\nimport {\n  TxnData,\n  runTxnOutsideBetQueueIgnoringBalance,\n  txnToRow,\n} from './txn/run-txn'\nimport {\n  revalidateStaticProps,\n  isProd,\n  log,\n  getContractAndMetricsAndLiquidities,\n} from './utils'\nimport {\n  getLoanPayouts,\n  getPayouts,\n  groupPayoutsByUser,\n  Payout,\n} from 'common/payouts'\nimport { APIError } from 'common//api/utils'\nimport { trackPublicEvent } from 'shared/analytics'\nimport { recordContractEdit } from 'shared/record-contract-edit'\nimport {\n  SERIAL_MODE,\n  SupabaseTransaction,\n  createSupabaseDirectClient,\n} from './supabase/init'\nimport { Answer } from 'common/answer'\nimport { isAdminId, isModId } from 'common/envs/constants'\nimport { convertTxn } from 'common/supabase/txns'\nimport { updateAnswer, updateAnswers } from './supabase/answers'\nimport { bulkInsertQuery, updateDataQuery } from './supabase/utils'\nimport { bulkIncrementBalancesQuery, UserUpdate } from './supabase/users'\nimport {\n  broadcastUpdatedContract,\n  broadcastUpdatedMetrics,\n} from './websockets/helpers'\nimport { ContractMetric } from 'common/contract-metric'\nimport { calculateUpdatedMetricsForContracts } from 'common/calculate-metrics'\nimport { PROFIT_FEE_FRACTION } from 'common/economy'\n\nexport type ResolutionParams = {\n  outcome: string\n  probabilityInt?: number\n  answerId?: string\n  value?: number\n  resolutions?: { [key: string]: number }\n}\n\nexport const resolveMarketHelper = async (\n  unresolvedContract: MarketContract,\n  resolver: User,\n  creator: User,\n  { value, resolutions, probabilityInt, outcome, answerId }: ResolutionParams\n) => {\n  const pg = createSupabaseDirectClient()\n\n  // TODO: Why not add this to front of bet queue?\n  const {\n    resolvedContract,\n    updatedContractMetrics,\n    payoutsWithoutLoans,\n    updatedContractAttrs,\n    userUpdates,\n  } = await pg.tx({ mode: SERIAL_MODE }, async (tx) => {\n    const { closeTime, id: contractId } = unresolvedContract\n    const {\n      contract: c,\n      liquidities,\n      contractMetrics,\n    } = await getContractAndMetricsAndLiquidities(\n      tx,\n      unresolvedContract,\n    )\n    const isIndieMC = c.mechanism === 'cpmm-multi-1' && !c.shouldAnswersSumToOne\n\n    unresolvedContract = c as MarketContract\n    if (unresolvedContract.isResolved) {\n      throw new APIError(403, 'Contract is already resolved')\n    }\n\n    const resolutionTime = Date.now()\n    const newCloseTime = closeTime\n      ? Math.min(closeTime, resolutionTime)\n      : closeTime\n\n    const {\n      resolutionProbability,\n      payouts,\n      payoutsWithoutLoans,\n      traderPayouts,\n    } = getPayoutInfo(\n      outcome,\n      unresolvedContract,\n      resolutions,\n      probabilityInt,\n      answerId,\n      contractMetrics,\n      liquidities\n    )\n    // Keep MKT resolution prob for consistency's sake\n    const probBeforeResolution =\n      outcome === 'MKT'\n        ? resolutionProbability\n        : unresolvedContract.mechanism === 'cpmm-1'\n        ? unresolvedContract.prob\n        : unresolvedContract.answers.find((a) => a.id === answerId)?.prob\n    const newProb =\n      outcome === 'YES' ? 1 : outcome === 'NO' ? 0 : probBeforeResolution\n    let updatedContractAttrs: Partial<Contract> & { id: string } =\n      removeUndefinedProps({\n        id: unresolvedContract.id,\n        isResolved: true,\n        resolution: outcome,\n        resolutionValue: value,\n        resolutionTime,\n        closeTime: newCloseTime,\n        prob: newProb,\n        resolutionProbability: probBeforeResolution,\n        resolutions,\n        resolverId: resolver.id,\n        subsidyPool: 0,\n        lastUpdatedTime: newCloseTime,\n      })\n    let updateAnswerAttrs: Partial<Answer> | undefined\n\n    if (unresolvedContract.mechanism === 'cpmm-multi-1' && answerId) {\n      // Only resolve the contract if all other answers are resolved.\n      const allOtherAnswers = unresolvedContract.answers.filter(\n        (a) => a.id !== answerId\n      )\n      const allOtherAnswersResolved = allOtherAnswers.every((a) => a.resolution)\n\n      const marketCancelled =\n        allOtherAnswers.every((a) => a.resolution === 'CANCEL') &&\n        outcome === 'CANCEL'\n      const finalResolution = marketCancelled ? 'CANCEL' : 'MKT'\n      if (allOtherAnswersResolved) {\n        updatedContractAttrs = {\n          ...updatedContractAttrs,\n          resolution: finalResolution,\n        }\n      } else {\n        updatedContractAttrs = {\n          id: unresolvedContract.id,\n        }\n      }\n      updateAnswerAttrs = removeUndefinedProps({\n        resolution: outcome,\n        resolutionTime,\n        resolutionProbability: probBeforeResolution,\n        prob: newProb,\n        resolverId: resolver.id,\n      }) as Partial<Answer>\n      // We have to update the denormalized answer data on the contract for the updateContractMetrics call\n      updatedContractAttrs = {\n        ...updatedContractAttrs,\n        answers: unresolvedContract.answers.map((a) =>\n          a.id === answerId\n            ? {\n                ...a,\n                ...updateAnswerAttrs,\n              }\n            : a\n        ),\n      } as Partial<CPMMMultiContract> & { id: string }\n    } else if (\n      unresolvedContract.mechanism === 'cpmm-multi-1' &&\n      updatedContractAttrs.isResolved\n    ) {\n      updateAnswerAttrs = removeUndefinedProps({\n        resolutionTime,\n        resolverId: resolver.id,\n      }) as Partial<Answer>\n      // We have to update the denormalized answer data on the contract for the updateContractMetrics call\n      updatedContractAttrs = {\n        ...updatedContractAttrs,\n        answers: unresolvedContract.answers.map((a) => ({\n          ...a,\n          ...updateAnswerAttrs,\n          prob: resolutions ? (resolutions[a.id] ?? 0) / 100 : a.prob,\n          resolutionProbability: a.prob,\n        })),\n      } as Partial<CPMMMultiContract> & { id: string }\n    }\n\n    const resolvedContract = {\n      ...unresolvedContract,\n      ...updatedContractAttrs,\n    } as MarketContract\n\n    // handle exploit where users can get negative payouts\n    const negPayoutThreshold =\n      resolvedContract.uniqueBettorCount < 100 ? 0 : -1000\n\n    const userPayouts = groupPayoutsByUser(payouts)\n    log('user payouts', { userPayouts })\n\n    const negativePayouts = Object.values(userPayouts).filter(\n      (p) => p < negPayoutThreshold\n    )\n\n    log('negative payouts', { negativePayouts })\n\n    if (\n      outcome === 'CANCEL' &&\n      !isAdminId(resolver.id) &&\n      !isModId(resolver.id) &&\n      negativePayouts.length > 0\n    ) {\n      throw new APIError(\n        403,\n        'Negative payouts too large for resolution. Contact admin or mod.'\n      )\n    }\n\n    if (updateAnswerAttrs && answerId) {\n      const props = removeUndefinedProps(updateAnswerAttrs)\n      await updateAnswer(tx, answerId, props)\n    } else if (\n      updateAnswerAttrs &&\n      resolvedContract.mechanism === 'cpmm-multi-1'\n    ) {\n      const answerUpdates = resolvedContract.answers.map((a) =>\n        removeUndefinedProps({\n          id: a.id,\n          ...updateAnswerAttrs,\n          prob: a.prob,\n          resolutionProbability: a.resolutionProbability,\n        })\n      )\n      await updateAnswers(tx, contractId, answerUpdates)\n    }\n    const { metricsByContract } = calculateUpdatedMetricsForContracts(\n      [{ contract: resolvedContract, metrics: contractMetrics }],\n      isIndieMC\n    )\n    const updatedContractMetrics = metricsByContract[resolvedContract.id] ?? []\n    const updateMetricsQuery = bulkUpdateContractMetricsQuery(\n      updatedContractMetrics\n    )\n    const { token } = resolvedContract\n    const payoutFees =\n      token === 'CASH'\n        ? assessProfitFees(traderPayouts, updatedContractMetrics, answerId)\n        : []\n    const { balanceUpdatesQuery, insertTxnsQuery } = getPayUsersQueries(\n      payouts,\n      contractId,\n      answerId,\n      token,\n      payoutFees\n    )\n    const contractUpdateQuery = updateDataQuery(\n      'contracts',\n      'id',\n      updatedContractAttrs\n    )\n\n    log('updating contract & processing payouts', { updatedContractAttrs })\n    const results = await tx.multi(`\n      ${balanceUpdatesQuery}; -- 1\n      ${insertTxnsQuery}; -- 2\n      ${contractUpdateQuery}; -- 3\n      ${updateMetricsQuery}; -- 4\n      `)\n    const userUpdates = results[0] as UserUpdate[]\n\n    // TODO: we may want to support clawing back trader bonuses on MC markets too\n    if (!answerId && outcome === 'CANCEL') {\n      await undoUniqueBettorRewardsIfCancelResolution(tx, resolvedContract)\n    }\n\n    return {\n      resolvedContract,\n      payoutsWithoutLoans,\n      updatedContractAttrs,\n      userUpdates,\n      updatedContractMetrics,\n    }\n  })\n\n  broadcastUpdatedContract(resolvedContract.visibility, updatedContractAttrs)\n  broadcastUpdatedMetrics(updatedContractMetrics)\n  const userPayoutsWithoutLoans = groupPayoutsByUser(payoutsWithoutLoans)\n\n  await trackPublicEvent(resolver.id, 'resolve market', {\n    resolution: outcome,\n    contractId: resolvedContract.id,\n  })\n\n  await recordContractEdit(\n    unresolvedContract,\n    resolver.id,\n    Object.keys(updatedContractAttrs ?? {})\n  )\n\n  await revalidateStaticProps(contractPath(resolvedContract))\n  const userIdToContractMetric = keyBy(\n    updatedContractMetrics.filter((m) =>\n      answerId ? m.answerId === answerId : m.answerId == null\n    ),\n    'userId'\n  )\n  await createContractResolvedNotifications(\n    resolvedContract,\n    resolver,\n    creator,\n    outcome,\n    probabilityInt,\n    value,\n    answerId,\n    {\n      userIdToContractMetric,\n      userPayouts: userPayoutsWithoutLoans,\n      creatorPayout: 0,\n      resolutionProbability: resolvedContract.resolutionProbability,\n      resolutions,\n    }\n  )\n\n  return { contract: resolvedContract, userUpdates }\n}\n\nexport const getPayoutInfo = (\n  outcome: string | undefined,\n  unresolvedContract: Contract,\n  resolutions: { [key: string]: number } | undefined,\n  probabilityInt: number | undefined,\n  answerId: string | undefined,\n  contractMetrics: ContractMetric[],\n  liquidities: LiquidityProvision[]\n) => {\n  const resolutionProbability =\n    probabilityInt !== undefined ? probabilityInt / 100 : undefined\n\n  const resolutionProbs = resolutions\n    ? (() => {\n        const total = sum(Object.values(resolutions))\n        return mapValues(resolutions, (p) => p / total)\n      })()\n    : undefined\n\n  // Calculate loan payouts from contract metrics\n  const loanPayouts = getLoanPayouts(contractMetrics, answerId)\n\n  // Calculate payouts using contract metrics instead of bets\n  const { traderPayouts, liquidityPayouts } = getPayouts(\n    outcome,\n    unresolvedContract,\n    contractMetrics,\n    liquidities,\n    resolutionProbs,\n    resolutionProbability,\n    answerId\n  )\n\n  const payoutsWithoutLoans = [\n    ...liquidityPayouts.map((p) => ({ ...p, deposit: p.payout })),\n    ...traderPayouts,\n  ]\n\n  if (!isProd())\n    console.log(\n      'trader payouts:',\n      traderPayouts,\n      'liquidity payout:',\n      liquidityPayouts,\n      'loan payouts:',\n      loanPayouts\n    )\n\n  const payouts = [...payoutsWithoutLoans, ...loanPayouts].filter(\n    (p) => p.payout !== 0\n  )\n\n  return {\n    payoutsWithoutLoans,\n    contractMetrics,\n    resolutionProbs,\n    resolutionProbability,\n    payouts,\n    traderPayouts,\n  }\n}\n\nasync function undoUniqueBettorRewardsIfCancelResolution(\n  pg: SupabaseTransaction,\n  contract: Contract\n) {\n  const bonusTxnsOnThisContract = await pg.map<Txn>(\n    `select * from txns where category = 'UNIQUE_BETTOR_BONUS'\n      and to_id = $1\n      and data->'data'->>'contractId' = $2`,\n    [contract.creatorId, contract.id],\n    convertTxn\n  )\n\n  log('total bonusTxnsOnThisContract ' + bonusTxnsOnThisContract.length)\n  const totalBonusAmount = sumBy(bonusTxnsOnThisContract, (txn) => txn.amount)\n  log('totalBonusAmount to be withdrawn ' + totalBonusAmount)\n\n  if (totalBonusAmount === 0) {\n    log('No bonus to cancel')\n    return\n  }\n\n  const undoBonusTxn = {\n    fromId: contract.creatorId,\n    fromType: 'USER',\n    toId: isProd()\n      ? HOUSE_LIQUIDITY_PROVIDER_ID\n      : DEV_HOUSE_LIQUIDITY_PROVIDER_ID,\n    toType: 'BANK',\n    amount: totalBonusAmount,\n    token: 'M$',\n    category: 'CANCEL_UNIQUE_BETTOR_BONUS',\n    data: {\n      contractId: contract.id,\n    },\n  } as Omit<CancelUniqueBettorBonusTxn, 'id' | 'createdTime'>\n\n  const txn = await runTxnOutsideBetQueueIgnoringBalance(pg, undoBonusTxn)\n  log(`Cancel Bonus txn for user: ${contract.creatorId} completed: ${txn.id}`)\n}\n\nexport const getPayUsersQueries = (\n  payouts: Payout[],\n  contractId: string,\n  answerId: string | undefined,\n  token: ContractToken,\n  payoutFees: Payout[]\n) => {\n  const payoutCash = token === 'CASH'\n  const payoutToken = token === 'CASH' ? 'CASH' : 'M$'\n  const mergedPayouts = checkAndMergePayouts(payouts)\n  const payoutStartTime = Date.now()\n\n  const balanceUpdates: {\n    id: string\n    balance?: number\n    spiceBalance?: number\n    totalDeposits?: number\n    totalCashDeposits?: number\n  }[] = []\n  const txns: TxnData[] = []\n\n  for (const { userId, payout, deposit } of mergedPayouts) {\n    const userPayoutFees = payoutFees.filter((t) => t.userId === userId)\n    if (userPayoutFees.length > 1) {\n      throw new APIError(\n        500,\n        `Multiple payout fees for user: ${userId} on contract: ${contractId}`\n      )\n    }\n    const payoutFee = userPayoutFees[0]?.payout ?? 0\n    balanceUpdates.push({\n      id: userId,\n      [payoutCash ? 'cashBalance' : 'balance']: payout + payoutFee,\n      [payoutCash ? 'totalCashDeposits' : 'totalDeposits']: deposit ?? 0,\n    })\n\n    txns.push({\n      category: 'CONTRACT_RESOLUTION_PAYOUT',\n      fromType: 'CONTRACT',\n      fromId: contractId,\n      toType: 'USER',\n      toId: userId,\n      amount: payout,\n      token: payoutToken,\n      data: removeUndefinedProps({\n        deposit: deposit ?? 0,\n        payoutStartTime,\n        answerId,\n      }),\n      description: 'Contract payout for resolution: ' + contractId,\n    })\n  }\n\n  for (const { userId, payout } of payoutFees) {\n    const balanceUpdate = balanceUpdates.find((b) => b.id === userId)\n    if (!balanceUpdate) {\n      balanceUpdates.push({\n        id: userId,\n        [payoutCash ? 'cashBalance' : 'balance']: payout,\n      })\n    }\n\n    txns.push({\n      category: 'CONTRACT_RESOLUTION_FEE',\n      fromType: 'USER',\n      fromId: userId,\n      toType: 'BANK',\n      toId: isProd()\n        ? HOUSE_LIQUIDITY_PROVIDER_ID\n        : DEV_HOUSE_LIQUIDITY_PROVIDER_ID,\n      amount: -payout,\n      token: payoutToken,\n      data: removeUndefinedProps({\n        contractId,\n        payoutStartTime,\n        answerId,\n      }),\n    })\n  }\n\n  const balanceUpdatesQuery = bulkIncrementBalancesQuery(balanceUpdates)\n  const insertTxnsQuery = bulkInsertQuery('txns', txns.map(txnToRow), false)\n\n  return { balanceUpdatesQuery, insertTxnsQuery }\n}\n\nconst checkAndMergePayouts = (payouts: Payout[]) => {\n  for (const { payout, deposit } of payouts) {\n    if (!isFinite(payout)) {\n      throw new Error('Payout is not finite: ' + payout)\n    }\n    if (deposit !== undefined && !isFinite(deposit)) {\n      throw new Error('Deposit is not finite: ' + deposit)\n    }\n  }\n\n  const groupedPayouts = groupBy(payouts, 'userId')\n  return Object.values(\n    mapValues(groupedPayouts, (payouts, userId) => ({\n      userId,\n      payout: sumBy(payouts, 'payout'),\n      deposit: sumBy(payouts, (p) => p.deposit ?? 0),\n    }))\n  ).filter((p) => p!.payout !== 0 || p!.deposit !== 0)\n}\n\nconst assessProfitFees = (\n  payouts: Payout[],\n  contractMetrics: Omit<ContractMetric, 'id'>[],\n  answerId: string | undefined\n) => {\n  return uniqBy(payouts, 'userId')\n    .map((payout) => {\n      const contractMetric = contractMetrics.find(\n        (m) => m.userId === payout.userId && m.answerId === (answerId ?? null)\n      )\n      if (!contractMetric) {\n        throw new APIError(\n          500,\n          'Contract metric not found for user: ' + payout.userId\n        )\n      }\n\n      const tax = contractMetric.profit * PROFIT_FEE_FRACTION\n      return {\n        userId: payout.userId,\n        payout: contractMetric.profit > 0 ? -tax : 0,\n      }\n    })\n    .filter((p) => p.payout !== 0)\n}\n"
        },
        {
          "path": "backend/shared/src/supabase/private-messages.ts",
          "preContent": "import { Json } from 'common/supabase/schema'\nimport { SupabaseDirectClient } from 'shared/supabase/init'\nimport { ChatVisibility } from 'common/chat-message'\nimport { User } from 'common/user'\nimport { first } from 'lodash'\n\nimport { log } from 'shared/monitoring/log'\nimport { HOUR_MS } from 'common/util/time'\nimport { getPrivateUser, getUser } from 'shared/utils'\nimport { JSONContent } from '@tiptap/core'\nimport { APIError } from 'common/api/utils'\nimport { broadcast } from 'shared/websockets/server'\nimport { track } from 'shared/analytics'\nimport { getNotificationDestinationsForUser } from 'common/user-notification-preferences'\nimport { Notification } from 'common/notification'\nimport { createPushNotifications } from 'shared/create-push-notifications'\nimport { sendNewMessageEmail } from 'shared/emails'\nimport * as dayjs from 'dayjs'\nimport * as utc from 'dayjs/plugin/utc'\nimport * as timezone from 'dayjs/plugin/timezone'\nimport { nanoid } from 'common/util/random'\ndayjs.extend(utc)\ndayjs.extend(timezone)\nexport const leaveChatContent = (userName: string) => ({\n  type: 'doc',\n  content: [\n    {\n      type: 'paragraph',\n      content: [{ text: `${userName} left the chat`, type: 'text' }],\n    },\n  ],\n})\nexport const joinChatContent = (userName: string) => {\n  return {\n    type: 'doc',\n    content: [\n      {\n        type: 'paragraph',\n        content: [{ text: `${userName} joined the chat!`, type: 'text' }],\n      },\n    ],\n  }\n}\n\nexport const insertPrivateMessage = async (\n  content: Json,\n  channelId: number,\n  userId: string,\n  visibility: ChatVisibility,\n  pg: SupabaseDirectClient\n) => {\n  const lastMessage = await pg.one(\n    `insert into private_user_messages (content, channel_id, user_id, visibility)\n    values ($1, $2, $3, $4) returning created_time`,\n    [content, channelId, userId, visibility]\n  )\n  await pg.none(\n    `update private_user_message_channels set last_updated_time = $1 where id = $2`,\n    [lastMessage.created_time, channelId]\n  )\n}\n\nexport const addUsersToPrivateMessageChannel = async (\n  userIds: string[],\n  channelId: number,\n  pg: SupabaseDirectClient\n) => {\n  await Promise.all(\n    userIds.map((id) =>\n      pg.none(\n        `insert into private_user_message_channel_members (channel_id, user_id, role, status)\n                values\n                ($1, $2, 'member', 'proposed')\n                on conflict do nothing\n              `,\n        [channelId, id]\n      )\n    )\n  )\n  await pg.none(\n    `update private_user_message_channels set last_updated_time = now() where id = $1`,\n    [channelId]\n  )\n}\n\nexport const createPrivateUserMessageMain = async (\n  creator: User,\n  channelId: number,\n  content: JSONContent,\n  pg: SupabaseDirectClient,\n  visibility: ChatVisibility\n) => {\n  // Normally, users can only submit messages to channels that they are members of\n  const authorized = await pg.oneOrNone(\n    `select 1\n       from private_user_message_channel_members\n       where channel_id = $1\n         and user_id = $2`,\n    [channelId, creator.id]\n  )\n  if (!authorized)\n    throw new APIError(403, 'You are not authorized to post to this channel')\n\n  await notifyOtherUserInChannelIfInactive(channelId, creator, pg)\n  await insertPrivateMessage(content, channelId, creator.id, visibility, pg)\n\n  const privateMessage = {\n    content: content as Json,\n    channel_id: channelId,\n    user_id: creator.id,\n  }\n\n  const otherUserIds = await pg.map<string>(\n    `select user_id from private_user_message_channel_members\n        where channel_id = $1 and user_id != $2\n        and status != 'left'\n        `,\n    [channelId, creator.id],\n    (r) => r.user_id\n  )\n  otherUserIds.concat(creator.id).forEach((otherUserId) => {\n    broadcast(`private-user-messages/${otherUserId}`, {})\n  })\n  let bothHaveLoverProfiles = false\n  const hasLoverProfile = await pg.oneOrNone(\n    'select 1 from lovers where user_id = $1',\n    [creator.id]\n  )\n  if (hasLoverProfile) {\n    const otherUserId = first(otherUserIds)\n\n    if (otherUserId && otherUserIds.length === 1) {\n      const otherHasLoverProfile = await pg.oneOrNone(\n        'select 1 from lovers where user_id = $1',\n        [otherUserId]\n      )\n      bothHaveLoverProfiles = !!otherHasLoverProfile\n    }\n  }\n\n  track(creator.id, 'send private message', {\n    channelId,\n    otherUserIds,\n    bothHaveLoverProfiles,\n  })\n\n  return { status: 'success', privateMessage }\n}\nconst notifyOtherUserInChannelIfInactive = async (\n  channelId: number,\n  creator: User,\n  pg: SupabaseDirectClient\n) => {\n  const otherUserIds = await pg.manyOrNone<{ user_id: string }>(\n    `select user_id from private_user_message_channel_members\n        where channel_id = $1 and user_id != $2\n        and status != 'left'\n        `,\n    [channelId, creator.id]\n  )\n  // We're only sending notifs for 1:1 channels\n  if (!otherUserIds || otherUserIds.length > 1) return\n\n  const otherUserId = first(otherUserIds)\n  if (!otherUserId) return\n\n  const startOfDay = dayjs()\n    .tz('America/Los_Angeles')\n    .startOf('day')\n    .toISOString()\n  const previousMessagesThisDayBetweenTheseUsers = await pg.one(\n    `select count(*) from private_user_messages\n            where channel_id = $1\n            and user_id = $2\n            and created_time > $3\n            `,\n    [channelId, creator.id, startOfDay]\n  )\n  log('previous messages this day', previousMessagesThisDayBetweenTheseUsers)\n  if (previousMessagesThisDayBetweenTheseUsers.count > 0) return\n\n  const lastUserEvent = await pg.oneOrNone(\n    `select coalesce(ts_to_millis(max(greatest(ucv.last_page_view_ts, ucv.last_promoted_view_ts, ucv.last_card_view_ts))),0) as ts\n     from user_contract_views ucv where ucv.user_id = $1`,\n    [otherUserId.user_id]\n  )\n  log('last user contract view for user ' + otherUserId.user_id, lastUserEvent)\n  if (lastUserEvent && lastUserEvent.ts > Date.now() - HOUR_MS) return\n\n  const otherUser = await getUser(otherUserId.user_id)\n  if (!otherUser) return\n  // We're only sending emails for users who have a lover profile\n  const hasLoverProfile = await pg.oneOrNone(\n    `select 1 from lovers where user_id = $1`,\n    [otherUserId.user_id]\n  )\n  await createNewMessageNotification(\n    creator,\n    otherUser,\n    channelId,\n    hasLoverProfile\n  )\n}\nconst createNewMessageNotification = async (\n  fromUser: User,\n  toUser: User,\n  channelId: number,\n  otherUserHasLoverProfile: boolean\n) => {\n  const privateUser = await getPrivateUser(toUser.id)\n  if (!privateUser) return\n  const reason = 'new_message'\n  const { sendToMobile, sendToEmail } = getNotificationDestinationsForUser(\n    privateUser,\n    reason\n  )\n  const sourceText = `${fromUser.name} sent you a message!`\n  const id = nanoid(6)\n  const notification: Notification = {\n    id,\n    userId: privateUser.id,\n    reason,\n    createdTime: Date.now(),\n    isSeen: false,\n    sourceId: channelId.toString(),\n    sourceType: reason,\n    sourceUpdateType: 'created',\n    sourceUserName: fromUser.name,\n    sourceUserUsername: fromUser.username,\n    sourceUserAvatarUrl: fromUser.avatarUrl,\n    sourceSlug: '/messages/' + channelId,\n    sourceText,\n  }\n\n  if (sendToMobile) {\n    await createPushNotifications([\n      [privateUser, notification, `${fromUser.name} messaged you`, sourceText],\n    ])\n  }\n  if (sendToEmail && otherUserHasLoverProfile) {\n    await sendNewMessageEmail(\n      reason,\n      privateUser,\n      fromUser,\n      toUser,\n      channelId,\n      sourceText\n    )\n  }\n}\n",
          "postContent": "import { Json } from 'common/supabase/schema'\nimport { SupabaseDirectClient } from 'shared/supabase/init'\nimport { ChatVisibility } from 'common/chat-message'\nimport { User } from 'common/user'\nimport { first } from 'lodash'\nimport { log } from 'shared/monitoring/log'\nimport { HOUR_MS } from 'common/util/time'\nimport { getPrivateUser, getUser } from 'shared/utils'\nimport { JSONContent } from '@tiptap/core'\nimport { APIError } from 'common/api/utils'\nimport { broadcast } from 'shared/websockets/server'\nimport { track } from 'shared/analytics'\nimport { getNotificationDestinationsForUser } from 'common/user-notification-preferences'\nimport { Notification } from 'common/notification'\nimport { createPushNotifications } from 'shared/create-push-notifications'\nimport * as dayjs from 'dayjs'\nimport * as utc from 'dayjs/plugin/utc'\nimport * as timezone from 'dayjs/plugin/timezone'\nimport { nanoid } from 'common/util/random'\ndayjs.extend(utc)\ndayjs.extend(timezone)\nexport const leaveChatContent = (userName: string) => ({\n  type: 'doc',\n  content: [\n    {\n      type: 'paragraph',\n      content: [{ text: `${userName} left the chat`, type: 'text' }],\n    },\n  ],\n})\nexport const joinChatContent = (userName: string) => {\n  return {\n    type: 'doc',\n    content: [\n      {\n        type: 'paragraph',\n        content: [{ text: `${userName} joined the chat!`, type: 'text' }],\n      },\n    ],\n  }\n}\n\nexport const insertPrivateMessage = async (\n  content: Json,\n  channelId: number,\n  userId: string,\n  visibility: ChatVisibility,\n  pg: SupabaseDirectClient\n) => {\n  const lastMessage = await pg.one(\n    `insert into private_user_messages (content, channel_id, user_id, visibility)\n    values ($1, $2, $3, $4) returning created_time`,\n    [content, channelId, userId, visibility]\n  )\n  await pg.none(\n    `update private_user_message_channels set last_updated_time = $1 where id = $2`,\n    [lastMessage.created_time, channelId]\n  )\n}\n\nexport const addUsersToPrivateMessageChannel = async (\n  userIds: string[],\n  channelId: number,\n  pg: SupabaseDirectClient\n) => {\n  await Promise.all(\n    userIds.map((id) =>\n      pg.none(\n        `insert into private_user_message_channel_members (channel_id, user_id, role, status)\n                values\n                ($1, $2, 'member', 'proposed')\n                on conflict do nothing\n              `,\n        [channelId, id]\n      )\n    )\n  )\n  await pg.none(\n    `update private_user_message_channels set last_updated_time = now() where id = $1`,\n    [channelId]\n  )\n}\n\nexport const createPrivateUserMessageMain = async (\n  creator: User,\n  channelId: number,\n  content: JSONContent,\n  pg: SupabaseDirectClient,\n  visibility: ChatVisibility\n) => {\n  // Normally, users can only submit messages to channels that they are members of\n  const authorized = await pg.oneOrNone(\n    `select 1\n       from private_user_message_channel_members\n       where channel_id = $1\n         and user_id = $2`,\n    [channelId, creator.id]\n  )\n  if (!authorized)\n    throw new APIError(403, 'You are not authorized to post to this channel')\n\n  await notifyOtherUserInChannelIfInactive(channelId, creator, pg)\n  await insertPrivateMessage(content, channelId, creator.id, visibility, pg)\n\n  const privateMessage = {\n    content: content as Json,\n    channel_id: channelId,\n    user_id: creator.id,\n  }\n\n  const otherUserIds = await pg.map<string>(\n    `select user_id from private_user_message_channel_members\n        where channel_id = $1 and user_id != $2\n        and status != 'left'\n        `,\n    [channelId, creator.id],\n    (r) => r.user_id\n  )\n  otherUserIds.concat(creator.id).forEach((otherUserId) => {\n    broadcast(`private-user-messages/${otherUserId}`, {})\n  })\n  let bothHaveLoverProfiles = false\n  const hasLoverProfile = await pg.oneOrNone(\n    'select 1 from lovers where user_id = $1',\n    [creator.id]\n  )\n  if (hasLoverProfile) {\n    const otherUserId = first(otherUserIds)\n\n    if (otherUserId && otherUserIds.length === 1) {\n      const otherHasLoverProfile = await pg.oneOrNone(\n        'select 1 from lovers where user_id = $1',\n        [otherUserId]\n      )\n      bothHaveLoverProfiles = !!otherHasLoverProfile\n    }\n  }\n\n  track(creator.id, 'send private message', {\n    channelId,\n    otherUserIds,\n    bothHaveLoverProfiles,\n  })\n\n  return { status: 'success', privateMessage }\n}\nconst notifyOtherUserInChannelIfInactive = async (\n  channelId: number,\n  creator: User,\n  pg: SupabaseDirectClient\n) => {\n  const otherUserIds = await pg.manyOrNone<{ user_id: string }>(\n    `select user_id from private_user_message_channel_members\n        where channel_id = $1 and user_id != $2\n        and status != 'left'\n        `,\n    [channelId, creator.id]\n  )\n  // We're only sending notifs for 1:1 channels\n  if (!otherUserIds || otherUserIds.length > 1) return\n\n  const otherUserId = first(otherUserIds)\n  if (!otherUserId) return\n\n  const startOfDay = dayjs()\n    .tz('America/Los_Angeles')\n    .startOf('day')\n    .toISOString()\n  const previousMessagesThisDayBetweenTheseUsers = await pg.one(\n    `select count(*) from private_user_messages\n            where channel_id = $1\n            and user_id = $2\n            and created_time > $3\n            `,\n    [channelId, creator.id, startOfDay]\n  )\n  log('previous messages this day', previousMessagesThisDayBetweenTheseUsers)\n  if (previousMessagesThisDayBetweenTheseUsers.count > 0) return\n\n  const lastUserEvent = await pg.oneOrNone(\n    `select coalesce(ts_to_millis(max(greatest(ucv.last_page_view_ts, ucv.last_promoted_view_ts, ucv.last_card_view_ts))),0) as ts\n     from user_contract_views ucv where ucv.user_id = $1`,\n    [otherUserId.user_id]\n  )\n  log('last user contract view for user ' + otherUserId.user_id, lastUserEvent)\n  if (lastUserEvent && lastUserEvent.ts > Date.now() - HOUR_MS) return\n\n  const otherUser = await getUser(otherUserId.user_id)\n  if (!otherUser) return\n\n  await createNewMessageNotification(creator, otherUser, channelId)\n}\nconst createNewMessageNotification = async (\n  fromUser: User,\n  toUser: User,\n  channelId: number\n) => {\n  const privateUser = await getPrivateUser(toUser.id)\n  if (!privateUser) return\n  const reason = 'new_message'\n  // TODO: send email\n  const { sendToMobile } = getNotificationDestinationsForUser(\n    privateUser,\n    reason\n  )\n  const sourceText = `${fromUser.name} sent you a message!`\n  const id = nanoid(6)\n  const notification: Notification = {\n    id,\n    userId: privateUser.id,\n    reason,\n    createdTime: Date.now(),\n    isSeen: false,\n    sourceId: channelId.toString(),\n    sourceType: reason,\n    sourceUpdateType: 'created',\n    sourceUserName: fromUser.name,\n    sourceUserUsername: fromUser.username,\n    sourceUserAvatarUrl: fromUser.avatarUrl,\n    sourceSlug: '/messages/' + channelId,\n    sourceText,\n  }\n\n  if (sendToMobile) {\n    await createPushNotifications([\n      [privateUser, notification, `${fromUser.name} messaged you`, sourceText],\n    ])\n  }\n}\n"
        },
        {
          "path": "backend/shared/src/utils.ts",
          "preContent": "import { generateJSON } from '@tiptap/html'\nimport { APIError, getCloudRunServiceUrl } from 'common/api/utils'\nimport {\n  Contract,\n  contractPath,\n  isSpecialLoveContract,\n  nativeContractColumnsArray,\n  MarketContract,\n} from 'common/contract'\nimport { PrivateUser } from 'common/user'\nimport { extensions } from 'common/util/parse'\nimport * as admin from 'firebase-admin'\nimport { first, uniq } from 'lodash'\nimport {\n  createSupabaseDirectClient,\n  SupabaseDirectClient,\n  SupabaseTransaction,\n} from 'shared/supabase/init'\nimport {\n  ENV_CONFIG,\n  GROUP_SLUGS_TO_IGNORE_IN_MARKETS_EMAIL,\n} from 'common/envs/constants'\nimport { convertPrivateUser, convertUser } from 'common/supabase/users'\nimport { convertAnswer, convertContract } from 'common/supabase/contracts'\nimport { Row, tsToMillis } from 'common/supabase/utils'\nimport { log } from 'shared/monitoring/log'\nimport { metrics } from 'shared/monitoring/metrics'\nimport { convertLiquidity } from 'common/supabase/liquidity'\nimport { ContractMetric } from 'common/contract-metric'\nexport { metrics }\nexport { log }\nimport * as dayjs from 'dayjs'\nimport * as utc from 'dayjs/plugin/utc'\nimport * as timezone from 'dayjs/plugin/timezone'\ndayjs.extend(utc)\ndayjs.extend(timezone)\n\nexport const logMemory = () => {\n  const used = process.memoryUsage()\n  for (const [k, v] of Object.entries(used)) {\n    log(`${k} ${Math.round((v / 1024 / 1024) * 100) / 100} MB`)\n  }\n}\n\nexport function htmlToRichText(html: string) {\n  return generateJSON(html, extensions)\n}\n\nexport const invokeFunction = async (name: string, body?: unknown) => {\n  const response = await fetch(getCloudRunServiceUrl(name), {\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    method: 'POST',\n    body: JSON.stringify(body ?? {}),\n  })\n\n  const json = await response.json()\n  if (response.ok) {\n    return json\n  } else {\n    throw new Error(\n      `${response.status} invoking ${name}: ${JSON.stringify(json)}`\n    )\n  }\n}\n\nexport const revalidateStaticProps = async (\n  // Path after domain: e.g. \"/JamesGrugett/will-pete-buttigieg-ever-be-us-pres\"\n  pathToRevalidate: string\n) => {\n  if (isProd()) {\n    const apiSecret = process.env.API_SECRET as string\n    if (!apiSecret)\n      throw new Error('Revalidation failed because of missing API_SECRET.')\n\n    const queryStr = `?pathToRevalidate=${pathToRevalidate}&apiSecret=${apiSecret}`\n    const resp = await fetch(\n      `https://${ENV_CONFIG.domain}/api/v0/revalidate` + queryStr\n    )\n\n    if (resp.ok) {\n      // metrics.inc('vercel/revalidations_succeeded', { path: pathToRevalidate })\n      log('Revalidated', pathToRevalidate)\n    } else {\n      // metrics.inc('vercel/revalidations_failed', { path: pathToRevalidate })\n      try {\n        const json = await resp.json()\n        log.error(\n          `HTTP ${\n            resp.status\n          } revalidating ${pathToRevalidate}: ${JSON.stringify(json)}`\n        )\n      } catch (e) {\n        const error = e as Error\n        log.error(`failed to parse response: ${error.message ?? error}`)\n        log.error(`HTTP ${resp.status} revalidating ${pathToRevalidate}`)\n      }\n    }\n  }\n}\n\nexport async function revalidateContractStaticProps(contract: Contract) {\n  await Promise.all([\n    revalidateStaticProps(contractPath(contract)),\n    revalidateStaticProps(`/embed${contractPath(contract)}`),\n  ])\n}\nexport const LOCAL_DEV = process.env.GOOGLE_CLOUD_PROJECT == null\n\n// TODO: deprecate in favor of common/src/envs/is-prod.ts\nexport const isProd = () => {\n  // ian: The first clause is for the API server, and the\n  // second clause is for local scripts and cloud functions\n  if (process.env.NEXT_PUBLIC_FIREBASE_ENV) {\n    return process.env.NEXT_PUBLIC_FIREBASE_ENV === 'PROD'\n  } else {\n    return admin.app().options.projectId === 'mantic-markets'\n  }\n}\n\nexport const contractColumnsToSelect = nativeContractColumnsArray.join(',')\nexport const prefixedContractColumnsToSelect = nativeContractColumnsArray\n  .map((col) => `c.${col}`)\n  .join(',')\nexport const contractColumnsToSelectWithPrefix = (prefix: string) =>\n  nativeContractColumnsArray.map((col) => `${prefix}.${col}`).join(',')\n\nexport const getContract = async (\n  pg: SupabaseDirectClient,\n  contractId: string\n) => {\n  const res = await pg.multi(\n    `select ${contractColumnsToSelect} from contracts where id = $1 limit 1;\n     select * from answers where contract_id = $1 order by index;`,\n    [contractId]\n  )\n  const contract = first(res[0].map(convertContract))\n  const answers = res[1].map(convertAnswer)\n  if (contract && 'answers' in contract) {\n    contract.answers = answers\n  }\n  return contract\n}\n\nexport const getContractAndMetricsAndLiquidities = async (\n  pg: SupabaseTransaction,\n  unresolvedContract: MarketContract,\n  answerId: string | undefined\n) => {\n  const { id: contractId, mechanism } = unresolvedContract\n  const isMulti = mechanism === 'cpmm-multi-1'\n  const sumsToOne = isMulti && unresolvedContract.shouldAnswersSumToOne\n  const metricsQuery = sumsToOne\n    ? `\n     select data from user_contract_metrics \n     where contract_id = $1 and\n     answer_id is not null`\n    : isMulti\n    ? `\n    select data from user_contract_metrics \n      where contract_id = $1\n      and (answer_id = $2 or (\n            -- Only get summary metric if they've bet on the answer\n            answer_id is null and\n            exists (\n              select 1 from user_contract_metrics ucm\n              where ucm.contract_id = $1\n              and ucm.answer_id = $2\n              )\n            )\n          )`\n    : `select data from user_contract_metrics where contract_id = $1`\n  // Filter out initial liquidity if set up with special liquidity per answer.\n  const filterAnte = isMulti && isSpecialLoveContract(unresolvedContract)\n  const results = await pg.multi(\n    `select ${contractColumnsToSelect} from contracts where id = $1;\n     select * from answers where contract_id = $1 order by index;\n     ${metricsQuery};\n     select * from contract_liquidity where contract_id = $1 ${\n       filterAnte ? `and data->>'answerId' = $2` : ''\n     };`,\n    [contractId, answerId]\n  )\n\n  const contract = first(results[0].map(convertContract)) as MarketContract\n  if (!contract) throw new APIError(404, 'Contract not found')\n  const answers = results[1].map(convertAnswer)\n  if ('answers' in contract) {\n    contract.answers = answers\n  }\n  // We don't get the summary metric, we recreate them from all the answer metrics\n  const contractMetrics = results[2].map((row) => row.data as ContractMetric)\n  const liquidities = results[3].map(convertLiquidity)\n\n  return { contract, contractMetrics, liquidities }\n}\n\nexport const getContractSupabase = async (contractId: string) => {\n  const pg = createSupabaseDirectClient()\n  return await getContract(pg, contractId)\n}\n\nexport const getContractFromSlugSupabase = async (contractSlug: string) => {\n  const pg = createSupabaseDirectClient()\n  const res = await pg.map(\n    `select ${contractColumnsToSelect} from contracts where slug = $1\n            limit 1`,\n    [contractSlug],\n    (row) => convertContract(row)\n  )\n  return first(res)\n}\n\nexport const getUser = async (\n  userId: string,\n  pg: SupabaseDirectClient = createSupabaseDirectClient()\n) => {\n  return await pg.oneOrNone(\n    `select * from users where id = $1 limit 1`,\n    [userId],\n    convertUser\n  )\n}\nexport const getUserAndPrivateUserOrThrow = async (\n  userId: string,\n  pg: SupabaseDirectClient = createSupabaseDirectClient()\n) => {\n  const rows = await pg.multi(\n    `select * from users where id = $1 limit 1;\n           select * from private_users where id = $1 limit 1;`,\n    [userId]\n  )\n  const userRow = rows[0][0] as Row<'users'> | null\n  const privateUserRow = rows[1][0] as Row<'private_users'> | null\n\n  if (!userRow || !privateUserRow) {\n    throw new APIError(404, 'User or private user not found.')\n  }\n\n  return {\n    user: convertUser(userRow),\n    privateUser: convertPrivateUser(privateUserRow),\n  }\n}\n\nexport const getUsers = async (\n  userIds: string[],\n  pg: SupabaseDirectClient = createSupabaseDirectClient()\n) => {\n  const res = await pg.map(\n    `select * from users where id = any($1)`,\n    [uniq(userIds)],\n    (row) => convertUser(row)\n  )\n  return res\n}\n\nexport const getPrivateUser = async (\n  userId: string,\n  pg: SupabaseDirectClient = createSupabaseDirectClient()\n) => {\n  return await pg.oneOrNone(\n    `select * from private_users where id = $1 limit 1`,\n    [userId],\n    convertPrivateUser\n  )\n}\nexport const getPrivateUserSupabase = (userId: string) => {\n  const pg = createSupabaseDirectClient()\n\n  return pg.oneOrNone(\n    `select data from private_users where id = $1`,\n    [userId],\n    (row) => (row ? (row.data as PrivateUser) : null)\n  )\n}\n\nexport const getPrivateUserByKey = async (\n  apiKey: string,\n  pg: SupabaseDirectClient = createSupabaseDirectClient()\n) => {\n  return await pg.oneOrNone(\n    `select * from private_users where data->>'apiKey' = $1 limit 1`,\n    [apiKey],\n    convertPrivateUser\n  )\n}\n\nexport const getPrivateUsersNotSent = async (\n  preference: 'trending_markets' | 'profit_loss_updates',\n  limit: number,\n  pg: SupabaseDirectClient\n) => {\n  return await pg.map(\n    `select pu.data, u.name,\n       u.created_time,\n       coalesce(((u.data->'creatorTraders'->>'weekly')::bigint),0) as weekly_traders,\n       coalesce(((u.data->>'currentBettingStreak')::bigint),0) as current_betting_streak\n         from private_users pu\n         join users u on pu.id = u.id\n         where (pu.data->'notificationPreferences'->>'${preference}')::jsonb @> '[\"email\"]'\n         and ${\n           preference === 'trending_markets'\n             ? 'weekly_trending_email_sent'\n             : 'weekly_portfolio_email_sent'\n         } = false\n         and (pu.data->'notificationPreferences'->>'opt_out_all')::jsonb <> '[\"email\"]'\n         and pu.data->>'email' is not null\n         limit $1`,\n    [limit],\n    (row) => ({\n      ...(row.data as PrivateUser),\n      createdTime: tsToMillis(row.created_time as string),\n      name: row.name as string,\n      weeklyTraders: row.weekly_traders as number,\n      currentBettingStreak: row.current_betting_streak as number,\n    })\n  )\n}\n\nexport const getUserByUsername = async (\n  username: string,\n  pg: SupabaseDirectClient = createSupabaseDirectClient()\n) => {\n  const res = await pg.oneOrNone<Row<'users'>>(\n    `select * from users where username = $1`,\n    username\n  )\n  return res ? convertUser(res) : null\n}\n\nexport function contractUrl(contract: Contract) {\n  return `https://manifold.markets${contractPath(contract)}`\n}\n\nexport async function getTrendingContractsToEmail() {\n  const pg = createSupabaseDirectClient()\n  return await pg.map(\n    `select data from contracts\n            where resolution_time is null\n              and visibility = 'public'\n              and not (group_slugs && $1)\n              and question not ilike '%stock%'\n              and question not ilike '%permanent%'\n              and ((close_time > current_date + interval '1 day') or close_time is null)\n              order by importance_score desc limit 25;`,\n    [GROUP_SLUGS_TO_IGNORE_IN_MARKETS_EMAIL],\n    (r) => r.data as Contract\n  )\n}\n\nexport const getBettingStreakResetTimeBeforeNow = () => {\n  // Get current time in Pacific\n  const now = dayjs().tz('America/Los_Angeles')\n\n  // Get today's reset time (midnight Pacific)\n  const todayResetTime = now.startOf('day')\n\n  // Get yesterday's reset time\n  const yesterdayResetTime = todayResetTime.subtract(1, 'day')\n\n  // Use yesterday's reset time if we haven't hit today's yet\n  const resetTime = (\n    now.isBefore(todayResetTime) ? yesterdayResetTime : todayResetTime\n  ).valueOf()\n  log('betting streak reset time', resetTime)\n  return resetTime\n}\n",
          "postContent": "import { generateJSON } from '@tiptap/html'\nimport { APIError, getCloudRunServiceUrl } from 'common/api/utils'\nimport {\n  Contract,\n  contractPath,\n  nativeContractColumnsArray,\n  MarketContract,\n} from 'common/contract'\nimport { PrivateUser } from 'common/user'\nimport { extensions } from 'common/util/parse'\nimport * as admin from 'firebase-admin'\nimport { first, uniq } from 'lodash'\nimport {\n  createSupabaseDirectClient,\n  SupabaseDirectClient,\n  SupabaseTransaction,\n} from 'shared/supabase/init'\nimport {\n  ENV_CONFIG,\n  GROUP_SLUGS_TO_IGNORE_IN_MARKETS_EMAIL,\n} from 'common/envs/constants'\nimport { convertPrivateUser, convertUser } from 'common/supabase/users'\nimport { convertAnswer, convertContract } from 'common/supabase/contracts'\nimport { Row, tsToMillis } from 'common/supabase/utils'\nimport { log } from 'shared/monitoring/log'\nimport { metrics } from 'shared/monitoring/metrics'\nimport { convertLiquidity } from 'common/supabase/liquidity'\nimport { ContractMetric } from 'common/contract-metric'\nexport { metrics }\nexport { log }\nimport * as dayjs from 'dayjs'\nimport * as utc from 'dayjs/plugin/utc'\nimport * as timezone from 'dayjs/plugin/timezone'\ndayjs.extend(utc)\ndayjs.extend(timezone)\n\nexport const logMemory = () => {\n  const used = process.memoryUsage()\n  for (const [k, v] of Object.entries(used)) {\n    log(`${k} ${Math.round((v / 1024 / 1024) * 100) / 100} MB`)\n  }\n}\n\nexport function htmlToRichText(html: string) {\n  return generateJSON(html, extensions)\n}\n\nexport const invokeFunction = async (name: string, body?: unknown) => {\n  const response = await fetch(getCloudRunServiceUrl(name), {\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    method: 'POST',\n    body: JSON.stringify(body ?? {}),\n  })\n\n  const json = await response.json()\n  if (response.ok) {\n    return json\n  } else {\n    throw new Error(\n      `${response.status} invoking ${name}: ${JSON.stringify(json)}`\n    )\n  }\n}\n\nexport const revalidateStaticProps = async (\n  // Path after domain: e.g. \"/JamesGrugett/will-pete-buttigieg-ever-be-us-pres\"\n  pathToRevalidate: string\n) => {\n  if (isProd()) {\n    const apiSecret = process.env.API_SECRET as string\n    if (!apiSecret)\n      throw new Error('Revalidation failed because of missing API_SECRET.')\n\n    const queryStr = `?pathToRevalidate=${pathToRevalidate}&apiSecret=${apiSecret}`\n    const resp = await fetch(\n      `https://${ENV_CONFIG.domain}/api/v0/revalidate` + queryStr\n    )\n\n    if (resp.ok) {\n      // metrics.inc('vercel/revalidations_succeeded', { path: pathToRevalidate })\n      log('Revalidated', pathToRevalidate)\n    } else {\n      // metrics.inc('vercel/revalidations_failed', { path: pathToRevalidate })\n      try {\n        const json = await resp.json()\n        log.error(\n          `HTTP ${\n            resp.status\n          } revalidating ${pathToRevalidate}: ${JSON.stringify(json)}`\n        )\n      } catch (e) {\n        const error = e as Error\n        log.error(`failed to parse response: ${error.message ?? error}`)\n        log.error(`HTTP ${resp.status} revalidating ${pathToRevalidate}`)\n      }\n    }\n  }\n}\n\nexport async function revalidateContractStaticProps(contract: Contract) {\n  await Promise.all([\n    revalidateStaticProps(contractPath(contract)),\n    revalidateStaticProps(`/embed${contractPath(contract)}`),\n  ])\n}\nexport const LOCAL_DEV = process.env.GOOGLE_CLOUD_PROJECT == null\n\n// TODO: deprecate in favor of common/src/envs/is-prod.ts\nexport const isProd = () => {\n  // ian: The first clause is for the API server, and the\n  // second clause is for local scripts and cloud functions\n  if (process.env.NEXT_PUBLIC_FIREBASE_ENV) {\n    return process.env.NEXT_PUBLIC_FIREBASE_ENV === 'PROD'\n  } else {\n    return admin.app().options.projectId === 'mantic-markets'\n  }\n}\n\nexport const contractColumnsToSelect = nativeContractColumnsArray.join(',')\nexport const prefixedContractColumnsToSelect = nativeContractColumnsArray\n  .map((col) => `c.${col}`)\n  .join(',')\nexport const contractColumnsToSelectWithPrefix = (prefix: string) =>\n  nativeContractColumnsArray.map((col) => `${prefix}.${col}`).join(',')\n\nexport const getContract = async (\n  pg: SupabaseDirectClient,\n  contractId: string\n) => {\n  const res = await pg.multi(\n    `select ${contractColumnsToSelect} from contracts where id = $1 limit 1;\n     select * from answers where contract_id = $1 order by index;`,\n    [contractId]\n  )\n  const contract = first(res[0].map(convertContract))\n  const answers = res[1].map(convertAnswer)\n  if (contract && 'answers' in contract) {\n    contract.answers = answers\n  }\n  return contract\n}\n\nexport const getContractAndMetricsAndLiquidities = async (\n  pg: SupabaseTransaction,\n  unresolvedContract: MarketContract,\n) => {\n  const { id: contractId, mechanism } = unresolvedContract\n  const isMulti = mechanism === 'cpmm-multi-1'\n  const sumsToOne = isMulti && unresolvedContract.shouldAnswersSumToOne\n  const metricsQuery = sumsToOne\n    ? `\n     select data from user_contract_metrics\n     where contract_id = $1 and\n     answer_id is not null`\n    : isMulti\n    ? `\n    select data from user_contract_metrics\n      where contract_id = $1\n      and (answer_id = $2 or (\n            -- Only get summary metric if they've bet on the answer\n            answer_id is null and\n            exists (\n              select 1 from user_contract_metrics ucm\n              where ucm.contract_id = $1\n              and ucm.answer_id = $2\n              )\n            )\n          )`\n    : `select data from user_contract_metrics where contract_id = $1`\n\n  const results = await pg.multi(\n    `select ${contractColumnsToSelect} from contracts where id = $1;\n     select * from answers where contract_id = $1 order by index;\n     ${metricsQuery};\n     select * from contract_liquidity where contract_id = $1`,\n    [contractId]\n  )\n\n  const contract = first(results[0].map(convertContract)) as MarketContract\n  if (!contract) throw new APIError(404, 'Contract not found')\n  const answers = results[1].map(convertAnswer)\n  if ('answers' in contract) {\n    contract.answers = answers\n  }\n  // We don't get the summary metric, we recreate them from all the answer metrics\n  const contractMetrics = results[2].map((row) => row.data as ContractMetric)\n  const liquidities = results[3].map(convertLiquidity)\n\n  return { contract, contractMetrics, liquidities }\n}\n\nexport const getContractSupabase = async (contractId: string) => {\n  const pg = createSupabaseDirectClient()\n  return await getContract(pg, contractId)\n}\n\nexport const getContractFromSlugSupabase = async (contractSlug: string) => {\n  const pg = createSupabaseDirectClient()\n  const res = await pg.map(\n    `select ${contractColumnsToSelect} from contracts where slug = $1\n            limit 1`,\n    [contractSlug],\n    (row) => convertContract(row)\n  )\n  return first(res)\n}\n\nexport const getUser = async (\n  userId: string,\n  pg: SupabaseDirectClient = createSupabaseDirectClient()\n) => {\n  return await pg.oneOrNone(\n    `select * from users where id = $1 limit 1`,\n    [userId],\n    convertUser\n  )\n}\nexport const getUserAndPrivateUserOrThrow = async (\n  userId: string,\n  pg: SupabaseDirectClient = createSupabaseDirectClient()\n) => {\n  const rows = await pg.multi(\n    `select * from users where id = $1 limit 1;\n           select * from private_users where id = $1 limit 1;`,\n    [userId]\n  )\n  const userRow = rows[0][0] as Row<'users'> | null\n  const privateUserRow = rows[1][0] as Row<'private_users'> | null\n\n  if (!userRow || !privateUserRow) {\n    throw new APIError(404, 'User or private user not found.')\n  }\n\n  return {\n    user: convertUser(userRow),\n    privateUser: convertPrivateUser(privateUserRow),\n  }\n}\n\nexport const getUsers = async (\n  userIds: string[],\n  pg: SupabaseDirectClient = createSupabaseDirectClient()\n) => {\n  const res = await pg.map(\n    `select * from users where id = any($1)`,\n    [uniq(userIds)],\n    (row) => convertUser(row)\n  )\n  return res\n}\n\nexport const getPrivateUser = async (\n  userId: string,\n  pg: SupabaseDirectClient = createSupabaseDirectClient()\n) => {\n  return await pg.oneOrNone(\n    `select * from private_users where id = $1 limit 1`,\n    [userId],\n    convertPrivateUser\n  )\n}\nexport const getPrivateUserSupabase = (userId: string) => {\n  const pg = createSupabaseDirectClient()\n\n  return pg.oneOrNone(\n    `select data from private_users where id = $1`,\n    [userId],\n    (row) => (row ? (row.data as PrivateUser) : null)\n  )\n}\n\nexport const getPrivateUserByKey = async (\n  apiKey: string,\n  pg: SupabaseDirectClient = createSupabaseDirectClient()\n) => {\n  return await pg.oneOrNone(\n    `select * from private_users where data->>'apiKey' = $1 limit 1`,\n    [apiKey],\n    convertPrivateUser\n  )\n}\n\nexport const getPrivateUsersNotSent = async (\n  preference: 'trending_markets' | 'profit_loss_updates',\n  limit: number,\n  pg: SupabaseDirectClient\n) => {\n  return await pg.map(\n    `select pu.data, u.name,\n       u.created_time,\n       coalesce(((u.data->'creatorTraders'->>'weekly')::bigint),0) as weekly_traders,\n       coalesce(((u.data->>'currentBettingStreak')::bigint),0) as current_betting_streak\n         from private_users pu\n         join users u on pu.id = u.id\n         where (pu.data->'notificationPreferences'->>'${preference}')::jsonb @> '[\"email\"]'\n         and ${\n           preference === 'trending_markets'\n             ? 'weekly_trending_email_sent'\n             : 'weekly_portfolio_email_sent'\n         } = false\n         and (pu.data->'notificationPreferences'->>'opt_out_all')::jsonb <> '[\"email\"]'\n         and pu.data->>'email' is not null\n         limit $1`,\n    [limit],\n    (row) => ({\n      ...(row.data as PrivateUser),\n      createdTime: tsToMillis(row.created_time as string),\n      name: row.name as string,\n      weeklyTraders: row.weekly_traders as number,\n      currentBettingStreak: row.current_betting_streak as number,\n    })\n  )\n}\n\nexport const getUserByUsername = async (\n  username: string,\n  pg: SupabaseDirectClient = createSupabaseDirectClient()\n) => {\n  const res = await pg.oneOrNone<Row<'users'>>(\n    `select * from users where username = $1`,\n    username\n  )\n  return res ? convertUser(res) : null\n}\n\nexport function contractUrl(contract: Contract) {\n  return `https://manifold.markets${contractPath(contract)}`\n}\n\nexport async function getTrendingContractsToEmail() {\n  const pg = createSupabaseDirectClient()\n  return await pg.map(\n    `select data from contracts\n            where resolution_time is null\n              and visibility = 'public'\n              and not (group_slugs && $1)\n              and question not ilike '%stock%'\n              and question not ilike '%permanent%'\n              and ((close_time > current_date + interval '1 day') or close_time is null)\n              order by importance_score desc limit 25;`,\n    [GROUP_SLUGS_TO_IGNORE_IN_MARKETS_EMAIL],\n    (r) => r.data as Contract\n  )\n}\n\nexport const getBettingStreakResetTimeBeforeNow = () => {\n  // Get current time in Pacific\n  const now = dayjs().tz('America/Los_Angeles')\n\n  // Get today's reset time (midnight Pacific)\n  const todayResetTime = now.startOf('day')\n\n  // Get yesterday's reset time\n  const yesterdayResetTime = todayResetTime.subtract(1, 'day')\n\n  // Use yesterday's reset time if we haven't hit today's yet\n  const resetTime = (\n    now.isBefore(todayResetTime) ? yesterdayResetTime : todayResetTime\n  ).valueOf()\n  log('betting streak reset time', resetTime)\n  return resetTime\n}\n"
        },
        {
          "path": "common/src/api/love-types.ts",
          "preContent": "export type LikeData = {\n  user_id: string\n  created_time: number\n}\nexport type ShipData = {\n  creator_id: string\n  target1_id: string\n  target2_id: string\n  target_id: string\n  created_time: number\n}\n",
          "postContent": "[DELETED]"
        },
        {
          "path": "common/src/api/schema.ts",
          "preContent": "import { z } from 'zod'\nimport {\n  Group,\n  MAX_ID_LENGTH,\n  MySearchGroupShape,\n  LiteGroup,\n  SearchGroupParams,\n  SearchGroupShape,\n  Topic,\n} from 'common/group'\nimport {\n  createMarketProps,\n  resolveMarketProps,\n  type LiteMarket,\n  FullMarket,\n  updateMarketProps,\n} from './market-types'\nimport { type Answer } from 'common/answer'\nimport {\n  Comment,\n  CommentWithTotalReplies,\n  MAX_COMMENT_LENGTH,\n  PostComment,\n  type ContractComment,\n} from 'common/comment'\nimport { CandidateBet } from 'common/new-bet'\nimport type { Bet, LimitBet } from 'common/bet'\nimport { coerceBoolean, contentSchema } from 'common/api/zod-types'\nimport { Lover } from 'common/love/lover'\nimport { AIGeneratedMarket, Contract, MarketContract } from 'common/contract'\nimport { CompatibilityScore } from 'common/love/compatibility-score'\nimport type { Txn, ManaPayTxn } from 'common/txn'\nimport { LiquidityProvision } from 'common/liquidity-provision'\nimport { DisplayUser, FullUser } from './user-types'\nimport { League } from 'common/leagues'\nimport { searchProps } from './market-search-types'\nimport { MAX_ANSWER_LENGTH } from 'common/answer'\nimport { type LinkPreview } from 'common/link-preview'\nimport { Headline } from 'common/news'\nimport { Row } from 'common/supabase/utils'\nimport { LikeData, ShipData } from './love-types'\nimport { AnyBalanceChangeType } from 'common/balance-change'\nimport { Dashboard } from 'common/dashboard'\nimport { ChatMessage, PrivateChatMessage } from 'common/chat-message'\nimport { PrivateUser, User } from '../user'\nimport { ManaSupply } from 'common/stats'\nimport { Repost } from 'common/repost'\nimport { PERIODS } from 'common/period'\nimport { SWEEPS_MIN_BET } from 'common/economy'\nimport {\n  LivePortfolioMetrics,\n  PortfolioMetrics,\n} from 'common/portfolio-metrics'\nimport { ModReport } from '../mod-report'\n\nimport { RegistrationReturnType } from 'common/reason-codes'\nimport {\n  CheckoutSession,\n  GIDXDocument,\n  GPSProps,\n  PaymentDetail,\n  checkoutParams,\n  verificationParams,\n  cashoutRequestParams,\n  PendingCashoutStatusData,\n  cashoutParams,\n} from 'common/gidx/gidx'\nimport { notification_preference } from 'common/user-notification-preferences'\nimport { PrivateMessageChannel } from 'common/supabase/private-messages'\nimport { Notification } from 'common/notification'\nimport { NON_POINTS_BETS_LIMIT } from 'common/supabase/bets'\nimport { ContractMetric } from 'common/contract-metric'\n\nimport { JSONContent } from '@tiptap/core'\nimport { Task, TaskCategory } from 'common/todo'\nimport { ChartAnnotation } from 'common/supabase/chart-annotations'\nimport { Dictionary } from 'lodash'\nimport { Reaction } from 'common/reaction'\nimport { YEAR_MS } from 'common/util/time'\nimport { MarketDraft } from 'common/drafts'\nimport { TopLevelPost } from 'common/top-level-post'\n// mqp: very unscientific, just balancing our willingness to accept load\n// with user willingness to put up with stale data\nexport const DEFAULT_CACHE_STRATEGY =\n  'public, max-age=5, stale-while-revalidate=10'\nconst MAX_EXPIRES_AT = 1_000 * YEAR_MS\n\ntype APIGenericSchema = {\n  // GET is for retrieval, POST is to mutate something, PUT is idempotent mutation (can be repeated safely)\n  method: 'GET' | 'POST' | 'PUT'\n  //private APIs can only be called from manifold. undocumented endpoints can change or be deleted at any time!\n  visibility: 'public' | 'undocumented' | 'private'\n  // whether the endpoint requires authentication\n  authed: boolean\n  // zod schema for the request body (or for params for GET requests)\n  props: z.ZodType\n  // note this has to be JSON serializable\n  returns?: Record<string, any>\n  // Cache-Control header. like, 'max-age=60'\n  cache?: string\n  // whether the endpoint should prefer authentication even if not required\n  preferAuth?: boolean\n}\n\nlet _apiTypeCheck: { [x: string]: APIGenericSchema }\nexport const API = (_apiTypeCheck = {\n  'refresh-all-clients': {\n    method: 'POST',\n    visibility: 'public',\n    props: z.object({ message: z.string().optional() }),\n    authed: true,\n  },\n  'toggle-system-trading-status': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        token: z.enum(['MANA', 'CASH']),\n      })\n      .strict(),\n    returns: {} as { status: boolean },\n  },\n  comment: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as ContractComment,\n    props: z\n      .object({\n        contractId: z.string(),\n        content: contentSchema.optional(),\n        html: z.string().optional(),\n        markdown: z.string().optional(),\n        replyToCommentId: z.string().optional(),\n        replyToAnswerId: z.string().optional(),\n        replyToBetId: z.string().optional(),\n      })\n      .strict(),\n  },\n\n  'follow-contract': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: true },\n    props: z\n      .object({\n        contractId: z.string(),\n        follow: z.boolean(),\n      })\n      .strict(),\n  },\n  'get-contract': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as Contract,\n    props: z\n      .object({\n        contractId: z.string(),\n      })\n      .strict(),\n  },\n  'answer/:answerId': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as Answer,\n    props: z.object({ answerId: z.string() }).strict(),\n  },\n  'market/:contractId/answers': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: [] as Answer[],\n    props: z.object({ contractId: z.string() }).strict(),\n  },\n  'hide-comment': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ commentPath: z.string() }).strict(),\n  },\n  'pin-comment': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({ commentPath: z.string() }).strict(),\n  },\n  comments: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    // cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as ContractComment[],\n    props: z\n      .object({\n        contractId: z.string().optional(),\n        contractSlug: z.string().optional(),\n        afterTime: z.coerce.number().optional(),\n        limit: z.coerce.number().gte(0).lte(1000).default(1000),\n        page: z.coerce.number().gte(0).default(0),\n        userId: z.string().optional(),\n        isPolitics: coerceBoolean.optional(),\n      })\n      .strict(),\n  },\n  'user-comments': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: [] as Comment[],\n    props: z\n      .object({\n        afterTime: z.coerce.number().optional(),\n        limit: z.coerce.number().gte(0).lte(1000).default(1000),\n        page: z.coerce.number().gte(0).default(0),\n        userId: z.string(),\n      })\n      .strict(),\n  },\n  bet: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as CandidateBet & { betId: string },\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gte(SWEEPS_MIN_BET),\n        replyToCommentId: z.string().optional(),\n        limitProb: z.number().gte(0.01).lte(0.99).optional(),\n        expiresMillisAfter: z.number().lt(MAX_EXPIRES_AT).optional(),\n        silent: z.boolean().optional(),\n        expiresAt: z.number().lt(MAX_EXPIRES_AT).optional(),\n        // Used for binary and new multiple choice contracts (cpmm-multi-1).\n        outcome: z.enum(['YES', 'NO']).default('YES'),\n        //Multi\n        answerId: z.string().optional(),\n        dryRun: z.boolean().optional(),\n        deps: z.array(z.string()).optional(),\n        deterministic: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  createuser: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { user: User; privateUser: PrivateUser },\n    props: z\n      .object({\n        deviceToken: z.string().optional(),\n        adminToken: z.string().optional(),\n        visitedContractIds: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'multi-bet': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as (CandidateBet & { betId: string })[],\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gte(1),\n        limitProb: z.number().gte(0).lte(1).optional(),\n        expiresAt: z.number().lt(MAX_EXPIRES_AT).optional(),\n        answerIds: z.array(z.string()).min(1),\n        deterministic: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  'multi-sell': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as (CandidateBet & { betId: string })[],\n    props: z\n      .object({\n        contractId: z.string(),\n        answerIds: z.array(z.string()).min(1),\n        deterministic: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  leaderboard: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as { userId: string; score: number }[],\n    props: z\n      .object({\n        groupId: z.string().optional(),\n        limit: z.coerce.number().min(1).max(100).default(50),\n        token: z.enum(['MANA', 'CASH']).default('MANA'),\n        kind: z.enum(['creator', 'profit', 'loss', 'volume', 'referral']),\n      })\n      .strict(),\n  },\n  'verify-phone-number': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { status: string },\n    props: z\n      .object({\n        phoneNumber: z.string(),\n        code: z.string(),\n      })\n      .strict(),\n  },\n  'request-otp': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { status: string },\n    props: z\n      .object({\n        phoneNumber: z.string(),\n      })\n      .strict(),\n  },\n  'bet/cancel/:betId': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ betId: z.string() }).strict(),\n    returns: {} as LimitBet,\n  },\n  // sell shares\n  'market/:contractId/sell': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as CandidateBet & { betId: string },\n    props: z\n      .object({\n        contractId: z.string(),\n        shares: z.number().positive().optional(), // leave it out to sell all shares\n        outcome: z.enum(['YES', 'NO']),\n        answerId: z.string().optional(), // Required for multi binary markets\n        deterministic: z.boolean().optional(),\n        deps: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'get-user-limit-orders-with-contracts': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as {\n      bets: LimitBet[]\n      contracts: MarketContract[]\n    },\n    props: z\n      .object({\n        userId: z.string(),\n        count: z.coerce.number().lte(5000),\n        includeExpired: coerceBoolean.optional().default(false),\n        includeCancelled: coerceBoolean.optional().default(false),\n        includeFilled: coerceBoolean.optional().default(false),\n      })\n      .strict(),\n  },\n  'get-interesting-groups-from-views': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as (Group & { hasBet: boolean })[],\n    props: z\n      .object({\n        userId: z.string(),\n        contractIds: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  bets: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Bet[],\n    props: z\n      .object({\n        id: z.string().optional(),\n        userId: z.string().optional(),\n        username: z.string().optional(),\n        contractId: z.string().or(z.array(z.string())).optional(),\n        contractSlug: z.string().optional(),\n        answerId: z.string().optional(),\n        // market: z.string().optional(), // deprecated, synonym for `contractSlug`\n        limit: z.coerce\n          .number()\n          .gte(0)\n          .lte(50000)\n          .default(NON_POINTS_BETS_LIMIT),\n        before: z.string().optional(),\n        after: z.string().optional(),\n        beforeTime: z.coerce.number().optional(),\n        afterTime: z.coerce.number().optional(),\n        order: z.enum(['asc', 'desc']).optional(),\n        kinds: z.enum(['open-limit']).optional(),\n        // undocumented fields. idk what a good api interface would be\n        filterRedemptions: coerceBoolean.optional(),\n        includeZeroShareRedemptions: coerceBoolean.optional(),\n        commentRepliesOnly: coerceBoolean.optional(),\n        count: coerceBoolean.optional(),\n        points: coerceBoolean.optional(),\n      })\n      .strict(),\n  },\n  'bet-points': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: 'public, max-age=600, stale-while-revalidate=60',\n    returns: [] as Bet[],\n    props: z\n      .object({\n        contractId: z.string(),\n        answerId: z.string().optional(),\n        limit: z.coerce.number().gte(0).lte(50000).default(5000),\n        beforeTime: z.coerce.number(),\n        afterTime: z.coerce.number(),\n        filterRedemptions: coerceBoolean.optional(),\n        includeZeroShareRedemptions: coerceBoolean.optional(),\n      })\n      .strict(),\n  },\n  'unique-bet-group-count': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as { count: number },\n    props: z\n      .object({\n        contractId: z.string(),\n      })\n      .strict(),\n  },\n  'get-daily-changed-metrics-and-contracts': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    cache: 'public, max-age=900, stale-while-revalidate=90', // 15 minute cache\n    props: z\n      .object({\n        limit: z.coerce.number(),\n        userId: z.string(),\n        balance: z.coerce.number(),\n      })\n      .strict(),\n    returns: {} as {\n      manaMetrics: ContractMetric[]\n      contracts: MarketContract[]\n      manaProfit: number\n      manaInvestmentValue: number\n      balance: number\n    },\n  },\n  // deprecated. use /bets?username= instead\n  'user/:username/bets': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Bet[],\n    props: z\n      .object({\n        username: z.string(),\n        limit: z.coerce.number().gte(0).lte(1000).default(1000),\n      })\n      .strict(),\n  },\n  'group/:slug': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as Group,\n    props: z.object({ slug: z.string() }),\n  },\n  'group/:slug/groups': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as { above: LiteGroup[]; below: LiteGroup[] },\n    props: z.object({ slug: z.string() }).strict(),\n  },\n  'group/:slug/dashboards': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as {\n      id: string\n      title: string\n      slug: string\n      creatorId: string\n    }[],\n    props: z.object({ slug: z.string() }).strict(),\n  },\n  'group/by-id/:id/groups': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as { above: LiteGroup[]; below: LiteGroup[] },\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'group/by-id/:id': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as Group,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  // deprecated. use /markets?groupId= instead\n  'group/by-id/:id/markets': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as LiteMarket[],\n    props: z\n      .object({\n        id: z.string(),\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n      })\n      .strict(),\n  },\n  'group/:slug/delete': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ slug: z.string() }),\n  },\n  'group/by-id/:id/delete': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ id: z.string() }),\n  },\n  'group/:slug/block': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ slug: z.string() }),\n  },\n  'group/:slug/unblock': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ slug: z.string() }).strict(),\n  },\n  'group/by-id/:topId/group/:bottomId': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        topId: z.string(),\n        bottomId: z.string(),\n        remove: z.boolean().optional(),\n      })\n      .strict(),\n    returns: {} as { status: 'success' },\n  },\n  groups: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Group[],\n    props: z\n      .object({\n        availableToUserId: z.string().optional(),\n        beforeTime: z.coerce.number().int().optional(),\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n      })\n      .strict(),\n  },\n  'market/:id': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as LiteMarket | FullMarket,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z.object({ id: z.string(), lite: coerceBoolean.optional() }),\n  },\n  'market/:id/prob': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as {\n      prob?: number\n      answerProbs?: { [answerId: string]: number }\n    },\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'market-probs': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as {\n      [contractId: string]: {\n        prob?: number\n        answerProbs?: { [answerId: string]: number }\n      }\n    },\n    props: z\n      .object({\n        ids: z.array(z.string()).max(100),\n      })\n      .strict(),\n  },\n  'markets-by-ids': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: [] as Contract[],\n    props: z\n      .object({\n        ids: z.array(z.string()).max(100),\n      })\n      .strict(),\n  },\n  // deprecated. use /market/:id?lite=true instead\n  'market/:id/lite': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as LiteMarket,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z.object({ id: z.string() }),\n  },\n  'slug/:slug': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as LiteMarket | FullMarket,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z.object({ slug: z.string(), lite: coerceBoolean.optional() }),\n  },\n  market: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as LiteMarket,\n    props: createMarketProps,\n  },\n  'market/:contractId/update': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: updateMarketProps,\n    returns: {} as { success: true },\n  },\n  'market/:contractId/close': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    // returns: {} as LiteMarket,\n    props: z\n      .object({\n        contractId: z.string(),\n        closeTime: z.number().int().nonnegative().optional(),\n      })\n      .strict(),\n  },\n  'market/:contractId/resolve': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { message: string },\n    props: resolveMarketProps,\n  },\n  'market/:contractId/add-liquidity': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as LiquidityProvision,\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gt(0).finite(),\n      })\n      .strict(),\n  },\n  'market/:contractId/remove-liquidity': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as LiquidityProvision,\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gt(0).finite(),\n      })\n      .strict(),\n  },\n  'market/:contractId/add-bounty': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as Txn,\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gt(0).finite(),\n      })\n      .strict(),\n  },\n  'market/:contractId/award-bounty': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as Txn,\n    props: z\n      .object({\n        contractId: z.string(),\n        commentId: z.string(),\n        amount: z.number().gt(0).finite(),\n      })\n      .strict(),\n  },\n  'market/:contractId/group': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        contractId: z.string(),\n        groupId: z.string(),\n        remove: z.boolean().default(false),\n      })\n      .strict(),\n    returns: {} as { success: true },\n  },\n  'market/:contractId/groups': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({ contractId: z.string() }),\n    returns: [] as LiteGroup[],\n  },\n  'market/:contractId/answer': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { newAnswerId: string },\n    props: z\n      .object({\n        contractId: z.string().max(MAX_ANSWER_LENGTH),\n        text: z.string().min(1).max(MAX_ANSWER_LENGTH),\n      })\n      .strict(),\n  },\n  'market/:contractId/block': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ contractId: z.string() }).strict(),\n  },\n  'market/:contractId/unblock': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ contractId: z.string() }).strict(),\n  },\n  unresolve: {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { success: true },\n    props: z\n      .object({\n        contractId: z.string().max(MAX_ANSWER_LENGTH),\n        answerId: z.string().max(MAX_ANSWER_LENGTH).optional(),\n      })\n      .strict(),\n  },\n  leagues: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as League[],\n    props: z\n      .object({\n        userId: z.string().optional(),\n        cohort: z.string().optional(),\n        season: z.coerce.number().optional(),\n      })\n      .strict(),\n  },\n  markets: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as LiteMarket[],\n    props: z\n      .object({\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n        sort: z\n          .enum([\n            'created-time',\n            'updated-time',\n            'last-bet-time',\n            'last-comment-time',\n          ])\n          .optional(),\n        order: z.enum(['asc', 'desc']).optional(),\n        before: z.string().optional(),\n        userId: z.string().optional(),\n        groupId: z.string().optional(),\n      })\n      .strict(),\n  },\n  'search-markets': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as LiteMarket[],\n    props: searchProps,\n  },\n  'search-markets-full': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    preferAuth: true,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Contract[],\n    props: searchProps,\n  },\n  managram: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        amount: z.number().finite(),\n        toIds: z.array(z.string()),\n        message: z.string().max(MAX_COMMENT_LENGTH),\n        groupId: z.string().max(MAX_ID_LENGTH).optional(),\n        token: z.enum(['M$', 'CASH']).default('M$'),\n      })\n      .strict(),\n  },\n  manalink: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { slug: string },\n    props: z\n      .object({\n        amount: z.number().positive().finite().safe(),\n        expiresTime: z.number().lt(MAX_EXPIRES_AT).optional(),\n        maxUses: z.number().optional(),\n        message: z.string().optional(),\n      })\n      .strict(),\n  },\n  donate: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        amount: z.number().positive().finite().safe(),\n        to: z.string(),\n      })\n      .strict(),\n  },\n  'convert-sp-to-mana': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ amount: z.number().positive().finite().safe() }).strict(),\n  },\n  'convert-cash-to-mana': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ amount: z.number().positive().finite().safe() }).strict(),\n  },\n  'request-loan': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({}),\n    returns: {} as { payout: number },\n  },\n  // deprecated. use /txns instead\n  managrams: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: [] as ManaPayTxn[],\n    props: z\n      .object({\n        toId: z.string().optional(),\n        fromId: z.string().optional(),\n        limit: z.coerce.number().gte(0).lte(100).default(100),\n        before: z.coerce.number().optional(),\n        after: z.coerce.number().optional(),\n      })\n      .strict(),\n  },\n  'market/:id/positions': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as ContractMetric[],\n    props: z\n      .object({\n        id: z.string(),\n        userId: z.string().optional(),\n        answerId: z.string().optional(),\n        summaryOnly: z.boolean().optional(),\n        top: z.undefined().or(z.coerce.number()),\n        bottom: z.undefined().or(z.coerce.number()),\n        order: z.enum(['shares', 'profit']).optional(),\n      })\n      .strict(),\n  },\n  me: {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z.object({}),\n    returns: {} as FullUser,\n  },\n  'me/update': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({\n      name: z.string().trim().min(1).optional(),\n      username: z.string().trim().min(1).optional(),\n      avatarUrl: z.string().optional(),\n      bio: z.string().optional(),\n      website: z.string().optional(),\n      twitterHandle: z.string().optional(),\n      discordHandle: z.string().optional(),\n      // settings\n      optOutBetWarnings: z.boolean().optional(),\n      isAdvancedTrader: z.boolean().optional(),\n      //internal\n      seenStreakModal: z.boolean().optional(),\n      shouldShowWelcome: z.boolean().optional(),\n      hasSeenContractFollowModal: z.boolean().optional(),\n      hasSeenLoanModal: z.boolean().optional(),\n    }),\n    returns: {} as FullUser,\n  },\n  'me/delete': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({\n      username: z.string(), // just so you're sure\n    }),\n  },\n  'me/private': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z.object({}),\n    returns: {} as PrivateUser,\n  },\n  'me/private/update': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    props: z\n      .object({\n        email: z.string().email().optional(),\n        apiKey: z.string().optional(),\n        pushToken: z.string().optional(),\n        rejectedPushNotificationsOn: z.number().optional(),\n        lastPromptedToEnablePushNotifications: z.number().optional(),\n        interestedInPushNotifications: z.boolean().optional(),\n        hasSeenAppBannerInNotificationsOn: z.number().optional(),\n        installedAppPlatforms: z.array(z.string()).optional(),\n        paymentInfo: z.string().optional(),\n        lastAppReviewTime: z.number().optional(),\n      })\n      .strict(),\n  },\n  'user/:username': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as FullUser,\n    props: z.object({ username: z.string() }).strict(),\n  },\n  'user/:username/lite': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as DisplayUser,\n    props: z.object({ username: z.string() }).strict(),\n  },\n  'user/by-id/:id': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    // Do not add a caching strategy here. New users need up-to-date data.\n    returns: {} as FullUser,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'user/by-id/:id/lite': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as DisplayUser,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'users/by-id': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as DisplayUser[],\n    props: z.object({ ids: z.array(z.string()) }).strict(),\n  },\n  'users/by-id/balance': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as { id: string; balance: number }[],\n    props: z.object({ ids: z.array(z.string()) }).strict(),\n  },\n  'user/by-id/:id/block': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'user/by-id/:id/unblock': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  users: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as FullUser[],\n    props: z\n      .object({\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n        before: z.string().optional(),\n      })\n      .strict(),\n  },\n  'search-users': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as FullUser[],\n    props: z\n      .object({\n        term: z.string(),\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n        page: z.coerce.number().gte(0).default(0),\n      })\n      .strict(),\n  },\n  'search-contract-positions': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as DisplayUser[],\n    props: z\n      .object({\n        term: z.string(),\n        contractId: z.string(),\n        limit: z.coerce.number().gte(0).lte(100).default(10),\n      })\n      .strict(),\n  },\n  'save-twitch': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        twitchInfo: z.object({\n          twitchName: z.string().optional(),\n          controlToken: z.string().optional(),\n          botEnabled: z.boolean().optional(),\n          needsRelinking: z.boolean().optional(),\n        }),\n      })\n      .strict(),\n  },\n  'set-push-token': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({ pushToken: z.string() }).strict(),\n  },\n  'update-notif-settings': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      type: z.string() as z.ZodType<notification_preference>,\n      medium: z.enum(['email', 'browser', 'mobile']),\n      enabled: z.boolean(),\n    }),\n  },\n  headlines: {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: [] as Headline[],\n    props: z.object({\n      slug: z.enum(['politics', 'ai', 'news']).optional(),\n    }),\n  },\n  'politics-headlines': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: [] as Headline[],\n    props: z.object({}),\n  },\n  'set-news': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { success: true },\n    props: z\n      .object({\n        dashboardIds: z.array(z.string()),\n        endpoint: z.enum(['politics', 'ai', 'news']),\n      })\n      .strict(),\n  },\n  react: {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        contentId: z.string(),\n        contentType: z.enum(['comment', 'contract', 'post']),\n        commentParentType: z.enum(['post']).optional(),\n        remove: z.boolean().optional(),\n        reactionType: z.enum(['like', 'dislike']).optional().default('like'),\n      })\n      .strict(),\n    returns: { success: true },\n  },\n  'compatible-lovers': {\n    method: 'GET',\n    visibility: 'private',\n    authed: false,\n    props: z.object({ userId: z.string() }),\n    returns: {} as {\n      lover: Lover\n      compatibleLovers: Lover[]\n      loverCompatibilityScores: {\n        [userId: string]: CompatibilityScore\n      }\n    },\n  },\n  post: {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    returns: {} as ContractComment,\n    props: z\n      .object({\n        contractId: z.string(),\n        betId: z.string().optional(),\n        commentId: z.string().optional(),\n        content: contentSchema.optional(),\n      })\n      .strict(),\n  },\n  'fetch-link-preview': {\n    method: 'GET',\n    visibility: 'private',\n    authed: false,\n    props: z.object({ url: z.string() }).strict(),\n    cache: 'max-age=86400, stale-while-revalidate=86400',\n    returns: {} as LinkPreview,\n  },\n  'remove-pinned-photo': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    returns: { success: true },\n    props: z\n      .object({\n        userId: z.string(),\n      })\n      .strict(),\n  },\n  'get-related-markets': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    props: z\n      .object({\n        contractId: z.string(),\n        limit: z.coerce.number().gte(0).lte(100),\n        userId: z.string().optional(),\n        question: z.string().optional(),\n        uniqueBettorCount: z.coerce.number().gte(0).optional(),\n      })\n      .strict(),\n    returns: {} as {\n      marketsFromEmbeddings: Contract[]\n    },\n    cache: 'public, max-age=3600, stale-while-revalidate=10',\n  },\n  'get-related-markets-by-group': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: 'public, max-age=3600, stale-while-revalidate=10',\n    returns: {} as {\n      groupContracts: Contract[]\n    },\n    props: z\n      .object({\n        contractId: z.string(),\n        limit: z.coerce.number().gte(0).lte(100),\n        offset: z.coerce.number().gte(0),\n      })\n      .strict(),\n  },\n  'unlist-and-cancel-user-contracts': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        userId: z.string(),\n      })\n      .strict(),\n  },\n  'get-boost-analytics': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: false,\n    props: z\n      .object({\n        contractId: z.string(),\n      })\n      .strict(),\n    returns: {} as {\n      uniqueViewers: number\n      totalViews: number\n      uniquePromotedViewers: number\n      totalPromotedViews: number\n      boostPeriods: {\n        startTime: string\n        endTime: string\n      }[]\n    },\n  },\n  'get-seen-market-ids': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      contractIds: z.array(z.string()),\n      types: z.array(z.enum(['page', 'card', 'promoted'])).optional(),\n      since: z.number(),\n    }),\n    returns: [] as string[],\n  },\n  'get-compatibility-questions': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({}),\n    returns: {} as {\n      status: 'success'\n      questions: (Row<'love_questions'> & {\n        answer_count: number\n        score: number\n      })[]\n    },\n  },\n  'like-lover': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    props: z.object({\n      targetUserId: z.string(),\n      remove: z.boolean().optional(),\n    }),\n    returns: {} as {\n      status: 'success'\n    },\n  },\n  'ship-lovers': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    props: z.object({\n      targetUserId1: z.string(),\n      targetUserId2: z.string(),\n      remove: z.boolean().optional(),\n    }),\n    returns: {} as {\n      status: 'success'\n    },\n  },\n\n  'get-likes-and-ships': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z\n      .object({\n        userId: z.string(),\n      })\n      .strict(),\n    returns: {} as {\n      status: 'success'\n      likesReceived: LikeData[]\n      likesGiven: LikeData[]\n      ships: ShipData[]\n    },\n  },\n  'has-free-like': {\n    method: 'GET',\n    visibility: 'private',\n    authed: true,\n    props: z.object({}).strict(),\n    returns: {} as {\n      status: 'success'\n      hasFreeLike: boolean\n    },\n  },\n  'star-lover': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    props: z.object({\n      targetUserId: z.string(),\n      remove: z.boolean().optional(),\n    }),\n    returns: {} as {\n      status: 'success'\n    },\n  },\n  'get-lovers': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({}).strict(),\n    returns: {} as {\n      status: 'success'\n      lovers: Lover[]\n    },\n  },\n  'get-lover-answers': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({ userId: z.string() }).strict(),\n    returns: {} as {\n      status: 'success'\n      answers: Row<'love_compatibility_answers'>[]\n    },\n  },\n  'search-groups': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    // Is there a way to infer return { lite:[] as LiteGroup[] } if type is 'lite'?\n    returns: {\n      full: [] as Group[],\n      lite: [] as LiteGroup[],\n    },\n    props: SearchGroupParams(SearchGroupShape),\n  },\n  'search-my-groups': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {\n      full: [] as Group[],\n      lite: [] as LiteGroup[],\n    },\n    props: SearchGroupParams(MySearchGroupShape),\n  },\n  'get-groups-with-top-contracts': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as { topic: Topic; contracts: Contract[] }[],\n    props: z.object({}),\n  },\n  'get-balance-changes': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: [] as AnyBalanceChangeType[],\n    props: z\n      .object({\n        before: z.coerce.number().optional(),\n        after: z.coerce.number().default(0),\n        userId: z.string(),\n      })\n      .strict(),\n  },\n  'get-partner-stats': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z\n      .object({\n        userId: z.string(),\n      })\n      .strict(),\n    returns: {} as {\n      status: 'success' | 'error'\n      username: string\n      numContractsCreated: number\n      numUniqueBettors: number\n      numReferrals: number\n      numReferralsWhoRetained: number\n      totalTraderIncome: number\n      totalReferralIncome: number\n      dollarsEarned: number\n    },\n  },\n  'record-contract-view': {\n    method: 'POST',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      userId: z.string().optional(),\n      contractId: z.string(),\n      kind: z.enum(['page', 'card', 'promoted']),\n    }),\n    returns: {} as { status: 'success' },\n  },\n  'record-comment-view': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({\n      contractId: z.string(),\n      commentId: z.string(),\n    }),\n    returns: {} as { status: 'success' },\n  },\n  'record-contract-interaction': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({\n      contractId: z.string(),\n      kind: z.enum([\n        'page bet',\n        'page comment',\n        'page repost',\n        'page like',\n        'card bet',\n        'card click',\n        'promoted click',\n        'card like',\n        'page share',\n        'browse click',\n      ]),\n      commentId: z.string().optional(),\n      feedReasons: z.array(z.string()).optional(),\n      feedType: z.string().optional(),\n      betGroupId: z.string().optional(),\n      betId: z.string().optional(),\n    }),\n    returns: {} as { status: 'success' },\n  },\n  'get-dashboard-from-slug': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      dashboardSlug: z.string(),\n    }),\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as Dashboard,\n  },\n  'get-posts': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    preferAuth: true,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z\n      .object({\n        sortBy: z\n          .enum(['created_time', 'importance_score'])\n          .optional()\n          .default('created_time'),\n        term: z.string().optional(),\n        limit: z.coerce.number().gte(0).lte(200).default(100),\n        userId: z.string().optional(),\n        offset: z.coerce.number().gte(0).default(0),\n        isChangeLog: coerceBoolean.optional(),\n      })\n      .strict(),\n    returns: [] as TopLevelPost[],\n  },\n  'create-public-chat-message': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as ChatMessage,\n    props: z.object({\n      content: contentSchema,\n      channelId: z.string(),\n    }),\n  },\n  'get-followed-groups': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      userId: z.string(),\n    }),\n    returns: {} as {\n      groups: Group[]\n    },\n  },\n  'get-user-portfolio': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      userId: z.string(),\n    }),\n    returns: {} as LivePortfolioMetrics,\n  },\n  'get-user-portfolio-history': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      userId: z.string(),\n      period: z.enum(PERIODS),\n    }),\n    returns: {} as PortfolioMetrics[],\n  },\n  'get-channel-memberships': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      channelId: z.coerce.number().optional(),\n      createdTime: z.string().optional(),\n      lastUpdatedTime: z.string().optional(),\n      limit: z.coerce.number(),\n    }),\n    returns: {\n      channels: [] as PrivateMessageChannel[],\n      memberIdsByChannelId: {} as { [channelId: string]: string[] },\n    },\n  },\n  'get-channel-messages': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      channelId: z.coerce.number(),\n      limit: z.coerce.number(),\n      id: z.coerce.number().optional(),\n    }),\n    returns: [] as PrivateChatMessage[],\n  },\n  'get-channel-seen-time': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      channelIds: z.array(z.coerce.number()),\n    }),\n    returns: [] as [number, string][],\n  },\n  'set-channel-seen-time': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      channelId: z.coerce.number(),\n    }),\n  },\n  'get-feed': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as {\n      contracts: Contract[]\n      comments: ContractComment[]\n      bets: Bet[]\n      reposts: Repost[]\n      idsToReason: { [id: string]: string }\n    },\n    props: z\n      .object({\n        userId: z.string(),\n        limit: z.coerce.number().gt(0).lte(100).default(100),\n        offset: z.coerce.number().gte(0).default(0),\n        ignoreContractIds: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'get-mana-supply': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as ManaSupply,\n    props: z.object({}).strict(),\n  },\n  'get-notifications': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as Notification[],\n    props: z\n      .object({\n        after: z.coerce.number().optional(),\n        limit: z.coerce.number().gte(0).lte(1000).default(100),\n      })\n      .strict(),\n  },\n  'update-mod-report': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        reportId: z.number(),\n        updates: z\n          .object({\n            status: z\n              .enum(['new', 'under review', 'resolved', 'needs admin'])\n              .optional(),\n            mod_note: z.string().optional(),\n          })\n          .partial(),\n      })\n      .strict(),\n    returns: {} as { status: string; report: ModReport },\n  },\n  'get-mod-reports': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        statuses: z.array(\n          z.enum(['new', 'under review', 'resolved', 'needs admin'])\n        ),\n        limit: z.coerce.number().gte(0).lte(100).default(25),\n        offset: z.coerce.number().gte(0).default(0),\n        count: coerceBoolean.optional(),\n      })\n      .strict(),\n    returns: {} as {\n      status: string\n      count?: number\n      reports: ModReport[]\n    },\n  },\n  'get-txn-summary-stats': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as Row<'txn_summary_stats'>[],\n    props: z\n      .object({\n        ignoreCategories: z.array(z.string()).optional(),\n        fromType: z.string().optional(),\n        toType: z.string().optional(),\n        limitDays: z.coerce.number(),\n      })\n      .strict(),\n  },\n  'get-mana-summary-stats': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as Row<'mana_supply_stats'>[],\n    props: z\n      .object({\n        limitDays: z.coerce.number(),\n      })\n      .strict(),\n  },\n  'register-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: verificationParams,\n    returns: {} as RegistrationReturnType,\n  },\n  'get-verification-status-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      documents?: GIDXDocument[]\n      message?: string\n      documentStatus?: string\n    },\n    props: z.object({}),\n  },\n  'get-monitor-status-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n    },\n    props: z.object({\n      DeviceGPS: GPSProps,\n    }),\n  },\n  'get-checkout-session-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n      session?: CheckoutSession\n    },\n    props: z.object({\n      PayActionCode: z.enum(['PAY', 'PAYOUT']).default('PAY'),\n      DeviceGPS: GPSProps,\n      userId: z.string().optional(),\n      ip: z.string().optional(),\n    }),\n  },\n  'complete-checkout-session-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n      gidxMessage?: string | null\n      details?: PaymentDetail[]\n    },\n    props: z.object(checkoutParams),\n  },\n  'complete-cashout-session-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n      gidxMessage?: string | null\n      details?: PaymentDetail[]\n    },\n    props: z.object(cashoutParams),\n  },\n  'complete-cashout-request': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n      gidxMessage?: string | null\n      details?: PaymentDetail[]\n    },\n    props: z.object(cashoutRequestParams),\n  },\n  'get-verification-documents-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      documents: GIDXDocument[]\n      utilityDocuments: GIDXDocument[]\n      idDocuments: GIDXDocument[]\n      rejectedDocuments: GIDXDocument[]\n    },\n    props: z.object({}),\n  },\n  'upload-document-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { status: string },\n    props: z.object({\n      CategoryType: z.number().gte(1).lte(7),\n      fileName: z.string(),\n      fileUrl: z.string(),\n    }),\n  },\n  'identity-callback-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as { Accepted: boolean },\n    props: z.object({\n      MerchantCustomerID: z.string(),\n      NotificationType: z.string(),\n    }),\n  },\n  'payment-callback-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as { MerchantTransactionID: string },\n    props: z\n      .object({\n        MerchantTransactionID: z.string(),\n        TransactionStatusCode: z.coerce.number(),\n        TransactionStatusMessage: z.string(),\n        StatusCode: z.coerce.number(),\n        SessionID: z.string(),\n        MerchantSessionID: z.string(),\n        SessionScore: z.coerce.number(),\n        ReasonCodes: z.array(z.string()).optional(),\n        ServiceType: z.string(),\n        StatusMessage: z.string(),\n      })\n      .strict(),\n  },\n  'get-best-comments': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { comments: ContractComment[]; contracts: Contract[] },\n    props: z.object({\n      limit: z.coerce.number().gte(0).lte(100).default(20),\n      offset: z.coerce.number().gte(0).default(0),\n      ignoreContractIds: z.array(z.string()).optional(),\n      justLikes: z.coerce.number().optional(),\n    }),\n  },\n  'get-redeemable-prize-cash': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { redeemablePrizeCash: number },\n    props: z.object({}),\n  },\n  'get-total-redeemable-prize-cash': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as { total: number },\n    props: z.object({}),\n  },\n  'get-cashouts': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as PendingCashoutStatusData[],\n    props: z\n      .object({\n        limit: z.coerce.number().gte(0).lte(100).default(10),\n        offset: z.coerce.number().gte(0).default(0),\n        userId: z.string().optional(),\n      })\n      .strict(),\n  },\n  'get-kyc-stats': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({}),\n    returns: {} as {\n      initialVerifications: {\n        count: number\n        day: string\n      }[]\n      phoneVerifications: {\n        count: number\n        day: string\n      }[]\n    },\n  },\n  txns: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z\n      .object({\n        token: z.string().optional(),\n        offset: z.coerce.number().default(0),\n        limit: z.coerce.number().gte(0).lte(100).default(100),\n        before: z.coerce.number().optional(),\n        after: z.coerce.number().optional(),\n        toId: z.string().optional(),\n        fromId: z.string().optional(),\n        category: z.string().optional(),\n        ignoreCategories: z.array(z.string()).optional(),\n      })\n      .strict(),\n    returns: [] as Txn[],\n  },\n  'generate-ai-market-suggestions': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: [] as AIGeneratedMarket[],\n    props: z\n      .object({\n        prompt: z.string(),\n        existingTitles: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'generate-ai-description': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { description: JSONContent | undefined },\n    props: z\n      .object({\n        question: z.string(),\n        description: z.string().optional(),\n        answers: z.array(z.string()).optional(),\n        outcomeType: z.string().optional(),\n        shouldAnswersSumToOne: coerceBoolean.optional(),\n        addAnswersMode: z\n          .enum(['DISABLED', 'ONLY_CREATOR', 'ANYONE'])\n          .optional(),\n      })\n      .strict(),\n  },\n  'generate-ai-answers': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as {\n      answers: string[]\n      addAnswersMode: 'DISABLED' | 'ONLY_CREATOR' | 'ANYONE'\n    },\n    props: z\n      .object({\n        question: z.string(),\n        answers: z.array(z.string()),\n        shouldAnswersSumToOne: coerceBoolean,\n        description: z.string().optional(),\n      })\n      .strict(),\n  },\n  'get-monthly-bets-2024': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ userId: z.string() }),\n    returns: [] as { month: string; bet_count: number; total_amount: number }[],\n  },\n  'get-max-min-profit-2024': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ userId: z.string() }),\n    returns: [] as {\n      profit: number\n      data: Contract\n      answer_id: string | null\n      has_no_shares: boolean\n      has_yes_shares: boolean\n    }[],\n  },\n  'get-next-loan-amount': {\n    method: 'GET',\n    visibility: 'undocumented',\n    cache: DEFAULT_CACHE_STRATEGY,\n    authed: false,\n    returns: {} as { amount: number },\n    props: z.object({\n      userId: z.string(),\n    }),\n  },\n  'create-task': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as Task,\n    props: z\n      .object({\n        text: z.string(),\n        category_id: z.number().optional(),\n        priority: z.number().default(0),\n        assignee_id: z.string().optional(),\n      })\n      .strict(),\n  },\n  'update-task': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z\n      .object({\n        id: z.number(),\n        text: z.string().optional(),\n        completed: z.boolean().optional(),\n        priority: z.number().optional(),\n        category_id: z.number().optional(),\n        archived: z.boolean().optional(),\n        assignee_id: z.string().optional(),\n      })\n      .strict(),\n  },\n  'create-category': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { id: number },\n    props: z\n      .object({\n        name: z.string(),\n        color: z.string().optional(),\n        displayOrder: z.number().optional(),\n      })\n      .strict(),\n  },\n  'get-categories': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { categories: TaskCategory[] },\n    props: z.object({}).strict(),\n  },\n  'update-category': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z\n      .object({\n        categoryId: z.number(),\n        name: z.string().optional(),\n        color: z.string().optional(),\n        displayOrder: z.number().optional(),\n        archived: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  'get-tasks': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { tasks: Task[] },\n    props: z.object({}).strict(),\n  },\n  'is-sports-interested': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { isSportsInterested: boolean },\n    props: z.object({}).strict(),\n  },\n  'get-site-activity': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as {\n      bets: Bet[]\n      comments: CommentWithTotalReplies[]\n      newContracts: Contract[]\n      relatedContracts: Contract[]\n    },\n    props: z\n      .object({\n        limit: z.coerce.number().default(10),\n        offset: z.coerce.number().default(0),\n        blockedUserIds: z.array(z.string()).optional(),\n        blockedGroupSlugs: z.array(z.string()).optional(),\n        blockedContractIds: z.array(z.string()).optional(),\n        topicIds: z.array(z.string()).optional(),\n        types: z\n          .array(z.enum(['bets', 'comments', 'markets', 'limit-orders']))\n          .optional(),\n        minBetAmount: z.coerce.number().optional(),\n        onlyFollowedTopics: coerceBoolean.optional(),\n        onlyFollowedContracts: coerceBoolean.optional(),\n        onlyFollowedUsers: coerceBoolean.optional(),\n        userId: z.string().optional(),\n      })\n      .strict(),\n  },\n  'get-sports-games': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { schedule: any[] },\n    props: z.object({}).strict(),\n  },\n  'get-market-props': {\n    method: 'GET',\n    visibility: 'public',\n    cache: DEFAULT_CACHE_STRATEGY,\n    // Could set authed false and preferAuth with an api secret if we want it to replace static props\n    authed: true,\n    returns: {} as {\n      manaContract: MarketContract\n      chartAnnotations: ChartAnnotation[]\n      topics: Topic[]\n      comments: ContractComment[]\n      pinnedComments: ContractComment[]\n      userPositionsByOutcome: {\n        YES: ContractMetric[]\n        NO: ContractMetric[]\n      }\n      topContractMetrics: ContractMetric[]\n      totalPositions: number\n      dashboards: Dashboard[]\n      cashContract: MarketContract\n      totalManaBets: number\n      totalCashBets: number\n    },\n    props: z.object({\n      slug: z.string().optional(),\n      id: z.string().optional(),\n    }),\n  },\n  'get-user-contract-metrics-with-contracts': {\n    method: 'GET',\n    visibility: 'public',\n    preferAuth: true,\n    authed: false,\n    returns: {} as {\n      metricsByContract: Dictionary<ContractMetric[]>\n      contracts: MarketContract[]\n    },\n    props: z.object({\n      userId: z.string(),\n      limit: z.coerce.number(),\n      offset: z.coerce.number().gte(0).optional(),\n      perAnswer: coerceBoolean.optional(),\n      inMani: coerceBoolean.optional(),\n    }),\n  },\n  validateIap: {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z.object({\n      receipt: z.string(),\n    }),\n  },\n  'check-sports-event': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as { exists: boolean; existingMarket?: LiteMarket },\n    props: z\n      .object({\n        sportsEventId: z.string(),\n      })\n      .strict(),\n  },\n  'comment-reactions': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Reaction[],\n    props: z\n      .object({\n        contentIds: z.array(z.string()),\n        contentType: z.enum(['comment', 'contract']),\n      })\n      .strict(),\n  },\n  'mark-all-notifications-new': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({}).strict(),\n    returns: {} as { success: boolean },\n  },\n  'get-contract-voters': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        contractId: z.string(),\n      })\n      .strict(),\n    returns: [] as DisplayUser[],\n  },\n  'get-contract-option-voters': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ contractId: z.string(), optionId: z.string() }),\n    returns: [] as DisplayUser[],\n  },\n  'purchase-contract-boost': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        contractId: z.string(),\n        startTime: z.number().positive().finite().safe(),\n        method: z.enum(['mana', 'cash']),\n      })\n      .strict(),\n    returns: {} as { success: boolean; checkoutUrl?: string },\n  },\n  'generate-ai-numeric-ranges': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as {\n      thresholds: { answers: string[]; midpoints: number[] }\n      buckets: { answers: string[]; midpoints: number[] }\n    },\n    props: z\n      .object({\n        question: z.string(),\n        min: z.number(),\n        max: z.number(),\n        description: z.string().optional(),\n        unit: z.string(),\n      })\n      .strict(),\n  },\n  'infer-numeric-unit': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as {\n      unit: string\n    },\n    props: z\n      .object({\n        question: z.string(),\n        description: z.string().optional(),\n      })\n      .strict(),\n  },\n  'generate-ai-date-ranges': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as {\n      buckets: { answers: string[]; midpoints: number[] }\n      thresholds: { answers: string[]; midpoints: number[] }\n    },\n    props: z\n      .object({\n        question: z.string(),\n        min: z.string(),\n        max: z.string(),\n        description: z.string().optional(),\n      })\n      .strict(),\n  },\n  'regenerate-numeric-midpoints': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { midpoints: number[] },\n    props: z\n      .object({\n        description: z.string().optional(),\n        question: z.string(),\n        answers: z.array(z.string()),\n        min: z.number(),\n        max: z.number(),\n        unit: z.string(),\n        tab: z.enum(['thresholds', 'buckets']),\n      })\n      .strict(),\n  },\n  'regenerate-date-midpoints': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { midpoints: number[] },\n    props: z\n      .object({\n        description: z.string().optional(),\n        question: z.string(),\n        answers: z.array(z.string()),\n        min: z.string(),\n        max: z.string(),\n        tab: z.enum(['thresholds', 'buckets']),\n      })\n      .strict(),\n  },\n\n  'generate-concise-title': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        question: z.string(),\n      })\n      .strict(),\n    returns: {} as { title: string },\n  },\n  'get-close-date': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        question: z.string(),\n        utcOffset: z.number().optional(),\n      })\n      .strict(),\n    returns: {} as { closeTime: number },\n  },\n  'refer-user': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        referredByUsername: z.string(),\n        contractId: z.string().optional(),\n      })\n      .strict(),\n    returns: {} as { success: boolean },\n  },\n\n  'save-market-draft': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { id: number },\n    props: z\n      .object({\n        data: z.object({\n          question: z.string(),\n          description: z.any().optional(),\n          outcomeType: z.string(),\n          answers: z.array(z.string()).optional(),\n          closeDate: z.string().optional(),\n          closeHoursMinutes: z.string().optional(),\n          visibility: z.string(),\n          selectedGroups: z.array(z.any()),\n          savedAt: z.number(),\n        }),\n      })\n      .strict(),\n  },\n\n  'get-market-drafts': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: [] as MarketDraft[],\n    props: z.object({}).strict(),\n  },\n\n  'delete-market-draft': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z\n      .object({\n        id: z.coerce.number(),\n      })\n      .strict(),\n  },\n  'get-season-info': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      season: z.coerce.number().int().positive().optional(),\n    }),\n    returns: {} as {\n      season: number\n      startTime: number // epoch ms\n      endTime: number | null // epoch ms, null if a *mystery* for clients\n      status: 'active' | 'processing' | 'complete'\n    },\n  },\n  'mark-notification-read': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z\n      .object({\n        notificationId: z.string(),\n      })\n      .strict(),\n  },\n  'dismiss-user-report': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        reportId: z.string(),\n      })\n      .strict(),\n    returns: {} as { success: boolean },\n  },\n  'create-post': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { post: TopLevelPost },\n    props: z\n      .object({\n        title: z.string().min(1).max(120),\n        content: contentSchema,\n        isAnnouncement: z.boolean().optional(),\n        visibility: z.enum(['public', 'unlisted']).optional(),\n        isChangeLog: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  'update-post': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { post: TopLevelPost },\n    props: z\n      .object({\n        id: z.string(),\n        title: z.string().min(1).max(480).optional(),\n        content: contentSchema.optional(),\n        visibility: z.enum(['public', 'unlisted']).optional(),\n      })\n      .strict(),\n  },\n  'create-post-comment': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { comment: PostComment },\n    props: z\n      .object({\n        postId: z.string(),\n        content: contentSchema,\n        replyToCommentId: z.string().optional(),\n      })\n      .strict(),\n  },\n  'update-post-comment': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { comment: PostComment },\n    props: z\n      .object({\n        commentId: z.string(),\n        postId: z.string(),\n        hidden: z.boolean(),\n      })\n      .strict(),\n  },\n  'follow-post': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: true },\n    props: z\n      .object({\n        postId: z.string(),\n        follow: z.boolean(),\n      })\n      .strict(),\n  },\n  'edit-post-comment': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        commentId: z.string(),\n        postId: z.string(),\n        content: contentSchema,\n      })\n      .strict(),\n    returns: {} as { success: boolean },\n  },\n} as const)\n\nexport type APIPath = keyof typeof API\nexport type APISchema<N extends APIPath> = (typeof API)[N]\n\nexport type APIParams<N extends APIPath> = z.input<APISchema<N>['props']>\nexport type ValidatedAPIParams<N extends APIPath> = z.output<\n  APISchema<N>['props']\n>\n\nexport type APIResponse<N extends APIPath> = APISchema<N> extends {\n  returns: Record<string, any>\n}\n  ? APISchema<N>['returns']\n  : void\n\nexport type APIResponseOptionalContinue<N extends APIPath> =\n  | { continue: () => Promise<void>; result: APIResponse<N> }\n  | APIResponse<N>\n",
          "postContent": "import { z } from 'zod'\nimport {\n  Group,\n  MAX_ID_LENGTH,\n  MySearchGroupShape,\n  LiteGroup,\n  SearchGroupParams,\n  SearchGroupShape,\n  Topic,\n} from 'common/group'\nimport {\n  createMarketProps,\n  resolveMarketProps,\n  type LiteMarket,\n  FullMarket,\n  updateMarketProps,\n} from './market-types'\nimport { type Answer } from 'common/answer'\nimport {\n  Comment,\n  CommentWithTotalReplies,\n  MAX_COMMENT_LENGTH,\n  PostComment,\n  type ContractComment,\n} from 'common/comment'\nimport { CandidateBet } from 'common/new-bet'\nimport type { Bet, LimitBet } from 'common/bet'\nimport { coerceBoolean, contentSchema } from 'common/api/zod-types'\nimport { AIGeneratedMarket, Contract, MarketContract } from 'common/contract'\nimport type { Txn, ManaPayTxn } from 'common/txn'\nimport { LiquidityProvision } from 'common/liquidity-provision'\nimport { DisplayUser, FullUser } from './user-types'\nimport { League } from 'common/leagues'\nimport { searchProps } from './market-search-types'\nimport { MAX_ANSWER_LENGTH } from 'common/answer'\nimport { type LinkPreview } from 'common/link-preview'\nimport { Headline } from 'common/news'\nimport { Row } from 'common/supabase/utils'\nimport { AnyBalanceChangeType } from 'common/balance-change'\nimport { Dashboard } from 'common/dashboard'\nimport { ChatMessage, PrivateChatMessage } from 'common/chat-message'\nimport { PrivateUser, User } from '../user'\nimport { ManaSupply } from 'common/stats'\nimport { Repost } from 'common/repost'\nimport { PERIODS } from 'common/period'\nimport { SWEEPS_MIN_BET } from 'common/economy'\nimport {\n  LivePortfolioMetrics,\n  PortfolioMetrics,\n} from 'common/portfolio-metrics'\nimport { ModReport } from '../mod-report'\n\nimport { RegistrationReturnType } from 'common/reason-codes'\nimport {\n  CheckoutSession,\n  GIDXDocument,\n  GPSProps,\n  PaymentDetail,\n  checkoutParams,\n  verificationParams,\n  cashoutRequestParams,\n  PendingCashoutStatusData,\n  cashoutParams,\n} from 'common/gidx/gidx'\nimport { notification_preference } from 'common/user-notification-preferences'\nimport { PrivateMessageChannel } from 'common/supabase/private-messages'\nimport { Notification } from 'common/notification'\nimport { NON_POINTS_BETS_LIMIT } from 'common/supabase/bets'\nimport { ContractMetric } from 'common/contract-metric'\n\nimport { JSONContent } from '@tiptap/core'\nimport { Task, TaskCategory } from 'common/todo'\nimport { ChartAnnotation } from 'common/supabase/chart-annotations'\nimport { Dictionary } from 'lodash'\nimport { Reaction } from 'common/reaction'\nimport { YEAR_MS } from 'common/util/time'\nimport { MarketDraft } from 'common/drafts'\nimport { TopLevelPost } from 'common/top-level-post'\n// mqp: very unscientific, just balancing our willingness to accept load\n// with user willingness to put up with stale data\nexport const DEFAULT_CACHE_STRATEGY =\n  'public, max-age=5, stale-while-revalidate=10'\nconst MAX_EXPIRES_AT = 1_000 * YEAR_MS\n\ntype APIGenericSchema = {\n  // GET is for retrieval, POST is to mutate something, PUT is idempotent mutation (can be repeated safely)\n  method: 'GET' | 'POST' | 'PUT'\n  //private APIs can only be called from manifold. undocumented endpoints can change or be deleted at any time!\n  visibility: 'public' | 'undocumented' | 'private'\n  // whether the endpoint requires authentication\n  authed: boolean\n  // zod schema for the request body (or for params for GET requests)\n  props: z.ZodType\n  // note this has to be JSON serializable\n  returns?: Record<string, any>\n  // Cache-Control header. like, 'max-age=60'\n  cache?: string\n  // whether the endpoint should prefer authentication even if not required\n  preferAuth?: boolean\n}\n\nlet _apiTypeCheck: { [x: string]: APIGenericSchema }\nexport const API = (_apiTypeCheck = {\n  'refresh-all-clients': {\n    method: 'POST',\n    visibility: 'public',\n    props: z.object({ message: z.string().optional() }),\n    authed: true,\n  },\n  'toggle-system-trading-status': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        token: z.enum(['MANA', 'CASH']),\n      })\n      .strict(),\n    returns: {} as { status: boolean },\n  },\n  comment: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as ContractComment,\n    props: z\n      .object({\n        contractId: z.string(),\n        content: contentSchema.optional(),\n        html: z.string().optional(),\n        markdown: z.string().optional(),\n        replyToCommentId: z.string().optional(),\n        replyToAnswerId: z.string().optional(),\n        replyToBetId: z.string().optional(),\n      })\n      .strict(),\n  },\n\n  'follow-contract': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: true },\n    props: z\n      .object({\n        contractId: z.string(),\n        follow: z.boolean(),\n      })\n      .strict(),\n  },\n  'get-contract': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as Contract,\n    props: z\n      .object({\n        contractId: z.string(),\n      })\n      .strict(),\n  },\n  'answer/:answerId': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as Answer,\n    props: z.object({ answerId: z.string() }).strict(),\n  },\n  'market/:contractId/answers': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: [] as Answer[],\n    props: z.object({ contractId: z.string() }).strict(),\n  },\n  'hide-comment': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ commentPath: z.string() }).strict(),\n  },\n  'pin-comment': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({ commentPath: z.string() }).strict(),\n  },\n  comments: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    // cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as ContractComment[],\n    props: z\n      .object({\n        contractId: z.string().optional(),\n        contractSlug: z.string().optional(),\n        afterTime: z.coerce.number().optional(),\n        limit: z.coerce.number().gte(0).lte(1000).default(1000),\n        page: z.coerce.number().gte(0).default(0),\n        userId: z.string().optional(),\n        isPolitics: coerceBoolean.optional(),\n      })\n      .strict(),\n  },\n  'user-comments': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: [] as Comment[],\n    props: z\n      .object({\n        afterTime: z.coerce.number().optional(),\n        limit: z.coerce.number().gte(0).lte(1000).default(1000),\n        page: z.coerce.number().gte(0).default(0),\n        userId: z.string(),\n      })\n      .strict(),\n  },\n  bet: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as CandidateBet & { betId: string },\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gte(SWEEPS_MIN_BET),\n        replyToCommentId: z.string().optional(),\n        limitProb: z.number().gte(0.01).lte(0.99).optional(),\n        expiresMillisAfter: z.number().lt(MAX_EXPIRES_AT).optional(),\n        silent: z.boolean().optional(),\n        expiresAt: z.number().lt(MAX_EXPIRES_AT).optional(),\n        // Used for binary and new multiple choice contracts (cpmm-multi-1).\n        outcome: z.enum(['YES', 'NO']).default('YES'),\n        //Multi\n        answerId: z.string().optional(),\n        dryRun: z.boolean().optional(),\n        deps: z.array(z.string()).optional(),\n        deterministic: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  createuser: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { user: User; privateUser: PrivateUser },\n    props: z\n      .object({\n        deviceToken: z.string().optional(),\n        adminToken: z.string().optional(),\n        visitedContractIds: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'multi-bet': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as (CandidateBet & { betId: string })[],\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gte(1),\n        limitProb: z.number().gte(0).lte(1).optional(),\n        expiresAt: z.number().lt(MAX_EXPIRES_AT).optional(),\n        answerIds: z.array(z.string()).min(1),\n        deterministic: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  'multi-sell': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as (CandidateBet & { betId: string })[],\n    props: z\n      .object({\n        contractId: z.string(),\n        answerIds: z.array(z.string()).min(1),\n        deterministic: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  leaderboard: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as { userId: string; score: number }[],\n    props: z\n      .object({\n        groupId: z.string().optional(),\n        limit: z.coerce.number().min(1).max(100).default(50),\n        token: z.enum(['MANA', 'CASH']).default('MANA'),\n        kind: z.enum(['creator', 'profit', 'loss', 'volume', 'referral']),\n      })\n      .strict(),\n  },\n  'verify-phone-number': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { status: string },\n    props: z\n      .object({\n        phoneNumber: z.string(),\n        code: z.string(),\n      })\n      .strict(),\n  },\n  'request-otp': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { status: string },\n    props: z\n      .object({\n        phoneNumber: z.string(),\n      })\n      .strict(),\n  },\n  'bet/cancel/:betId': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ betId: z.string() }).strict(),\n    returns: {} as LimitBet,\n  },\n  // sell shares\n  'market/:contractId/sell': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as CandidateBet & { betId: string },\n    props: z\n      .object({\n        contractId: z.string(),\n        shares: z.number().positive().optional(), // leave it out to sell all shares\n        outcome: z.enum(['YES', 'NO']),\n        answerId: z.string().optional(), // Required for multi binary markets\n        deterministic: z.boolean().optional(),\n        deps: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'get-user-limit-orders-with-contracts': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as {\n      bets: LimitBet[]\n      contracts: MarketContract[]\n    },\n    props: z\n      .object({\n        userId: z.string(),\n        count: z.coerce.number().lte(5000),\n        includeExpired: coerceBoolean.optional().default(false),\n        includeCancelled: coerceBoolean.optional().default(false),\n        includeFilled: coerceBoolean.optional().default(false),\n      })\n      .strict(),\n  },\n  'get-interesting-groups-from-views': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as (Group & { hasBet: boolean })[],\n    props: z\n      .object({\n        userId: z.string(),\n        contractIds: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  bets: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Bet[],\n    props: z\n      .object({\n        id: z.string().optional(),\n        userId: z.string().optional(),\n        username: z.string().optional(),\n        contractId: z.string().or(z.array(z.string())).optional(),\n        contractSlug: z.string().optional(),\n        answerId: z.string().optional(),\n        // market: z.string().optional(), // deprecated, synonym for `contractSlug`\n        limit: z.coerce\n          .number()\n          .gte(0)\n          .lte(50000)\n          .default(NON_POINTS_BETS_LIMIT),\n        before: z.string().optional(),\n        after: z.string().optional(),\n        beforeTime: z.coerce.number().optional(),\n        afterTime: z.coerce.number().optional(),\n        order: z.enum(['asc', 'desc']).optional(),\n        kinds: z.enum(['open-limit']).optional(),\n        // undocumented fields. idk what a good api interface would be\n        filterRedemptions: coerceBoolean.optional(),\n        includeZeroShareRedemptions: coerceBoolean.optional(),\n        commentRepliesOnly: coerceBoolean.optional(),\n        count: coerceBoolean.optional(),\n        points: coerceBoolean.optional(),\n      })\n      .strict(),\n  },\n  'bet-points': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: 'public, max-age=600, stale-while-revalidate=60',\n    returns: [] as Bet[],\n    props: z\n      .object({\n        contractId: z.string(),\n        answerId: z.string().optional(),\n        limit: z.coerce.number().gte(0).lte(50000).default(5000),\n        beforeTime: z.coerce.number(),\n        afterTime: z.coerce.number(),\n        filterRedemptions: coerceBoolean.optional(),\n        includeZeroShareRedemptions: coerceBoolean.optional(),\n      })\n      .strict(),\n  },\n  'unique-bet-group-count': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as { count: number },\n    props: z\n      .object({\n        contractId: z.string(),\n      })\n      .strict(),\n  },\n  'get-daily-changed-metrics-and-contracts': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    cache: 'public, max-age=900, stale-while-revalidate=90', // 15 minute cache\n    props: z\n      .object({\n        limit: z.coerce.number(),\n        userId: z.string(),\n        balance: z.coerce.number(),\n      })\n      .strict(),\n    returns: {} as {\n      manaMetrics: ContractMetric[]\n      contracts: MarketContract[]\n      manaProfit: number\n      manaInvestmentValue: number\n      balance: number\n    },\n  },\n  // deprecated. use /bets?username= instead\n  'user/:username/bets': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Bet[],\n    props: z\n      .object({\n        username: z.string(),\n        limit: z.coerce.number().gte(0).lte(1000).default(1000),\n      })\n      .strict(),\n  },\n  'group/:slug': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as Group,\n    props: z.object({ slug: z.string() }),\n  },\n  'group/:slug/groups': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as { above: LiteGroup[]; below: LiteGroup[] },\n    props: z.object({ slug: z.string() }).strict(),\n  },\n  'group/:slug/dashboards': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as {\n      id: string\n      title: string\n      slug: string\n      creatorId: string\n    }[],\n    props: z.object({ slug: z.string() }).strict(),\n  },\n  'group/by-id/:id/groups': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as { above: LiteGroup[]; below: LiteGroup[] },\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'group/by-id/:id': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as Group,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  // deprecated. use /markets?groupId= instead\n  'group/by-id/:id/markets': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as LiteMarket[],\n    props: z\n      .object({\n        id: z.string(),\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n      })\n      .strict(),\n  },\n  'group/:slug/delete': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ slug: z.string() }),\n  },\n  'group/by-id/:id/delete': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ id: z.string() }),\n  },\n  'group/:slug/block': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ slug: z.string() }),\n  },\n  'group/:slug/unblock': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ slug: z.string() }).strict(),\n  },\n  'group/by-id/:topId/group/:bottomId': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        topId: z.string(),\n        bottomId: z.string(),\n        remove: z.boolean().optional(),\n      })\n      .strict(),\n    returns: {} as { status: 'success' },\n  },\n  groups: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Group[],\n    props: z\n      .object({\n        availableToUserId: z.string().optional(),\n        beforeTime: z.coerce.number().int().optional(),\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n      })\n      .strict(),\n  },\n  'market/:id': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as LiteMarket | FullMarket,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z.object({ id: z.string(), lite: coerceBoolean.optional() }),\n  },\n  'market/:id/prob': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as {\n      prob?: number\n      answerProbs?: { [answerId: string]: number }\n    },\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'market-probs': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as {\n      [contractId: string]: {\n        prob?: number\n        answerProbs?: { [answerId: string]: number }\n      }\n    },\n    props: z\n      .object({\n        ids: z.array(z.string()).max(100),\n      })\n      .strict(),\n  },\n  'markets-by-ids': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: [] as Contract[],\n    props: z\n      .object({\n        ids: z.array(z.string()).max(100),\n      })\n      .strict(),\n  },\n  // deprecated. use /market/:id?lite=true instead\n  'market/:id/lite': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as LiteMarket,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z.object({ id: z.string() }),\n  },\n  'slug/:slug': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as LiteMarket | FullMarket,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z.object({ slug: z.string(), lite: coerceBoolean.optional() }),\n  },\n  market: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as LiteMarket,\n    props: createMarketProps,\n  },\n  'market/:contractId/update': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: updateMarketProps,\n    returns: {} as { success: true },\n  },\n  'market/:contractId/close': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    // returns: {} as LiteMarket,\n    props: z\n      .object({\n        contractId: z.string(),\n        closeTime: z.number().int().nonnegative().optional(),\n      })\n      .strict(),\n  },\n  'market/:contractId/resolve': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { message: string },\n    props: resolveMarketProps,\n  },\n  'market/:contractId/add-liquidity': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as LiquidityProvision,\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gt(0).finite(),\n      })\n      .strict(),\n  },\n  'market/:contractId/remove-liquidity': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as LiquidityProvision,\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gt(0).finite(),\n      })\n      .strict(),\n  },\n  'market/:contractId/add-bounty': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as Txn,\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gt(0).finite(),\n      })\n      .strict(),\n  },\n  'market/:contractId/award-bounty': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as Txn,\n    props: z\n      .object({\n        contractId: z.string(),\n        commentId: z.string(),\n        amount: z.number().gt(0).finite(),\n      })\n      .strict(),\n  },\n  'market/:contractId/group': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        contractId: z.string(),\n        groupId: z.string(),\n        remove: z.boolean().default(false),\n      })\n      .strict(),\n    returns: {} as { success: true },\n  },\n  'market/:contractId/groups': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({ contractId: z.string() }),\n    returns: [] as LiteGroup[],\n  },\n  'market/:contractId/answer': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { newAnswerId: string },\n    props: z\n      .object({\n        contractId: z.string().max(MAX_ANSWER_LENGTH),\n        text: z.string().min(1).max(MAX_ANSWER_LENGTH),\n      })\n      .strict(),\n  },\n  'market/:contractId/block': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ contractId: z.string() }).strict(),\n  },\n  'market/:contractId/unblock': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ contractId: z.string() }).strict(),\n  },\n  unresolve: {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { success: true },\n    props: z\n      .object({\n        contractId: z.string().max(MAX_ANSWER_LENGTH),\n        answerId: z.string().max(MAX_ANSWER_LENGTH).optional(),\n      })\n      .strict(),\n  },\n  leagues: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as League[],\n    props: z\n      .object({\n        userId: z.string().optional(),\n        cohort: z.string().optional(),\n        season: z.coerce.number().optional(),\n      })\n      .strict(),\n  },\n  markets: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as LiteMarket[],\n    props: z\n      .object({\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n        sort: z\n          .enum([\n            'created-time',\n            'updated-time',\n            'last-bet-time',\n            'last-comment-time',\n          ])\n          .optional(),\n        order: z.enum(['asc', 'desc']).optional(),\n        before: z.string().optional(),\n        userId: z.string().optional(),\n        groupId: z.string().optional(),\n      })\n      .strict(),\n  },\n  'search-markets': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as LiteMarket[],\n    props: searchProps,\n  },\n  'search-markets-full': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    preferAuth: true,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Contract[],\n    props: searchProps,\n  },\n  managram: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        amount: z.number().finite(),\n        toIds: z.array(z.string()),\n        message: z.string().max(MAX_COMMENT_LENGTH),\n        groupId: z.string().max(MAX_ID_LENGTH).optional(),\n        token: z.enum(['M$', 'CASH']).default('M$'),\n      })\n      .strict(),\n  },\n  manalink: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { slug: string },\n    props: z\n      .object({\n        amount: z.number().positive().finite().safe(),\n        expiresTime: z.number().lt(MAX_EXPIRES_AT).optional(),\n        maxUses: z.number().optional(),\n        message: z.string().optional(),\n      })\n      .strict(),\n  },\n  donate: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        amount: z.number().positive().finite().safe(),\n        to: z.string(),\n      })\n      .strict(),\n  },\n  'convert-sp-to-mana': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ amount: z.number().positive().finite().safe() }).strict(),\n  },\n  'convert-cash-to-mana': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ amount: z.number().positive().finite().safe() }).strict(),\n  },\n  'request-loan': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({}),\n    returns: {} as { payout: number },\n  },\n  // deprecated. use /txns instead\n  managrams: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: [] as ManaPayTxn[],\n    props: z\n      .object({\n        toId: z.string().optional(),\n        fromId: z.string().optional(),\n        limit: z.coerce.number().gte(0).lte(100).default(100),\n        before: z.coerce.number().optional(),\n        after: z.coerce.number().optional(),\n      })\n      .strict(),\n  },\n  'market/:id/positions': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as ContractMetric[],\n    props: z\n      .object({\n        id: z.string(),\n        userId: z.string().optional(),\n        answerId: z.string().optional(),\n        summaryOnly: z.boolean().optional(),\n        top: z.undefined().or(z.coerce.number()),\n        bottom: z.undefined().or(z.coerce.number()),\n        order: z.enum(['shares', 'profit']).optional(),\n      })\n      .strict(),\n  },\n  me: {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z.object({}),\n    returns: {} as FullUser,\n  },\n  'me/update': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({\n      name: z.string().trim().min(1).optional(),\n      username: z.string().trim().min(1).optional(),\n      avatarUrl: z.string().optional(),\n      bio: z.string().optional(),\n      website: z.string().optional(),\n      twitterHandle: z.string().optional(),\n      discordHandle: z.string().optional(),\n      // settings\n      optOutBetWarnings: z.boolean().optional(),\n      isAdvancedTrader: z.boolean().optional(),\n      //internal\n      seenStreakModal: z.boolean().optional(),\n      shouldShowWelcome: z.boolean().optional(),\n      hasSeenContractFollowModal: z.boolean().optional(),\n      hasSeenLoanModal: z.boolean().optional(),\n    }),\n    returns: {} as FullUser,\n  },\n  'me/delete': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({\n      username: z.string(), // just so you're sure\n    }),\n  },\n  'me/private': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z.object({}),\n    returns: {} as PrivateUser,\n  },\n  'me/private/update': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    props: z\n      .object({\n        email: z.string().email().optional(),\n        apiKey: z.string().optional(),\n        pushToken: z.string().optional(),\n        rejectedPushNotificationsOn: z.number().optional(),\n        lastPromptedToEnablePushNotifications: z.number().optional(),\n        interestedInPushNotifications: z.boolean().optional(),\n        hasSeenAppBannerInNotificationsOn: z.number().optional(),\n        installedAppPlatforms: z.array(z.string()).optional(),\n        paymentInfo: z.string().optional(),\n        lastAppReviewTime: z.number().optional(),\n      })\n      .strict(),\n  },\n  'user/:username': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as FullUser,\n    props: z.object({ username: z.string() }).strict(),\n  },\n  'user/:username/lite': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as DisplayUser,\n    props: z.object({ username: z.string() }).strict(),\n  },\n  'user/by-id/:id': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    // Do not add a caching strategy here. New users need up-to-date data.\n    returns: {} as FullUser,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'user/by-id/:id/lite': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as DisplayUser,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'users/by-id': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as DisplayUser[],\n    props: z.object({ ids: z.array(z.string()) }).strict(),\n  },\n  'users/by-id/balance': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as { id: string; balance: number }[],\n    props: z.object({ ids: z.array(z.string()) }).strict(),\n  },\n  'user/by-id/:id/block': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'user/by-id/:id/unblock': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  users: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as FullUser[],\n    props: z\n      .object({\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n        before: z.string().optional(),\n      })\n      .strict(),\n  },\n  'search-users': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as FullUser[],\n    props: z\n      .object({\n        term: z.string(),\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n        page: z.coerce.number().gte(0).default(0),\n      })\n      .strict(),\n  },\n  'search-contract-positions': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as DisplayUser[],\n    props: z\n      .object({\n        term: z.string(),\n        contractId: z.string(),\n        limit: z.coerce.number().gte(0).lte(100).default(10),\n      })\n      .strict(),\n  },\n  'save-twitch': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        twitchInfo: z.object({\n          twitchName: z.string().optional(),\n          controlToken: z.string().optional(),\n          botEnabled: z.boolean().optional(),\n          needsRelinking: z.boolean().optional(),\n        }),\n      })\n      .strict(),\n  },\n  'set-push-token': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({ pushToken: z.string() }).strict(),\n  },\n  'update-notif-settings': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      type: z.string() as z.ZodType<notification_preference>,\n      medium: z.enum(['email', 'browser', 'mobile']),\n      enabled: z.boolean(),\n    }),\n  },\n  headlines: {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: [] as Headline[],\n    props: z.object({\n      slug: z.enum(['politics', 'ai', 'news']).optional(),\n    }),\n  },\n  'politics-headlines': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: [] as Headline[],\n    props: z.object({}),\n  },\n  'set-news': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { success: true },\n    props: z\n      .object({\n        dashboardIds: z.array(z.string()),\n        endpoint: z.enum(['politics', 'ai', 'news']),\n      })\n      .strict(),\n  },\n  react: {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        contentId: z.string(),\n        contentType: z.enum(['comment', 'contract', 'post']),\n        commentParentType: z.enum(['post']).optional(),\n        remove: z.boolean().optional(),\n        reactionType: z.enum(['like', 'dislike']).optional().default('like'),\n      })\n      .strict(),\n    returns: { success: true },\n  },\n  post: {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    returns: {} as ContractComment,\n    props: z\n      .object({\n        contractId: z.string(),\n        betId: z.string().optional(),\n        commentId: z.string().optional(),\n        content: contentSchema.optional(),\n      })\n      .strict(),\n  },\n  'fetch-link-preview': {\n    method: 'GET',\n    visibility: 'private',\n    authed: false,\n    props: z.object({ url: z.string() }).strict(),\n    cache: 'max-age=86400, stale-while-revalidate=86400',\n    returns: {} as LinkPreview,\n  },\n  'get-related-markets': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    props: z\n      .object({\n        contractId: z.string(),\n        limit: z.coerce.number().gte(0).lte(100),\n        userId: z.string().optional(),\n        question: z.string().optional(),\n        uniqueBettorCount: z.coerce.number().gte(0).optional(),\n      })\n      .strict(),\n    returns: {} as {\n      marketsFromEmbeddings: Contract[]\n    },\n    cache: 'public, max-age=3600, stale-while-revalidate=10',\n  },\n  'get-related-markets-by-group': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: 'public, max-age=3600, stale-while-revalidate=10',\n    returns: {} as {\n      groupContracts: Contract[]\n    },\n    props: z\n      .object({\n        contractId: z.string(),\n        limit: z.coerce.number().gte(0).lte(100),\n        offset: z.coerce.number().gte(0),\n      })\n      .strict(),\n  },\n  'unlist-and-cancel-user-contracts': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        userId: z.string(),\n      })\n      .strict(),\n  },\n  'get-boost-analytics': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: false,\n    props: z\n      .object({\n        contractId: z.string(),\n      })\n      .strict(),\n    returns: {} as {\n      uniqueViewers: number\n      totalViews: number\n      uniquePromotedViewers: number\n      totalPromotedViews: number\n      boostPeriods: {\n        startTime: string\n        endTime: string\n      }[]\n    },\n  },\n  'get-seen-market-ids': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      contractIds: z.array(z.string()),\n      types: z.array(z.enum(['page', 'card', 'promoted'])).optional(),\n      since: z.number(),\n    }),\n    returns: [] as string[],\n  },\n  'search-groups': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    // Is there a way to infer return { lite:[] as LiteGroup[] } if type is 'lite'?\n    returns: {\n      full: [] as Group[],\n      lite: [] as LiteGroup[],\n    },\n    props: SearchGroupParams(SearchGroupShape),\n  },\n  'search-my-groups': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {\n      full: [] as Group[],\n      lite: [] as LiteGroup[],\n    },\n    props: SearchGroupParams(MySearchGroupShape),\n  },\n  'get-groups-with-top-contracts': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as { topic: Topic; contracts: Contract[] }[],\n    props: z.object({}),\n  },\n  'get-balance-changes': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: [] as AnyBalanceChangeType[],\n    props: z\n      .object({\n        before: z.coerce.number().optional(),\n        after: z.coerce.number().default(0),\n        userId: z.string(),\n      })\n      .strict(),\n  },\n  'get-partner-stats': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z\n      .object({\n        userId: z.string(),\n      })\n      .strict(),\n    returns: {} as {\n      status: 'success' | 'error'\n      username: string\n      numContractsCreated: number\n      numUniqueBettors: number\n      numReferrals: number\n      numReferralsWhoRetained: number\n      totalTraderIncome: number\n      totalReferralIncome: number\n      dollarsEarned: number\n    },\n  },\n  'record-contract-view': {\n    method: 'POST',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      userId: z.string().optional(),\n      contractId: z.string(),\n      kind: z.enum(['page', 'card', 'promoted']),\n    }),\n    returns: {} as { status: 'success' },\n  },\n  'record-comment-view': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({\n      contractId: z.string(),\n      commentId: z.string(),\n    }),\n    returns: {} as { status: 'success' },\n  },\n  'record-contract-interaction': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({\n      contractId: z.string(),\n      kind: z.enum([\n        'page bet',\n        'page comment',\n        'page repost',\n        'page like',\n        'card bet',\n        'card click',\n        'promoted click',\n        'card like',\n        'page share',\n        'browse click',\n      ]),\n      commentId: z.string().optional(),\n      feedReasons: z.array(z.string()).optional(),\n      feedType: z.string().optional(),\n      betGroupId: z.string().optional(),\n      betId: z.string().optional(),\n    }),\n    returns: {} as { status: 'success' },\n  },\n  'get-dashboard-from-slug': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      dashboardSlug: z.string(),\n    }),\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as Dashboard,\n  },\n  'get-posts': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    preferAuth: true,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z\n      .object({\n        sortBy: z\n          .enum(['created_time', 'importance_score'])\n          .optional()\n          .default('created_time'),\n        term: z.string().optional(),\n        limit: z.coerce.number().gte(0).lte(200).default(100),\n        userId: z.string().optional(),\n        offset: z.coerce.number().gte(0).default(0),\n        isChangeLog: coerceBoolean.optional(),\n      })\n      .strict(),\n    returns: [] as TopLevelPost[],\n  },\n  'create-public-chat-message': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as ChatMessage,\n    props: z.object({\n      content: contentSchema,\n      channelId: z.string(),\n    }),\n  },\n  'get-followed-groups': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      userId: z.string(),\n    }),\n    returns: {} as {\n      groups: Group[]\n    },\n  },\n  'get-user-portfolio': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      userId: z.string(),\n    }),\n    returns: {} as LivePortfolioMetrics,\n  },\n  'get-user-portfolio-history': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      userId: z.string(),\n      period: z.enum(PERIODS),\n    }),\n    returns: {} as PortfolioMetrics[],\n  },\n  'get-channel-memberships': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      channelId: z.coerce.number().optional(),\n      createdTime: z.string().optional(),\n      lastUpdatedTime: z.string().optional(),\n      limit: z.coerce.number(),\n    }),\n    returns: {\n      channels: [] as PrivateMessageChannel[],\n      memberIdsByChannelId: {} as { [channelId: string]: string[] },\n    },\n  },\n  'get-channel-messages': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      channelId: z.coerce.number(),\n      limit: z.coerce.number(),\n      id: z.coerce.number().optional(),\n    }),\n    returns: [] as PrivateChatMessage[],\n  },\n  'get-channel-seen-time': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      channelIds: z.array(z.coerce.number()),\n    }),\n    returns: [] as [number, string][],\n  },\n  'set-channel-seen-time': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      channelId: z.coerce.number(),\n    }),\n  },\n  'get-feed': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as {\n      contracts: Contract[]\n      comments: ContractComment[]\n      bets: Bet[]\n      reposts: Repost[]\n      idsToReason: { [id: string]: string }\n    },\n    props: z\n      .object({\n        userId: z.string(),\n        limit: z.coerce.number().gt(0).lte(100).default(100),\n        offset: z.coerce.number().gte(0).default(0),\n        ignoreContractIds: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'get-mana-supply': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as ManaSupply,\n    props: z.object({}).strict(),\n  },\n  'get-notifications': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as Notification[],\n    props: z\n      .object({\n        after: z.coerce.number().optional(),\n        limit: z.coerce.number().gte(0).lte(1000).default(100),\n      })\n      .strict(),\n  },\n  'update-mod-report': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        reportId: z.number(),\n        updates: z\n          .object({\n            status: z\n              .enum(['new', 'under review', 'resolved', 'needs admin'])\n              .optional(),\n            mod_note: z.string().optional(),\n          })\n          .partial(),\n      })\n      .strict(),\n    returns: {} as { status: string; report: ModReport },\n  },\n  'get-mod-reports': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        statuses: z.array(\n          z.enum(['new', 'under review', 'resolved', 'needs admin'])\n        ),\n        limit: z.coerce.number().gte(0).lte(100).default(25),\n        offset: z.coerce.number().gte(0).default(0),\n        count: coerceBoolean.optional(),\n      })\n      .strict(),\n    returns: {} as {\n      status: string\n      count?: number\n      reports: ModReport[]\n    },\n  },\n  'get-txn-summary-stats': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as Row<'txn_summary_stats'>[],\n    props: z\n      .object({\n        ignoreCategories: z.array(z.string()).optional(),\n        fromType: z.string().optional(),\n        toType: z.string().optional(),\n        limitDays: z.coerce.number(),\n      })\n      .strict(),\n  },\n  'get-mana-summary-stats': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as Row<'mana_supply_stats'>[],\n    props: z\n      .object({\n        limitDays: z.coerce.number(),\n      })\n      .strict(),\n  },\n  'register-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: verificationParams,\n    returns: {} as RegistrationReturnType,\n  },\n  'get-verification-status-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      documents?: GIDXDocument[]\n      message?: string\n      documentStatus?: string\n    },\n    props: z.object({}),\n  },\n  'get-monitor-status-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n    },\n    props: z.object({\n      DeviceGPS: GPSProps,\n    }),\n  },\n  'get-checkout-session-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n      session?: CheckoutSession\n    },\n    props: z.object({\n      PayActionCode: z.enum(['PAY', 'PAYOUT']).default('PAY'),\n      DeviceGPS: GPSProps,\n      userId: z.string().optional(),\n      ip: z.string().optional(),\n    }),\n  },\n  'complete-checkout-session-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n      gidxMessage?: string | null\n      details?: PaymentDetail[]\n    },\n    props: z.object(checkoutParams),\n  },\n  'complete-cashout-session-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n      gidxMessage?: string | null\n      details?: PaymentDetail[]\n    },\n    props: z.object(cashoutParams),\n  },\n  'complete-cashout-request': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n      gidxMessage?: string | null\n      details?: PaymentDetail[]\n    },\n    props: z.object(cashoutRequestParams),\n  },\n  'get-verification-documents-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      documents: GIDXDocument[]\n      utilityDocuments: GIDXDocument[]\n      idDocuments: GIDXDocument[]\n      rejectedDocuments: GIDXDocument[]\n    },\n    props: z.object({}),\n  },\n  'upload-document-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { status: string },\n    props: z.object({\n      CategoryType: z.number().gte(1).lte(7),\n      fileName: z.string(),\n      fileUrl: z.string(),\n    }),\n  },\n  'identity-callback-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as { Accepted: boolean },\n    props: z.object({\n      MerchantCustomerID: z.string(),\n      NotificationType: z.string(),\n    }),\n  },\n  'payment-callback-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as { MerchantTransactionID: string },\n    props: z\n      .object({\n        MerchantTransactionID: z.string(),\n        TransactionStatusCode: z.coerce.number(),\n        TransactionStatusMessage: z.string(),\n        StatusCode: z.coerce.number(),\n        SessionID: z.string(),\n        MerchantSessionID: z.string(),\n        SessionScore: z.coerce.number(),\n        ReasonCodes: z.array(z.string()).optional(),\n        ServiceType: z.string(),\n        StatusMessage: z.string(),\n      })\n      .strict(),\n  },\n  'get-best-comments': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { comments: ContractComment[]; contracts: Contract[] },\n    props: z.object({\n      limit: z.coerce.number().gte(0).lte(100).default(20),\n      offset: z.coerce.number().gte(0).default(0),\n      ignoreContractIds: z.array(z.string()).optional(),\n      justLikes: z.coerce.number().optional(),\n    }),\n  },\n  'get-redeemable-prize-cash': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { redeemablePrizeCash: number },\n    props: z.object({}),\n  },\n  'get-total-redeemable-prize-cash': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as { total: number },\n    props: z.object({}),\n  },\n  'get-cashouts': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as PendingCashoutStatusData[],\n    props: z\n      .object({\n        limit: z.coerce.number().gte(0).lte(100).default(10),\n        offset: z.coerce.number().gte(0).default(0),\n        userId: z.string().optional(),\n      })\n      .strict(),\n  },\n  'get-kyc-stats': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({}),\n    returns: {} as {\n      initialVerifications: {\n        count: number\n        day: string\n      }[]\n      phoneVerifications: {\n        count: number\n        day: string\n      }[]\n    },\n  },\n  txns: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z\n      .object({\n        token: z.string().optional(),\n        offset: z.coerce.number().default(0),\n        limit: z.coerce.number().gte(0).lte(100).default(100),\n        before: z.coerce.number().optional(),\n        after: z.coerce.number().optional(),\n        toId: z.string().optional(),\n        fromId: z.string().optional(),\n        category: z.string().optional(),\n        ignoreCategories: z.array(z.string()).optional(),\n      })\n      .strict(),\n    returns: [] as Txn[],\n  },\n  'generate-ai-market-suggestions': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: [] as AIGeneratedMarket[],\n    props: z\n      .object({\n        prompt: z.string(),\n        existingTitles: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'generate-ai-description': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { description: JSONContent | undefined },\n    props: z\n      .object({\n        question: z.string(),\n        description: z.string().optional(),\n        answers: z.array(z.string()).optional(),\n        outcomeType: z.string().optional(),\n        shouldAnswersSumToOne: coerceBoolean.optional(),\n        addAnswersMode: z\n          .enum(['DISABLED', 'ONLY_CREATOR', 'ANYONE'])\n          .optional(),\n      })\n      .strict(),\n  },\n  'generate-ai-answers': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as {\n      answers: string[]\n      addAnswersMode: 'DISABLED' | 'ONLY_CREATOR' | 'ANYONE'\n    },\n    props: z\n      .object({\n        question: z.string(),\n        answers: z.array(z.string()),\n        shouldAnswersSumToOne: coerceBoolean,\n        description: z.string().optional(),\n      })\n      .strict(),\n  },\n  'get-monthly-bets-2024': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ userId: z.string() }),\n    returns: [] as { month: string; bet_count: number; total_amount: number }[],\n  },\n  'get-max-min-profit-2024': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ userId: z.string() }),\n    returns: [] as {\n      profit: number\n      data: Contract\n      answer_id: string | null\n      has_no_shares: boolean\n      has_yes_shares: boolean\n    }[],\n  },\n  'get-next-loan-amount': {\n    method: 'GET',\n    visibility: 'undocumented',\n    cache: DEFAULT_CACHE_STRATEGY,\n    authed: false,\n    returns: {} as { amount: number },\n    props: z.object({\n      userId: z.string(),\n    }),\n  },\n  'create-task': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as Task,\n    props: z\n      .object({\n        text: z.string(),\n        category_id: z.number().optional(),\n        priority: z.number().default(0),\n        assignee_id: z.string().optional(),\n      })\n      .strict(),\n  },\n  'update-task': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z\n      .object({\n        id: z.number(),\n        text: z.string().optional(),\n        completed: z.boolean().optional(),\n        priority: z.number().optional(),\n        category_id: z.number().optional(),\n        archived: z.boolean().optional(),\n        assignee_id: z.string().optional(),\n      })\n      .strict(),\n  },\n  'create-category': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { id: number },\n    props: z\n      .object({\n        name: z.string(),\n        color: z.string().optional(),\n        displayOrder: z.number().optional(),\n      })\n      .strict(),\n  },\n  'get-categories': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { categories: TaskCategory[] },\n    props: z.object({}).strict(),\n  },\n  'update-category': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z\n      .object({\n        categoryId: z.number(),\n        name: z.string().optional(),\n        color: z.string().optional(),\n        displayOrder: z.number().optional(),\n        archived: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  'get-tasks': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { tasks: Task[] },\n    props: z.object({}).strict(),\n  },\n  'is-sports-interested': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { isSportsInterested: boolean },\n    props: z.object({}).strict(),\n  },\n  'get-site-activity': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as {\n      bets: Bet[]\n      comments: CommentWithTotalReplies[]\n      newContracts: Contract[]\n      relatedContracts: Contract[]\n    },\n    props: z\n      .object({\n        limit: z.coerce.number().default(10),\n        offset: z.coerce.number().default(0),\n        blockedUserIds: z.array(z.string()).optional(),\n        blockedGroupSlugs: z.array(z.string()).optional(),\n        blockedContractIds: z.array(z.string()).optional(),\n        topicIds: z.array(z.string()).optional(),\n        types: z\n          .array(z.enum(['bets', 'comments', 'markets', 'limit-orders']))\n          .optional(),\n        minBetAmount: z.coerce.number().optional(),\n        onlyFollowedTopics: coerceBoolean.optional(),\n        onlyFollowedContracts: coerceBoolean.optional(),\n        onlyFollowedUsers: coerceBoolean.optional(),\n        userId: z.string().optional(),\n      })\n      .strict(),\n  },\n  'get-sports-games': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { schedule: any[] },\n    props: z.object({}).strict(),\n  },\n  'get-market-props': {\n    method: 'GET',\n    visibility: 'public',\n    cache: DEFAULT_CACHE_STRATEGY,\n    // Could set authed false and preferAuth with an api secret if we want it to replace static props\n    authed: true,\n    returns: {} as {\n      manaContract: MarketContract\n      chartAnnotations: ChartAnnotation[]\n      topics: Topic[]\n      comments: ContractComment[]\n      pinnedComments: ContractComment[]\n      userPositionsByOutcome: {\n        YES: ContractMetric[]\n        NO: ContractMetric[]\n      }\n      topContractMetrics: ContractMetric[]\n      totalPositions: number\n      dashboards: Dashboard[]\n      cashContract: MarketContract\n      totalManaBets: number\n      totalCashBets: number\n    },\n    props: z.object({\n      slug: z.string().optional(),\n      id: z.string().optional(),\n    }),\n  },\n  'get-user-contract-metrics-with-contracts': {\n    method: 'GET',\n    visibility: 'public',\n    preferAuth: true,\n    authed: false,\n    returns: {} as {\n      metricsByContract: Dictionary<ContractMetric[]>\n      contracts: MarketContract[]\n    },\n    props: z.object({\n      userId: z.string(),\n      limit: z.coerce.number(),\n      offset: z.coerce.number().gte(0).optional(),\n      perAnswer: coerceBoolean.optional(),\n      inMani: coerceBoolean.optional(),\n    }),\n  },\n  validateIap: {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z.object({\n      receipt: z.string(),\n    }),\n  },\n  'check-sports-event': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as { exists: boolean; existingMarket?: LiteMarket },\n    props: z\n      .object({\n        sportsEventId: z.string(),\n      })\n      .strict(),\n  },\n  'comment-reactions': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Reaction[],\n    props: z\n      .object({\n        contentIds: z.array(z.string()),\n        contentType: z.enum(['comment', 'contract']),\n      })\n      .strict(),\n  },\n  'mark-all-notifications-new': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({}).strict(),\n    returns: {} as { success: boolean },\n  },\n  'get-contract-voters': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        contractId: z.string(),\n      })\n      .strict(),\n    returns: [] as DisplayUser[],\n  },\n  'get-contract-option-voters': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ contractId: z.string(), optionId: z.string() }),\n    returns: [] as DisplayUser[],\n  },\n  'purchase-contract-boost': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        contractId: z.string(),\n        startTime: z.number().positive().finite().safe(),\n        method: z.enum(['mana', 'cash']),\n      })\n      .strict(),\n    returns: {} as { success: boolean; checkoutUrl?: string },\n  },\n  'generate-ai-numeric-ranges': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as {\n      thresholds: { answers: string[]; midpoints: number[] }\n      buckets: { answers: string[]; midpoints: number[] }\n    },\n    props: z\n      .object({\n        question: z.string(),\n        min: z.number(),\n        max: z.number(),\n        description: z.string().optional(),\n        unit: z.string(),\n      })\n      .strict(),\n  },\n  'infer-numeric-unit': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as {\n      unit: string\n    },\n    props: z\n      .object({\n        question: z.string(),\n        description: z.string().optional(),\n      })\n      .strict(),\n  },\n  'generate-ai-date-ranges': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as {\n      buckets: { answers: string[]; midpoints: number[] }\n      thresholds: { answers: string[]; midpoints: number[] }\n    },\n    props: z\n      .object({\n        question: z.string(),\n        min: z.string(),\n        max: z.string(),\n        description: z.string().optional(),\n      })\n      .strict(),\n  },\n  'regenerate-numeric-midpoints': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { midpoints: number[] },\n    props: z\n      .object({\n        description: z.string().optional(),\n        question: z.string(),\n        answers: z.array(z.string()),\n        min: z.number(),\n        max: z.number(),\n        unit: z.string(),\n        tab: z.enum(['thresholds', 'buckets']),\n      })\n      .strict(),\n  },\n  'regenerate-date-midpoints': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { midpoints: number[] },\n    props: z\n      .object({\n        description: z.string().optional(),\n        question: z.string(),\n        answers: z.array(z.string()),\n        min: z.string(),\n        max: z.string(),\n        tab: z.enum(['thresholds', 'buckets']),\n      })\n      .strict(),\n  },\n\n  'generate-concise-title': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        question: z.string(),\n      })\n      .strict(),\n    returns: {} as { title: string },\n  },\n  'get-close-date': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        question: z.string(),\n        utcOffset: z.number().optional(),\n      })\n      .strict(),\n    returns: {} as { closeTime: number },\n  },\n  'refer-user': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        referredByUsername: z.string(),\n        contractId: z.string().optional(),\n      })\n      .strict(),\n    returns: {} as { success: boolean },\n  },\n\n  'save-market-draft': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { id: number },\n    props: z\n      .object({\n        data: z.object({\n          question: z.string(),\n          description: z.any().optional(),\n          outcomeType: z.string(),\n          answers: z.array(z.string()).optional(),\n          closeDate: z.string().optional(),\n          closeHoursMinutes: z.string().optional(),\n          visibility: z.string(),\n          selectedGroups: z.array(z.any()),\n          savedAt: z.number(),\n        }),\n      })\n      .strict(),\n  },\n\n  'get-market-drafts': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: [] as MarketDraft[],\n    props: z.object({}).strict(),\n  },\n\n  'delete-market-draft': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z\n      .object({\n        id: z.coerce.number(),\n      })\n      .strict(),\n  },\n  'get-season-info': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      season: z.coerce.number().int().positive().optional(),\n    }),\n    returns: {} as {\n      season: number\n      startTime: number // epoch ms\n      endTime: number | null // epoch ms, null if a *mystery* for clients\n      status: 'active' | 'processing' | 'complete'\n    },\n  },\n  'mark-notification-read': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z\n      .object({\n        notificationId: z.string(),\n      })\n      .strict(),\n  },\n  'dismiss-user-report': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        reportId: z.string(),\n      })\n      .strict(),\n    returns: {} as { success: boolean },\n  },\n  'create-post': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { post: TopLevelPost },\n    props: z\n      .object({\n        title: z.string().min(1).max(120),\n        content: contentSchema,\n        isAnnouncement: z.boolean().optional(),\n        visibility: z.enum(['public', 'unlisted']).optional(),\n        isChangeLog: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  'update-post': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { post: TopLevelPost },\n    props: z\n      .object({\n        id: z.string(),\n        title: z.string().min(1).max(480).optional(),\n        content: contentSchema.optional(),\n        visibility: z.enum(['public', 'unlisted']).optional(),\n      })\n      .strict(),\n  },\n  'create-post-comment': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { comment: PostComment },\n    props: z\n      .object({\n        postId: z.string(),\n        content: contentSchema,\n        replyToCommentId: z.string().optional(),\n      })\n      .strict(),\n  },\n  'update-post-comment': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { comment: PostComment },\n    props: z\n      .object({\n        commentId: z.string(),\n        postId: z.string(),\n        hidden: z.boolean(),\n      })\n      .strict(),\n  },\n  'follow-post': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: true },\n    props: z\n      .object({\n        postId: z.string(),\n        follow: z.boolean(),\n      })\n      .strict(),\n  },\n  'edit-post-comment': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        commentId: z.string(),\n        postId: z.string(),\n        content: contentSchema,\n      })\n      .strict(),\n    returns: {} as { success: boolean },\n  },\n} as const)\n\nexport type APIPath = keyof typeof API\nexport type APISchema<N extends APIPath> = (typeof API)[N]\n\nexport type APIParams<N extends APIPath> = z.input<APISchema<N>['props']>\nexport type ValidatedAPIParams<N extends APIPath> = z.output<\n  APISchema<N>['props']\n>\n\nexport type APIResponse<N extends APIPath> = APISchema<N> extends {\n  returns: Record<string, any>\n}\n  ? APISchema<N>['returns']\n  : void\n\nexport type APIResponseOptionalContinue<N extends APIPath> =\n  | { continue: () => Promise<void>; result: APIResponse<N> }\n  | APIResponse<N>\n"
        },
        {
          "path": "common/src/comment.ts",
          "preContent": "import { type JSONContent } from '@tiptap/core'\nimport { type OnLover } from 'common/love/love-comment'\nimport { type ContractToken, type Visibility } from './contract'\n\nexport const MAX_COMMENT_LENGTH = 10000\n\nexport type AnyCommentType = OnContract | OnPost | OnLover\n\n// Currently, comments are created after the bet, not atomically with the bet.\n// They're uniquely identified by the pair contractId/betId.\nexport type Comment<T extends AnyCommentType = AnyCommentType> = {\n  id: string\n  replyToCommentId?: string\n  userId: string\n\n  /** @deprecated - content now stored as JSON in content*/\n  text?: string\n  content: JSONContent\n  createdTime: number\n\n  // Denormalized, for rendering comments\n  userName: string\n  userUsername: string\n  userAvatarUrl?: string\n  /** @deprecated Not actually deprecated, only in supabase column, and not in data column */\n  likes?: number\n  dislikes?: number\n  hidden?: boolean\n  hiddenTime?: number\n  hiderId?: string\n  pinned?: boolean\n  pinnedTime?: number\n  pinnerId?: string\n  visibility: Visibility\n  editedTime?: number\n  isApi?: boolean\n} & T\n\nexport type OnContract = {\n  commentType: 'contract'\n  contractId: string\n  answerOutcome?: string // reply to answer.id\n  betId?: string\n\n  // denormalized from main contract\n  contractSlug: string\n  contractQuestion: string\n\n  // denormalized from bet\n  betAmount?: number\n  betOutcome?: string\n  betAnswerId?: string\n  // denormalized from the contract you are betting on (may be cash)\n  betToken?: ContractToken\n\n  // Used to respond to another user's bet\n  bettorUsername?: string\n  bettorName?: string\n  betLimitProb?: number\n  betOrderAmount?: number\n  bettorId?: string\n\n  // denormalized based on betting history\n  commenterPositionProb?: number // binary only\n  commenterPositionShares?: number\n  commenterPositionOutcome?: string\n  commenterPositionAnswerId?: string\n\n  bountyAwarded?: number\n  betReplyAmountsByOutcome?: { [outcome: string]: number }\n\n  isRepost?: boolean\n}\n\nexport type ContractComment = Comment<OnContract>\n\nexport type CommentWithTotalReplies = ContractComment & {\n  totalReplies?: number\n}\nexport type OnPost = {\n  commentType: 'post'\n  postId: string\n  postSlug?: string // only available via get-comments api\n  postTitle?: string // only available via get-comments api\n}\nexport type PostComment = Comment<OnPost>\n",
          "postContent": "import { type JSONContent } from '@tiptap/core'\nimport { type ContractToken, type Visibility } from './contract'\n\nexport const MAX_COMMENT_LENGTH = 10000\n\nexport type AnyCommentType = OnContract | OnPost\n\n// Currently, comments are created after the bet, not atomically with the bet.\n// They're uniquely identified by the pair contractId/betId.\nexport type Comment<T extends AnyCommentType = AnyCommentType> = {\n  id: string\n  replyToCommentId?: string\n  userId: string\n\n  /** @deprecated - content now stored as JSON in content*/\n  text?: string\n  content: JSONContent\n  createdTime: number\n\n  // Denormalized, for rendering comments\n  userName: string\n  userUsername: string\n  userAvatarUrl?: string\n  /** @deprecated Not actually deprecated, only in supabase column, and not in data column */\n  likes?: number\n  dislikes?: number\n  hidden?: boolean\n  hiddenTime?: number\n  hiderId?: string\n  pinned?: boolean\n  pinnedTime?: number\n  pinnerId?: string\n  visibility: Visibility\n  editedTime?: number\n  isApi?: boolean\n} & T\n\nexport type OnContract = {\n  commentType: 'contract'\n  contractId: string\n  answerOutcome?: string // reply to answer.id\n  betId?: string\n\n  // denormalized from main contract\n  contractSlug: string\n  contractQuestion: string\n\n  // denormalized from bet\n  betAmount?: number\n  betOutcome?: string\n  betAnswerId?: string\n  // denormalized from the contract you are betting on (may be cash)\n  betToken?: ContractToken\n\n  // Used to respond to another user's bet\n  bettorUsername?: string\n  bettorName?: string\n  betLimitProb?: number\n  betOrderAmount?: number\n  bettorId?: string\n\n  // denormalized based on betting history\n  commenterPositionProb?: number // binary only\n  commenterPositionShares?: number\n  commenterPositionOutcome?: string\n  commenterPositionAnswerId?: string\n\n  bountyAwarded?: number\n  betReplyAmountsByOutcome?: { [outcome: string]: number }\n\n  isRepost?: boolean\n}\n\nexport type ContractComment = Comment<OnContract>\n\nexport type CommentWithTotalReplies = ContractComment & {\n  totalReplies?: number\n}\nexport type OnPost = {\n  commentType: 'post'\n  postId: string\n  postSlug?: string // only available via get-comments api\n  postTitle?: string // only available via get-comments api\n}\nexport type PostComment = Comment<OnPost>\n"
        },
        {
          "path": "common/src/contract.ts",
          "preContent": "import { JSONContent } from '@tiptap/core'\nimport { getDisplayProbability } from 'common/calculate'\nimport { Topic } from 'common/group'\nimport { ChartAnnotation } from 'common/supabase/chart-annotations'\nimport { sum } from 'lodash'\nimport { Answer } from './answer'\nimport { getLiquidity } from './calculate-cpmm'\nimport { ContractComment } from './comment'\nimport { ContractMetric } from './contract-metric'\nimport { CASH_SUFFIX, ENV_CONFIG } from './envs/constants'\nimport { Fees } from './fees'\nimport { PollOption } from './poll-option'\nimport { formatMoney, formatPercent } from './util/format'\nimport { MultiBase64Points } from './chart'\nimport { DAY_MS } from './util/time'\n\n/************************************************\n\nsupabase status: columns exist for\n  slug: text\n  creatorId: text\n  question: text\n  visibility: text\n  mechanism: text\n  outcomeType: text\n  createdTime: timestamp (from millis)\n  closeTime?: timestamp (from millis)\n  resolutionTime?: timestamp (from millis)\n  resolution?: text\n  resolutionProbability?: numeric\n  popularityScore: numeric\n  importanceScore: numeric\n\nany changes to the type of these columns in firestore will require modifying\nthe supabase trigger, or replication of contracts may fail!\n\n*************************************************/\n\ntype AnyContractType =\n  | (CPMM & Binary)\n  | (CPMM & PseudoNumeric)\n  | QuadraticFunding\n  | (CPMM & Stonk)\n  | CPMMMulti\n  | (NonBet & BountiedQuestion)\n  | (NonBet & Poll)\n  | CPMMNumber\n  | MultiNumeric\n  | MultiDate\nexport type Contract<T extends AnyContractType = AnyContractType> = {\n  id: string\n  slug: string // auto-generated; must be unique\n\n  creatorId: string\n  creatorName: string\n  creatorUsername: string\n  creatorAvatarUrl?: string\n  creatorCreatedTime?: number\n\n  question: string\n  description: string | JSONContent // More info about what the contract is about\n  visibility: Visibility\n\n  createdTime: number // Milliseconds since epoch\n  lastUpdatedTime: number // Updated on any change to the market (metadata, bet, comment)\n  lastBetTime?: number\n  lastCommentTime?: number\n  closeTime?: number // When no more trading is allowed\n  deleted?: boolean // If true, don't show market anywhere.\n\n  isResolved: boolean\n  resolutionTime?: number // When the contract creator resolved the market\n  resolution?: string\n  resolutionProbability?: number\n  resolverId?: string\n  isSpicePayout?: boolean\n\n  closeEmailsSent?: number\n\n  volume: number\n  volume24Hours: number\n  elasticity: number\n\n  collectedFees: Fees\n  uniqueBettorCount: number\n  uniqueBettorCountDay: number\n\n  unlistedById?: string\n  featuredLabel?: string\n  isTwitchContract?: boolean\n\n  coverImageUrl?: string\n  isRanked?: boolean\n\n  gptCommentSummary?: string\n\n  token: ContractToken\n  siblingContractId?: string\n\n  /** @deprecated - no longer used */\n  takerAPIOrdersDisabled?: boolean\n\n  // Manifold.love\n  loverUserId1?: string // The user id's of the pair of lovers referenced in the question.\n  loverUserId2?: string // The user id's of the pair of lovers referenced in the question.\n  matchCreatorId?: string // The user id of the person who proposed the match.\n  isLove?: boolean\n\n  /** @deprecated - no more auto-subsidization */\n  isSubsidized?: boolean // NOTE: not backfilled, undefined = true\n  /** @deprecated - try to use group-contracts table instead */\n  groupSlugs?: string[]\n  /** @deprecated - not deprecated, only updated in native column though*/\n  popularityScore: number\n  /** @deprecated - not deprecated, only updated in native column though*/\n  importanceScore: number\n  /** @deprecated - not deprecated, only updated in native column though*/\n  dailyScore: number\n  /** @deprecated - not deprecated, only updated in native column though*/\n  freshnessScore: number\n  /** @deprecated - not deprecated, only updated in native column though*/\n  conversionScore: number\n  /** @deprecated - not deprecated, only updated in native column though*/\n  viewCount: number\n  /** @deprecated - not deprecated, only updated in native column though*/\n  boosted: boolean\n  /** @deprecated - not up-to-date */\n  likedByUserCount?: number\n} & T\n\nexport type ContractToken = 'MANA' | 'CASH'\nexport type CPMMContract = Contract & CPMM\nexport type CPMMMultiContract = Contract & CPMMMulti\nexport type CPMMNumericContract = Contract & CPMMNumber\nexport type MultiNumericContract = Contract & MultiNumeric\nexport type MultiDateContract = Contract & MultiDate\nexport type MarketContract =\n  | CPMMContract\n  | CPMMMultiContract\n  | CPMMNumericContract\n  | MultiNumericContract\n  | MultiDateContract\nexport type BinaryContract = Contract & Binary\nexport type PseudoNumericContract = Contract & PseudoNumeric\nexport type QuadraticFundingContract = Contract & QuadraticFunding\nexport type StonkContract = Contract & Stonk\nexport type BountiedQuestionContract = Contract & BountiedQuestion\nexport type PollContract = Contract & Poll\nexport type SportsContract = Contract & Sports\nexport type BinaryOrPseudoNumericContract =\n  | BinaryContract\n  | PseudoNumericContract\n  | StonkContract\n\nexport type CPMM = {\n  mechanism: 'cpmm-1'\n  pool: { [outcome: string]: number }\n  p: number // probability constant in y^p * n^(1-p) = k\n  totalLiquidity: number // for historical reasons, this the total subsidy amount added in Ṁ\n  subsidyPool: number // current value of subsidy pool in Ṁ\n  prob: number\n  probChanges: {\n    day: number\n    week: number\n    month: number\n  }\n}\n\nexport type NonBet = {\n  mechanism: 'none'\n}\n\nexport const NON_BETTING_OUTCOMES: OutcomeType[] = ['BOUNTIED_QUESTION', 'POLL']\nexport const NO_CLOSE_TIME_TYPES: OutcomeType[] = NON_BETTING_OUTCOMES.concat([\n  'STONK',\n])\n\n/**\n * Implemented as a set of cpmm-1 binary contracts, one for each answer.\n * The mechanism is stored among the contract's answers, which each\n * reference this contract id.\n */\nexport type CPMMMulti = {\n  mechanism: 'cpmm-multi-1'\n  outcomeType: 'MULTIPLE_CHOICE'\n  shouldAnswersSumToOne: boolean\n  addAnswersMode?: add_answers_mode\n\n  totalLiquidity: number // for historical reasons, this the total subsidy amount added in Ṁ\n  subsidyPool: number // current value of subsidy pool in Ṁ\n  specialLiquidityPerAnswer?: number // Special liquidity mode, where initial ante is copied into each answer's pool, with a min probability, and only one answer can resolve YES. shouldAnswersSumToOne must be false.\n\n  // Answers chosen on resolution, with the weights of each answer.\n  // Weights sum to 100 if shouldAnswersSumToOne is true. Otherwise, range from 0 to 100 for each answerId.\n  resolutions?: { [answerId: string]: number }\n\n  // NOTE: This field is stored in the answers table and must be denormalized to the client.\n  answers: Answer[]\n  sort?: SortType\n}\n\nexport const isSpecialLoveContract = (contract: Contract) =>\n  contract.mechanism === 'cpmm-multi-1' &&\n  contract.outcomeType !== 'NUMBER' &&\n  contract.outcomeType !== 'MULTI_NUMERIC' &&\n  contract.outcomeType !== 'DATE' &&\n  contract.specialLiquidityPerAnswer\n\nexport type CPMMNumber = {\n  mechanism: 'cpmm-multi-1'\n  outcomeType: 'NUMBER'\n  shouldAnswersSumToOne: true\n  addAnswersMode: 'DISABLED'\n  max: number\n  min: number\n\n  totalLiquidity: number // for historical reasons, this the total subsidy amount added in Ṁ\n  subsidyPool: number // current value of subsidy pool in Ṁ\n\n  // Answers chosen on resolution, with the weights of each answer.\n  // Weights sum to 100 if shouldAnswersSumToOne is true. Otherwise, range from 0 to 100 for each answerId.\n  resolutions?: { [answerId: string]: number }\n\n  // NOTE: This field is stored in the answers table and must be denormalized to the client.\n  answers: Answer[]\n  sort?: SortType\n}\n\nexport type add_answers_mode = 'DISABLED' | 'ONLY_CREATOR' | 'ANYONE'\n\nexport type QuadraticFunding = {\n  outcomeType: 'QUADRATIC_FUNDING'\n  mechanism: 'qf'\n  answers: any[]\n  // Mapping of how much each user has contributed to the matching pool\n  // Note: Our codebase assumes every contract has a pool, which is why this isn't just a constant\n  pool: { M$: number }\n\n  // Used when the funding round pays out\n  resolution?: 'MKT' | 'CANCEL'\n  resolutions?: { [outcome: string]: number } // Used for MKT resolution.\n}\n\nexport type Binary = {\n  outcomeType: 'BINARY'\n  initialProbability: number\n  resolutionProbability?: number // Used for BINARY markets resolved to MKT\n  resolution?: resolution\n}\n\nexport type PseudoNumeric = {\n  outcomeType: 'PSEUDO_NUMERIC'\n  min: number\n  max: number\n  isLogScale: boolean\n  resolutionValue?: number\n\n  // same as binary market; map everything to probability\n  initialProbability: number\n  resolutionProbability?: number\n}\n\nexport type Number = {\n  outcomeType: 'NUMBER'\n  answers: Answer[]\n  min: number\n  max: number\n  resolution?: string | 'MKT' | 'CANCEL'\n  resolutions?: { [outcome: string]: number } // Used for MKT resolution.\n}\n\nexport type MultiNumeric = {\n  mechanism: 'cpmm-multi-1'\n  outcomeType: 'MULTI_NUMERIC'\n  unit: string\n  answers: Answer[]\n  shouldAnswersSumToOne: boolean\n  addAnswersMode: 'DISABLED'\n  totalLiquidity: number\n  subsidyPool: number\n  resolutions?: { [answerId: string]: number }\n  resolution?: string | 'CHOOSE_MULTIPLE' | 'CANCEL'\n  sort?: SortType\n}\n\nexport type MultiDate = Omit<MultiNumeric, 'outcomeType' | 'unit'> & {\n  outcomeType: 'DATE'\n  timezone: string\n  display?: 'clock'\n}\n\nexport type Stonk = {\n  outcomeType: 'STONK'\n  initialProbability: number\n}\n\nexport type BountiedQuestion = {\n  outcomeType: 'BOUNTIED_QUESTION'\n  totalBounty: number\n  bountyLeft: number\n  /** @deprecated */\n  bountyTxns?: string[]\n\n  // Special mode where bounty pays out automatically in proportion to likes over 48 hours.\n  isAutoBounty?: boolean\n}\n\nexport type PollVoterVisibility = 'creator' | 'everyone'\n\nexport type Poll = {\n  outcomeType: 'POLL'\n  options: PollOption[]\n  resolutions?: string[]\n  voterVisibility?: PollVoterVisibility\n}\n\nexport type Sports = {\n  sportsStartTimestamp: string\n  sportsEventId: string\n  sportsLeague: string\n}\n\nexport type MultiContract =\n  | CPMMMultiContract\n  | CPMMNumericContract\n  | MultiNumericContract\n  | MultiDateContract\n\ntype AnyOutcomeType =\n  | Binary\n  | QuadraticFunding\n  | Stonk\n  | BountiedQuestion\n  | Poll\n  | Number\n  | CPMMMulti\n  | PseudoNumeric\n  | MultiNumeric\n  | MultiDate\n\nexport type OutcomeType = AnyOutcomeType['outcomeType']\nexport type resolution = 'YES' | 'NO' | 'MKT' | 'CANCEL'\nexport const RESOLUTIONS = ['YES', 'NO', 'MKT', 'CANCEL'] as const\nexport const CREATEABLE_OUTCOME_TYPES = [\n  'BINARY',\n  'MULTIPLE_CHOICE',\n  'PSEUDO_NUMERIC',\n  'STONK',\n  'BOUNTIED_QUESTION',\n  'POLL',\n  'NUMBER',\n  'MULTI_NUMERIC',\n  'DATE',\n] as const\n\nexport const CREATEABLE_NON_PREDICTIVE_OUTCOME_TYPES = [\n  'POLL',\n  'BOUNTIED_QUESTION',\n]\n\nexport type CreateableOutcomeType = (typeof CREATEABLE_OUTCOME_TYPES)[number]\n\nexport const renderResolution = (resolution: string, prob?: number) => {\n  return (\n    {\n      YES: 'YES',\n      NO: 'NO',\n      CANCEL: 'N/A',\n      MKT: formatPercent(prob ?? 0),\n    }[resolution] || resolution\n  )\n}\n\nexport function contractPathWithoutContract(\n  creatorUsername: string,\n  slug: string\n) {\n  return `/${creatorUsername}/${slug}`\n}\n\nexport function contractUrl(contract: Contract) {\n  return `https://${ENV_CONFIG.domain}${contractPath(contract)}`\n}\n\nexport function contractPool(contract: Contract) {\n  return contract.mechanism === 'cpmm-1'\n    ? formatMoney(contract.totalLiquidity)\n    : contract.mechanism === 'cpmm-multi-1'\n    ? formatMoney(\n        sum(\n          contract.answers.map((a) =>\n            getLiquidity({ YES: a.poolYes, NO: a.poolNo })\n          )\n        )\n      )\n    : 'Empty pool'\n}\n\nexport const isBinaryMulti = (contract: Contract) =>\n  contract.mechanism === 'cpmm-multi-1' &&\n  contract.outcomeType !== 'NUMBER' &&\n  contract.outcomeType !== 'MULTI_NUMERIC' &&\n  contract.outcomeType !== 'DATE' &&\n  contract.answers.length === 2 &&\n  contract.addAnswersMode === 'DISABLED' &&\n  contract.shouldAnswersSumToOne\n// contract.createdTime > 1708574059795 // In case we don't want to convert pre-commit contracts\n\nexport const isSportsContract = (\n  contract: Contract\n): contract is SportsContract => 'sportsEventId' in contract\n\nexport const getMainBinaryMCAnswer = (contract: Contract) =>\n  isBinaryMulti(contract) && contract.mechanism === 'cpmm-multi-1'\n    ? contract.answers[0]\n    : undefined\n\nexport const getBinaryMCProb = (prob: number, outcome: 'YES' | 'NO' | string) =>\n  outcome === 'YES' ? prob : 1 - prob\n\nexport function getBinaryProbPercent(contract: BinaryContract) {\n  return formatPercent(getDisplayProbability(contract))\n}\n\nexport function tradingAllowed(contract: Contract, answer?: Answer) {\n  return (\n    !contract.isResolved &&\n    (!contract.closeTime || contract.closeTime > Date.now()) &&\n    contract.mechanism !== 'none' &&\n    (!answer || !answer.resolution)\n  )\n}\n\nexport const MAX_QUESTION_LENGTH = 120\nexport const MAX_DESCRIPTION_LENGTH = 16000\n\nexport const CPMM_MIN_POOL_QTY = 0.01\nexport const NUMBER_BUCKETS_MAX = 50\nexport const NUMBER_CREATION_ENABLED = false\n\nexport type Visibility = 'public' | 'unlisted'\nexport const VISIBILITIES = ['public', 'unlisted'] as const\n\nexport const SORTS = [\n  { label: 'High %', value: 'prob-desc' },\n  { label: 'Low %', value: 'prob-asc' },\n  { label: 'Oldest', value: 'old' },\n  { label: 'Newest', value: 'new' },\n  { label: 'Trending', value: 'liquidity' },\n  { label: 'A-Z', value: 'alphabetical' },\n] as const\n\nexport type SortType = (typeof SORTS)[number]['value']\n\nexport const MINUTES_ALLOWED_TO_UNRESOLVE = 10\n\nexport function contractPath(contract: {\n  creatorUsername: string\n  slug: string\n}) {\n  return `/${contract.creatorUsername}/${contract.slug}`\n}\n\nexport function twombaContractPath(contract: {\n  creatorUsername: string\n  slug: string\n  token?: ContractToken\n}) {\n  const isCashContract = contract.token == 'CASH'\n  const cleanedSlug = contract.slug.replace(new RegExp(`${CASH_SUFFIX}$`), '')\n  return `/${contract.creatorUsername}/${cleanedSlug}${\n    isCashContract ? '?play=false' : '?play=true'\n  }`\n}\n\nexport type CashType = {\n  contract: Contract\n  lastBetTime?: number\n  pointsString: string\n  multiPointsString: MultiBase64Points\n  totalPositions: number\n  totalBets: number\n}\n\nexport type ContractParams = {\n  contract: Contract\n  lastBetTime?: number\n  pointsString?: string\n  multiPointsString?: MultiBase64Points\n  comments: ContractComment[]\n  totalPositions: number\n  totalBets: number\n  topContractMetrics: ContractMetric[]\n  relatedContracts: Contract[]\n  chartAnnotations: ChartAnnotation[]\n  topics: Topic[]\n  dashboards: { slug: string; title: string }[]\n  pinnedComments: ContractComment[]\n  cash?: CashType\n}\n\nexport type MaybeAuthedContractParams =\n  | {\n      state: 'authed'\n      params: ContractParams\n    }\n  | {\n      state: 'deleted'\n    }\n\nexport const MAX_CPMM_PROB = 0.99\nexport const MIN_CPMM_PROB = 0.01\nexport const MAX_STONK_PROB = 0.95\nexport const MIN_STONK_PROB = 0.2\n\nexport const isMarketRanked = (contract: Contract) =>\n  contract.isRanked != false &&\n  contract.visibility === 'public' &&\n  contract.deleted !== true\n\nexport const PROFIT_CUTOFF_TIME = 1715805887741\nexport const DPM_CUTOFF_TIMESTAMP = '2023-08-01 18:06:58.813000 +00:00'\nexport const getAdjustedProfit = (\n  contract: Contract,\n  profit: number,\n  answers: Answer[] | undefined,\n  answerId: string | null\n) => {\n  if (contract.mechanism === 'cpmm-multi-1') {\n    // Null answerId stands for the summary of all answer metrics\n    if (!answerId) {\n      return isMarketRanked(contract) &&\n        contract.resolutionTime &&\n        contract.resolutionTime <= PROFIT_CUTOFF_TIME &&\n        contract.createdTime > Date.parse(DPM_CUTOFF_TIMESTAMP)\n        ? 9 * profit\n        : isMarketRanked(contract)\n        ? undefined\n        : -1 * profit\n    }\n    const answer = answers?.find((a) => a.id === answerId)\n    if (!answer) {\n      console.log(\n        `answer with id ${answerId} not found, but is required for cpmm-multi-1 contract: ${contract.id}`\n      )\n      return undefined\n    }\n    return isMarketRanked(contract) &&\n      answer.resolutionTime &&\n      answer.resolutionTime <= PROFIT_CUTOFF_TIME &&\n      contract.createdTime > Date.parse(DPM_CUTOFF_TIMESTAMP)\n      ? 9 * profit\n      : isMarketRanked(contract)\n      ? undefined\n      : -1 * profit\n  }\n\n  return isMarketRanked(contract) &&\n    contract.resolutionTime &&\n    contract.resolutionTime <= PROFIT_CUTOFF_TIME\n    ? 9 * profit\n    : isMarketRanked(contract)\n    ? undefined\n    : -1 * profit\n}\n\n// Add the AIGeneratedMarket type definition here, before the API object\nexport type AIGeneratedMarket = Pick<\n  MarketContract,\n  'question' | 'description'\n> & {\n  outcomeType:\n    | 'INDEPENDENT_MULTIPLE_CHOICE'\n    | 'DEPENDENT_MULTIPLE_CHOICE'\n    | 'BINARY'\n    | 'POLL'\n  descriptionMarkdown: string\n  closeDate: string\n  shouldAnswersSumToOne?: boolean\n  initialProb?: number\n  answers?: string[]\n  reasoning?: string\n  addAnswersMode?: add_answers_mode\n  promptVersion: number\n}\n\nexport const nativeContractColumnsArray = [\n  'data',\n  'importance_score',\n  'freshness_score',\n  'conversion_score',\n  'view_count',\n  'token',\n  'boosted',\n  'daily_score',\n]\n\nexport const clampChange = (currentProb: number, probChange: number) => {\n  if (probChange < 0.01 && probChange > -0.01) return 0\n\n  if (probChange > 0) {\n    // For positive changes, clamp to min of change and current probability\n    return Math.min(probChange, currentProb)\n  } else {\n    // For negative changes, clamp to min of absolute change and (1 - currentProb)\n    return -Math.min(Math.abs(probChange), 1 - currentProb)\n  }\n}\n\nexport const dayProbChange = (contract: CPMMContract) => {\n  const { createdTime } = contract\n  if (Date.now() - createdTime < DAY_MS) {\n    return 0\n  }\n  const change = Math.abs(\n    Math.round(clampChange(contract.prob, contract.probChanges.day) * 100)\n  )\n  return change > 2 ? change : 0\n}\n",
          "postContent": "import { JSONContent } from '@tiptap/core'\nimport { getDisplayProbability } from 'common/calculate'\nimport { Topic } from 'common/group'\nimport { ChartAnnotation } from 'common/supabase/chart-annotations'\nimport { sum } from 'lodash'\nimport { Answer } from './answer'\nimport { getLiquidity } from './calculate-cpmm'\nimport { ContractComment } from './comment'\nimport { ContractMetric } from './contract-metric'\nimport { CASH_SUFFIX, ENV_CONFIG } from './envs/constants'\nimport { Fees } from './fees'\nimport { PollOption } from './poll-option'\nimport { formatMoney, formatPercent } from './util/format'\nimport { MultiBase64Points } from './chart'\nimport { DAY_MS } from './util/time'\n\n/************************************************\n\nsupabase status: columns exist for\n  slug: text\n  creatorId: text\n  question: text\n  visibility: text\n  mechanism: text\n  outcomeType: text\n  createdTime: timestamp (from millis)\n  closeTime?: timestamp (from millis)\n  resolutionTime?: timestamp (from millis)\n  resolution?: text\n  resolutionProbability?: numeric\n  popularityScore: numeric\n  importanceScore: numeric\n\nany changes to the type of these columns in firestore will require modifying\nthe supabase trigger, or replication of contracts may fail!\n\n*************************************************/\n\ntype AnyContractType =\n  | (CPMM & Binary)\n  | (CPMM & PseudoNumeric)\n  | QuadraticFunding\n  | (CPMM & Stonk)\n  | CPMMMulti\n  | (NonBet & BountiedQuestion)\n  | (NonBet & Poll)\n  | CPMMNumber\n  | MultiNumeric\n  | MultiDate\nexport type Contract<T extends AnyContractType = AnyContractType> = {\n  id: string\n  slug: string // auto-generated; must be unique\n\n  creatorId: string\n  creatorName: string\n  creatorUsername: string\n  creatorAvatarUrl?: string\n  creatorCreatedTime?: number\n\n  question: string\n  description: string | JSONContent // More info about what the contract is about\n  visibility: Visibility\n\n  createdTime: number // Milliseconds since epoch\n  lastUpdatedTime: number // Updated on any change to the market (metadata, bet, comment)\n  lastBetTime?: number\n  lastCommentTime?: number\n  closeTime?: number // When no more trading is allowed\n  deleted?: boolean // If true, don't show market anywhere.\n\n  isResolved: boolean\n  resolutionTime?: number // When the contract creator resolved the market\n  resolution?: string\n  resolutionProbability?: number\n  resolverId?: string\n  isSpicePayout?: boolean\n\n  closeEmailsSent?: number\n\n  volume: number\n  volume24Hours: number\n  elasticity: number\n\n  collectedFees: Fees\n  uniqueBettorCount: number\n  uniqueBettorCountDay: number\n\n  unlistedById?: string\n  featuredLabel?: string\n  isTwitchContract?: boolean\n\n  coverImageUrl?: string\n  isRanked?: boolean\n\n  gptCommentSummary?: string\n\n  token: ContractToken\n  siblingContractId?: string\n\n  /** @deprecated - no longer used */\n  takerAPIOrdersDisabled?: boolean\n\n  // Manifold.love\n  loverUserId1?: string // The user id's of the pair of lovers referenced in the question.\n  loverUserId2?: string // The user id's of the pair of lovers referenced in the question.\n  matchCreatorId?: string // The user id of the person who proposed the match.\n  isLove?: boolean\n\n  /** @deprecated - no more auto-subsidization */\n  isSubsidized?: boolean // NOTE: not backfilled, undefined = true\n  /** @deprecated - try to use group-contracts table instead */\n  groupSlugs?: string[]\n  /** @deprecated - not deprecated, only updated in native column though*/\n  popularityScore: number\n  /** @deprecated - not deprecated, only updated in native column though*/\n  importanceScore: number\n  /** @deprecated - not deprecated, only updated in native column though*/\n  dailyScore: number\n  /** @deprecated - not deprecated, only updated in native column though*/\n  freshnessScore: number\n  /** @deprecated - not deprecated, only updated in native column though*/\n  conversionScore: number\n  /** @deprecated - not deprecated, only updated in native column though*/\n  viewCount: number\n  /** @deprecated - not deprecated, only updated in native column though*/\n  boosted: boolean\n  /** @deprecated - not up-to-date */\n  likedByUserCount?: number\n} & T\n\nexport type ContractToken = 'MANA' | 'CASH'\nexport type CPMMContract = Contract & CPMM\nexport type CPMMMultiContract = Contract & CPMMMulti\nexport type CPMMNumericContract = Contract & CPMMNumber\nexport type MultiNumericContract = Contract & MultiNumeric\nexport type MultiDateContract = Contract & MultiDate\nexport type MarketContract =\n  | CPMMContract\n  | CPMMMultiContract\n  | CPMMNumericContract\n  | MultiNumericContract\n  | MultiDateContract\nexport type BinaryContract = Contract & Binary\nexport type PseudoNumericContract = Contract & PseudoNumeric\nexport type QuadraticFundingContract = Contract & QuadraticFunding\nexport type StonkContract = Contract & Stonk\nexport type BountiedQuestionContract = Contract & BountiedQuestion\nexport type PollContract = Contract & Poll\nexport type SportsContract = Contract & Sports\nexport type BinaryOrPseudoNumericContract =\n  | BinaryContract\n  | PseudoNumericContract\n  | StonkContract\n\nexport type CPMM = {\n  mechanism: 'cpmm-1'\n  pool: { [outcome: string]: number }\n  p: number // probability constant in y^p * n^(1-p) = k\n  totalLiquidity: number // for historical reasons, this the total subsidy amount added in Ṁ\n  subsidyPool: number // current value of subsidy pool in Ṁ\n  prob: number\n  probChanges: {\n    day: number\n    week: number\n    month: number\n  }\n}\n\nexport type NonBet = {\n  mechanism: 'none'\n}\n\nexport const NON_BETTING_OUTCOMES: OutcomeType[] = ['BOUNTIED_QUESTION', 'POLL']\nexport const NO_CLOSE_TIME_TYPES: OutcomeType[] = NON_BETTING_OUTCOMES.concat([\n  'STONK',\n])\n\n/**\n * Implemented as a set of cpmm-1 binary contracts, one for each answer.\n * The mechanism is stored among the contract's answers, which each\n * reference this contract id.\n */\nexport type CPMMMulti = {\n  mechanism: 'cpmm-multi-1'\n  outcomeType: 'MULTIPLE_CHOICE'\n  shouldAnswersSumToOne: boolean\n  addAnswersMode?: add_answers_mode\n\n  totalLiquidity: number // for historical reasons, this the total subsidy amount added in Ṁ\n  subsidyPool: number // current value of subsidy pool in Ṁ\n  specialLiquidityPerAnswer?: number // Special liquidity mode, where initial ante is copied into each answer's pool, with a min probability, and only one answer can resolve YES. shouldAnswersSumToOne must be false.\n\n  // Answers chosen on resolution, with the weights of each answer.\n  // Weights sum to 100 if shouldAnswersSumToOne is true. Otherwise, range from 0 to 100 for each answerId.\n  resolutions?: { [answerId: string]: number }\n\n  // NOTE: This field is stored in the answers table and must be denormalized to the client.\n  answers: Answer[]\n  sort?: SortType\n}\n\nexport type CPMMNumber = {\n  mechanism: 'cpmm-multi-1'\n  outcomeType: 'NUMBER'\n  shouldAnswersSumToOne: true\n  addAnswersMode: 'DISABLED'\n  max: number\n  min: number\n\n  totalLiquidity: number // for historical reasons, this the total subsidy amount added in Ṁ\n  subsidyPool: number // current value of subsidy pool in Ṁ\n\n  // Answers chosen on resolution, with the weights of each answer.\n  // Weights sum to 100 if shouldAnswersSumToOne is true. Otherwise, range from 0 to 100 for each answerId.\n  resolutions?: { [answerId: string]: number }\n\n  // NOTE: This field is stored in the answers table and must be denormalized to the client.\n  answers: Answer[]\n  sort?: SortType\n}\n\nexport type add_answers_mode = 'DISABLED' | 'ONLY_CREATOR' | 'ANYONE'\n\nexport type QuadraticFunding = {\n  outcomeType: 'QUADRATIC_FUNDING'\n  mechanism: 'qf'\n  answers: any[]\n  // Mapping of how much each user has contributed to the matching pool\n  // Note: Our codebase assumes every contract has a pool, which is why this isn't just a constant\n  pool: { M$: number }\n\n  // Used when the funding round pays out\n  resolution?: 'MKT' | 'CANCEL'\n  resolutions?: { [outcome: string]: number } // Used for MKT resolution.\n}\n\nexport type Binary = {\n  outcomeType: 'BINARY'\n  initialProbability: number\n  resolutionProbability?: number // Used for BINARY markets resolved to MKT\n  resolution?: resolution\n}\n\nexport type PseudoNumeric = {\n  outcomeType: 'PSEUDO_NUMERIC'\n  min: number\n  max: number\n  isLogScale: boolean\n  resolutionValue?: number\n\n  // same as binary market; map everything to probability\n  initialProbability: number\n  resolutionProbability?: number\n}\n\nexport type Number = {\n  outcomeType: 'NUMBER'\n  answers: Answer[]\n  min: number\n  max: number\n  resolution?: string | 'MKT' | 'CANCEL'\n  resolutions?: { [outcome: string]: number } // Used for MKT resolution.\n}\n\nexport type MultiNumeric = {\n  mechanism: 'cpmm-multi-1'\n  outcomeType: 'MULTI_NUMERIC'\n  unit: string\n  answers: Answer[]\n  shouldAnswersSumToOne: boolean\n  addAnswersMode: 'DISABLED'\n  totalLiquidity: number\n  subsidyPool: number\n  resolutions?: { [answerId: string]: number }\n  resolution?: string | 'CHOOSE_MULTIPLE' | 'CANCEL'\n  sort?: SortType\n}\n\nexport type MultiDate = Omit<MultiNumeric, 'outcomeType' | 'unit'> & {\n  outcomeType: 'DATE'\n  timezone: string\n  display?: 'clock'\n}\n\nexport type Stonk = {\n  outcomeType: 'STONK'\n  initialProbability: number\n}\n\nexport type BountiedQuestion = {\n  outcomeType: 'BOUNTIED_QUESTION'\n  totalBounty: number\n  bountyLeft: number\n  /** @deprecated */\n  bountyTxns?: string[]\n\n  // Special mode where bounty pays out automatically in proportion to likes over 48 hours.\n  isAutoBounty?: boolean\n}\n\nexport type PollVoterVisibility = 'creator' | 'everyone'\n\nexport type Poll = {\n  outcomeType: 'POLL'\n  options: PollOption[]\n  resolutions?: string[]\n  voterVisibility?: PollVoterVisibility\n}\n\nexport type Sports = {\n  sportsStartTimestamp: string\n  sportsEventId: string\n  sportsLeague: string\n}\n\nexport type MultiContract =\n  | CPMMMultiContract\n  | CPMMNumericContract\n  | MultiNumericContract\n  | MultiDateContract\n\ntype AnyOutcomeType =\n  | Binary\n  | QuadraticFunding\n  | Stonk\n  | BountiedQuestion\n  | Poll\n  | Number\n  | CPMMMulti\n  | PseudoNumeric\n  | MultiNumeric\n  | MultiDate\n\nexport type OutcomeType = AnyOutcomeType['outcomeType']\nexport type resolution = 'YES' | 'NO' | 'MKT' | 'CANCEL'\nexport const RESOLUTIONS = ['YES', 'NO', 'MKT', 'CANCEL'] as const\nexport const CREATEABLE_OUTCOME_TYPES = [\n  'BINARY',\n  'MULTIPLE_CHOICE',\n  'PSEUDO_NUMERIC',\n  'STONK',\n  'BOUNTIED_QUESTION',\n  'POLL',\n  'NUMBER',\n  'MULTI_NUMERIC',\n  'DATE',\n] as const\n\nexport const CREATEABLE_NON_PREDICTIVE_OUTCOME_TYPES = [\n  'POLL',\n  'BOUNTIED_QUESTION',\n]\n\nexport type CreateableOutcomeType = (typeof CREATEABLE_OUTCOME_TYPES)[number]\n\nexport const renderResolution = (resolution: string, prob?: number) => {\n  return (\n    {\n      YES: 'YES',\n      NO: 'NO',\n      CANCEL: 'N/A',\n      MKT: formatPercent(prob ?? 0),\n    }[resolution] || resolution\n  )\n}\n\nexport function contractPathWithoutContract(\n  creatorUsername: string,\n  slug: string\n) {\n  return `/${creatorUsername}/${slug}`\n}\n\nexport function contractUrl(contract: Contract) {\n  return `https://${ENV_CONFIG.domain}${contractPath(contract)}`\n}\n\nexport function contractPool(contract: Contract) {\n  return contract.mechanism === 'cpmm-1'\n    ? formatMoney(contract.totalLiquidity)\n    : contract.mechanism === 'cpmm-multi-1'\n    ? formatMoney(\n        sum(\n          contract.answers.map((a) =>\n            getLiquidity({ YES: a.poolYes, NO: a.poolNo })\n          )\n        )\n      )\n    : 'Empty pool'\n}\n\nexport const isBinaryMulti = (contract: Contract) =>\n  contract.mechanism === 'cpmm-multi-1' &&\n  contract.outcomeType !== 'NUMBER' &&\n  contract.outcomeType !== 'MULTI_NUMERIC' &&\n  contract.outcomeType !== 'DATE' &&\n  contract.answers.length === 2 &&\n  contract.addAnswersMode === 'DISABLED' &&\n  contract.shouldAnswersSumToOne\n// contract.createdTime > 1708574059795 // In case we don't want to convert pre-commit contracts\n\nexport const isSportsContract = (\n  contract: Contract\n): contract is SportsContract => 'sportsEventId' in contract\n\nexport const getMainBinaryMCAnswer = (contract: Contract) =>\n  isBinaryMulti(contract) && contract.mechanism === 'cpmm-multi-1'\n    ? contract.answers[0]\n    : undefined\n\nexport const getBinaryMCProb = (prob: number, outcome: 'YES' | 'NO' | string) =>\n  outcome === 'YES' ? prob : 1 - prob\n\nexport function getBinaryProbPercent(contract: BinaryContract) {\n  return formatPercent(getDisplayProbability(contract))\n}\n\nexport function tradingAllowed(contract: Contract, answer?: Answer) {\n  return (\n    !contract.isResolved &&\n    (!contract.closeTime || contract.closeTime > Date.now()) &&\n    contract.mechanism !== 'none' &&\n    (!answer || !answer.resolution)\n  )\n}\n\nexport const MAX_QUESTION_LENGTH = 120\nexport const MAX_DESCRIPTION_LENGTH = 16000\n\nexport const CPMM_MIN_POOL_QTY = 0.01\nexport const NUMBER_BUCKETS_MAX = 50\nexport const NUMBER_CREATION_ENABLED = false\n\nexport type Visibility = 'public' | 'unlisted'\nexport const VISIBILITIES = ['public', 'unlisted'] as const\n\nexport const SORTS = [\n  { label: 'High %', value: 'prob-desc' },\n  { label: 'Low %', value: 'prob-asc' },\n  { label: 'Oldest', value: 'old' },\n  { label: 'Newest', value: 'new' },\n  { label: 'Trending', value: 'liquidity' },\n  { label: 'A-Z', value: 'alphabetical' },\n] as const\n\nexport type SortType = (typeof SORTS)[number]['value']\n\nexport const MINUTES_ALLOWED_TO_UNRESOLVE = 10\n\nexport function contractPath(contract: {\n  creatorUsername: string\n  slug: string\n}) {\n  return `/${contract.creatorUsername}/${contract.slug}`\n}\n\nexport function twombaContractPath(contract: {\n  creatorUsername: string\n  slug: string\n  token?: ContractToken\n}) {\n  const isCashContract = contract.token == 'CASH'\n  const cleanedSlug = contract.slug.replace(new RegExp(`${CASH_SUFFIX}$`), '')\n  return `/${contract.creatorUsername}/${cleanedSlug}${\n    isCashContract ? '?play=false' : '?play=true'\n  }`\n}\n\nexport type CashType = {\n  contract: Contract\n  lastBetTime?: number\n  pointsString: string\n  multiPointsString: MultiBase64Points\n  totalPositions: number\n  totalBets: number\n}\n\nexport type ContractParams = {\n  contract: Contract\n  lastBetTime?: number\n  pointsString?: string\n  multiPointsString?: MultiBase64Points\n  comments: ContractComment[]\n  totalPositions: number\n  totalBets: number\n  topContractMetrics: ContractMetric[]\n  relatedContracts: Contract[]\n  chartAnnotations: ChartAnnotation[]\n  topics: Topic[]\n  dashboards: { slug: string; title: string }[]\n  pinnedComments: ContractComment[]\n  cash?: CashType\n}\n\nexport type MaybeAuthedContractParams =\n  | {\n      state: 'authed'\n      params: ContractParams\n    }\n  | {\n      state: 'deleted'\n    }\n\nexport const MAX_CPMM_PROB = 0.99\nexport const MIN_CPMM_PROB = 0.01\nexport const MAX_STONK_PROB = 0.95\nexport const MIN_STONK_PROB = 0.2\n\nexport const isMarketRanked = (contract: Contract) =>\n  contract.isRanked != false &&\n  contract.visibility === 'public' &&\n  contract.deleted !== true\n\nexport const PROFIT_CUTOFF_TIME = 1715805887741\nexport const DPM_CUTOFF_TIMESTAMP = '2023-08-01 18:06:58.813000 +00:00'\nexport const getAdjustedProfit = (\n  contract: Contract,\n  profit: number,\n  answers: Answer[] | undefined,\n  answerId: string | null\n) => {\n  if (contract.mechanism === 'cpmm-multi-1') {\n    // Null answerId stands for the summary of all answer metrics\n    if (!answerId) {\n      return isMarketRanked(contract) &&\n        contract.resolutionTime &&\n        contract.resolutionTime <= PROFIT_CUTOFF_TIME &&\n        contract.createdTime > Date.parse(DPM_CUTOFF_TIMESTAMP)\n        ? 9 * profit\n        : isMarketRanked(contract)\n        ? undefined\n        : -1 * profit\n    }\n    const answer = answers?.find((a) => a.id === answerId)\n    if (!answer) {\n      console.log(\n        `answer with id ${answerId} not found, but is required for cpmm-multi-1 contract: ${contract.id}`\n      )\n      return undefined\n    }\n    return isMarketRanked(contract) &&\n      answer.resolutionTime &&\n      answer.resolutionTime <= PROFIT_CUTOFF_TIME &&\n      contract.createdTime > Date.parse(DPM_CUTOFF_TIMESTAMP)\n      ? 9 * profit\n      : isMarketRanked(contract)\n      ? undefined\n      : -1 * profit\n  }\n\n  return isMarketRanked(contract) &&\n    contract.resolutionTime &&\n    contract.resolutionTime <= PROFIT_CUTOFF_TIME\n    ? 9 * profit\n    : isMarketRanked(contract)\n    ? undefined\n    : -1 * profit\n}\n\n// Add the AIGeneratedMarket type definition here, before the API object\nexport type AIGeneratedMarket = Pick<\n  MarketContract,\n  'question' | 'description'\n> & {\n  outcomeType:\n    | 'INDEPENDENT_MULTIPLE_CHOICE'\n    | 'DEPENDENT_MULTIPLE_CHOICE'\n    | 'BINARY'\n    | 'POLL'\n  descriptionMarkdown: string\n  closeDate: string\n  shouldAnswersSumToOne?: boolean\n  initialProb?: number\n  answers?: string[]\n  reasoning?: string\n  addAnswersMode?: add_answers_mode\n  promptVersion: number\n}\n\nexport const nativeContractColumnsArray = [\n  'data',\n  'importance_score',\n  'freshness_score',\n  'conversion_score',\n  'view_count',\n  'token',\n  'boosted',\n  'daily_score',\n]\n\nexport const clampChange = (currentProb: number, probChange: number) => {\n  if (probChange < 0.01 && probChange > -0.01) return 0\n\n  if (probChange > 0) {\n    // For positive changes, clamp to min of change and current probability\n    return Math.min(probChange, currentProb)\n  } else {\n    // For negative changes, clamp to min of absolute change and (1 - currentProb)\n    return -Math.min(Math.abs(probChange), 1 - currentProb)\n  }\n}\n\nexport const dayProbChange = (contract: CPMMContract) => {\n  const { createdTime } = contract\n  if (Date.now() - createdTime < DAY_MS) {\n    return 0\n  }\n  const change = Math.abs(\n    Math.round(clampChange(contract.prob, contract.probChanges.day) * 100)\n  )\n  return change > 2 ? change : 0\n}\n"
        },
        {
          "path": "common/src/envs/constants.ts",
          "preContent": "import { escapeRegExp } from 'lodash'\nimport { DEV_CONFIG } from './dev'\nimport { EnvConfig, PROD_CONFIG } from './prod'\n\nexport const ENV = (process.env.NEXT_PUBLIC_FIREBASE_ENV ?? 'PROD') as\n  | 'PROD'\n  | 'DEV'\n\nexport const CONFIGS: { [env: string]: EnvConfig } = {\n  PROD: PROD_CONFIG,\n  DEV: DEV_CONFIG,\n}\n\nexport const TWOMBA_CASHOUT_ENABLED = true\nexport const SWEEP_PRODUCTION_ENABLED = false\nexport const SPICE_PRODUCTION_ENABLED = false\nexport const SPICE_TO_MANA_CONVERSION_RATE = 1\nexport const CASH_TO_MANA_CONVERSION_RATE = 100\nexport const MIN_CASH_DONATION = 25\nexport const MIN_SPICE_DONATION = 25000\nexport const CASH_TO_CHARITY_DOLLARS = 1\nexport const NY_FL_CASHOUT_LIMIT = 5000\nexport const DOLLAR_PURCHASE_LIMIT = 5000\n\nexport const SPICE_NAME = 'Prize Point'\nexport const SWEEPIES_NAME = 'sweepcash'\nexport const SPICE_MARKET_TOOLTIP = `Prize market! Earn ${SPICE_NAME}s on resolution`\nexport const SWEEPIES_MARKET_TOOLTIP = `Sweepstakes market! Win real cash prizes.`\nexport const CASH_SUFFIX = '--cash'\n\nexport const TRADE_TERM = 'bet'\nexport const TRADED_TERM = 'bet'\nexport const TRADING_TERM = 'betting'\nexport const TRADER_TERM = 'trader'\n\nexport const ENV_CONFIG = CONFIGS[ENV]\n\nexport function isAdminId(id: string) {\n  return ENV_CONFIG.adminIds.includes(id)\n}\n\nexport function isModId(id: string) {\n  return MOD_IDS.includes(id)\n}\nexport function isSweepstakesModId(id: string) {\n  return SWEEPSTAKES_MOD_IDS.includes(id)\n}\nexport const DOMAIN = ENV_CONFIG.domain\nexport const LOVE_DOMAIN = ENV_CONFIG.loveDomain\nexport const LOVE_DOMAIN_ALTERNATE = ENV_CONFIG.loveDomainAlternate\nexport const FIREBASE_CONFIG = ENV_CONFIG.firebaseConfig\nexport const PROJECT_ID = ENV_CONFIG.firebaseConfig.projectId\nexport const IS_PRIVATE_MANIFOLD = ENV_CONFIG.visibility === 'PRIVATE'\n\nexport const AUTH_COOKIE_NAME = `FBUSER_${PROJECT_ID.toUpperCase().replace(\n  /-/g,\n  '_'\n)}`\n\n// Manifold's domain or any subdomains thereof\nexport const CORS_ORIGIN_MANIFOLD = new RegExp(\n  '^https?://(?:[a-zA-Z0-9\\\\-]+\\\\.)*' + escapeRegExp(ENV_CONFIG.domain) + '$'\n)\n// Manifold love domain or any subdomains thereof\nexport const CORS_ORIGIN_MANIFOLD_LOVE = new RegExp(\n  '^https?://(?:[a-zA-Z0-9\\\\-]+\\\\.)*' +\n    escapeRegExp(ENV_CONFIG.loveDomain) +\n    '$'\n)\n// Manifold love domain or any subdomains thereof\nexport const CORS_ORIGIN_MANIFOLD_LOVE_ALTERNATE = new RegExp(\n  '^https?://(?:[a-zA-Z0-9\\\\-]+\\\\.)*' +\n    escapeRegExp(ENV_CONFIG.loveDomainAlternate) +\n    '$'\n)\n\nexport const CORS_ORIGIN_CHARITY = new RegExp(\n  '^https?://(?:[a-zA-Z0-9\\\\-]+\\\\.)*' + escapeRegExp('manifund.org') + '$'\n)\n\n// Vercel deployments, used for testing.\nexport const CORS_ORIGIN_VERCEL = new RegExp(\n  '^https?://[a-zA-Z0-9\\\\-]+' + escapeRegExp('mantic.vercel.app') + '$'\n)\n// Any localhost server on any port\nexport const CORS_ORIGIN_LOCALHOST = /^http:\\/\\/localhost:\\d+$/\n\n// TODO: These should maybe be part of the env config?\nexport const BOT_USERNAMES = [\n  'TenShinoe908',\n  'subooferbot',\n  'pos',\n  'v',\n  'acc',\n  'jerk',\n  'snap',\n  'ArbitrageBot',\n  'MarketManagerBot',\n  'Botlab',\n  'JuniorBot',\n  'ManifoldDream',\n  'ManifoldBugs',\n  'ACXBot',\n  'JamesBot',\n  'RyanBot',\n  'trainbot',\n  'runebot',\n  'LiquidityBonusBot',\n  '538',\n  'FairlyRandom',\n  'Anatolii',\n  'JeremyK',\n  'Botmageddon',\n  'SmartBot',\n  'ShifraGazsi',\n  'NiciusBot',\n  'Bot',\n  'Mason',\n  'VersusBot',\n  'GPT4',\n  'EntropyBot',\n  'veat',\n  'ms_test',\n  'arb',\n  'Turbot',\n  'MetaculusBot',\n  'burkebot',\n  'Botflux',\n  '7',\n  'hyperkaehler',\n  'NcyBot',\n  'ithaca',\n  'GigaGaussian',\n  'BottieMcBotface',\n  'Seldon',\n  'OnePercentBot',\n  'arrbit',\n  'ManaMaximizer',\n  'rita',\n  'uhh',\n  'ArkPoint',\n  'EliBot',\n  'manifestussy',\n  'mirrorbot',\n  'JakeBot',\n  'loopsbot',\n  'breezybot',\n  'echo',\n  'Sayaka',\n  'cc7',\n  'Yuna',\n  'ManifoldLove',\n  'chooterb0t',\n  'bonkbot',\n  'NermitBundaloy',\n  'FirstBot',\n  'bawt',\n  'FireTheCEO',\n  'JointBot',\n  'WrenTec',\n  'TigerMcBot',\n  'Euclidean',\n  'manakin',\n  'LUCAtheory',\n  'TunglBot',\n  'timetraveler',\n  'bayesianbot',\n  'CharlesLienBot',\n  'JaguarMcBot',\n  'AImogus',\n  'brake',\n  'brontobot',\n  'OracleBot',\n  'spacedroplet',\n  'AriZernerBot',\n  'PV_bot',\n  'draaglom_bot',\n  'SiriusBOT',\n  'bradbot',\n  'ShrimpLute',\n  'kbot',\n  'ataribot',\n  'RISKBOT',\n  'harmonia',\n  'Dagonet',\n]\n\nexport const MOD_IDS = [\n  'qnIAzz9RamaodeiJSiGZO6xRGC63', // Agh\n  'srFlJRuVlGa7SEJDM4cY9B5k4Lj2', // bayesian\n  'EJQOCF3MfLTFYbhiKncrNefQDBz1', // chrisjbillington\n  'MV9fTVHetcfp3h6CVYzpypIsbyN2', // CodeandSolder\n  'HTbxWFlzWGeHUTiwZvvF0qm8W433', // Conflux\n  '9dAaZrNSx5OT0su6rpusDoG9WPN2', // dglid\n  '5XMvQhA3YgcTzyoJRiNqGWyuB9k2', // dreev\n  '946iB1LqFIR06G7d8q89um57PHh2', // egroj\n  'hqdXgp0jK2YMMhPs067eFK4afEH3', // Eliza\n  'kbHiTAGBahXdX9Z4sW29JpNrB0l2', // Ernie\n  'W4yEF6idSMcNWEVUquowziSCZFI3', // EvanDaniel\n  '2VhlvfTaRqZbFn2jqxk2Am9jgsE2', // Gabrielle\n  'cA1JupYR5AR8btHUs2xvkui7jA93', // Gen\n  'YGZdZUSFQyM8j2YzPaBqki8NBz23', // jack\n  'cgrBqe2O3AU4Dnng7Nc9wuJHLKb2', // jskf\n  '4juQfJkFnwX9nws3dFOpz4gc1mi2', // jacksonpolack\n  'XeQf3ygmrGM1MxdsE3JSlmq8vL42', // Jacy\n  'eSqS9cD5mzYcP2o7FrST8aC5IWn2', // PlasmaBallin (previously JosephNoonan)\n  'JlVpsgzLsbOUT4pajswVMr0ZzmM2', // Joshua\n  '7HhTMy4xECaVKvl5MmEAfVUkRCS2', // KevinBurke\n  'jO7sUhIDTQbAJ3w86akzncTlpRG2', // MichaelWheatley\n  'lkkqZxiWCpOgtJ9ztJcAKz4d9y33', // NathanpmYoung\n  'fSrex43BDjeneNZ4ZLfxllSb8b42', // NcyRocks\n  'BgCeVUcOzkexeJpSPRNomWQaQaD3', // SemioticRivalry\n  'KHX2ThSFtLQlau58hrjtCX7OL2h2', // shankypanky (stefanie)\n  'hUM4SO8a8qhfqT1gEZ7ElTCGSEz2', // Stralor\n  'tO4DwIsujySUwtSnrr2hnU1WJtJ3', // WieDan\n  'oPxjIzlvC5fRbGCaVgkvAiyoXBB2', // mattyb\n  'Iua2KQvL6KYcfGLGNI6PVeGkseo1', // Ziddletwix\n  'Gg7t9vPD4WPD1iPgj9RUFLYTxgH2', // nikki\n  'XNrWcIrA22hpv20fHn4ApoTPsh63', // bagelfan\n  '0k1suGSJKVUnHbCPEhHNpgZPkUP2', // Sinclair\n]\n\nexport const SWEEPSTAKES_MOD_IDS = [\n  'uglwf3YKOZNGjjEXKc5HampOFRE2', // SirSalty\n  'KHX2ThSFtLQlau58hrjtCX7OL2h2', // shankypanky (stefanie)\n  '2VhlvfTaRqZbFn2jqxk2Am9jgsE2', // Gabrielle\n  'HTbxWFlzWGeHUTiwZvvF0qm8W433', // Conflux\n  'YGZdZUSFQyM8j2YzPaBqki8NBz23', // jack\n  'JlVpsgzLsbOUT4pajswVMr0ZzmM2', // Joshua\n]\n\nexport const MVP = ['Eliza', 'Gabrielle', 'jacksonpolack']\n\nexport const VERIFIED_USERNAMES = [\n  'EliezerYudkowsky',\n  'ScottAlexander',\n  'Aella',\n  'ZviMowshowitz',\n  'GavrielK',\n  'CGPGrey',\n  'LexFridman',\n  'patio11',\n  'RichardHanania',\n  'Qualy',\n  'Roko',\n  'JonathanBlow',\n  'DwarkeshPatel',\n  'ByrneHobart',\n  'RobertWiblin',\n  'KelseyPiper',\n  'SpencerGreenberg',\n  'PaulChristiano',\n  'BuckShlegeris',\n  'Natalia',\n  'zero',\n  'OzzieGooen',\n  'OliverHabryka',\n  'Alicorn',\n  'RazibKhan',\n  'JamesMedlock',\n  'Writer',\n  'geohot',\n  'ShayneCoplan',\n  'SanghyeonSeo',\n  'KatjaGrace',\n  'EmmettShear',\n  'CateHall',\n  'RobertSKMiles',\n  'TarekMansour',\n  'DylanMatthews',\n  'RobinHanson',\n  'KevinRoose18ac',\n  'KnowNothing',\n  'SantaPawsSSB',\n  'AndersSandberg',\n  'JosephWeisenthal',\n  'LawrenceLessig',\n  'NatFriedman',\n  'patrissimo',\n  'postjawline',\n  'MatthewYglesias',\n  'MatthewYglesiasvuyf',\n  'BillyMcRascal',\n  'kyootbot',\n  'MaximLott',\n  'liron',\n  'LarsDoucet',\n  'PeterWildeford',\n  'SethWalder',\n  'SneakySly',\n  'ConorSen',\n  'transmissions11',\n  'DanHendrycks',\n  'Cremieux',\n  'tracewoodgrains',\n  'LuigiMangione',\n  'LeahLibresco',\n  'ModernDayDebate',\n  'NickyCase',\n  'TamayBesiroglu',\n]\n\nexport const BANNED_TRADING_USER_IDS = [\n  'zgCIqq8AmRUYVu6AdQ9vVEJN8On1', // firstuserhere aka _deleted_\n  'LIBAoi7tpqeNLYM1xxJ1QJBQqW32', // lastuserhere\n  'p3ADzwIUS3fk0ka80XYEE3OM3S32', // PC\n  '4JuXgDx47xPagH5mcLDqLzUSN5g2', // BTE\n  'iD1ObV4sInhkBXs3Ten96j4Co6O2', // BTE alt\n  'zRMxfUt51RcEIcZkuw6ySiNJYBE3', // BTE alt\n  'wo2LRCvgaNSllK3q0Wnv8hlusTa2', // BTE alt\n  'os2ilMb1d8WDeXxiQAo6btlig1Z2', // BTE alt\n  'zRMxfUt51RcEIcZkuw6ySiNJYBE3', // BTE alt\n  'fnuHBW8dHwZp2TbEt2MKJY9d28V2', // Klob (Caleb)\n  'RK6Nd7IBfMVOcLekfqcN9Ys17qJ2', // PeterNjeim\n]\n\nexport const PARTNER_USER_IDS: string[] = [\n  'sTUV8ejuM2byukNZp7qKP2OKXMx2', // NFL\n  'rFJu0EIdR6RP8d1vHKSh62pbnbH2', // SimonGrayson\n  'cb6PJqGOSVPEUhprDHCKWWMuJqu1', // DanMan314\n  'HTbxWFlzWGeHUTiwZvvF0qm8W433', // Conflux\n  'YGZdZUSFQyM8j2YzPaBqki8NBz23', // jack\n  'hDq0cvn68jbAUVd6aWIU9aSv9ZA2', // strutheo\n  'OEbsAczmbBc4Sl1bacYZNPJLLLc2', // SirCryptomind\n  'JlVpsgzLsbOUT4pajswVMr0ZzmM2', // Joshua\n  'xQqqZqlgcoSxTgPe03BiXmVE2JJ2', // Soli\n  'Iiok8KHMCRfUiwtMq1tl5PeDbA73', // Lion\n  'SqOJYkeySMQjqP3UAypw6DxPx4Z2', // Shump\n  'hqdXgp0jK2YMMhPs067eFK4afEH3', // Eliza\n  'BgCeVUcOzkexeJpSPRNomWQaQaD3', // SemioticRivalry\n  'X1xu1kvOxuevx09xuR2urWfzf7i1', // KeenenWatts\n  '4juQfJkFnwX9nws3dFOpz4gc1mi2', // jacksonpolack\n  '8WEiWcxUd7QLeiveyI8iqbSIffU2', // goblinodds\n  'Iua2KQvL6KYcfGLGNI6PVeGkseo1', // Ziddletwix\n  'GRaWlYn2fNah0bvr6OW28l28nFn1', // cash\n  'ZKkL3lFRFaYfiaT9ZOdiv2iUJBM2', // mint\n  'hRbPwezgxnat6GpJQxoFxq1xgUZ2', // AmmonLam\n  'foOeshHZOET3yMvRTMPINpnb8Bj2', // PunishedFurry\n  'EBGhoFSxRtVBu4617SLZUe1FeJt1', // FranklinBaldo\n  '4xOTMCIOkGesdJft50wVFZFb5IB3', // Tripping\n  'srFlJRuVlGa7SEJDM4cY9B5k4Lj2', // Bayesian\n  'H6b5PWELWfRV6HhyHAlCGq7yJJu2', // AndrewG\n  'EJQOCF3MfLTFYbhiKncrNefQDBz1', // chrisjbillington\n  '7HhTMy4xECaVKvl5MmEAfVUkRCS2', // KevinBurke\n  'oPxjIzlvC5fRbGCaVgkvAiyoXBB2', // mattyb\n  'OdBj5DW6PbYtnImvybpyZzfhb133', // jim\n  'm5K4FlZLo0aeDd5Z7W4xX3TAGHs1', // JeffBerman\n  'LmtawaGf6jO0oFGzth1UCrUXFW82', // AaronSimansky\n]\n\nexport const NEW_USER_HERLPER_IDS = [\n  '2VhlvfTaRqZbFn2jqxk2Am9jgsE2', // Gabrielle\n  'BgCeVUcOzkexeJpSPRNomWQaQaD3', // SemioticRivalry\n  'rQPOELuW5zaapaNPnBYQBMoonk92', // Tumbles\n  'tlmGNz9kjXc2EteizMORes4qvWl2', // Stephen\n  'AJwLWoo3xue32XIiAVrL5SyR1WB2', // Ian\n  'uglwf3YKOZNGjjEXKc5HampOFRE2', // D4vid\n  'cA1JupYR5AR8btHUs2xvkui7jA93', // Genzy\n  'srFlJRuVlGa7SEJDM4cY9B5k4Lj2', // Bayesian\n  'Gg7t9vPD4WPD1iPgj9RUFLYTxgH2', // nikki\n  'OdBj5DW6PbYtnImvybpyZzfhb133', // jim\n]\n\nexport const OPTED_OUT_OF_LEAGUES = [\n  'vuI5upWB8yU00rP7yxj95J2zd952', // ManifoldPolitics\n  '8lZo8X5lewh4hnCoreI7iSc0GxK2', // ManifoldAI\n  'IPTOzEqrpkWmEzh6hwvAyY9PqFb2', // Manifold\n  'tRZZ6ihugZQLXPf6aPRneGpWLmz1', // ManifoldLove\n  'BhNkw088bMNwIFF2Aq5Gg9NTPzz1', // acc\n  'JlVpsgzLsbOUT4pajswVMr0ZzmM2', // Joshua\n  'oPxjIzlvC5fRbGCaVgkvAiyoXBB2', // mattyb\n  'NndHcEmeJhPQ6n7e7yqAPa3Oiih2', // josh\n]\n\nexport const HIDE_FROM_LEADERBOARD_USER_IDS = [\n  'BhNkw088bMNwIFF2Aq5Gg9NTPzz1', // acc\n  'tRZZ6ihugZQLXPf6aPRneGpWLmz1', // ManifoldLove\n]\n\nexport const INSTITUTIONAL_PARTNER_USER_IDS: string[] = []\n\nexport const BEING_DEAD_HEADS = [\n  '6hHpzvRG0pMq8PNJs7RZj2qlZGn2',\n  'AJwLWoo3xue32XIiAVrL5SyR1WB2',\n  'D8O4yNtFhEU8Y7Taf3BilznJOcu2',\n  'tlmGNz9kjXc2EteizMORes4qvWl2',\n]\n\nexport const HOUSE_BOT_USERNAME = 'acc'\n\nexport function supabaseUserConsolePath(userId: string) {\n  const tableId = ENV === 'DEV' ? 19247 : 25916\n  return `https://supabase.com/dashboard/project/${ENV_CONFIG.supabaseInstanceId}/editor/${tableId}/?filter=id%3Aeq%3A${userId}`\n}\n\nexport function supabasePrivateUserConsolePath(userId: string) {\n  const tableId = ENV === 'DEV' ? 2189688 : 153495548\n  return `https://supabase.com/dashboard/project/${ENV_CONFIG.supabaseInstanceId}/editor/${tableId}/?filter=id%3Aeq%3A${userId}`\n}\n\nexport function supabaseConsoleContractPath(contractId: string) {\n  const tableId = ENV === 'DEV' ? 19254 : 25924\n  return `https://supabase.com/dashboard/project/${ENV_CONFIG.supabaseInstanceId}/editor/${tableId}?filter=id%3Aeq%3A${contractId}`\n}\n\nexport function supabaseConsoleTxnPath(txnId: string) {\n  const tableId = ENV === 'DEV' ? 20014 : 25940\n  return `https://supabase.com/dashboard/project/${ENV_CONFIG.supabaseInstanceId}/editor/${tableId}?filter=id%3Aeq%3A${txnId}`\n}\n\nexport const GOOGLE_PLAY_APP_URL =\n  'https://play.google.com/store/apps/details?id=com.markets.manifold'\nexport const APPLE_APP_URL =\n  'https://apps.apple.com/us/app/manifold-markets/id6444136749'\n\nexport const TEN_YEARS_SECS = 60 * 60 * 24 * 365 * 10\n\nexport const DESTINY_GROUP_SLUG = 'destinygg'\nexport const PROD_MANIFOLD_LOVE_GROUP_SLUG = 'manifoldlove-relationships'\n\nexport const RATING_GROUP_SLUGS = ['nonpredictive', 'unsubsidized']\n\nexport const GROUP_SLUGS_TO_IGNORE_IN_MARKETS_EMAIL = [\n  'manifold-6748e065087e',\n  'manifold-features-25bad7c7792e',\n  'bugs',\n  'manifold-leagues',\n  ...RATING_GROUP_SLUGS,\n  DESTINY_GROUP_SLUG,\n  PROD_MANIFOLD_LOVE_GROUP_SLUG,\n]\n\n// - Hide markets from signed-out landing page\n// - Hide from onboarding topic selector\n// - De-emphasize markets in the very first feed items generated for new users\nexport const HIDE_FROM_NEW_USER_SLUGS = [\n  'fun',\n  'selfresolving',\n  'experimental',\n  'trading-bots',\n  'gambling',\n  'free-money',\n  'mana',\n  'whale-watching',\n  'spam',\n  'test',\n  'no-resolution',\n  'eto',\n  'friend-stocks',\n  'ancient-markets',\n  'jokes',\n  'planecrash',\n  'glowfic',\n  'all-stonks',\n  'the-market',\n  'nonpredictive-profits',\n  'personal-goals',\n  'personal',\n  'rationalussy',\n  'nsfw',\n  'manifold-6748e065087e',\n  'bugs',\n  'new-years-resolutions-2024',\n  'metamarkets',\n  'metaforecasting',\n  'death-markets',\n  ...GROUP_SLUGS_TO_IGNORE_IN_MARKETS_EMAIL,\n]\n\nexport const GROUP_SLUGS_TO_NOT_INTRODUCE_IN_FEED = [\n  'rationalussy',\n  'nsfw',\n  'planecrash',\n  'glowfic',\n  'no-resolution',\n  'the-market',\n  'spam',\n  'test',\n  'eto',\n  'friend-stocks',\n  'testing',\n  'all-stonks',\n  PROD_MANIFOLD_LOVE_GROUP_SLUG,\n]\n\nexport const EXTERNAL_REDIRECTS = ['/umami']\n\nexport const DISCORD_INVITE_LINK = 'https://discord.com/invite/eHQBNBqXuh'\nexport const DISCORD_BOT_INVITE_LINK =\n  'https://discord.com/api/oauth2/authorize?client_id=1074829857537663098&permissions=328565385280&scope=bot%20applications.commands'\n\nexport const YES_GRAPH_COLOR = '#11b981'\n\nexport const RESERVED_PATHS = [\n  '_next',\n  'about',\n  'ad',\n  'add-funds',\n  'ads',\n  'analytics',\n  'api',\n  'browse',\n  'calibration',\n  'card',\n  'cards',\n  'career',\n  'careers',\n  'charity',\n  'common',\n  'contact',\n  'contacts',\n  'cowp',\n  'create',\n  'date-docs',\n  'dashboard',\n  'discord',\n  'discord-bot',\n  'dream',\n  'embed',\n  'facebook',\n  'find',\n  'github',\n  'google',\n  'group',\n  'groups',\n  'help',\n  'home',\n  'jobs',\n  'leaderboard',\n  'leaderboards',\n  'league',\n  'leagues',\n  'link',\n  'linkAccount',\n  'links',\n  'live',\n  'login',\n  'lootbox',\n  'mana-auction',\n  'manifest',\n  'markets',\n  'messages',\n  'mtg',\n  'news',\n  'notifications',\n  'og-test',\n  'payments',\n  'portfolio',\n  'privacy',\n  'profile',\n  'public',\n  'questions',\n  'referral',\n  'referrals',\n  'send',\n  'server-sitemap',\n  'sign-in',\n  'sign-in-waiting',\n  'sitemap',\n  'slack',\n  'stats',\n  'styles',\n  'swipe',\n  'team',\n  'terms',\n  'tournament',\n  'tournaments',\n  'twitch',\n  'twitter',\n  'umami',\n  'user',\n  'users',\n  'versus',\n  'web',\n  'welcome',\n]\n\nexport const MANA_PURCHASE_RATE_CHANGE_DATE = new Date('2024-05-16T18:20:00Z')\nexport const MANA_PURCHASE_RATE_REVERT_DATE = new Date('2024-09-17T17:06:00Z') // commit date of sweepcash - PR #2840 5e8b46d8\n",
          "postContent": "import { escapeRegExp } from 'lodash'\nimport { DEV_CONFIG } from './dev'\nimport { EnvConfig, PROD_CONFIG } from './prod'\n\nexport const ENV = (process.env.NEXT_PUBLIC_FIREBASE_ENV ?? 'PROD') as\n  | 'PROD'\n  | 'DEV'\n\nexport const CONFIGS: { [env: string]: EnvConfig } = {\n  PROD: PROD_CONFIG,\n  DEV: DEV_CONFIG,\n}\n\nexport const TWOMBA_CASHOUT_ENABLED = true\nexport const SWEEP_PRODUCTION_ENABLED = false\nexport const SPICE_PRODUCTION_ENABLED = false\nexport const SPICE_TO_MANA_CONVERSION_RATE = 1\nexport const CASH_TO_MANA_CONVERSION_RATE = 100\nexport const MIN_CASH_DONATION = 25\nexport const MIN_SPICE_DONATION = 25000\nexport const CASH_TO_CHARITY_DOLLARS = 1\nexport const NY_FL_CASHOUT_LIMIT = 5000\nexport const DOLLAR_PURCHASE_LIMIT = 5000\n\nexport const SPICE_NAME = 'Prize Point'\nexport const SWEEPIES_NAME = 'sweepcash'\nexport const SPICE_MARKET_TOOLTIP = `Prize market! Earn ${SPICE_NAME}s on resolution`\nexport const SWEEPIES_MARKET_TOOLTIP = `Sweepstakes market! Win real cash prizes.`\nexport const CASH_SUFFIX = '--cash'\n\nexport const TRADE_TERM = 'bet'\nexport const TRADED_TERM = 'bet'\nexport const TRADING_TERM = 'betting'\nexport const TRADER_TERM = 'trader'\n\nexport const ENV_CONFIG = CONFIGS[ENV]\n\nexport function isAdminId(id: string) {\n  return ENV_CONFIG.adminIds.includes(id)\n}\n\nexport function isModId(id: string) {\n  return MOD_IDS.includes(id)\n}\nexport function isSweepstakesModId(id: string) {\n  return SWEEPSTAKES_MOD_IDS.includes(id)\n}\nexport const DOMAIN = ENV_CONFIG.domain\nexport const FIREBASE_CONFIG = ENV_CONFIG.firebaseConfig\nexport const PROJECT_ID = ENV_CONFIG.firebaseConfig.projectId\nexport const IS_PRIVATE_MANIFOLD = ENV_CONFIG.visibility === 'PRIVATE'\n\nexport const AUTH_COOKIE_NAME = `FBUSER_${PROJECT_ID.toUpperCase().replace(\n  /-/g,\n  '_'\n)}`\n\n// Manifold's domain or any subdomains thereof\nexport const CORS_ORIGIN_MANIFOLD = new RegExp(\n  '^https?://(?:[a-zA-Z0-9\\\\-]+\\\\.)*' + escapeRegExp(ENV_CONFIG.domain) + '$'\n)\n\nexport const CORS_ORIGIN_CHARITY = new RegExp(\n  '^https?://(?:[a-zA-Z0-9\\\\-]+\\\\.)*' + escapeRegExp('manifund.org') + '$'\n)\n\n// Vercel deployments, used for testing.\nexport const CORS_ORIGIN_VERCEL = new RegExp(\n  '^https?://[a-zA-Z0-9\\\\-]+' + escapeRegExp('mantic.vercel.app') + '$'\n)\n// Any localhost server on any port\nexport const CORS_ORIGIN_LOCALHOST = /^http:\\/\\/localhost:\\d+$/\n\n// TODO: These should maybe be part of the env config?\nexport const BOT_USERNAMES = [\n  'TenShinoe908',\n  'subooferbot',\n  'pos',\n  'v',\n  'acc',\n  'jerk',\n  'snap',\n  'ArbitrageBot',\n  'MarketManagerBot',\n  'Botlab',\n  'JuniorBot',\n  'ManifoldDream',\n  'ManifoldBugs',\n  'ACXBot',\n  'JamesBot',\n  'RyanBot',\n  'trainbot',\n  'runebot',\n  'LiquidityBonusBot',\n  '538',\n  'FairlyRandom',\n  'Anatolii',\n  'JeremyK',\n  'Botmageddon',\n  'SmartBot',\n  'ShifraGazsi',\n  'NiciusBot',\n  'Bot',\n  'Mason',\n  'VersusBot',\n  'GPT4',\n  'EntropyBot',\n  'veat',\n  'ms_test',\n  'arb',\n  'Turbot',\n  'MetaculusBot',\n  'burkebot',\n  'Botflux',\n  '7',\n  'hyperkaehler',\n  'NcyBot',\n  'ithaca',\n  'GigaGaussian',\n  'BottieMcBotface',\n  'Seldon',\n  'OnePercentBot',\n  'arrbit',\n  'ManaMaximizer',\n  'rita',\n  'uhh',\n  'ArkPoint',\n  'EliBot',\n  'manifestussy',\n  'mirrorbot',\n  'JakeBot',\n  'loopsbot',\n  'breezybot',\n  'echo',\n  'Sayaka',\n  'cc7',\n  'Yuna',\n  'ManifoldLove',\n  'chooterb0t',\n  'bonkbot',\n  'NermitBundaloy',\n  'FirstBot',\n  'bawt',\n  'FireTheCEO',\n  'JointBot',\n  'WrenTec',\n  'TigerMcBot',\n  'Euclidean',\n  'manakin',\n  'LUCAtheory',\n  'TunglBot',\n  'timetraveler',\n  'bayesianbot',\n  'CharlesLienBot',\n  'JaguarMcBot',\n  'AImogus',\n  'brake',\n  'brontobot',\n  'OracleBot',\n  'spacedroplet',\n  'AriZernerBot',\n  'PV_bot',\n  'draaglom_bot',\n  'SiriusBOT',\n  'bradbot',\n  'ShrimpLute',\n  'kbot',\n  'ataribot',\n  'RISKBOT',\n  'harmonia',\n  'Dagonet',\n]\n\nexport const MOD_IDS = [\n  'qnIAzz9RamaodeiJSiGZO6xRGC63', // Agh\n  'srFlJRuVlGa7SEJDM4cY9B5k4Lj2', // bayesian\n  'EJQOCF3MfLTFYbhiKncrNefQDBz1', // chrisjbillington\n  'MV9fTVHetcfp3h6CVYzpypIsbyN2', // CodeandSolder\n  'HTbxWFlzWGeHUTiwZvvF0qm8W433', // Conflux\n  '9dAaZrNSx5OT0su6rpusDoG9WPN2', // dglid\n  '5XMvQhA3YgcTzyoJRiNqGWyuB9k2', // dreev\n  '946iB1LqFIR06G7d8q89um57PHh2', // egroj\n  'hqdXgp0jK2YMMhPs067eFK4afEH3', // Eliza\n  'kbHiTAGBahXdX9Z4sW29JpNrB0l2', // Ernie\n  'W4yEF6idSMcNWEVUquowziSCZFI3', // EvanDaniel\n  '2VhlvfTaRqZbFn2jqxk2Am9jgsE2', // Gabrielle\n  'cA1JupYR5AR8btHUs2xvkui7jA93', // Gen\n  'YGZdZUSFQyM8j2YzPaBqki8NBz23', // jack\n  'cgrBqe2O3AU4Dnng7Nc9wuJHLKb2', // jskf\n  '4juQfJkFnwX9nws3dFOpz4gc1mi2', // jacksonpolack\n  'XeQf3ygmrGM1MxdsE3JSlmq8vL42', // Jacy\n  'eSqS9cD5mzYcP2o7FrST8aC5IWn2', // PlasmaBallin (previously JosephNoonan)\n  'JlVpsgzLsbOUT4pajswVMr0ZzmM2', // Joshua\n  '7HhTMy4xECaVKvl5MmEAfVUkRCS2', // KevinBurke\n  'jO7sUhIDTQbAJ3w86akzncTlpRG2', // MichaelWheatley\n  'lkkqZxiWCpOgtJ9ztJcAKz4d9y33', // NathanpmYoung\n  'fSrex43BDjeneNZ4ZLfxllSb8b42', // NcyRocks\n  'BgCeVUcOzkexeJpSPRNomWQaQaD3', // SemioticRivalry\n  'KHX2ThSFtLQlau58hrjtCX7OL2h2', // shankypanky (stefanie)\n  'hUM4SO8a8qhfqT1gEZ7ElTCGSEz2', // Stralor\n  'tO4DwIsujySUwtSnrr2hnU1WJtJ3', // WieDan\n  'oPxjIzlvC5fRbGCaVgkvAiyoXBB2', // mattyb\n  'Iua2KQvL6KYcfGLGNI6PVeGkseo1', // Ziddletwix\n  'Gg7t9vPD4WPD1iPgj9RUFLYTxgH2', // nikki\n  'XNrWcIrA22hpv20fHn4ApoTPsh63', // bagelfan\n  '0k1suGSJKVUnHbCPEhHNpgZPkUP2', // Sinclair\n]\n\nexport const SWEEPSTAKES_MOD_IDS = [\n  'uglwf3YKOZNGjjEXKc5HampOFRE2', // SirSalty\n  'KHX2ThSFtLQlau58hrjtCX7OL2h2', // shankypanky (stefanie)\n  '2VhlvfTaRqZbFn2jqxk2Am9jgsE2', // Gabrielle\n  'HTbxWFlzWGeHUTiwZvvF0qm8W433', // Conflux\n  'YGZdZUSFQyM8j2YzPaBqki8NBz23', // jack\n  'JlVpsgzLsbOUT4pajswVMr0ZzmM2', // Joshua\n]\n\nexport const MVP = ['Eliza', 'Gabrielle', 'jacksonpolack']\n\nexport const VERIFIED_USERNAMES = [\n  'EliezerYudkowsky',\n  'ScottAlexander',\n  'Aella',\n  'ZviMowshowitz',\n  'GavrielK',\n  'CGPGrey',\n  'LexFridman',\n  'patio11',\n  'RichardHanania',\n  'Qualy',\n  'Roko',\n  'JonathanBlow',\n  'DwarkeshPatel',\n  'ByrneHobart',\n  'RobertWiblin',\n  'KelseyPiper',\n  'SpencerGreenberg',\n  'PaulChristiano',\n  'BuckShlegeris',\n  'Natalia',\n  'zero',\n  'OzzieGooen',\n  'OliverHabryka',\n  'Alicorn',\n  'RazibKhan',\n  'JamesMedlock',\n  'Writer',\n  'geohot',\n  'ShayneCoplan',\n  'SanghyeonSeo',\n  'KatjaGrace',\n  'EmmettShear',\n  'CateHall',\n  'RobertSKMiles',\n  'TarekMansour',\n  'DylanMatthews',\n  'RobinHanson',\n  'KevinRoose18ac',\n  'KnowNothing',\n  'SantaPawsSSB',\n  'AndersSandberg',\n  'JosephWeisenthal',\n  'LawrenceLessig',\n  'NatFriedman',\n  'patrissimo',\n  'postjawline',\n  'MatthewYglesias',\n  'MatthewYglesiasvuyf',\n  'BillyMcRascal',\n  'kyootbot',\n  'MaximLott',\n  'liron',\n  'LarsDoucet',\n  'PeterWildeford',\n  'SethWalder',\n  'SneakySly',\n  'ConorSen',\n  'transmissions11',\n  'DanHendrycks',\n  'Cremieux',\n  'tracewoodgrains',\n  'LuigiMangione',\n  'LeahLibresco',\n  'ModernDayDebate',\n  'NickyCase',\n  'TamayBesiroglu',\n]\n\nexport const BANNED_TRADING_USER_IDS = [\n  'zgCIqq8AmRUYVu6AdQ9vVEJN8On1', // firstuserhere aka _deleted_\n  'LIBAoi7tpqeNLYM1xxJ1QJBQqW32', // lastuserhere\n  'p3ADzwIUS3fk0ka80XYEE3OM3S32', // PC\n  '4JuXgDx47xPagH5mcLDqLzUSN5g2', // BTE\n  'iD1ObV4sInhkBXs3Ten96j4Co6O2', // BTE alt\n  'zRMxfUt51RcEIcZkuw6ySiNJYBE3', // BTE alt\n  'wo2LRCvgaNSllK3q0Wnv8hlusTa2', // BTE alt\n  'os2ilMb1d8WDeXxiQAo6btlig1Z2', // BTE alt\n  'zRMxfUt51RcEIcZkuw6ySiNJYBE3', // BTE alt\n  'fnuHBW8dHwZp2TbEt2MKJY9d28V2', // Klob (Caleb)\n  'RK6Nd7IBfMVOcLekfqcN9Ys17qJ2', // PeterNjeim\n]\n\nexport const PARTNER_USER_IDS: string[] = [\n  'sTUV8ejuM2byukNZp7qKP2OKXMx2', // NFL\n  'rFJu0EIdR6RP8d1vHKSh62pbnbH2', // SimonGrayson\n  'cb6PJqGOSVPEUhprDHCKWWMuJqu1', // DanMan314\n  'HTbxWFlzWGeHUTiwZvvF0qm8W433', // Conflux\n  'YGZdZUSFQyM8j2YzPaBqki8NBz23', // jack\n  'hDq0cvn68jbAUVd6aWIU9aSv9ZA2', // strutheo\n  'OEbsAczmbBc4Sl1bacYZNPJLLLc2', // SirCryptomind\n  'JlVpsgzLsbOUT4pajswVMr0ZzmM2', // Joshua\n  'xQqqZqlgcoSxTgPe03BiXmVE2JJ2', // Soli\n  'Iiok8KHMCRfUiwtMq1tl5PeDbA73', // Lion\n  'SqOJYkeySMQjqP3UAypw6DxPx4Z2', // Shump\n  'hqdXgp0jK2YMMhPs067eFK4afEH3', // Eliza\n  'BgCeVUcOzkexeJpSPRNomWQaQaD3', // SemioticRivalry\n  'X1xu1kvOxuevx09xuR2urWfzf7i1', // KeenenWatts\n  '4juQfJkFnwX9nws3dFOpz4gc1mi2', // jacksonpolack\n  '8WEiWcxUd7QLeiveyI8iqbSIffU2', // goblinodds\n  'Iua2KQvL6KYcfGLGNI6PVeGkseo1', // Ziddletwix\n  'GRaWlYn2fNah0bvr6OW28l28nFn1', // cash\n  'ZKkL3lFRFaYfiaT9ZOdiv2iUJBM2', // mint\n  'hRbPwezgxnat6GpJQxoFxq1xgUZ2', // AmmonLam\n  'foOeshHZOET3yMvRTMPINpnb8Bj2', // PunishedFurry\n  'EBGhoFSxRtVBu4617SLZUe1FeJt1', // FranklinBaldo\n  '4xOTMCIOkGesdJft50wVFZFb5IB3', // Tripping\n  'srFlJRuVlGa7SEJDM4cY9B5k4Lj2', // Bayesian\n  'H6b5PWELWfRV6HhyHAlCGq7yJJu2', // AndrewG\n  'EJQOCF3MfLTFYbhiKncrNefQDBz1', // chrisjbillington\n  '7HhTMy4xECaVKvl5MmEAfVUkRCS2', // KevinBurke\n  'oPxjIzlvC5fRbGCaVgkvAiyoXBB2', // mattyb\n  'OdBj5DW6PbYtnImvybpyZzfhb133', // jim\n  'm5K4FlZLo0aeDd5Z7W4xX3TAGHs1', // JeffBerman\n  'LmtawaGf6jO0oFGzth1UCrUXFW82', // AaronSimansky\n]\n\nexport const NEW_USER_HERLPER_IDS = [\n  '2VhlvfTaRqZbFn2jqxk2Am9jgsE2', // Gabrielle\n  'BgCeVUcOzkexeJpSPRNomWQaQaD3', // SemioticRivalry\n  'rQPOELuW5zaapaNPnBYQBMoonk92', // Tumbles\n  'tlmGNz9kjXc2EteizMORes4qvWl2', // Stephen\n  'AJwLWoo3xue32XIiAVrL5SyR1WB2', // Ian\n  'uglwf3YKOZNGjjEXKc5HampOFRE2', // D4vid\n  'cA1JupYR5AR8btHUs2xvkui7jA93', // Genzy\n  'srFlJRuVlGa7SEJDM4cY9B5k4Lj2', // Bayesian\n  'Gg7t9vPD4WPD1iPgj9RUFLYTxgH2', // nikki\n  'OdBj5DW6PbYtnImvybpyZzfhb133', // jim\n]\n\nexport const OPTED_OUT_OF_LEAGUES = [\n  'vuI5upWB8yU00rP7yxj95J2zd952', // ManifoldPolitics\n  '8lZo8X5lewh4hnCoreI7iSc0GxK2', // ManifoldAI\n  'IPTOzEqrpkWmEzh6hwvAyY9PqFb2', // Manifold\n  'tRZZ6ihugZQLXPf6aPRneGpWLmz1', // ManifoldLove\n  'BhNkw088bMNwIFF2Aq5Gg9NTPzz1', // acc\n  'JlVpsgzLsbOUT4pajswVMr0ZzmM2', // Joshua\n  'oPxjIzlvC5fRbGCaVgkvAiyoXBB2', // mattyb\n  'NndHcEmeJhPQ6n7e7yqAPa3Oiih2', // josh\n]\n\nexport const HIDE_FROM_LEADERBOARD_USER_IDS = [\n  'BhNkw088bMNwIFF2Aq5Gg9NTPzz1', // acc\n  'tRZZ6ihugZQLXPf6aPRneGpWLmz1', // ManifoldLove\n]\n\nexport const INSTITUTIONAL_PARTNER_USER_IDS: string[] = []\n\nexport const BEING_DEAD_HEADS = [\n  '6hHpzvRG0pMq8PNJs7RZj2qlZGn2',\n  'AJwLWoo3xue32XIiAVrL5SyR1WB2',\n  'D8O4yNtFhEU8Y7Taf3BilznJOcu2',\n  'tlmGNz9kjXc2EteizMORes4qvWl2',\n]\n\nexport const HOUSE_BOT_USERNAME = 'acc'\n\nexport function supabaseUserConsolePath(userId: string) {\n  const tableId = ENV === 'DEV' ? 19247 : 25916\n  return `https://supabase.com/dashboard/project/${ENV_CONFIG.supabaseInstanceId}/editor/${tableId}/?filter=id%3Aeq%3A${userId}`\n}\n\nexport function supabasePrivateUserConsolePath(userId: string) {\n  const tableId = ENV === 'DEV' ? 2189688 : 153495548\n  return `https://supabase.com/dashboard/project/${ENV_CONFIG.supabaseInstanceId}/editor/${tableId}/?filter=id%3Aeq%3A${userId}`\n}\n\nexport function supabaseConsoleContractPath(contractId: string) {\n  const tableId = ENV === 'DEV' ? 19254 : 25924\n  return `https://supabase.com/dashboard/project/${ENV_CONFIG.supabaseInstanceId}/editor/${tableId}?filter=id%3Aeq%3A${contractId}`\n}\n\nexport function supabaseConsoleTxnPath(txnId: string) {\n  const tableId = ENV === 'DEV' ? 20014 : 25940\n  return `https://supabase.com/dashboard/project/${ENV_CONFIG.supabaseInstanceId}/editor/${tableId}?filter=id%3Aeq%3A${txnId}`\n}\n\nexport const GOOGLE_PLAY_APP_URL =\n  'https://play.google.com/store/apps/details?id=com.markets.manifold'\nexport const APPLE_APP_URL =\n  'https://apps.apple.com/us/app/manifold-markets/id6444136749'\n\nexport const TEN_YEARS_SECS = 60 * 60 * 24 * 365 * 10\n\nexport const DESTINY_GROUP_SLUG = 'destinygg'\nexport const PROD_MANIFOLD_LOVE_GROUP_SLUG = 'manifoldlove-relationships'\n\nexport const RATING_GROUP_SLUGS = ['nonpredictive', 'unsubsidized']\n\nexport const GROUP_SLUGS_TO_IGNORE_IN_MARKETS_EMAIL = [\n  'manifold-6748e065087e',\n  'manifold-features-25bad7c7792e',\n  'bugs',\n  'manifold-leagues',\n  ...RATING_GROUP_SLUGS,\n  DESTINY_GROUP_SLUG,\n  PROD_MANIFOLD_LOVE_GROUP_SLUG,\n]\n\n// - Hide markets from signed-out landing page\n// - Hide from onboarding topic selector\n// - De-emphasize markets in the very first feed items generated for new users\nexport const HIDE_FROM_NEW_USER_SLUGS = [\n  'fun',\n  'selfresolving',\n  'experimental',\n  'trading-bots',\n  'gambling',\n  'free-money',\n  'mana',\n  'whale-watching',\n  'spam',\n  'test',\n  'no-resolution',\n  'eto',\n  'friend-stocks',\n  'ancient-markets',\n  'jokes',\n  'planecrash',\n  'glowfic',\n  'all-stonks',\n  'the-market',\n  'nonpredictive-profits',\n  'personal-goals',\n  'personal',\n  'rationalussy',\n  'nsfw',\n  'manifold-6748e065087e',\n  'bugs',\n  'new-years-resolutions-2024',\n  'metamarkets',\n  'metaforecasting',\n  'death-markets',\n  ...GROUP_SLUGS_TO_IGNORE_IN_MARKETS_EMAIL,\n]\n\nexport const GROUP_SLUGS_TO_NOT_INTRODUCE_IN_FEED = [\n  'rationalussy',\n  'nsfw',\n  'planecrash',\n  'glowfic',\n  'no-resolution',\n  'the-market',\n  'spam',\n  'test',\n  'eto',\n  'friend-stocks',\n  'testing',\n  'all-stonks',\n  PROD_MANIFOLD_LOVE_GROUP_SLUG,\n]\n\nexport const EXTERNAL_REDIRECTS = ['/umami']\n\nexport const DISCORD_INVITE_LINK = 'https://discord.com/invite/eHQBNBqXuh'\nexport const DISCORD_BOT_INVITE_LINK =\n  'https://discord.com/api/oauth2/authorize?client_id=1074829857537663098&permissions=328565385280&scope=bot%20applications.commands'\n\nexport const YES_GRAPH_COLOR = '#11b981'\n\nexport const RESERVED_PATHS = [\n  '_next',\n  'about',\n  'ad',\n  'add-funds',\n  'ads',\n  'analytics',\n  'api',\n  'browse',\n  'calibration',\n  'card',\n  'cards',\n  'career',\n  'careers',\n  'charity',\n  'common',\n  'contact',\n  'contacts',\n  'cowp',\n  'create',\n  'date-docs',\n  'dashboard',\n  'discord',\n  'discord-bot',\n  'dream',\n  'embed',\n  'facebook',\n  'find',\n  'github',\n  'google',\n  'group',\n  'groups',\n  'help',\n  'home',\n  'jobs',\n  'leaderboard',\n  'leaderboards',\n  'league',\n  'leagues',\n  'link',\n  'linkAccount',\n  'links',\n  'live',\n  'login',\n  'lootbox',\n  'mana-auction',\n  'manifest',\n  'markets',\n  'messages',\n  'mtg',\n  'news',\n  'notifications',\n  'og-test',\n  'payments',\n  'portfolio',\n  'privacy',\n  'profile',\n  'public',\n  'questions',\n  'referral',\n  'referrals',\n  'send',\n  'server-sitemap',\n  'sign-in',\n  'sign-in-waiting',\n  'sitemap',\n  'slack',\n  'stats',\n  'styles',\n  'swipe',\n  'team',\n  'terms',\n  'tournament',\n  'tournaments',\n  'twitch',\n  'twitter',\n  'umami',\n  'user',\n  'users',\n  'versus',\n  'web',\n  'welcome',\n]\n\nexport const MANA_PURCHASE_RATE_CHANGE_DATE = new Date('2024-05-16T18:20:00Z')\nexport const MANA_PURCHASE_RATE_REVERT_DATE = new Date('2024-09-17T17:06:00Z') // commit date of sweepcash - PR #2840 5e8b46d8\n"
        },
        {
          "path": "common/src/envs/dev.ts",
          "preContent": "import { EnvConfig, PROD_CONFIG } from './prod'\n\nexport const DEV_CONFIG: EnvConfig = {\n  ...PROD_CONFIG,\n  domain: 'dev.manifold.markets',\n  loveDomain: 'dev.manifold.love',\n  loveDomainAlternate: 'dev.manifoldlove.com',\n  googleAnalyticsId: '',\n  firebaseConfig: {\n    apiKey: 'AIzaSyBoq3rzUa8Ekyo3ZaTnlycQYPRCA26VpOw',\n    authDomain: 'dev-mantic-markets.firebaseapp.com',\n    projectId: 'dev-mantic-markets',\n    region: 'us-central1',\n    storageBucket: 'dev-mantic-markets.appspot.com',\n    privateBucket: 'dev-mantic-markets-private',\n    messagingSenderId: '134303100058',\n    appId: '1:134303100058:web:27f9ea8b83347251f80323',\n    measurementId: 'G-YJC9E37P37',\n  },\n  cloudRunId: 'w3txbmd3ba',\n  cloudRunRegion: 'uc',\n  amplitudeApiKey: 'fd8cbfd964b9a205b8678a39faae71b3',\n  supabaseInstanceId: 'mfodonznyfxllcezufgr',\n  supabaseAnonKey:\n    'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1mb2RvbnpueWZ4bGxjZXp1ZmdyIiwicm9sZSI6ImFub24iLCJpYXQiOjE2Njc5ODgxNjcsImV4cCI6MTk4MzU2NDE2N30.RK8CA3G2_yccgiIFoxzweEuJ2XU5SoB7x7wBzMKitvo',\n  twitchBotEndpoint: 'https://dev-twitch-bot.manifold.markets',\n  apiEndpoint: 'api.dev.manifold.markets',\n  expoConfig: {\n    iosClientId:\n      '134303100058-lioqb7auc8minvqt9iamuit2pg10pubt.apps.googleusercontent.com',\n    iosClientId2:\n      '134303100058-9464q86hhfloaij15dl9ekn6l39e3cv8.apps.googleusercontent.com',\n    expoClientId:\n      '134303100058-2uvio555s8mnhde20b4old97ptjnji3u.apps.googleusercontent.com',\n    androidClientId:\n      '134303100058-mu6dbubhks8khpqi3dq0fokqnkbputiq.apps.googleusercontent.com',\n    androidClientId2:\n      '134303100058-p29jv704pu0p8helj0pqruidi4lqss9j.apps.googleusercontent.com',\n  },\n  adminIds: [\n    'pfKxvtgSEua5DxoIfiPXxR4fAWd2',\n    '6hHpzvRG0pMq8PNJs7RZj2qlZGn2', // Ian\n    'MxyCh2xvsFMFywwjg3Az0w4xP5B3', // Dev Manifold\n    '2cO953kN1sTBpfbhPVnTjRNqLJh2', // Sinclair\n  ],\n}\n",
          "postContent": "import { EnvConfig, PROD_CONFIG } from './prod'\n\nexport const DEV_CONFIG: EnvConfig = {\n  ...PROD_CONFIG,\n  domain: 'dev.manifold.markets',\n  googleAnalyticsId: '',\n  firebaseConfig: {\n    apiKey: 'AIzaSyBoq3rzUa8Ekyo3ZaTnlycQYPRCA26VpOw',\n    authDomain: 'dev-mantic-markets.firebaseapp.com',\n    projectId: 'dev-mantic-markets',\n    region: 'us-central1',\n    storageBucket: 'dev-mantic-markets.appspot.com',\n    privateBucket: 'dev-mantic-markets-private',\n    messagingSenderId: '134303100058',\n    appId: '1:134303100058:web:27f9ea8b83347251f80323',\n    measurementId: 'G-YJC9E37P37',\n  },\n  cloudRunId: 'w3txbmd3ba',\n  cloudRunRegion: 'uc',\n  amplitudeApiKey: 'fd8cbfd964b9a205b8678a39faae71b3',\n  supabaseInstanceId: 'mfodonznyfxllcezufgr',\n  supabaseAnonKey:\n    'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1mb2RvbnpueWZ4bGxjZXp1ZmdyIiwicm9sZSI6ImFub24iLCJpYXQiOjE2Njc5ODgxNjcsImV4cCI6MTk4MzU2NDE2N30.RK8CA3G2_yccgiIFoxzweEuJ2XU5SoB7x7wBzMKitvo',\n  twitchBotEndpoint: 'https://dev-twitch-bot.manifold.markets',\n  apiEndpoint: 'api.dev.manifold.markets',\n  expoConfig: {\n    iosClientId:\n      '134303100058-lioqb7auc8minvqt9iamuit2pg10pubt.apps.googleusercontent.com',\n    iosClientId2:\n      '134303100058-9464q86hhfloaij15dl9ekn6l39e3cv8.apps.googleusercontent.com',\n    expoClientId:\n      '134303100058-2uvio555s8mnhde20b4old97ptjnji3u.apps.googleusercontent.com',\n    androidClientId:\n      '134303100058-mu6dbubhks8khpqi3dq0fokqnkbputiq.apps.googleusercontent.com',\n    androidClientId2:\n      '134303100058-p29jv704pu0p8helj0pqruidi4lqss9j.apps.googleusercontent.com',\n  },\n  adminIds: [\n    'pfKxvtgSEua5DxoIfiPXxR4fAWd2',\n    '6hHpzvRG0pMq8PNJs7RZj2qlZGn2', // Ian\n    'MxyCh2xvsFMFywwjg3Az0w4xP5B3', // Dev Manifold\n    '2cO953kN1sTBpfbhPVnTjRNqLJh2', // Sinclair\n  ],\n}\n"
        },
        {
          "path": "common/src/envs/prod.ts",
          "preContent": "export type EnvConfig = {\n  domain: string\n  loveDomain: string\n  loveDomainAlternate: string\n  firebaseConfig: FirebaseConfig\n  amplitudeApiKey: string\n  supabaseInstanceId: string\n  supabaseAnonKey: string\n  twitchBotEndpoint: string\n  apiEndpoint: string\n  googleAnalyticsId: string\n\n  // IDs for v2 cloud functions -- find these by deploying a cloud function and\n  // examining the URL, https://[name]-[cloudRunId]-[cloudRunRegion].a.run.app\n  cloudRunId: string\n  cloudRunRegion: string\n\n  // Access controls\n  adminIds: string[]\n  visibility: 'PRIVATE' | 'PUBLIC'\n\n  // Branding\n  moneyMoniker: string // e.g. 'Ṁ'\n  spiceMoniker: string // e.g. 'S'\n  bettor: string // e.g. 'predictor'\n  nounBet: string // e.g. 'prediction'\n  verbPastBet: string // e.g. 'predicted'\n  faviconPath: string // Should be a file in /public\n  newQuestionPlaceholders: string[]\n  expoConfig: {\n    iosClientId?: string\n    iosClientId2?: string\n    expoClientId?: string\n    androidClientId?: string\n    androidClientId2?: string\n  }\n}\n\ntype FirebaseConfig = {\n  apiKey: string\n  authDomain: string\n  projectId: string\n  region?: string\n  storageBucket: string\n  privateBucket: string\n  messagingSenderId: string\n  appId: string\n  measurementId: string\n}\n\nexport const PROD_CONFIG: EnvConfig = {\n  domain: 'manifold.markets',\n  loveDomain: 'manifold.love',\n  loveDomainAlternate: 'manifoldlove.com',\n  amplitudeApiKey: '2d6509fd4185ebb8be29709842752a15',\n  supabaseInstanceId: 'pxidrgkatumlvfqaxcll',\n  supabaseAnonKey:\n    'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InB4aWRyZ2thdHVtbHZmcWF4Y2xsIiwicm9sZSI6ImFub24iLCJpYXQiOjE2Njg5OTUzOTgsImV4cCI6MTk4NDU3MTM5OH0.d_yYtASLzAoIIGdXUBIgRAGLBnNow7JG2SoaNMQ8ySg',\n  googleAnalyticsId: 'GTM-MLMPXHJ6',\n  firebaseConfig: {\n    apiKey: 'AIzaSyDp3J57vLeAZCzxLD-vcPaGIkAmBoGOSYw',\n    authDomain: 'mantic-markets.firebaseapp.com',\n    projectId: 'mantic-markets',\n    region: 'us-central1',\n    storageBucket: 'mantic-markets.appspot.com',\n    privateBucket: 'mantic-markets-private',\n    messagingSenderId: '128925704902',\n    appId: '1:128925704902:web:f61f86944d8ffa2a642dc7',\n    measurementId: 'G-SSFK1Q138D',\n  },\n  twitchBotEndpoint: 'https://twitch-bot.manifold.markets',\n  apiEndpoint: 'api.manifold.markets',\n  cloudRunId: 'nggbo3neva',\n  cloudRunRegion: 'uc',\n\n  adminIds: [\n    'igi2zGXsfxYPgB0DJTXVJVmwCOr2', // Austin\n    'tlmGNz9kjXc2EteizMORes4qvWl2', // Stephen\n    'IPTOzEqrpkWmEzh6hwvAyY9PqFb2', // Manifold\n    'AJwLWoo3xue32XIiAVrL5SyR1WB2', // Ian\n    'uglwf3YKOZNGjjEXKc5HampOFRE2', // D4vid\n    '62TNqzdBx7X2q621HltsJm8UFht2', // Marshall\n    'z0cH5XmIM9XgWFOBAILQWt0fTHr1', // Rachel W\n    'cA1JupYR5AR8btHUs2xvkui7jA93', // Genzy\n    'vuI5upWB8yU00rP7yxj95J2zd952', // Manifold Politics\n    '8lZo8X5lewh4hnCoreI7iSc0GxK2', // Manifold AI\n    'mwaVAaKkabODsH8g5VrtbshsXz03', // Ian's alt\n  ],\n  visibility: 'PUBLIC',\n\n  moneyMoniker: 'Ṁ',\n  spiceMoniker: 'P',\n  bettor: 'trader',\n  verbPastBet: 'traded',\n  nounBet: 'trade',\n  faviconPath: '/favicon.ico',\n  newQuestionPlaceholders: [\n    'Will anyone I know get engaged this year?',\n    'Will humans set foot on Mars by the end of 2030?',\n    'Will any cryptocurrency eclipse Bitcoin by market cap this year?',\n    'Will the Democrats win the 2024 presidential election?',\n  ],\n  expoConfig: {\n    iosClientId:\n      '128925704902-n0ic4j1s5tk51t2vu8anu8glh3t5jimo.apps.googleusercontent.com',\n    iosClientId2:\n      '128925704902-k6d8219pss8nubk1bb1n5kisn5l8fv1a.apps.googleusercontent.com',\n    expoClientId:\n      '128925704902-bpcbnlp2gt73au3rrjjtnup6cskr89p0.apps.googleusercontent.com',\n    androidClientId:\n      '128925704902-ur9hevfika2rs0sni6ju236u82hbct3i.apps.googleusercontent.com',\n    androidClientId2:\n      '128925704902-r23bsi4ca28sprdh49mprl1ov33pvvau.apps.googleusercontent.com',\n  },\n}\n",
          "postContent": "export type EnvConfig = {\n  domain: string\n  firebaseConfig: FirebaseConfig\n  amplitudeApiKey: string\n  supabaseInstanceId: string\n  supabaseAnonKey: string\n  twitchBotEndpoint: string\n  apiEndpoint: string\n  googleAnalyticsId: string\n\n  // IDs for v2 cloud functions -- find these by deploying a cloud function and\n  // examining the URL, https://[name]-[cloudRunId]-[cloudRunRegion].a.run.app\n  cloudRunId: string\n  cloudRunRegion: string\n\n  // Access controls\n  adminIds: string[]\n  visibility: 'PRIVATE' | 'PUBLIC'\n\n  // Branding\n  moneyMoniker: string // e.g. 'Ṁ'\n  spiceMoniker: string // e.g. 'S'\n  bettor: string // e.g. 'predictor'\n  nounBet: string // e.g. 'prediction'\n  verbPastBet: string // e.g. 'predicted'\n  faviconPath: string // Should be a file in /public\n  newQuestionPlaceholders: string[]\n  expoConfig: {\n    iosClientId?: string\n    iosClientId2?: string\n    expoClientId?: string\n    androidClientId?: string\n    androidClientId2?: string\n  }\n}\n\ntype FirebaseConfig = {\n  apiKey: string\n  authDomain: string\n  projectId: string\n  region?: string\n  storageBucket: string\n  privateBucket: string\n  messagingSenderId: string\n  appId: string\n  measurementId: string\n}\n\nexport const PROD_CONFIG: EnvConfig = {\n  domain: 'manifold.markets',\n  amplitudeApiKey: '2d6509fd4185ebb8be29709842752a15',\n  supabaseInstanceId: 'pxidrgkatumlvfqaxcll',\n  supabaseAnonKey:\n    'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InB4aWRyZ2thdHVtbHZmcWF4Y2xsIiwicm9sZSI6ImFub24iLCJpYXQiOjE2Njg5OTUzOTgsImV4cCI6MTk4NDU3MTM5OH0.d_yYtASLzAoIIGdXUBIgRAGLBnNow7JG2SoaNMQ8ySg',\n  googleAnalyticsId: 'GTM-MLMPXHJ6',\n  firebaseConfig: {\n    apiKey: 'AIzaSyDp3J57vLeAZCzxLD-vcPaGIkAmBoGOSYw',\n    authDomain: 'mantic-markets.firebaseapp.com',\n    projectId: 'mantic-markets',\n    region: 'us-central1',\n    storageBucket: 'mantic-markets.appspot.com',\n    privateBucket: 'mantic-markets-private',\n    messagingSenderId: '128925704902',\n    appId: '1:128925704902:web:f61f86944d8ffa2a642dc7',\n    measurementId: 'G-SSFK1Q138D',\n  },\n  twitchBotEndpoint: 'https://twitch-bot.manifold.markets',\n  apiEndpoint: 'api.manifold.markets',\n  cloudRunId: 'nggbo3neva',\n  cloudRunRegion: 'uc',\n\n  adminIds: [\n    'igi2zGXsfxYPgB0DJTXVJVmwCOr2', // Austin\n    'tlmGNz9kjXc2EteizMORes4qvWl2', // Stephen\n    'IPTOzEqrpkWmEzh6hwvAyY9PqFb2', // Manifold\n    'AJwLWoo3xue32XIiAVrL5SyR1WB2', // Ian\n    'uglwf3YKOZNGjjEXKc5HampOFRE2', // D4vid\n    '62TNqzdBx7X2q621HltsJm8UFht2', // Marshall\n    'z0cH5XmIM9XgWFOBAILQWt0fTHr1', // Rachel W\n    'cA1JupYR5AR8btHUs2xvkui7jA93', // Genzy\n    'vuI5upWB8yU00rP7yxj95J2zd952', // Manifold Politics\n    '8lZo8X5lewh4hnCoreI7iSc0GxK2', // Manifold AI\n    'mwaVAaKkabODsH8g5VrtbshsXz03', // Ian's alt\n  ],\n  visibility: 'PUBLIC',\n\n  moneyMoniker: 'Ṁ',\n  spiceMoniker: 'P',\n  bettor: 'trader',\n  verbPastBet: 'traded',\n  nounBet: 'trade',\n  faviconPath: '/favicon.ico',\n  newQuestionPlaceholders: [\n    'Will anyone I know get engaged this year?',\n    'Will humans set foot on Mars by the end of 2030?',\n    'Will any cryptocurrency eclipse Bitcoin by market cap this year?',\n    'Will the Democrats win the 2024 presidential election?',\n  ],\n  expoConfig: {\n    iosClientId:\n      '128925704902-n0ic4j1s5tk51t2vu8anu8glh3t5jimo.apps.googleusercontent.com',\n    iosClientId2:\n      '128925704902-k6d8219pss8nubk1bb1n5kisn5l8fv1a.apps.googleusercontent.com',\n    expoClientId:\n      '128925704902-bpcbnlp2gt73au3rrjjtnup6cskr89p0.apps.googleusercontent.com',\n    androidClientId:\n      '128925704902-ur9hevfika2rs0sni6ju236u82hbct3i.apps.googleusercontent.com',\n    androidClientId2:\n      '128925704902-r23bsi4ca28sprdh49mprl1ov33pvvau.apps.googleusercontent.com',\n  },\n}\n"
        },
        {
          "path": "common/src/love/compatibility-score.ts",
          "preContent": "import { keyBy, sumBy } from 'lodash'\nimport { LoverRow } from 'common/love/lover'\nimport { Row as rowFor } from 'common/supabase/utils'\nimport {\n  areAgeCompatible,\n  areLocationCompatible,\n  areRelationshipStyleCompatible,\n  areWantKidsCompatible,\n} from './compatibility-util'\n\nconst importanceToScore = {\n  0: 0,\n  1: 1,\n  2: 5,\n  3: 25,\n} as { [importance: string]: number }\n\nexport type CompatibilityScore = {\n  score: number\n  confidence: 'low' | 'medium' | 'high'\n}\n\nexport const getCompatibilityScore = (\n  answers1: rowFor<'love_compatibility_answers'>[],\n  answers2: rowFor<'love_compatibility_answers'>[]\n): CompatibilityScore => {\n  const {\n    score: score1,\n    maxScore: maxScore1,\n    answerCount,\n  } = getAnswersCompatibility(answers1, answers2)\n  const { score: score2, maxScore: maxScore2 } = getAnswersCompatibility(\n    answers2,\n    answers1\n  )\n\n  // >=100 answers in common leads to no weight toward 50%.\n  // Use sqrt for diminishing returns to answering more questions.\n  const weightTowardFiftyPercent = Math.max(\n    25 - 2.5 * Math.sqrt(answerCount),\n    0\n  )\n  const upWeight = weightTowardFiftyPercent / 2\n  const downWeight = weightTowardFiftyPercent\n  const compat1 = (score1 + upWeight) / (maxScore1 + downWeight)\n  const compat2 = (score2 + upWeight) / (maxScore2 + downWeight)\n  const geometricMean = Math.sqrt(compat1 * compat2)\n\n  const confidence =\n    answerCount < 10 ? 'low' : answerCount < 100 ? 'medium' : 'high'\n\n  return { score: geometricMean, confidence }\n}\n\nconst getAnswersCompatibility = (\n  answers1: rowFor<'love_compatibility_answers'>[],\n  answers2: rowFor<'love_compatibility_answers'>[]\n) => {\n  const answers2ByQuestionId = keyBy(answers2, 'question_id')\n  let maxScore = 0\n  let answerCount = 0\n\n  const score = sumBy(answers1, (a) => {\n    if (a.importance === -1) return 0\n\n    const answer2 = answers2ByQuestionId[a.question_id]\n    // Not answered or skipped.\n    if (!answer2 || answer2.importance === -1) return 0\n\n    answerCount++\n    const importanceScore = importanceToScore[a.importance] ?? 0\n    maxScore += importanceScore\n    return getAnswerCompatibilityImportanceScore(a, answer2)\n  })\n\n  return { score, maxScore, answerCount }\n}\n\nexport function getAnswerCompatibilityImportanceScore(\n  answer1: rowFor<'love_compatibility_answers'>,\n  answer2: rowFor<'love_compatibility_answers'>\n) {\n  const importanceScore = importanceToScore[answer1.importance] ?? 0\n  return answer1.pref_choices.includes(answer2.multiple_choice)\n    ? importanceScore\n    : 0\n}\n\nexport function getAnswerCompatibility(\n  answer1: rowFor<'love_compatibility_answers'>,\n  answer2: rowFor<'love_compatibility_answers'>\n) {\n  if (answer1.importance < 0 || answer2.importance < 0) {\n    return false\n  }\n\n  const compatibility1to2 = answer1.pref_choices.includes(\n    answer2.multiple_choice\n  )\n  const compatibility2to1 = answer2.pref_choices.includes(\n    answer1.multiple_choice\n  )\n\n  return compatibility1to2 && compatibility2to1\n}\n\nexport function getScoredAnswerCompatibility(\n  answer1: rowFor<'love_compatibility_answers'>,\n  answer2: rowFor<'love_compatibility_answers'>\n) {\n  if (answer1.importance < 0 || answer2.importance < 0) {\n    return 0\n  }\n\n  const compatibility1to2 = +answer1.pref_choices.includes(\n    answer2.multiple_choice\n  )\n  const compatibility2to1 = +answer2.pref_choices.includes(\n    answer1.multiple_choice\n  )\n  const importanceCompatibility =\n    1 - Math.abs(answer1.importance - answer2.importance) / 4\n\n  // Adjust these weights to change the impact of each component\n  const compatibilityWeight = 0.7\n  const importanceWeight = 0.3\n\n  return (\n    ((compatibility1to2 + compatibility2to1) * compatibilityWeight +\n      importanceCompatibility * importanceWeight) /\n    2\n  )\n}\n\nexport const getLoversCompatibilityFactor = (\n  lover1: LoverRow,\n  lover2: LoverRow\n) => {\n  let multiplier = 1\n  multiplier *= areAgeCompatible(lover1, lover2) ? 1 : 0.5\n  multiplier *= areRelationshipStyleCompatible(lover1, lover2) ? 1 : 0.5\n  multiplier *= areWantKidsCompatible(lover1, lover2) ? 1 : 0.5\n  multiplier *= areLocationCompatible(lover1, lover2) ? 1 : 0.1\n  return multiplier\n}\n",
          "postContent": "[DELETED]"
        },
        {
          "path": "common/src/love/compatibility-util.ts",
          "preContent": "import { LoverRow } from 'common/love/lover'\n\nconst isPreferredGender = (\n  preferredGenders: string[] | undefined,\n  gender: string | undefined\n) => {\n  if (preferredGenders === undefined || gender === undefined) return true\n\n  // If simple gender preference, don't include non-binary.\n  if (\n    preferredGenders.length === 1 &&\n    (preferredGenders[0] === 'male' || preferredGenders[0] === 'female')\n  ) {\n    return preferredGenders.includes(gender)\n  }\n  return preferredGenders.includes(gender) || gender === 'non-binary'\n}\n\nexport const areGenderCompatible = (lover1: LoverRow, lover2: LoverRow) => {\n  return (\n    isPreferredGender(lover1.pref_gender, lover2.gender) &&\n    isPreferredGender(lover2.pref_gender, lover1.gender)\n  )\n}\n\nconst satisfiesAgeRange = (lover: LoverRow, age: number) => {\n  return age >= lover.pref_age_min && age <= lover.pref_age_max\n}\n\nexport const areAgeCompatible = (lover1: LoverRow, lover2: LoverRow) => {\n  return (\n    satisfiesAgeRange(lover1, lover2.age) &&\n    satisfiesAgeRange(lover2, lover1.age)\n  )\n}\n\nexport const areLocationCompatible = (lover1: LoverRow, lover2: LoverRow) => {\n  if (\n    !lover1.city_latitude ||\n    !lover2.city_latitude ||\n    !lover1.city_longitude ||\n    !lover2.city_longitude\n  )\n    return lover1.city.trim().toLowerCase() === lover2.city.trim().toLowerCase()\n\n  const latitudeDiff = Math.abs(lover1.city_latitude - lover2.city_latitude)\n  const longigudeDiff = Math.abs(lover1.city_longitude - lover2.city_longitude)\n\n  const root = (latitudeDiff ** 2 + longigudeDiff ** 2) ** 0.5\n  return root < 2.5\n}\n\nexport const areRelationshipStyleCompatible = (\n  lover1: LoverRow,\n  lover2: LoverRow\n) => {\n  return lover1.pref_relation_styles.some((style) =>\n    lover2.pref_relation_styles.includes(style)\n  )\n}\n\nexport const areWantKidsCompatible = (lover1: LoverRow, lover2: LoverRow) => {\n  const { wants_kids_strength: kids1 } = lover1\n  const { wants_kids_strength: kids2 } = lover2\n\n  if (kids1 === undefined || kids2 === undefined) return true\n\n  const diff = Math.abs(kids1 - kids2)\n  return diff <= 2\n}\n",
          "postContent": "[DELETED]"
        },
        {
          "path": "common/src/love/constants.ts",
          "preContent": "export const MIN_BET_AMOUNT_FOR_NEW_MATCH = 50\n\nexport const MAX_COMPATIBILITY_QUESTION_LENGTH = 240\n\nexport const LIKE_COST = 50\nexport const LOVE_MARKET_COST = 10000\n",
          "postContent": "[DELETED]"
        },
        {
          "path": "common/src/love/love-comment.ts",
          "preContent": "import { Comment } from 'common/comment'\n\nexport type OnLover = {\n  commentType: 'lover'\n  onUserId: string\n}\nexport type LoverComment = Comment<OnLover>\n",
          "postContent": "[DELETED]"
        },
        {
          "path": "common/src/love/lover.ts",
          "preContent": "import { Row, run, SupabaseClient } from 'common/supabase/utils'\nimport { User } from 'common/user'\n\nexport type Lover = LoverRow & { user: User }\nexport type LoverRow = Row<'lovers'>\nexport const getLoverRow = async (userId: string, db: SupabaseClient) => {\n  const res = await run(db.from('lovers').select('*').eq('user_id', userId))\n  return res.data[0]\n}\n",
          "postContent": "[DELETED]"
        },
        {
          "path": "common/src/love/multiple-choice.ts",
          "preContent": "export const MultipleChoiceOptions = {\n  'Strongly disagree': 0,\n  Disagree: 1,\n  Neutral: 2,\n  Agree: 3,\n  'Strongly agree': 4,\n}\n\nexport const MultipleChoiceColors = [\n  'bg-rose-600',\n  'bg-rose-400',\n  'bg-stone-400',\n  'dark:bg-teal-200 bg-teal-300',\n  'bg-teal-400',\n]\n",
          "postContent": "[DELETED]"
        },
        {
          "path": "common/src/love/og-image.ts",
          "preContent": "import { User } from 'common/user'\nimport { LoverRow } from 'common/love/lover'\n\nexport type LoveOgProps = {\n  // user props\n  avatarUrl: string\n  username: string\n  name: string\n  // lover props\n  age: string\n  city: string\n  gender: string\n}\n\nexport function getLoveOgImageUrl(user: User, lover?: LoverRow | null) {\n  const loveProps = {\n    avatarUrl: lover?.pinned_url,\n    username: user.username,\n    name: user.name,\n    age: lover?.age.toString() ?? '25',\n    city: lover?.city ?? 'Internet',\n    gender: lover?.gender ?? '???',\n  } as LoveOgProps\n  // TODO: would be better to unify with buildOgUrl from common/util/og,\n  // but we'd need to pass in the \"manifold.love\" domain\n  const params = new URLSearchParams(loveProps).toString()\n  return `https://manifold.love/api/og/lover?${params}`\n}\n",
          "postContent": "[DELETED]"
        }
      ]
    },
    {
      "sha": "b41ec01baf617a5f01f30aca6b4f4f6b1ca9edb4",
      "author": "Ian Philips",
      "date": "2025-05-19 11:45:41 -0700",
      "message": "Fix filling your own limit orders to go negative",
      "stats": {
        "filesChanged": 5,
        "insertions": 16,
        "deletions": 2
      },
      "selectionReason": "Prevents users from filling their own limit orders to go negative - implements important business logic constraints",
      "spec": "Introduce a new validation rule within the bet execution process. After determining the final balances for all users affected by a bet (the bettor and any makers whose limit orders are filled), the following condition must be checked for each of these users: if a user's final balance is negative AND this final balance is less than their balance recorded immediately prior to the current bet's execution, the bet operation must fail. Upon such a failure, an error with the exact message 'Maker has insufficient balance.' must be returned. This validation requires comparing each affected user's post-bet balance with their pre-bet balance.",
      "fileStates": [
        {
          "path": "backend/api/src/helpers/bets.ts",
          "preContent": "import {\n  pgp,\n  SupabaseDirectClient,\n  SupabaseTransaction,\n} from 'shared/supabase/init'\nimport { Contract, MarketContract } from 'common/contract'\nimport { groupBy, mapValues, orderBy, sumBy, uniq, uniqBy } from 'lodash'\nimport { LimitBet, maker } from 'common/bet'\nimport { ContractMetric, isSummary } from 'common/contract-metric'\nimport { MarginalBet } from 'common/calculate-metrics'\nimport { floatingEqual } from 'common/util/math'\nimport { bulkUpdateUserMetricsWithNewBetsOnly } from 'shared/helpers/user-contract-metrics'\nimport { log } from 'shared/monitoring/log'\nimport { redeemShares } from 'api/redeem-shares'\nimport { convertBet } from 'common/supabase/bets'\nimport { APIError } from 'common/api/utils'\nimport { User } from 'common/user'\nimport { CandidateBet } from 'common/new-bet'\nimport {\n  BANNED_TRADING_USER_IDS,\n  BOT_USERNAMES,\n  PARTNER_USER_IDS,\n} from 'common/envs/constants'\nimport { Answer } from 'common/answer'\nimport { getUniqueBettorBonusAmount } from 'common/economy'\nimport { removeUndefinedProps } from 'common/util/object'\nimport { UniqueBettorBonusTxn } from 'common/txn'\nimport { getInsertQuery } from 'shared/supabase/utils'\nimport { txnToRow } from 'shared/txn/run-txn'\nimport { contractColumnsToSelect } from 'shared/utils'\nimport { convertUser } from 'common/supabase/users'\nimport { convertAnswer, convertContract } from 'common/supabase/contracts'\nimport { NewBetResult } from 'api/place-bet'\n\nexport const fetchContractBetDataAndValidate = async (\n  pgTrans: SupabaseTransaction | SupabaseDirectClient,\n  body: {\n    contractId: string\n    amount: number | undefined\n    answerId?: string\n    answerIds?: string[]\n    outcome: 'YES' | 'NO'\n  },\n  uid: string,\n  isApi: boolean\n) => {\n  const startTime = Date.now()\n  const { amount, contractId, outcome } = body\n  const answerIds =\n    'answerIds' in body\n      ? body.answerIds\n      : 'answerId' in body && body.answerId !== undefined\n      ? [body.answerId]\n      : undefined\n\n  const isSumsToOne = `(select coalesce((data->>'shouldAnswersSumToOne')::boolean, false) from contracts where id = $2)`\n  const whereLimitOrderBets = `\n    b.contract_id = $2 and not b.is_filled and not b.is_cancelled and\n    (b.expires_at is null or b.expires_at > now()) and\n    (\n      -- For sums to one markets:\n      (${isSumsToOne} and (\n        -- Get opposite outcome bets for selected answers\n        ($3 is null or b.answer_id in ($3:list)) and b.outcome != $4\n        or\n        -- Get same outcome bets for other answers\n        ($3 is null or b.answer_id not in ($3:list)) and b.outcome = $4\n      ))\n      or\n      -- For non-sums to one markets, just get opposite outcome bets\n      (not ${isSumsToOne} and ($3 is null or b.answer_id in ($3:list)) and b.outcome != $4)\n    )\n  `\n  const queries = pgp.as.format(\n    `\n    select * from users where id = $1;\n    select ${contractColumnsToSelect} from contracts where id = $2;\n    select * from answers\n      where contract_id = $2 and (\n        $3 is null or id in ($3:list) or ${isSumsToOne}\n      ) order by index;\n    select b.*, u.balance from contract_bets b join users u on b.user_id = u.id\n      where ${whereLimitOrderBets};\n    -- My contract metrics\n    select data from user_contract_metrics ucm where \n      contract_id = $2 and user_id = $1\n      and (\n        -- Get metrics for selected answers\n        $3 is null or ucm.answer_id in ($3:list)\n        or\n        -- Get null answer metrics\n        ucm.answer_id is null\n      ); \n    -- Limit orderers' contract metrics\n    with matching_user_answer_pairs as (\n      select distinct b.user_id, b.answer_id\n      from contract_bets b\n      where ${whereLimitOrderBets}\n    )\n    select data from user_contract_metrics ucm\n    where contract_id = $2\n      and user_id in (select user_id from matching_user_answer_pairs)\n      and (answer_id in (select answer_id from matching_user_answer_pairs)\n        or answer_id is null);\n    select status from system_trading_status where token = (select token from contracts where id = $2);\n  `,\n    [uid, contractId, answerIds ?? null, outcome]\n  )\n  const results = await pgTrans.multi(queries)\n  const user = convertUser(results[0][0])\n  const contract = convertContract(results[1][0])\n  const answers = results[2].map(convertAnswer)\n  const unfilledBets = results[3].map(convertBet) as (LimitBet & {\n    balance: number\n  })[]\n  const myContractMetrics = results[4].map((r) => r.data as ContractMetric)\n  // We get slightly more contract metrics than we need bc the contract_metrics index works poorly when selecting\n  // (user_id, answer_id) in (select user_id, answer_id from matching_user_answer_pairs)\n  const limitOrderersContractMetrics = results[5]\n    .map((r) => r.data as ContractMetric)\n    .filter((m) =>\n      unfilledBets.some(\n        (b) =>\n          b.userId === m.userId && (b.answerId === m.answerId || isSummary(m))\n      )\n    )\n  const contractMetrics = uniqBy(\n    [...myContractMetrics, ...limitOrderersContractMetrics],\n    (m) => m.userId + m.answerId + m.contractId\n  )\n  const systemStatus = results[6][0]\n\n  if (!systemStatus.status) {\n    throw new APIError(\n      403,\n      `Trading with ${contract.token} is currently disabled.`\n    )\n  }\n\n  if (!user) throw new APIError(404, 'User not found.')\n  if (!contract) throw new APIError(404, 'Contract not found.')\n  if (contract.mechanism === 'none' || contract.mechanism === 'qf')\n    throw new APIError(400, 'This is not a market')\n\n  const { closeTime, isResolved } = contract\n  if (closeTime && Date.now() > closeTime)\n    throw new APIError(403, 'Trading is closed.')\n  if (isResolved) throw new APIError(403, 'Market is resolved.')\n\n  const balanceByUserId = Object.fromEntries(\n    uniqBy(unfilledBets, (b) => b.userId).map((bet) => [\n      bet.userId,\n      bet.balance,\n    ])\n  )\n  const unfilledBetUserIds = Object.keys(balanceByUserId)\n  const balance = user.balance\n  if (amount !== undefined && balance < amount)\n    throw new APIError(403, 'Insufficient balance.')\n\n  if (BANNED_TRADING_USER_IDS.includes(user.id) || user.userDeleted) {\n    throw new APIError(403, 'You are banned or deleted. And not #blessed.')\n  }\n  if (contract.outcomeType === 'STONK' && isApi) {\n    throw new APIError(403, 'API users cannot bet on STONK contracts.')\n  }\n  log(\n    `Loaded user ${user.username} with id ${user.id} betting on slug ${contract.slug} with contract id: ${contract.id}.`\n  )\n  log(`Fetch bet data took ${Date.now() - startTime}ms`)\n\n  return {\n    user,\n    contract,\n    answers,\n    unfilledBets,\n    balanceByUserId,\n    unfilledBetUserIds,\n    contractMetrics,\n  }\n}\n\nexport const getUnfilledBets = async (\n  pg: SupabaseDirectClient,\n  contractId: string,\n  answerId?: string\n) => {\n  return await pg.map(\n    `select * from contract_bets\n    where contract_id = $1\n    and contract_bets.is_filled = false\n    and contract_bets.is_cancelled = false\n    ${answerId ? `and answer_id = $2` : ''}`,\n    [contractId, answerId],\n    (r) => convertBet(r) as LimitBet\n  )\n}\nexport const getUserBalancesAndMetrics = async (\n  pgTrans: SupabaseTransaction | SupabaseDirectClient,\n  userIds: string[],\n  contract: Contract,\n  answerId?: string\n) => {\n  const startTime = Date.now()\n  const { id: contractId, mechanism } = contract\n  // TODO: if we pass the makers' answerIds, we don't need to fetch the metrics for all answers\n  const sumsToOne =\n    mechanism === 'cpmm-multi-1' && contract.shouldAnswersSumToOne\n  const results = await pgTrans.multi(\n    `\n      SELECT balance, id FROM users WHERE id = ANY($1);\n      select data from user_contract_metrics where user_id = any($1) and contract_id = $2 and\n           ($3 is null or answer_id = $3 or answer_id is null);\n    `,\n    [userIds, contractId, sumsToOne ? null : answerId ?? null]\n  )\n  const balanceByUserId = Object.fromEntries(\n    results[0].map((user) => [user.id, user.balance])\n  )\n  const contractMetrics = results[1].map((r) => r.data) as ContractMetric[]\n  log(`Fetch user balances and metrics took ${Date.now() - startTime}ms`)\n  return { balanceByUserId, contractMetrics }\n}\nexport const getUnfilledBetsAndUserBalances = async (\n  pgTrans: SupabaseTransaction,\n  contract: Contract,\n  userId: string,\n  answerId?: string\n) => {\n  const unfilledBets = await getUnfilledBets(pgTrans, contract.id, answerId)\n  const userIds = uniq([userId, ...unfilledBets.map((bet) => bet.userId)])\n  const { balanceByUserId, contractMetrics } = await getUserBalancesAndMetrics(\n    pgTrans,\n    userIds,\n    contract,\n    answerId\n  )\n\n  return { unfilledBets, balanceByUserId, contractMetrics }\n}\n\nexport const getBulkUpdateLimitOrdersQueryAndValues = (\n  updates: Array<\n    {\n      bet: LimitBet\n    } & Pick<LimitBet, 'fills' | 'isFilled' | 'amount' | 'shares'>\n  >\n) => {\n  if (updates.length === 0)\n    return { query: 'select 1 where false', updatedMakers: [] }\n  const results = updates.map((update) => {\n    const { bet, ...updateData } = update\n    const updatedBet = {\n      ...bet,\n      ...updateData,\n    }\n    const updateQ = `('${bet.id}', '${JSON.stringify(updateData)}'::jsonb)`\n    return { updatedBet, updateQ }\n  })\n\n  const values = results.map(({ updateQ }) => updateQ).join(',\\n')\n  const updatedMakers = results.map(({ updatedBet }) => updatedBet)\n\n  const query = `UPDATE contract_bets AS c\n       SET data = data || v.update\n       FROM (VALUES ${values}) AS v(id, update)\n       WHERE c.bet_id = v.id`\n  return { query, updatedMakers }\n}\n\nexport const updateMakers = async (\n  makersByTakerBetId: Record<string, maker[]>,\n  contract: MarketContract,\n  contractMetrics: ContractMetric[],\n  pgTrans: SupabaseTransaction\n) => {\n  const allFillsAsNewBets: MarginalBet[] = []\n  const allMakerIds: string[] = []\n  const allSpentByUser: Record<string, number> = {}\n  const allUpdates: Array<\n    {\n      bet: LimitBet\n    } & Pick<LimitBet, 'fills' | 'isFilled' | 'amount' | 'shares'>\n  > = []\n\n  for (const [takerBetId, makers] of Object.entries(makersByTakerBetId)) {\n    const makersByBet = groupBy(makers, (maker) => maker.bet.id)\n\n    for (const makers of Object.values(makersByBet)) {\n      const limitOrderBet = makers[0].bet\n      const newFills = makers.map((maker) => {\n        const { amount, shares, timestamp } = maker\n        return { amount, shares, matchedBetId: takerBetId, timestamp }\n      })\n      const fills = [...limitOrderBet.fills, ...newFills]\n      const totalShares = sumBy(fills, 'shares')\n      const totalAmount = sumBy(fills, 'amount')\n      const isFilled = floatingEqual(totalAmount, limitOrderBet.orderAmount)\n      allFillsAsNewBets.push({\n        ...limitOrderBet,\n        amount: sumBy(newFills, 'amount'),\n        shares: sumBy(newFills, 'shares'),\n        createdTime: orderBy(newFills, 'timestamp', 'desc')[0].timestamp,\n        loanAmount: 0,\n        isRedemption: false,\n      })\n      allUpdates.push({\n        bet: limitOrderBet,\n        fills,\n        isFilled,\n        amount: totalAmount,\n        shares: totalShares,\n      })\n    }\n\n    const spentByUser = mapValues(\n      groupBy(makers, (maker) => maker.bet.userId),\n      (makers) => sumBy(makers, (maker) => maker.amount)\n    )\n\n    for (const [userId, spent] of Object.entries(spentByUser)) {\n      allSpentByUser[userId] = (allSpentByUser[userId] || 0) + spent\n    }\n\n    allMakerIds.push(...Object.keys(spentByUser))\n  }\n\n  if (allUpdates.length === 0) {\n    return {\n      betsToInsert: [],\n      updatedMetrics: contractMetrics,\n      balanceUpdates: [],\n      bulkUpdateLimitOrdersQuery: 'select 1 where false',\n      updatedMakers: [],\n    }\n  }\n\n  const allUpdatedMetrics = await bulkUpdateUserMetricsWithNewBetsOnly(\n    pgTrans,\n    allFillsAsNewBets,\n    contractMetrics,\n    false\n  )\n\n  const bulkLimitOrderBalanceUpdates = Object.entries(allSpentByUser).map(\n    ([userId, spent]) => ({\n      id: userId,\n      balance: -spent,\n    })\n  )\n\n  const makerIds = uniq(allMakerIds)\n  log('Redeeming shares for makers', makerIds)\n  const {\n    betsToInsert: redemptionBets,\n    updatedMetrics: redemptionUpdatedMetrics,\n    balanceUpdates: redemptionBalanceUpdates,\n  } = await redeemShares(\n    pgTrans,\n    makerIds,\n    contract,\n    allFillsAsNewBets,\n    allUpdatedMetrics\n  )\n  const { query: bulkUpdateLimitOrdersQuery, updatedMakers } =\n    getBulkUpdateLimitOrdersQueryAndValues(allUpdates)\n  return {\n    betsToInsert: redemptionBets,\n    updatedMetrics: redemptionUpdatedMetrics,\n    balanceUpdates: redemptionBalanceUpdates.concat(\n      bulkLimitOrderBalanceUpdates\n    ),\n    bulkUpdateLimitOrdersQuery,\n    updatedMakers,\n  }\n}\n\nexport const getRoundedLimitProb = (limitProb: number | undefined) => {\n  if (limitProb === undefined) return limitProb\n  const isRounded = floatingEqual(Math.round(limitProb * 100), limitProb * 100)\n  if (!isRounded)\n    throw new APIError(\n      400,\n      'limitProb must be in increments of 0.01 (i.e. whole percentage points)'\n    )\n\n  return Math.round(limitProb * 100) / 100\n}\n\nexport const getMakerIdsFromBetResult = (result: NewBetResult) => {\n  const { makers = [], otherBetResults = [], ordersToCancel = [] } = result\n\n  const makerUserIds = [\n    ...makers,\n    ...otherBetResults.flatMap((r) => r.makers),\n  ].map((m) => m.bet.userId)\n\n  const cancelledUserIds = [\n    ...ordersToCancel,\n    ...otherBetResults.flatMap((r) => r.ordersToCancel),\n  ].map((o) => o.userId)\n\n  return uniq([...makerUserIds, ...cancelledUserIds])\n}\n\nexport const getUniqueBettorBonusQuery = (\n  contract: MarketContract,\n  bettor: User,\n  bet: CandidateBet\n) => {\n  const { answerId, isRedemption, isApi } = bet\n\n  const isBot = BOT_USERNAMES.includes(bettor.username)\n  const isUnlisted = contract.visibility === 'unlisted'\n\n  const answer =\n    answerId && 'answers' in contract\n      ? (contract.answers as Answer[]).find((a) => a.id == answerId)\n      : undefined\n  const answerCreatorId = answer?.userId\n  const creatorId = answerCreatorId ?? contract.creatorId\n  const isCreator = bettor.id == creatorId\n  const isUnfilledLimitOrder =\n    bet.limitProb !== undefined && (!bet.fills || bet.fills.length === 0)\n\n  const isPartner =\n    PARTNER_USER_IDS.includes(contract.creatorId) &&\n    // Require the contract creator to also be the answer creator for real-money bonus.\n    creatorId === contract.creatorId\n\n  if (\n    isCreator ||\n    isBot ||\n    isUnlisted ||\n    isRedemption ||\n    isUnfilledLimitOrder ||\n    isApi\n  )\n    return {\n      balanceUpdate: undefined,\n      txnQuery: 'select 1 where false',\n    }\n\n  // ian: removed the diminishing bonuses, but we could add them back via contract.uniqueBettorCount\n  const bonusAmount = getUniqueBettorBonusAmount(\n    contract.totalLiquidity,\n    'answers' in contract ? contract.answers.length : 0\n  )\n\n  const bonusTxnData = removeUndefinedProps({\n    contractId: contract.id,\n    uniqueNewBettorId: bettor.id,\n    answerId,\n    isPartner,\n  })\n\n  const bonusTxn: Omit<UniqueBettorBonusTxn, 'id' | 'createdTime'> = {\n    fromType: 'BANK',\n    fromId: 'BANK',\n    toId: creatorId,\n    toType: 'USER',\n    amount: bonusAmount,\n    token: 'M$',\n    category: 'UNIQUE_BETTOR_BONUS',\n    data: bonusTxnData,\n  } as const\n  const balanceUpdate = {\n    id: bonusTxn.toId,\n    balance: bonusAmount,\n    totalDeposits: bonusAmount,\n  }\n  const txnQuery = getInsertQuery('txns', txnToRow(bonusTxn))\n\n  log(`Bonus txn for user: ${contract.creatorId} constructed:`, bonusTxn)\n  return {\n    balanceUpdate,\n    txnQuery,\n  }\n}\n",
          "postContent": "import {\n  pgp,\n  SupabaseDirectClient,\n  SupabaseTransaction,\n} from 'shared/supabase/init'\nimport { Contract, MarketContract } from 'common/contract'\nimport { groupBy, mapValues, orderBy, sumBy, uniq, uniqBy } from 'lodash'\nimport { LimitBet, maker } from 'common/bet'\nimport { ContractMetric, isSummary } from 'common/contract-metric'\nimport { MarginalBet } from 'common/calculate-metrics'\nimport { floatingEqual } from 'common/util/math'\nimport { bulkUpdateUserMetricsWithNewBetsOnly } from 'shared/helpers/user-contract-metrics'\nimport { log } from 'shared/monitoring/log'\nimport { redeemShares } from 'api/redeem-shares'\nimport { convertBet } from 'common/supabase/bets'\nimport { APIError } from 'common/api/utils'\nimport { User } from 'common/user'\nimport { CandidateBet } from 'common/new-bet'\nimport {\n  BANNED_TRADING_USER_IDS,\n  BOT_USERNAMES,\n  PARTNER_USER_IDS,\n} from 'common/envs/constants'\nimport { Answer } from 'common/answer'\nimport { getUniqueBettorBonusAmount } from 'common/economy'\nimport { removeUndefinedProps } from 'common/util/object'\nimport { UniqueBettorBonusTxn } from 'common/txn'\nimport { getInsertQuery } from 'shared/supabase/utils'\nimport { txnToRow } from 'shared/txn/run-txn'\nimport { contractColumnsToSelect } from 'shared/utils'\nimport { convertUser } from 'common/supabase/users'\nimport { convertAnswer, convertContract } from 'common/supabase/contracts'\nimport { NewBetResult } from 'api/place-bet'\n\nexport const fetchContractBetDataAndValidate = async (\n  pgTrans: SupabaseTransaction | SupabaseDirectClient,\n  body: {\n    contractId: string\n    amount: number | undefined\n    answerId?: string\n    answerIds?: string[]\n    outcome: 'YES' | 'NO'\n  },\n  uid: string,\n  isApi: boolean\n) => {\n  const startTime = Date.now()\n  const { amount, contractId, outcome } = body\n  const answerIds =\n    'answerIds' in body\n      ? body.answerIds\n      : 'answerId' in body && body.answerId !== undefined\n      ? [body.answerId]\n      : undefined\n\n  const isSumsToOne = `(select coalesce((data->>'shouldAnswersSumToOne')::boolean, false) from contracts where id = $2)`\n  const whereLimitOrderBets = `\n    b.contract_id = $2 and not b.is_filled and not b.is_cancelled and\n    (b.expires_at is null or b.expires_at > now()) and\n    (\n      -- For sums to one markets:\n      (${isSumsToOne} and (\n        -- Get opposite outcome bets for selected answers\n        ($3 is null or b.answer_id in ($3:list)) and b.outcome != $4\n        or\n        -- Get same outcome bets for other answers\n        ($3 is null or b.answer_id not in ($3:list)) and b.outcome = $4\n      ))\n      or\n      -- For non-sums to one markets, just get opposite outcome bets\n      (not ${isSumsToOne} and ($3 is null or b.answer_id in ($3:list)) and b.outcome != $4)\n    )\n  `\n  const queries = pgp.as.format(\n    `\n    select * from users where id = $1;\n    select ${contractColumnsToSelect} from contracts where id = $2;\n    select * from answers\n      where contract_id = $2 and (\n        $3 is null or id in ($3:list) or ${isSumsToOne}\n      ) order by index;\n    select b.*, u.balance from contract_bets b join users u on b.user_id = u.id\n      where ${whereLimitOrderBets};\n    -- My contract metrics\n    select data from user_contract_metrics ucm where \n      contract_id = $2 and user_id = $1\n      and (\n        -- Get metrics for selected answers\n        $3 is null or ucm.answer_id in ($3:list)\n        or\n        -- Get null answer metrics\n        ucm.answer_id is null\n      ); \n    -- Limit orderers' contract metrics\n    with matching_user_answer_pairs as (\n      select distinct b.user_id, b.answer_id\n      from contract_bets b\n      where ${whereLimitOrderBets}\n    )\n    select data from user_contract_metrics ucm\n    where contract_id = $2\n      and user_id in (select user_id from matching_user_answer_pairs)\n      and (answer_id in (select answer_id from matching_user_answer_pairs)\n        or answer_id is null);\n    select status from system_trading_status where token = (select token from contracts where id = $2);\n  `,\n    [uid, contractId, answerIds ?? null, outcome]\n  )\n  const results = await pgTrans.multi(queries)\n  const user = convertUser(results[0][0])\n  const contract = convertContract(results[1][0])\n  const answers = results[2].map(convertAnswer)\n  const unfilledBets = results[3].map(convertBet) as (LimitBet & {\n    balance: number\n  })[]\n  const myContractMetrics = results[4].map((r) => r.data as ContractMetric)\n  // We get slightly more contract metrics than we need bc the contract_metrics index works poorly when selecting\n  // (user_id, answer_id) in (select user_id, answer_id from matching_user_answer_pairs)\n  const limitOrderersContractMetrics = results[5]\n    .map((r) => r.data as ContractMetric)\n    .filter((m) =>\n      unfilledBets.some(\n        (b) =>\n          b.userId === m.userId && (b.answerId === m.answerId || isSummary(m))\n      )\n    )\n  const contractMetrics = uniqBy(\n    [...myContractMetrics, ...limitOrderersContractMetrics],\n    (m) => m.userId + m.answerId + m.contractId\n  )\n  const systemStatus = results[6][0]\n\n  if (!systemStatus.status) {\n    throw new APIError(\n      403,\n      `Trading with ${contract.token} is currently disabled.`\n    )\n  }\n\n  if (!user) throw new APIError(404, 'User not found.')\n  if (!contract) throw new APIError(404, 'Contract not found.')\n  if (contract.mechanism === 'none' || contract.mechanism === 'qf')\n    throw new APIError(400, 'This is not a market')\n\n  const { closeTime, isResolved } = contract\n  if (closeTime && Date.now() > closeTime)\n    throw new APIError(403, 'Trading is closed.')\n  if (isResolved) throw new APIError(403, 'Market is resolved.')\n\n  const balanceByUserId = Object.fromEntries(\n    uniqBy(unfilledBets, (b) => b.userId).map((bet) => [\n      bet.userId,\n      bet.balance,\n    ])\n  )\n  const unfilledBetUserIds = Object.keys(balanceByUserId)\n  const balance = user.balance\n  if (amount !== undefined && balance < amount)\n    throw new APIError(403, 'Insufficient balance.')\n\n  if (BANNED_TRADING_USER_IDS.includes(user.id) || user.userDeleted) {\n    throw new APIError(403, 'You are banned or deleted. And not #blessed.')\n  }\n  if (contract.outcomeType === 'STONK' && isApi) {\n    throw new APIError(403, 'API users cannot bet on STONK contracts.')\n  }\n  log(\n    `Loaded user ${user.username} with id ${user.id} betting on slug ${contract.slug} with contract id: ${contract.id}.`\n  )\n  log(`Fetch bet data took ${Date.now() - startTime}ms`)\n\n  return {\n    user,\n    contract,\n    answers,\n    unfilledBets,\n    balanceByUserId,\n    unfilledBetUserIds,\n    contractMetrics,\n  }\n}\n\nexport const getUnfilledBets = async (\n  pg: SupabaseDirectClient,\n  contractId: string,\n  answerId?: string\n) => {\n  return await pg.map(\n    `select * from contract_bets\n    where contract_id = $1\n    and contract_bets.is_filled = false\n    and contract_bets.is_cancelled = false\n    ${answerId ? `and answer_id = $2` : ''}`,\n    [contractId, answerId],\n    (r) => convertBet(r) as LimitBet\n  )\n}\nexport const getUserBalancesAndMetrics = async (\n  pgTrans: SupabaseTransaction | SupabaseDirectClient,\n  userIds: string[],\n  contract: Contract,\n  answerId?: string\n) => {\n  const startTime = Date.now()\n  const { id: contractId, mechanism } = contract\n  // TODO: if we pass the makers' answerIds, we don't need to fetch the metrics for all answers\n  const sumsToOne =\n    mechanism === 'cpmm-multi-1' && contract.shouldAnswersSumToOne\n  const results = await pgTrans.multi(\n    `\n      SELECT balance, id FROM users WHERE id = ANY($1);\n      select data from user_contract_metrics where user_id = any($1) and contract_id = $2 and\n           ($3 is null or answer_id = $3 or answer_id is null);\n    `,\n    [userIds, contractId, sumsToOne ? null : answerId ?? null]\n  )\n  const balanceByUserId: Record<string, number> = Object.fromEntries(\n    results[0].map((user) => [user.id, user.balance])\n  )\n  const contractMetrics = results[1].map((r) => r.data) as ContractMetric[]\n  log(`Fetch user balances and metrics took ${Date.now() - startTime}ms`)\n  return { balanceByUserId, contractMetrics }\n}\nexport const getUnfilledBetsAndUserBalances = async (\n  pgTrans: SupabaseTransaction,\n  contract: Contract,\n  userId: string,\n  answerId?: string\n) => {\n  const unfilledBets = await getUnfilledBets(pgTrans, contract.id, answerId)\n  const userIds = uniq([userId, ...unfilledBets.map((bet) => bet.userId)])\n  const { balanceByUserId, contractMetrics } = await getUserBalancesAndMetrics(\n    pgTrans,\n    userIds,\n    contract,\n    answerId\n  )\n\n  return { unfilledBets, balanceByUserId, contractMetrics }\n}\n\nexport const getBulkUpdateLimitOrdersQueryAndValues = (\n  updates: Array<\n    {\n      bet: LimitBet\n    } & Pick<LimitBet, 'fills' | 'isFilled' | 'amount' | 'shares'>\n  >\n) => {\n  if (updates.length === 0)\n    return { query: 'select 1 where false', updatedMakers: [] }\n  const results = updates.map((update) => {\n    const { bet, ...updateData } = update\n    const updatedBet = {\n      ...bet,\n      ...updateData,\n    }\n    const updateQ = `('${bet.id}', '${JSON.stringify(updateData)}'::jsonb)`\n    return { updatedBet, updateQ }\n  })\n\n  const values = results.map(({ updateQ }) => updateQ).join(',\\n')\n  const updatedMakers = results.map(({ updatedBet }) => updatedBet)\n\n  const query = `UPDATE contract_bets AS c\n       SET data = data || v.update\n       FROM (VALUES ${values}) AS v(id, update)\n       WHERE c.bet_id = v.id`\n  return { query, updatedMakers }\n}\n\nexport const updateMakers = async (\n  makersByTakerBetId: Record<string, maker[]>,\n  contract: MarketContract,\n  contractMetrics: ContractMetric[],\n  pgTrans: SupabaseTransaction\n) => {\n  const allFillsAsNewBets: MarginalBet[] = []\n  const allMakerIds: string[] = []\n  const allSpentByUser: Record<string, number> = {}\n  const allUpdates: Array<\n    {\n      bet: LimitBet\n    } & Pick<LimitBet, 'fills' | 'isFilled' | 'amount' | 'shares'>\n  > = []\n\n  for (const [takerBetId, makers] of Object.entries(makersByTakerBetId)) {\n    const makersByBet = groupBy(makers, (maker) => maker.bet.id)\n\n    for (const makers of Object.values(makersByBet)) {\n      const limitOrderBet = makers[0].bet\n      const newFills = makers.map((maker) => {\n        const { amount, shares, timestamp } = maker\n        return { amount, shares, matchedBetId: takerBetId, timestamp }\n      })\n      const fills = [...limitOrderBet.fills, ...newFills]\n      const totalShares = sumBy(fills, 'shares')\n      const totalAmount = sumBy(fills, 'amount')\n      const isFilled = floatingEqual(totalAmount, limitOrderBet.orderAmount)\n      allFillsAsNewBets.push({\n        ...limitOrderBet,\n        amount: sumBy(newFills, 'amount'),\n        shares: sumBy(newFills, 'shares'),\n        createdTime: orderBy(newFills, 'timestamp', 'desc')[0].timestamp,\n        loanAmount: 0,\n        isRedemption: false,\n      })\n      allUpdates.push({\n        bet: limitOrderBet,\n        fills,\n        isFilled,\n        amount: totalAmount,\n        shares: totalShares,\n      })\n    }\n\n    const spentByUser = mapValues(\n      groupBy(makers, (maker) => maker.bet.userId),\n      (makers) => sumBy(makers, (maker) => maker.amount)\n    )\n\n    for (const [userId, spent] of Object.entries(spentByUser)) {\n      allSpentByUser[userId] = (allSpentByUser[userId] || 0) + spent\n    }\n\n    allMakerIds.push(...Object.keys(spentByUser))\n  }\n\n  if (allUpdates.length === 0) {\n    return {\n      betsToInsert: [],\n      updatedMetrics: contractMetrics,\n      balanceUpdates: [],\n      bulkUpdateLimitOrdersQuery: 'select 1 where false',\n      updatedMakers: [],\n    }\n  }\n\n  const allUpdatedMetrics = await bulkUpdateUserMetricsWithNewBetsOnly(\n    pgTrans,\n    allFillsAsNewBets,\n    contractMetrics,\n    false\n  )\n\n  const bulkLimitOrderBalanceUpdates = Object.entries(allSpentByUser).map(\n    ([userId, spent]) => ({\n      id: userId,\n      balance: -spent,\n    })\n  )\n\n  const makerIds = uniq(allMakerIds)\n  log('Redeeming shares for makers', makerIds)\n  const {\n    betsToInsert: redemptionBets,\n    updatedMetrics: redemptionUpdatedMetrics,\n    balanceUpdates: redemptionBalanceUpdates,\n  } = await redeemShares(\n    pgTrans,\n    makerIds,\n    contract,\n    allFillsAsNewBets,\n    allUpdatedMetrics\n  )\n  const { query: bulkUpdateLimitOrdersQuery, updatedMakers } =\n    getBulkUpdateLimitOrdersQueryAndValues(allUpdates)\n  return {\n    betsToInsert: redemptionBets,\n    updatedMetrics: redemptionUpdatedMetrics,\n    balanceUpdates: redemptionBalanceUpdates.concat(\n      bulkLimitOrderBalanceUpdates\n    ),\n    bulkUpdateLimitOrdersQuery,\n    updatedMakers,\n  }\n}\n\nexport const getRoundedLimitProb = (limitProb: number | undefined) => {\n  if (limitProb === undefined) return limitProb\n  const isRounded = floatingEqual(Math.round(limitProb * 100), limitProb * 100)\n  if (!isRounded)\n    throw new APIError(\n      400,\n      'limitProb must be in increments of 0.01 (i.e. whole percentage points)'\n    )\n\n  return Math.round(limitProb * 100) / 100\n}\n\nexport const getMakerIdsFromBetResult = (result: NewBetResult) => {\n  const { makers = [], otherBetResults = [], ordersToCancel = [] } = result\n\n  const makerUserIds = [\n    ...makers,\n    ...otherBetResults.flatMap((r) => r.makers),\n  ].map((m) => m.bet.userId)\n\n  const cancelledUserIds = [\n    ...ordersToCancel,\n    ...otherBetResults.flatMap((r) => r.ordersToCancel),\n  ].map((o) => o.userId)\n\n  return uniq([...makerUserIds, ...cancelledUserIds])\n}\n\nexport const getUniqueBettorBonusQuery = (\n  contract: MarketContract,\n  bettor: User,\n  bet: CandidateBet\n) => {\n  const { answerId, isRedemption, isApi } = bet\n\n  const isBot = BOT_USERNAMES.includes(bettor.username)\n  const isUnlisted = contract.visibility === 'unlisted'\n\n  const answer =\n    answerId && 'answers' in contract\n      ? (contract.answers as Answer[]).find((a) => a.id == answerId)\n      : undefined\n  const answerCreatorId = answer?.userId\n  const creatorId = answerCreatorId ?? contract.creatorId\n  const isCreator = bettor.id == creatorId\n  const isUnfilledLimitOrder =\n    bet.limitProb !== undefined && (!bet.fills || bet.fills.length === 0)\n\n  const isPartner =\n    PARTNER_USER_IDS.includes(contract.creatorId) &&\n    // Require the contract creator to also be the answer creator for real-money bonus.\n    creatorId === contract.creatorId\n\n  if (\n    isCreator ||\n    isBot ||\n    isUnlisted ||\n    isRedemption ||\n    isUnfilledLimitOrder ||\n    isApi\n  )\n    return {\n      balanceUpdate: undefined,\n      txnQuery: 'select 1 where false',\n    }\n\n  // ian: removed the diminishing bonuses, but we could add them back via contract.uniqueBettorCount\n  const bonusAmount = getUniqueBettorBonusAmount(\n    contract.totalLiquidity,\n    'answers' in contract ? contract.answers.length : 0\n  )\n\n  const bonusTxnData = removeUndefinedProps({\n    contractId: contract.id,\n    uniqueNewBettorId: bettor.id,\n    answerId,\n    isPartner,\n  })\n\n  const bonusTxn: Omit<UniqueBettorBonusTxn, 'id' | 'createdTime'> = {\n    fromType: 'BANK',\n    fromId: 'BANK',\n    toId: creatorId,\n    toType: 'USER',\n    amount: bonusAmount,\n    token: 'M$',\n    category: 'UNIQUE_BETTOR_BONUS',\n    data: bonusTxnData,\n  } as const\n  const balanceUpdate = {\n    id: bonusTxn.toId,\n    balance: bonusAmount,\n    totalDeposits: bonusAmount,\n  }\n  const txnQuery = getInsertQuery('txns', txnToRow(bonusTxn))\n\n  log(`Bonus txn for user: ${contract.creatorId} constructed:`, bonusTxn)\n  return {\n    balanceUpdate,\n    txnQuery,\n  }\n}\n"
        },
        {
          "path": "backend/api/src/multi-sell.ts",
          "preContent": "import * as crypto from 'crypto'\nimport { APIError, type APIHandler } from './helpers/endpoint'\nimport { onCreateBets } from 'api/on-create-bet'\nimport { executeNewBetResult } from 'api/place-bet'\nimport { getContract, getUser, log } from 'shared/utils'\nimport { groupBy, keyBy, mapValues, sumBy } from 'lodash'\nimport { getCpmmMultiSellSharesInfo } from 'common/sell-bet'\nimport { runTransactionWithRetries } from 'shared/transact-with-retries'\nimport { convertBet } from 'common/supabase/bets'\nimport { betsQueue } from 'shared/helpers/fn-queue'\nimport { getContractMetrics } from 'shared/helpers/user-contract-metrics'\nimport { getUnfilledBetsAndUserBalances } from 'api/helpers/bets'\nimport { isSummary } from 'common/contract-metric'\n\nexport const multiSell: APIHandler<'multi-sell'> = async (props, auth, req) => {\n  return await betsQueue.enqueueFn(\n    () => multiSellMain(props, auth, req),\n    [props.contractId, auth.uid]\n  )\n}\n\nconst multiSellMain: APIHandler<'multi-sell'> = async (props, auth) => {\n  const { contractId, answerIds, deterministic } = props\n  const { uid } = auth\n  const isApi = auth.creds.kind === 'key'\n\n  const user = await getUser(uid)\n  if (!user) throw new APIError(401, 'Your account was not found')\n\n  const results = await runTransactionWithRetries(async (pgTrans) => {\n    const contract = await getContract(pgTrans, contractId)\n    if (!contract) throw new APIError(404, 'Contract not found')\n    const { closeTime, isResolved, mechanism } = contract\n    if (closeTime && Date.now() > closeTime)\n      throw new APIError(403, 'Trading is closed.')\n    if (isResolved) throw new APIError(403, 'Market is resolved.')\n    if (mechanism != 'cpmm-multi-1' || !('shouldAnswersSumToOne' in contract))\n      throw new APIError(400, 'Contract type/mechanism not supported')\n\n    const answersToSell = contract.answers.filter((a) =>\n      answerIds.includes(a.id)\n    )\n    if (!answersToSell) throw new APIError(404, 'Answers not found')\n\n    const unfilledBetsAndBalances = await Promise.all(\n      answersToSell.map((answer) =>\n        getUnfilledBetsAndUserBalances(pgTrans, contract, uid, answer.id)\n      )\n    )\n    const unfilledBets = unfilledBetsAndBalances.flatMap((b) => b.unfilledBets)\n    let balancesByUserId: Record<string, number> = {}\n    unfilledBetsAndBalances.forEach((b) => {\n      balancesByUserId = { ...balancesByUserId, ...b.balanceByUserId }\n    })\n    const allMyMetrics = await getContractMetrics(\n      pgTrans,\n      [uid],\n      contractId,\n      contract.answers.map((a) => a.id),\n      true\n    )\n    const contractMetrics = [\n      ...(unfilledBetsAndBalances.flatMap((b) => b.contractMetrics) ?? []),\n      ...allMyMetrics,\n    ]\n\n    const userBets = await pgTrans.map(\n      `select * from contract_bets\n        where user_id = $1 and contract_id = $2 and answer_id in ($3:list)`,\n      [uid, contractId, answersToSell.map((a) => a.id)],\n      convertBet\n    )\n\n    const loanAmountByAnswerId = mapValues(\n      keyBy(\n        allMyMetrics.filter((m) => !isSummary(m)),\n        'answerId'\n      ),\n      (m) => m.loan ?? 0\n    )\n\n    const nonRedemptionBetsByAnswerId = groupBy(\n      userBets.filter((bet) => bet.shares !== 0),\n      (bet) => bet.answerId\n    )\n    const sharesByAnswerId = mapValues(nonRedemptionBetsByAnswerId, (bets) =>\n      sumBy(bets, (b) => b.shares)\n    )\n    const minShares = Math.min(...Object.values(sharesByAnswerId))\n\n    if (minShares === 0)\n      throw new APIError(\n        400,\n        `You specified an answer to sell in which you have 0 shares.`\n      )\n\n    const betResults = getCpmmMultiSellSharesInfo(\n      contract,\n      nonRedemptionBetsByAnswerId,\n      unfilledBets,\n      balancesByUserId,\n      loanAmountByAnswerId\n    )\n    const results = []\n    log(`Calculated new bet information for ${user.username} - auth ${uid}.`)\n    const betGroupId = crypto.randomBytes(12).toString('hex')\n    for (const newBetResult of betResults) {\n      const result = await executeNewBetResult(\n        pgTrans,\n        newBetResult,\n        contract,\n        user,\n        isApi,\n        contractMetrics,\n        undefined,\n        betGroupId,\n        deterministic,\n        false\n      )\n      results.push(result)\n    }\n    return results\n  })\n\n  log(`Main transaction finished - auth ${uid}.`)\n\n  const continuation = async () => {\n    const fullBets = results.flatMap((result) => result.fullBets)\n    const updatedMakers = results.flatMap((result) => result.updatedMakers)\n    const cancelledLimitOrders = results.flatMap(\n      (result) => result.cancelledLimitOrders\n    )\n    const makers = results.flatMap((result) => result.makers ?? [])\n    const user = results[0].user\n    await onCreateBets({\n      fullBets,\n      contract: results[0].contract,\n      user,\n      cancelledLimitOrders,\n      makers,\n      streakIncremented: results.some((b) => b.streakIncremented),\n      bonusTxn: results.find((r) => r.bonusTxn)?.bonusTxn,\n      reloadMetrics: true,\n      updatedMetrics: [],\n      userUpdates: undefined,\n      contractUpdate: undefined,\n      answerUpdates: undefined,\n      updatedMakers,\n    })\n  }\n\n  return {\n    result: results.map((result) => ({\n      ...result.newBet,\n      betId: result.betId,\n      betGroupId: result.betGroupId,\n    })),\n    continue: continuation,\n  }\n}\n",
          "postContent": "import * as crypto from 'crypto'\nimport { APIError, type APIHandler } from './helpers/endpoint'\nimport { onCreateBets } from 'api/on-create-bet'\nimport { executeNewBetResult } from 'api/place-bet'\nimport { getContract, getUser, log } from 'shared/utils'\nimport { groupBy, keyBy, mapValues, sumBy } from 'lodash'\nimport { getCpmmMultiSellSharesInfo } from 'common/sell-bet'\nimport { runTransactionWithRetries } from 'shared/transact-with-retries'\nimport { convertBet } from 'common/supabase/bets'\nimport { betsQueue } from 'shared/helpers/fn-queue'\nimport { getContractMetrics } from 'shared/helpers/user-contract-metrics'\nimport { getUnfilledBetsAndUserBalances } from 'api/helpers/bets'\nimport { isSummary } from 'common/contract-metric'\n\nexport const multiSell: APIHandler<'multi-sell'> = async (props, auth, req) => {\n  return await betsQueue.enqueueFn(\n    () => multiSellMain(props, auth, req),\n    [props.contractId, auth.uid]\n  )\n}\n\nconst multiSellMain: APIHandler<'multi-sell'> = async (props, auth) => {\n  const { contractId, answerIds, deterministic } = props\n  const { uid } = auth\n  const isApi = auth.creds.kind === 'key'\n\n  const user = await getUser(uid)\n  if (!user) throw new APIError(401, 'Your account was not found')\n\n  const results = await runTransactionWithRetries(async (pgTrans) => {\n    const contract = await getContract(pgTrans, contractId)\n    if (!contract) throw new APIError(404, 'Contract not found')\n    const { closeTime, isResolved, mechanism } = contract\n    if (closeTime && Date.now() > closeTime)\n      throw new APIError(403, 'Trading is closed.')\n    if (isResolved) throw new APIError(403, 'Market is resolved.')\n    if (mechanism != 'cpmm-multi-1' || !('shouldAnswersSumToOne' in contract))\n      throw new APIError(400, 'Contract type/mechanism not supported')\n\n    const answersToSell = contract.answers.filter((a) =>\n      answerIds.includes(a.id)\n    )\n    if (!answersToSell) throw new APIError(404, 'Answers not found')\n\n    const unfilledBetsAndBalances = await Promise.all(\n      answersToSell.map((answer) =>\n        getUnfilledBetsAndUserBalances(pgTrans, contract, uid, answer.id)\n      )\n    )\n    const unfilledBets = unfilledBetsAndBalances.flatMap((b) => b.unfilledBets)\n    let balancesByUserId: Record<string, number> = {}\n    unfilledBetsAndBalances.forEach((b) => {\n      balancesByUserId = { ...balancesByUserId, ...b.balanceByUserId }\n    })\n    const allMyMetrics = await getContractMetrics(\n      pgTrans,\n      [uid],\n      contractId,\n      contract.answers.map((a) => a.id),\n      true\n    )\n    const contractMetrics = [\n      ...(unfilledBetsAndBalances.flatMap((b) => b.contractMetrics) ?? []),\n      ...allMyMetrics,\n    ]\n\n    const userBets = await pgTrans.map(\n      `select * from contract_bets\n        where user_id = $1 and contract_id = $2 and answer_id in ($3:list)`,\n      [uid, contractId, answersToSell.map((a) => a.id)],\n      convertBet\n    )\n\n    const loanAmountByAnswerId = mapValues(\n      keyBy(\n        allMyMetrics.filter((m) => !isSummary(m)),\n        'answerId'\n      ),\n      (m) => m.loan ?? 0\n    )\n\n    const nonRedemptionBetsByAnswerId = groupBy(\n      userBets.filter((bet) => bet.shares !== 0),\n      (bet) => bet.answerId\n    )\n    const sharesByAnswerId = mapValues(nonRedemptionBetsByAnswerId, (bets) =>\n      sumBy(bets, (b) => b.shares)\n    )\n    const minShares = Math.min(...Object.values(sharesByAnswerId))\n\n    if (minShares === 0)\n      throw new APIError(\n        400,\n        `You specified an answer to sell in which you have 0 shares.`\n      )\n\n    const betResults = getCpmmMultiSellSharesInfo(\n      contract,\n      nonRedemptionBetsByAnswerId,\n      unfilledBets,\n      balancesByUserId,\n      loanAmountByAnswerId\n    )\n    const results = []\n    log(`Calculated new bet information for ${user.username} - auth ${uid}.`)\n    const betGroupId = crypto.randomBytes(12).toString('hex')\n    for (const newBetResult of betResults) {\n      const result = await executeNewBetResult(\n        pgTrans,\n        newBetResult,\n        contract,\n        user,\n        isApi,\n        contractMetrics,\n        balancesByUserId,\n        undefined,\n        betGroupId,\n        deterministic,\n        false\n      )\n      results.push(result)\n    }\n    return results\n  })\n\n  log(`Main transaction finished - auth ${uid}.`)\n\n  const continuation = async () => {\n    const fullBets = results.flatMap((result) => result.fullBets)\n    const updatedMakers = results.flatMap((result) => result.updatedMakers)\n    const cancelledLimitOrders = results.flatMap(\n      (result) => result.cancelledLimitOrders\n    )\n    const makers = results.flatMap((result) => result.makers ?? [])\n    const user = results[0].user\n    await onCreateBets({\n      fullBets,\n      contract: results[0].contract,\n      user,\n      cancelledLimitOrders,\n      makers,\n      streakIncremented: results.some((b) => b.streakIncremented),\n      bonusTxn: results.find((r) => r.bonusTxn)?.bonusTxn,\n      reloadMetrics: true,\n      updatedMetrics: [],\n      userUpdates: undefined,\n      contractUpdate: undefined,\n      answerUpdates: undefined,\n      updatedMakers,\n    })\n  }\n\n  return {\n    result: results.map((result) => ({\n      ...result.newBet,\n      betId: result.betId,\n      betGroupId: result.betGroupId,\n    })),\n    continue: continuation,\n  }\n}\n"
        },
        {
          "path": "backend/api/src/place-bet.ts",
          "preContent": "import { first, isEqual, maxBy, sumBy } from 'lodash'\nimport { APIError, AuthedUser, type APIHandler } from './helpers/endpoint'\nimport { CPMM_MIN_POOL_QTY, MarketContract } from 'common/contract'\nimport { User } from 'common/user'\nimport {\n  BetInfo,\n  CandidateBet,\n  getBinaryCpmmBetInfo,\n  getNewMultiCpmmBetInfo,\n} from 'common/new-bet'\nimport { removeUndefinedProps } from 'common/util/object'\nimport { Bet, getNewBetId, LimitBet, maker } from 'common/bet'\nimport { floatingEqual } from 'common/util/math'\nimport { log } from 'shared/utils'\nimport { Answer } from 'common/answer'\nimport { CpmmState, getCpmmProbability } from 'common/calculate-cpmm'\nimport { ValidatedAPIParams } from 'common/api/schema'\nimport { onCreateBets } from 'api/on-create-bet'\nimport {\n  createSupabaseDirectClient,\n  SupabaseTransaction,\n} from 'shared/supabase/init'\nimport {\n  broadcastUserUpdates,\n  bulkIncrementBalancesQuery,\n  incrementStreakQuery,\n  UserUpdate,\n} from 'shared/supabase/users'\nimport { convertBet } from 'common/supabase/bets'\nimport {\n  bulkInsertBetsQuery,\n  cancelLimitOrdersQuery,\n  insertZeroAmountLimitBet,\n} from 'shared/supabase/bets'\nimport { betsQueue, ordersQueue } from 'shared/helpers/fn-queue'\nimport { FLAT_TRADE_FEE } from 'common/fees'\nimport { redeemShares } from './redeem-shares'\nimport { partialAnswerToRow } from 'shared/supabase/answers'\nimport { filterDefined } from 'common/util/array'\nimport { convertContract } from 'common/supabase/contracts'\nimport { UniqueBettorBonusTxn } from 'common/txn'\nimport {\n  bulkUpdateContractMetricsQuery,\n  bulkUpdateUserMetricsWithNewBetsOnly,\n  getContractMetrics,\n} from 'shared/helpers/user-contract-metrics'\nimport { ContractMetric } from 'common/contract-metric'\nimport {\n  broadcastUpdatedAnswers,\n  broadcastUpdatedContract,\n} from 'shared/websockets/helpers'\nimport { bulkUpdateQuery, updateDataQuery } from 'shared/supabase/utils'\nimport { convertTxn } from 'common/supabase/txns'\nimport {\n  fetchContractBetDataAndValidate,\n  getMakerIdsFromBetResult,\n  getRoundedLimitProb,\n  getUniqueBettorBonusQuery,\n  getUserBalancesAndMetrics,\n  updateMakers,\n} from 'api/helpers/bets'\nimport { runTransactionWithRetries } from 'shared/transact-with-retries'\n\nexport const placeBet: APIHandler<'bet'> = async (props, auth) => {\n  const isApi = auth.creds.kind === 'key'\n  const { deps, contractId, dryRun } = props\n\n  if (deps === undefined || dryRun) {\n    return queueDependenciesThenBet(props, auth, isApi)\n  }\n\n  // Worst thing that could happen from wrong deps is contention\n  const fullDeps = [auth.uid, contractId, ...(deps ?? [])]\n  return await betsQueue.enqueueFn(() => {\n    return placeBetMain(props, auth.uid, isApi)\n  }, fullDeps)\n}\n\nconst queueDependenciesThenBet = async (\n  props: ValidatedAPIParams<'bet'>,\n  auth: AuthedUser,\n  isApi: boolean\n) => {\n  const { dryRun, contractId } = props\n  const minimalDeps = [auth.uid, contractId]\n  return await ordersQueue.enqueueFn(async () => {\n    const { contract, answers, unfilledBets, balanceByUserId } =\n      await fetchContractBetDataAndValidate(\n        createSupabaseDirectClient(),\n        props,\n        auth.uid,\n        isApi\n      )\n    // Simulate bet to see whose limit orders you match.\n    const simulatedResult = calculateBetResult(\n      props,\n      contract,\n      answers,\n      unfilledBets,\n      balanceByUserId\n    )\n    if (dryRun)\n      return {\n        result: {\n          ...simulatedResult.newBet,\n          betId: 'dry-run',\n        },\n        continue: () => Promise.resolve(),\n      }\n\n    const makerIds = getMakerIdsFromBetResult(simulatedResult)\n    return await betsQueue.enqueueFn(async () => {\n      return placeBetMain(props, auth.uid, isApi)\n    }, [...minimalDeps, ...makerIds])\n  }, minimalDeps)\n}\n\nexport const placeBetMain = async (\n  body: ValidatedAPIParams<'bet'>,\n  uid: string,\n  isApi: boolean\n) => {\n  const startTime = Date.now()\n  const { contractId, replyToCommentId, deterministic, answerId, silent } = body\n  // Fetch data outside transaction first to avoid locking all limit orderers\n  const {\n    user,\n    contract,\n    answers,\n    unfilledBets,\n    balanceByUserId,\n    unfilledBetUserIds,\n  } = await fetchContractBetDataAndValidate(\n    createSupabaseDirectClient(),\n    body,\n    uid,\n    isApi\n  )\n  // Simulate bet to see whose limit orders you match.\n  const simulatedResult = calculateBetResult(\n    body,\n    contract,\n    answers,\n    unfilledBets,\n    balanceByUserId\n  )\n  const simulatedMakerIds = getMakerIdsFromBetResult(simulatedResult)\n\n  const result = await runTransactionWithRetries(async (pgTrans) => {\n    log(`Inside main transaction for ${uid} placing a bet on ${contractId}.`)\n    // Refetch just user balance and metrics in transaction, since queue only enforces contract and bets not changing.\n    const { balanceByUserId, contractMetrics } =\n      await getUserBalancesAndMetrics(\n        pgTrans,\n        [uid, ...simulatedMakerIds], // Fetch just the makers that matched in the simulation.\n        contract,\n        answerId\n      )\n    user.balance = balanceByUserId[uid]\n    if (user.balance < body.amount)\n      throw new APIError(403, 'Insufficient balance.')\n\n    for (const userId of unfilledBetUserIds) {\n      if (!(userId in balanceByUserId)) {\n        // Assume other makers have infinite balance since they are not involved in this bet.\n        balanceByUserId[userId] = Number.MAX_SAFE_INTEGER\n      }\n    }\n    const newBetResult = calculateBetResult(\n      body,\n      contract,\n      answers,\n      unfilledBets,\n      balanceByUserId\n    )\n    log(`Calculated new bet information for ${user.username} - auth ${uid}.`)\n    const { newBet } = newBetResult\n    if (!newBet.amount && !newBet.orderAmount && !newBet.shares) {\n      throw new APIError(400, 'Betting allowed only between 1-99%.')\n    }\n    const actualMakerIds = getMakerIdsFromBetResult(newBetResult)\n    log(\n      'simulated makerIds',\n      simulatedMakerIds,\n      'actualMakerIds',\n      actualMakerIds\n    )\n    if (!isEqual(simulatedMakerIds, actualMakerIds)) {\n      log.warn('Matched limit orders changed from simulated values.')\n      throw new APIError(503, 'Please try betting again.')\n    }\n\n    const betGroupId =\n      contract.mechanism === 'cpmm-multi-1' && contract.shouldAnswersSumToOne\n        ? getNewBetId()\n        : undefined\n\n    return await executeNewBetResult(\n      pgTrans,\n      newBetResult,\n      contract,\n      user,\n      isApi,\n      contractMetrics,\n      replyToCommentId,\n      betGroupId,\n      deterministic,\n      false,\n      isApi ? undefined : silent\n    )\n  })\n\n  const { newBet, betId, betGroupId } = result\n\n  log(`Main transaction finished - auth ${uid}.`)\n  // metrics.inc('app/bet_count', { contract_id: contractId })\n\n  const continuation = async () => {\n    await onCreateBets(result)\n  }\n\n  const time = Date.now() - startTime\n  log(`Place bet took ${time}ms.`)\n\n  return {\n    result: { ...newBet, betId, betGroupId },\n    continue: continuation,\n  }\n}\n\nexport const calculateBetResult = (\n  body: ValidatedAPIParams<'bet'>,\n  contract: MarketContract,\n  answers: Answer[] | undefined,\n  unfilledBets: LimitBet[],\n  balanceByUserId: Record<string, number>\n) => {\n  const { amount, expiresMillisAfter } = body\n  const { outcomeType, mechanism } = contract\n\n  if (mechanism == 'cpmm-1') {\n    // eslint-disable-next-line prefer-const\n    let { outcome, limitProb, expiresAt } = body\n    if (expiresAt && expiresAt < Date.now())\n      throw new APIError(400, 'Bet cannot expire in the past.')\n\n    if (limitProb !== undefined && outcomeType === 'BINARY') {\n      const isRounded = floatingEqual(\n        Math.round(limitProb * 100),\n        limitProb * 100\n      )\n      if (!isRounded)\n        throw new APIError(\n          400,\n          'limitProb must be in increments of 0.01 (i.e. whole percentage points)'\n        )\n\n      limitProb = Math.round(limitProb * 100) / 100\n    }\n\n    return getBinaryCpmmBetInfo(\n      contract,\n      outcome,\n      amount,\n      limitProb,\n      unfilledBets,\n      balanceByUserId,\n      expiresAt,\n      expiresMillisAfter\n    )\n  } else if (mechanism == 'cpmm-multi-1') {\n    const { shouldAnswersSumToOne } = contract\n    if (!body.answerId || !answers) {\n      throw new APIError(400, 'answerId must be specified for multi bets')\n    }\n\n    const { answerId, outcome, limitProb, expiresAt } = body\n    if (expiresAt && expiresAt < Date.now())\n      throw new APIError(403, 'Bet cannot expire in the past.')\n    const answer = answers.find((a) => a.id === answerId)\n    if (!answer) throw new APIError(404, 'Answer not found')\n    if (answer.resolution)\n      throw new APIError(403, 'Answer is resolved and cannot be bet on')\n    if (shouldAnswersSumToOne && answers.length < 2)\n      throw new APIError(\n        403,\n        'Cannot bet until at least two answers are added.'\n      )\n\n    const roundedLimitProb = getRoundedLimitProb(limitProb)\n\n    return getNewMultiCpmmBetInfo(\n      contract,\n      answers,\n      answer,\n      outcome,\n      amount,\n      roundedLimitProb,\n      unfilledBets,\n      balanceByUserId,\n      expiresAt,\n      expiresMillisAfter\n    )\n  } else {\n    throw new APIError(\n      400,\n      'Contract type/mechanism not supported (or is no longer)'\n    )\n  }\n}\n\nexport type NewBetResult = BetInfo & {\n  makers?: maker[]\n  ordersToCancel?: LimitBet[]\n  otherBetResults?: {\n    answer: Answer\n    bet: CandidateBet<Bet>\n    cpmmState: CpmmState\n    makers: maker[]\n    ordersToCancel: LimitBet[]\n  }[]\n}\nexport const executeNewBetResult = async (\n  pgTrans: SupabaseTransaction,\n  newBetResult: NewBetResult,\n  contract: MarketContract,\n  user: User,\n  isApi: boolean,\n  contractMetrics: ContractMetric[],\n  replyToCommentId?: string,\n  betGroupId?: string,\n  deterministic?: boolean,\n  firstBetInMultiBet?: boolean,\n  silent?: boolean\n) => {\n  const {\n    newBet,\n    otherBetResults,\n    newPool,\n    newTotalLiquidity,\n    newP,\n    makers,\n    ordersToCancel,\n  } = newBetResult\n  const { mechanism } = contract\n  if (\n    mechanism == 'cpmm-1' &&\n    (!newP ||\n      !isFinite(newP) ||\n      Math.min(...Object.values(newPool ?? {})) < CPMM_MIN_POOL_QTY)\n  ) {\n    throw new APIError(403, 'Trade too large for current liquidity pool.')\n  }\n\n  if (\n    !isFinite(newBet.amount) ||\n    !isFinite(newBet.shares) ||\n    !isFinite(newBet.probAfter)\n  ) {\n    throw new APIError(\n      500,\n      'Bet calculation produced invalid number, please try again later.'\n    )\n  }\n\n  const candidateBet = removeUndefinedProps({\n    id: getNewBetId(),\n    userId: user.id,\n    isApi,\n    silent,\n    replyToCommentId,\n    betGroupId,\n    ...newBet,\n  })\n\n  // Just an unfilled limit order, no need to update metrics, maker shares, contract, etc.\n  if (newBet.amount === 0) {\n    const betRow = await insertZeroAmountLimitBet(candidateBet, pgTrans)\n    log(`Inserted limit bet for ${user.username} - auth ${user.id}.`)\n    return {\n      contract,\n      newBet,\n      betId: betRow.bet_id,\n      makers,\n      cancelledLimitOrders: [],\n      fullBets: [convertBet(betRow)],\n      user,\n      betGroupId,\n      streakIncremented: false,\n      updatedMetrics: [],\n      bonusTxn: undefined,\n      userUpdates: undefined,\n      contractUpdate: undefined,\n      answerUpdates: undefined,\n      updatedMakers: [],\n    }\n  }\n  const isNumberContract = contract.outcomeType === 'NUMBER'\n  const apiFee = isApi ? FLAT_TRADE_FEE : 0\n  const betsToInsert: Bet[] = [candidateBet]\n  const allOrdersToCancel: LimitBet[] = filterDefined(ordersToCancel ?? [])\n  const userBalanceUpdates = [\n    {\n      id: user.id,\n      balance: -newBet.amount - apiFee + (newBet.loanAmount ?? 0),\n    },\n  ]\n  const makersByTakerBetId: Record<string, maker[]> = {\n    [candidateBet.id]: makers ?? [],\n  }\n  const answerUpdates: {\n    id: string\n    poolYes: number\n    poolNo: number\n    prob: number\n  }[] = []\n\n  const sumsToOne =\n    contract.mechanism === 'cpmm-multi-1' && contract.shouldAnswersSumToOne\n  let bonusTxnQuery = 'select 1 where false'\n  if (\n    (!isNumberContract || firstBetInMultiBet) &&\n    !contractMetrics.find(\n      (m) =>\n        m.userId === user.id &&\n        (sumsToOne ? true : m.answerId == candidateBet.answerId)\n    )\n  ) {\n    const { balanceUpdate, txnQuery } = getUniqueBettorBonusQuery(\n      contract,\n      user,\n      newBet\n    )\n    if (balanceUpdate) {\n      userBalanceUpdates.push(balanceUpdate)\n    }\n    bonusTxnQuery = txnQuery\n  }\n\n  if (otherBetResults) {\n    const otherBetsToInsert = filterDefined(\n      otherBetResults.map((result) => {\n        const { answer, bet, cpmmState, ordersToCancel, makers } = result\n        const { probBefore, probAfter } = bet\n        const smallEnoughToIgnore =\n          probBefore < 0.001 &&\n          probAfter < 0.001 &&\n          Math.abs(probAfter - probBefore) < 0.00001\n\n        if (deterministic || !smallEnoughToIgnore || Math.random() < 0.01) {\n          const candidateBet = removeUndefinedProps({\n            id: getNewBetId(),\n            userId: user.id,\n            isApi,\n            betGroupId,\n            ...bet,\n          })\n\n          const { YES: poolYes, NO: poolNo } = cpmmState.pool\n          const prob = getCpmmProbability(cpmmState.pool, 0.5)\n          answerUpdates.push({\n            id: answer.id,\n            poolYes,\n            poolNo,\n            prob,\n          })\n          makersByTakerBetId[candidateBet.id] = makers\n          return candidateBet\n        }\n\n        allOrdersToCancel.push(...ordersToCancel)\n        return undefined\n      })\n    )\n    betsToInsert.push(...otherBetsToInsert)\n  }\n  const isUniqueBettor =\n    (!isNumberContract || firstBetInMultiBet) &&\n    !contractMetrics.find((m) => m.userId === user.id)\n  const lastBetTime =\n    maxBy(betsToInsert, (b) => b.createdTime)?.createdTime ?? Date.now()\n  const contractUpdate: Partial<MarketContract> & { id: string } =\n    removeUndefinedProps({\n      id: contract.id,\n      lastBetTime,\n      volume: contract.volume + sumBy(betsToInsert, (b) => Math.abs(b.amount)),\n      lastUpdatedTime: lastBetTime,\n      uniqueBettorCount: contract.uniqueBettorCount + (isUniqueBettor ? 1 : 0),\n      ...(contract.mechanism === 'cpmm-1'\n        ? {\n            pool: newPool,\n            p: newP,\n            totalLiquidity: newTotalLiquidity,\n            prob:\n              newPool && newP ? getCpmmProbability(newPool, newP) : undefined,\n          }\n        : {}),\n    })\n  // Multi-cpmm-1 contract\n  if (newBet.answerId && newPool) {\n    const { YES: poolYes, NO: poolNo } = newPool\n    const prob = getCpmmProbability(newPool, 0.5)\n    answerUpdates.push({\n      id: newBet.answerId,\n      poolYes,\n      poolNo,\n      prob,\n    })\n  }\n\n  const metrics =\n    isNumberContract && !firstBetInMultiBet\n      ? await getContractMetrics(\n          pgTrans,\n          [user.id],\n          contract.id,\n          filterDefined(betsToInsert.map((b) => b.answerId)),\n          true\n        )\n      : contractMetrics\n\n  const updatedMetrics = await bulkUpdateUserMetricsWithNewBetsOnly(\n    pgTrans,\n    betsToInsert,\n    metrics,\n    false\n  )\n\n  const {\n    betsToInsert: makerRedemptionBetsToInsert,\n    updatedMetrics: makerRedemptionAndFillUpdatedMetrics,\n    balanceUpdates: makerRedemptionAndFillBalanceUpdates,\n    bulkUpdateLimitOrdersQuery,\n    updatedMakers,\n  } = await updateMakers(makersByTakerBetId, contract, updatedMetrics, pgTrans)\n  // Create redemption bets for bettor w/o limit fills if needed:\n  const {\n    betsToInsert: bettorRedemptionBetsToInsert,\n    updatedMetrics: bettorRedemptionUpdatedMetrics,\n    balanceUpdates: bettorRedemptionBalanceUpdates,\n  } = await redeemShares(\n    pgTrans,\n    [user.id],\n    contract,\n    [candidateBet],\n    makerRedemptionAndFillUpdatedMetrics\n  )\n\n  const userBalanceUpdatesQuery = bulkIncrementBalancesQuery([\n    ...userBalanceUpdates,\n    ...makerRedemptionAndFillBalanceUpdates,\n    ...bettorRedemptionBalanceUpdates,\n  ])\n  const insertedBets = [\n    ...betsToInsert,\n    ...makerRedemptionBetsToInsert,\n    ...bettorRedemptionBetsToInsert,\n  ]\n  const insertBetsQuery = bulkInsertBetsQuery(insertedBets)\n  const newMetrics = bettorRedemptionUpdatedMetrics.filter((m) => {\n    const existingMetric = metrics.find(\n      (m2) =>\n        m2.userId === m.userId &&\n        m2.answerId === m.answerId &&\n        m2.contractId === m.contractId\n    )\n    return !existingMetric || !isEqual(existingMetric, m)\n  })\n  const metricsQuery = bulkUpdateContractMetricsQuery(newMetrics)\n  const streakIncrementedQuery = incrementStreakQuery(user, newBet.createdTime)\n  const contractUpdateQuery = updateDataQuery('contracts', 'id', contractUpdate)\n  const answerUpdateQuery = bulkUpdateQuery(\n    'answers',\n    ['id'],\n    answerUpdates.map(partialAnswerToRow)\n  )\n  const { query: cancelLimitsQuery, bets: cancelledLimitOrders } =\n    cancelLimitOrdersQuery(allOrdersToCancel)\n  const startTime = Date.now()\n  const results = await pgTrans.multi(\n    `\n    ${userBalanceUpdatesQuery}; --0\n    ${streakIncrementedQuery}; --1\n    ${insertBetsQuery}; --2\n    ${metricsQuery}; --3\n    ${contractUpdateQuery}; --4\n    ${answerUpdateQuery}; --5\n    ${cancelLimitsQuery}; --6\n    ${bulkUpdateLimitOrdersQuery}; --7\n    ${bonusTxnQuery}; --8\n     `\n  )\n  log(`placeBet bulk insert/update took ${Date.now() - startTime}ms`)\n  const userUpdates = results[0] as UserUpdate[]\n  const streakIncremented = results[1][0].streak_incremented\n  const newContract = results[4].map(convertContract)[0]\n  const bonusTxn = first(results[8].map(convertTxn)) as\n    | UniqueBettorBonusTxn\n    | undefined\n\n  // On normal contracts, we do this in on-create-bet\n  if (isNumberContract) {\n    broadcastUserUpdates(userUpdates)\n    broadcastUpdatedContract(newContract.visibility, contractUpdate)\n    broadcastUpdatedAnswers(newContract.id, answerUpdates)\n  }\n\n  return {\n    contract,\n    newBet,\n    betId: betsToInsert[0].id,\n    makers,\n    cancelledLimitOrders: cancelledLimitOrders,\n    fullBets: insertedBets,\n    user,\n    betGroupId,\n    streakIncremented,\n    bonusTxn,\n    updatedMetrics: bettorRedemptionUpdatedMetrics,\n    answerUpdates,\n    contractUpdate,\n    userUpdates,\n    updatedMakers,\n  }\n}\n",
          "postContent": "import { first, isEqual, maxBy, sumBy } from 'lodash'\nimport { APIError, AuthedUser, type APIHandler } from './helpers/endpoint'\nimport { CPMM_MIN_POOL_QTY, MarketContract } from 'common/contract'\nimport { User } from 'common/user'\nimport {\n  BetInfo,\n  CandidateBet,\n  getBinaryCpmmBetInfo,\n  getNewMultiCpmmBetInfo,\n} from 'common/new-bet'\nimport { removeUndefinedProps } from 'common/util/object'\nimport { Bet, getNewBetId, LimitBet, maker } from 'common/bet'\nimport { floatingEqual } from 'common/util/math'\nimport { log } from 'shared/utils'\nimport { Answer } from 'common/answer'\nimport { CpmmState, getCpmmProbability } from 'common/calculate-cpmm'\nimport { ValidatedAPIParams } from 'common/api/schema'\nimport { onCreateBets } from 'api/on-create-bet'\nimport {\n  createSupabaseDirectClient,\n  SupabaseTransaction,\n} from 'shared/supabase/init'\nimport {\n  broadcastUserUpdates,\n  bulkIncrementBalancesQuery,\n  incrementStreakQuery,\n  UserUpdate,\n} from 'shared/supabase/users'\nimport { convertBet } from 'common/supabase/bets'\nimport {\n  bulkInsertBetsQuery,\n  cancelLimitOrdersQuery,\n  insertZeroAmountLimitBet,\n} from 'shared/supabase/bets'\nimport { betsQueue, ordersQueue } from 'shared/helpers/fn-queue'\nimport { FLAT_TRADE_FEE } from 'common/fees'\nimport { redeemShares } from './redeem-shares'\nimport { partialAnswerToRow } from 'shared/supabase/answers'\nimport { filterDefined } from 'common/util/array'\nimport { convertContract } from 'common/supabase/contracts'\nimport { UniqueBettorBonusTxn } from 'common/txn'\nimport {\n  bulkUpdateContractMetricsQuery,\n  bulkUpdateUserMetricsWithNewBetsOnly,\n  getContractMetrics,\n} from 'shared/helpers/user-contract-metrics'\nimport { ContractMetric } from 'common/contract-metric'\nimport {\n  broadcastUpdatedAnswers,\n  broadcastUpdatedContract,\n} from 'shared/websockets/helpers'\nimport { bulkUpdateQuery, updateDataQuery } from 'shared/supabase/utils'\nimport { convertTxn } from 'common/supabase/txns'\nimport {\n  fetchContractBetDataAndValidate,\n  getMakerIdsFromBetResult,\n  getRoundedLimitProb,\n  getUniqueBettorBonusQuery,\n  getUserBalancesAndMetrics,\n  updateMakers,\n} from 'api/helpers/bets'\nimport { runTransactionWithRetries } from 'shared/transact-with-retries'\n\nexport const placeBet: APIHandler<'bet'> = async (props, auth) => {\n  const isApi = auth.creds.kind === 'key'\n  const { deps, contractId, dryRun } = props\n\n  if (deps === undefined || dryRun) {\n    return queueDependenciesThenBet(props, auth, isApi)\n  }\n\n  // Worst thing that could happen from wrong deps is contention\n  const fullDeps = [auth.uid, contractId, ...(deps ?? [])]\n  return await betsQueue.enqueueFn(() => {\n    return placeBetMain(props, auth.uid, isApi)\n  }, fullDeps)\n}\n\nconst queueDependenciesThenBet = async (\n  props: ValidatedAPIParams<'bet'>,\n  auth: AuthedUser,\n  isApi: boolean\n) => {\n  const { dryRun, contractId } = props\n  const minimalDeps = [auth.uid, contractId]\n  return await ordersQueue.enqueueFn(async () => {\n    const { contract, answers, unfilledBets, balanceByUserId } =\n      await fetchContractBetDataAndValidate(\n        createSupabaseDirectClient(),\n        props,\n        auth.uid,\n        isApi\n      )\n    // Simulate bet to see whose limit orders you match.\n    const simulatedResult = calculateBetResult(\n      props,\n      contract,\n      answers,\n      unfilledBets,\n      balanceByUserId\n    )\n    if (dryRun)\n      return {\n        result: {\n          ...simulatedResult.newBet,\n          betId: 'dry-run',\n        },\n        continue: () => Promise.resolve(),\n      }\n\n    const makerIds = getMakerIdsFromBetResult(simulatedResult)\n    return await betsQueue.enqueueFn(async () => {\n      return placeBetMain(props, auth.uid, isApi)\n    }, [...minimalDeps, ...makerIds])\n  }, minimalDeps)\n}\n\nexport const placeBetMain = async (\n  body: ValidatedAPIParams<'bet'>,\n  uid: string,\n  isApi: boolean\n) => {\n  const startTime = Date.now()\n  const { contractId, replyToCommentId, deterministic, answerId, silent } = body\n  // Fetch data outside transaction first to avoid locking all limit orderers\n  const {\n    user,\n    contract,\n    answers,\n    unfilledBets,\n    balanceByUserId,\n    unfilledBetUserIds,\n  } = await fetchContractBetDataAndValidate(\n    createSupabaseDirectClient(),\n    body,\n    uid,\n    isApi\n  )\n  // Simulate bet to see whose limit orders you match.\n  const simulatedResult = calculateBetResult(\n    body,\n    contract,\n    answers,\n    unfilledBets,\n    balanceByUserId\n  )\n  const simulatedMakerIds = getMakerIdsFromBetResult(simulatedResult)\n\n  const result = await runTransactionWithRetries(async (pgTrans) => {\n    log(`Inside main transaction for ${uid} placing a bet on ${contractId}.`)\n    // Refetch just user balance and metrics in transaction, since queue only enforces contract and bets not changing.\n    const { balanceByUserId, contractMetrics } =\n      await getUserBalancesAndMetrics(\n        pgTrans,\n        [uid, ...simulatedMakerIds], // Fetch just the makers that matched in the simulation.\n        contract,\n        answerId\n      )\n    user.balance = balanceByUserId[uid]\n    if (user.balance < body.amount)\n      throw new APIError(403, 'Insufficient balance.')\n\n    for (const userId of unfilledBetUserIds) {\n      if (!(userId in balanceByUserId)) {\n        // Assume other makers have infinite balance since they are not involved in this bet.\n        balanceByUserId[userId] = Number.MAX_SAFE_INTEGER\n      }\n    }\n    const newBetResult = calculateBetResult(\n      body,\n      contract,\n      answers,\n      unfilledBets,\n      balanceByUserId\n    )\n    log(`Calculated new bet information for ${user.username} - auth ${uid}.`)\n    const { newBet } = newBetResult\n    if (!newBet.amount && !newBet.orderAmount && !newBet.shares) {\n      throw new APIError(400, 'Betting allowed only between 1-99%.')\n    }\n    const actualMakerIds = getMakerIdsFromBetResult(newBetResult)\n    log(\n      'simulated makerIds',\n      simulatedMakerIds,\n      'actualMakerIds',\n      actualMakerIds\n    )\n    if (!isEqual(simulatedMakerIds, actualMakerIds)) {\n      log.warn('Matched limit orders changed from simulated values.')\n      throw new APIError(503, 'Please try betting again.')\n    }\n\n    const betGroupId =\n      contract.mechanism === 'cpmm-multi-1' && contract.shouldAnswersSumToOne\n        ? getNewBetId()\n        : undefined\n\n    return await executeNewBetResult(\n      pgTrans,\n      newBetResult,\n      contract,\n      user,\n      isApi,\n      contractMetrics,\n      balanceByUserId,\n      replyToCommentId,\n      betGroupId,\n      deterministic,\n      false,\n      isApi ? undefined : silent\n    )\n  })\n\n  const { newBet, betId, betGroupId } = result\n\n  log(`Main transaction finished - auth ${uid}.`)\n  // metrics.inc('app/bet_count', { contract_id: contractId })\n\n  const continuation = async () => {\n    await onCreateBets(result)\n  }\n\n  const time = Date.now() - startTime\n  log(`Place bet took ${time}ms.`)\n\n  return {\n    result: { ...newBet, betId, betGroupId },\n    continue: continuation,\n  }\n}\n\nexport const calculateBetResult = (\n  body: ValidatedAPIParams<'bet'>,\n  contract: MarketContract,\n  answers: Answer[] | undefined,\n  unfilledBets: LimitBet[],\n  balanceByUserId: Record<string, number>\n) => {\n  const { amount, expiresMillisAfter } = body\n  const { outcomeType, mechanism } = contract\n\n  if (mechanism == 'cpmm-1') {\n    // eslint-disable-next-line prefer-const\n    let { outcome, limitProb, expiresAt } = body\n    if (expiresAt && expiresAt < Date.now())\n      throw new APIError(400, 'Bet cannot expire in the past.')\n\n    if (limitProb !== undefined && outcomeType === 'BINARY') {\n      const isRounded = floatingEqual(\n        Math.round(limitProb * 100),\n        limitProb * 100\n      )\n      if (!isRounded)\n        throw new APIError(\n          400,\n          'limitProb must be in increments of 0.01 (i.e. whole percentage points)'\n        )\n\n      limitProb = Math.round(limitProb * 100) / 100\n    }\n\n    return getBinaryCpmmBetInfo(\n      contract,\n      outcome,\n      amount,\n      limitProb,\n      unfilledBets,\n      balanceByUserId,\n      expiresAt,\n      expiresMillisAfter\n    )\n  } else if (mechanism == 'cpmm-multi-1') {\n    const { shouldAnswersSumToOne } = contract\n    if (!body.answerId || !answers) {\n      throw new APIError(400, 'answerId must be specified for multi bets')\n    }\n\n    const { answerId, outcome, limitProb, expiresAt } = body\n    if (expiresAt && expiresAt < Date.now())\n      throw new APIError(403, 'Bet cannot expire in the past.')\n    const answer = answers.find((a) => a.id === answerId)\n    if (!answer) throw new APIError(404, 'Answer not found')\n    if (answer.resolution)\n      throw new APIError(403, 'Answer is resolved and cannot be bet on')\n    if (shouldAnswersSumToOne && answers.length < 2)\n      throw new APIError(\n        403,\n        'Cannot bet until at least two answers are added.'\n      )\n\n    const roundedLimitProb = getRoundedLimitProb(limitProb)\n\n    return getNewMultiCpmmBetInfo(\n      contract,\n      answers,\n      answer,\n      outcome,\n      amount,\n      roundedLimitProb,\n      unfilledBets,\n      balanceByUserId,\n      expiresAt,\n      expiresMillisAfter\n    )\n  } else {\n    throw new APIError(\n      400,\n      'Contract type/mechanism not supported (or is no longer)'\n    )\n  }\n}\n\nexport type NewBetResult = BetInfo & {\n  makers?: maker[]\n  ordersToCancel?: LimitBet[]\n  otherBetResults?: {\n    answer: Answer\n    bet: CandidateBet<Bet>\n    cpmmState: CpmmState\n    makers: maker[]\n    ordersToCancel: LimitBet[]\n  }[]\n}\nexport const executeNewBetResult = async (\n  pgTrans: SupabaseTransaction,\n  newBetResult: NewBetResult,\n  contract: MarketContract,\n  user: User,\n  isApi: boolean,\n  contractMetrics: ContractMetric[],\n  balanceByUserId: Record<string, number>,\n  replyToCommentId?: string,\n  betGroupId?: string,\n  deterministic?: boolean,\n  firstBetInMultiBet?: boolean,\n  silent?: boolean\n) => {\n  const {\n    newBet,\n    otherBetResults,\n    newPool,\n    newTotalLiquidity,\n    newP,\n    makers,\n    ordersToCancel,\n  } = newBetResult\n  const { mechanism } = contract\n  if (\n    mechanism == 'cpmm-1' &&\n    (!newP ||\n      !isFinite(newP) ||\n      Math.min(...Object.values(newPool ?? {})) < CPMM_MIN_POOL_QTY)\n  ) {\n    throw new APIError(403, 'Trade too large for current liquidity pool.')\n  }\n\n  if (\n    !isFinite(newBet.amount) ||\n    !isFinite(newBet.shares) ||\n    !isFinite(newBet.probAfter)\n  ) {\n    throw new APIError(\n      500,\n      'Bet calculation produced invalid number, please try again later.'\n    )\n  }\n\n  const candidateBet = removeUndefinedProps({\n    id: getNewBetId(),\n    userId: user.id,\n    isApi,\n    silent,\n    replyToCommentId,\n    betGroupId,\n    ...newBet,\n  })\n\n  // Just an unfilled limit order, no need to update metrics, maker shares, contract, etc.\n  if (newBet.amount === 0) {\n    const betRow = await insertZeroAmountLimitBet(candidateBet, pgTrans)\n    log(`Inserted limit bet for ${user.username} - auth ${user.id}.`)\n    return {\n      contract,\n      newBet,\n      betId: betRow.bet_id,\n      makers,\n      cancelledLimitOrders: [],\n      fullBets: [convertBet(betRow)],\n      user,\n      betGroupId,\n      streakIncremented: false,\n      updatedMetrics: [],\n      bonusTxn: undefined,\n      userUpdates: undefined,\n      contractUpdate: undefined,\n      answerUpdates: undefined,\n      updatedMakers: [],\n    }\n  }\n  const isNumberContract = contract.outcomeType === 'NUMBER'\n  const apiFee = isApi ? FLAT_TRADE_FEE : 0\n  const betsToInsert: Bet[] = [candidateBet]\n  const allOrdersToCancel: LimitBet[] = filterDefined(ordersToCancel ?? [])\n  const userBalanceUpdates = [\n    {\n      id: user.id,\n      balance: -newBet.amount - apiFee + (newBet.loanAmount ?? 0),\n    },\n  ]\n  const makersByTakerBetId: Record<string, maker[]> = {\n    [candidateBet.id]: makers ?? [],\n  }\n  const answerUpdates: {\n    id: string\n    poolYes: number\n    poolNo: number\n    prob: number\n  }[] = []\n\n  const sumsToOne =\n    contract.mechanism === 'cpmm-multi-1' && contract.shouldAnswersSumToOne\n  let bonusTxnQuery = 'select 1 where false'\n  if (\n    (!isNumberContract || firstBetInMultiBet) &&\n    !contractMetrics.find(\n      (m) =>\n        m.userId === user.id &&\n        (sumsToOne ? true : m.answerId == candidateBet.answerId)\n    )\n  ) {\n    const { balanceUpdate, txnQuery } = getUniqueBettorBonusQuery(\n      contract,\n      user,\n      newBet\n    )\n    if (balanceUpdate) {\n      userBalanceUpdates.push(balanceUpdate)\n    }\n    bonusTxnQuery = txnQuery\n  }\n\n  if (otherBetResults) {\n    const otherBetsToInsert = filterDefined(\n      otherBetResults.map((result) => {\n        const { answer, bet, cpmmState, ordersToCancel, makers } = result\n        const { probBefore, probAfter } = bet\n        const smallEnoughToIgnore =\n          probBefore < 0.001 &&\n          probAfter < 0.001 &&\n          Math.abs(probAfter - probBefore) < 0.00001\n\n        if (deterministic || !smallEnoughToIgnore || Math.random() < 0.01) {\n          const candidateBet = removeUndefinedProps({\n            id: getNewBetId(),\n            userId: user.id,\n            isApi,\n            betGroupId,\n            ...bet,\n          })\n\n          const { YES: poolYes, NO: poolNo } = cpmmState.pool\n          const prob = getCpmmProbability(cpmmState.pool, 0.5)\n          answerUpdates.push({\n            id: answer.id,\n            poolYes,\n            poolNo,\n            prob,\n          })\n          makersByTakerBetId[candidateBet.id] = makers\n          return candidateBet\n        }\n\n        allOrdersToCancel.push(...ordersToCancel)\n        return undefined\n      })\n    )\n    betsToInsert.push(...otherBetsToInsert)\n  }\n  const isUniqueBettor =\n    (!isNumberContract || firstBetInMultiBet) &&\n    !contractMetrics.find((m) => m.userId === user.id)\n  const lastBetTime =\n    maxBy(betsToInsert, (b) => b.createdTime)?.createdTime ?? Date.now()\n  const contractUpdate: Partial<MarketContract> & { id: string } =\n    removeUndefinedProps({\n      id: contract.id,\n      lastBetTime,\n      volume: contract.volume + sumBy(betsToInsert, (b) => Math.abs(b.amount)),\n      lastUpdatedTime: lastBetTime,\n      uniqueBettorCount: contract.uniqueBettorCount + (isUniqueBettor ? 1 : 0),\n      ...(contract.mechanism === 'cpmm-1'\n        ? {\n            pool: newPool,\n            p: newP,\n            totalLiquidity: newTotalLiquidity,\n            prob:\n              newPool && newP ? getCpmmProbability(newPool, newP) : undefined,\n          }\n        : {}),\n    })\n  // Multi-cpmm-1 contract\n  if (newBet.answerId && newPool) {\n    const { YES: poolYes, NO: poolNo } = newPool\n    const prob = getCpmmProbability(newPool, 0.5)\n    answerUpdates.push({\n      id: newBet.answerId,\n      poolYes,\n      poolNo,\n      prob,\n    })\n  }\n\n  const metrics =\n    isNumberContract && !firstBetInMultiBet\n      ? await getContractMetrics(\n          pgTrans,\n          [user.id],\n          contract.id,\n          filterDefined(betsToInsert.map((b) => b.answerId)),\n          true\n        )\n      : contractMetrics\n\n  const updatedMetrics = await bulkUpdateUserMetricsWithNewBetsOnly(\n    pgTrans,\n    betsToInsert,\n    metrics,\n    false\n  )\n\n  const {\n    betsToInsert: makerRedemptionBetsToInsert,\n    updatedMetrics: makerRedemptionAndFillUpdatedMetrics,\n    balanceUpdates: makerRedemptionAndFillBalanceUpdates,\n    bulkUpdateLimitOrdersQuery,\n    updatedMakers,\n  } = await updateMakers(makersByTakerBetId, contract, updatedMetrics, pgTrans)\n  // Create redemption bets for bettor w/o limit fills if needed:\n  const {\n    betsToInsert: bettorRedemptionBetsToInsert,\n    updatedMetrics: bettorRedemptionUpdatedMetrics,\n    balanceUpdates: bettorRedemptionBalanceUpdates,\n  } = await redeemShares(\n    pgTrans,\n    [user.id],\n    contract,\n    [candidateBet],\n    makerRedemptionAndFillUpdatedMetrics\n  )\n\n  const userBalanceUpdatesQuery = bulkIncrementBalancesQuery([\n    ...userBalanceUpdates,\n    ...makerRedemptionAndFillBalanceUpdates,\n    ...bettorRedemptionBalanceUpdates,\n  ])\n  const insertedBets = [\n    ...betsToInsert,\n    ...makerRedemptionBetsToInsert,\n    ...bettorRedemptionBetsToInsert,\n  ]\n  const insertBetsQuery = bulkInsertBetsQuery(insertedBets)\n  const newMetrics = bettorRedemptionUpdatedMetrics.filter((m) => {\n    const existingMetric = metrics.find(\n      (m2) =>\n        m2.userId === m.userId &&\n        m2.answerId === m.answerId &&\n        m2.contractId === m.contractId\n    )\n    return !existingMetric || !isEqual(existingMetric, m)\n  })\n  const metricsQuery = bulkUpdateContractMetricsQuery(newMetrics)\n  const streakIncrementedQuery = incrementStreakQuery(user, newBet.createdTime)\n  const contractUpdateQuery = updateDataQuery('contracts', 'id', contractUpdate)\n  const answerUpdateQuery = bulkUpdateQuery(\n    'answers',\n    ['id'],\n    answerUpdates.map(partialAnswerToRow)\n  )\n  const { query: cancelLimitsQuery, bets: cancelledLimitOrders } =\n    cancelLimitOrdersQuery(allOrdersToCancel)\n  const startTime = Date.now()\n  const results = await pgTrans.multi(\n    `\n    ${userBalanceUpdatesQuery}; --0\n    ${streakIncrementedQuery}; --1\n    ${insertBetsQuery}; --2\n    ${metricsQuery}; --3\n    ${contractUpdateQuery}; --4\n    ${answerUpdateQuery}; --5\n    ${cancelLimitsQuery}; --6\n    ${bulkUpdateLimitOrdersQuery}; --7\n    ${bonusTxnQuery}; --8\n     `\n  )\n  log(`placeBet bulk insert/update took ${Date.now() - startTime}ms`)\n  const userUpdates = results[0] as UserUpdate[]\n  if (userUpdates.length) {\n    // if negative balances, make sure the balance is higher than when they started\n    for (const userUpdate of userUpdates) {\n      if (userUpdate.balance < 0) {\n        if (userUpdate.balance < balanceByUserId[userUpdate.id]) {\n          throw new APIError(403, 'Maker has insufficient balance.')\n        }\n      }\n    }\n  }\n  const streakIncremented = results[1][0].streak_incremented\n  const newContract = results[4].map(convertContract)[0]\n  const bonusTxn = first(results[8].map(convertTxn)) as\n    | UniqueBettorBonusTxn\n    | undefined\n\n  // On normal contracts, we do this in on-create-bet\n  if (isNumberContract) {\n    broadcastUserUpdates(userUpdates)\n    broadcastUpdatedContract(newContract.visibility, contractUpdate)\n    broadcastUpdatedAnswers(newContract.id, answerUpdates)\n  }\n\n  return {\n    contract,\n    newBet,\n    betId: betsToInsert[0].id,\n    makers,\n    cancelledLimitOrders: cancelledLimitOrders,\n    fullBets: insertedBets,\n    user,\n    betGroupId,\n    streakIncremented,\n    bonusTxn,\n    updatedMetrics: bettorRedemptionUpdatedMetrics,\n    answerUpdates,\n    contractUpdate,\n    userUpdates,\n    updatedMakers,\n  }\n}\n"
        },
        {
          "path": "backend/api/src/place-multi-bet.ts",
          "preContent": "import * as crypto from 'crypto'\nimport { APIError, type APIHandler } from './helpers/endpoint'\nimport { getNewMultiCpmmBetsInfo } from 'common/new-bet'\nimport { ValidatedAPIParams } from 'common/api/schema'\nimport { onCreateBets } from 'api/on-create-bet'\nimport { executeNewBetResult } from 'api/place-bet'\nimport { log } from 'shared/utils'\nimport { runTransactionWithRetries } from 'shared/transact-with-retries'\nimport { betsQueue } from 'shared/helpers/fn-queue'\nimport {\n  fetchContractBetDataAndValidate,\n  getRoundedLimitProb,\n} from 'api/helpers/bets'\n\nexport const placeMultiBet: APIHandler<'multi-bet'> = async (props, auth) => {\n  const isApi = auth.creds.kind === 'key'\n\n  return await betsQueue.enqueueFn(\n    () => placeMultiBetMain(props, auth.uid, isApi),\n    [auth.uid, props.contractId]\n  )\n}\n\n// Note: this returns a continuation function that should be run for consistency.\nexport const placeMultiBetMain = async (\n  body: ValidatedAPIParams<'multi-bet'>,\n  uid: string,\n  isApi: boolean\n) => {\n  const results = await runTransactionWithRetries(async (pgTrans) => {\n    log(\n      `Inside main transaction for ${uid} placing a bet on ${body.contractId}.`\n    )\n\n    const {\n      user,\n      contract,\n      answers,\n      unfilledBets,\n      balanceByUserId,\n      contractMetrics,\n    } = await fetchContractBetDataAndValidate(\n      pgTrans,\n      { ...body, outcome: 'YES' },\n      uid,\n      isApi\n    )\n\n    const { mechanism } = contract\n\n    if (mechanism != 'cpmm-multi-1' || !('shouldAnswersSumToOne' in contract)) {\n      throw new APIError(400, 'Contract type/mechanism not supported')\n    }\n    if (!answers) throw new APIError(404, 'Answers not found')\n\n    const { shouldAnswersSumToOne } = contract\n    const { answerIds, limitProb, expiresAt, deterministic } = body\n    if (expiresAt && expiresAt < Date.now())\n      throw new APIError(403, 'Bet cannot expire in the past.')\n\n    const betOnAnswers = answers.filter((a) => answerIds.includes(a.id))\n    if (!betOnAnswers) throw new APIError(404, 'Answers not found')\n    if ('resolution' in betOnAnswers && betOnAnswers.resolution)\n      throw new APIError(403, 'Answer is resolved and cannot be bet on')\n    if (shouldAnswersSumToOne && answers.length < 2)\n      throw new APIError(\n        403,\n        'Cannot bet until at least two answers are added.'\n      )\n\n    const roundedLimitProb = getRoundedLimitProb(limitProb)\n\n    const newBetResults = getNewMultiCpmmBetsInfo(\n      contract,\n      answers,\n      betOnAnswers,\n      'YES',\n      body.amount,\n      roundedLimitProb,\n      unfilledBets,\n      balanceByUserId,\n      expiresAt\n    )\n\n    const results = []\n    log(`Calculated new bet information for ${user.username} - auth ${uid}.`)\n    const betGroupId = crypto.randomBytes(12).toString('hex')\n    for (const [i, newBetResult] of newBetResults.entries()) {\n      const result = await executeNewBetResult(\n        pgTrans,\n        newBetResult,\n        contract,\n        user,\n        isApi,\n        contractMetrics,\n        undefined,\n        betGroupId,\n        deterministic,\n        i === 0\n      )\n      results.push(result)\n    }\n    return results\n  })\n\n  log(`Main transaction finished - auth ${uid}.`)\n  const contract = results[0].contract\n\n  const continuation = async () => {\n    const fullBets = results.flatMap((result) => result.fullBets)\n    const updatedMakers = results.flatMap((result) => result.updatedMakers)\n    const cancelledLimitOrders = results.flatMap(\n      (result) => result.cancelledLimitOrders\n    )\n    const makers = results.flatMap((result) => result.makers ?? [])\n    const user = results[0].user\n    await onCreateBets({\n      fullBets,\n      contract,\n      user,\n      cancelledLimitOrders,\n      makers,\n      updatedMakers,\n      streakIncremented: results.some((r) => r.streakIncremented),\n      bonusTxn: results.find((r) => r.bonusTxn)?.bonusTxn,\n      reloadMetrics: true,\n      updatedMetrics: [],\n      userUpdates: undefined,\n      contractUpdate: undefined,\n      answerUpdates: undefined,\n    })\n  }\n\n  return {\n    result: results.map((result) => ({\n      ...result.newBet,\n      betId: result.betId,\n      betGroupId: result.betGroupId,\n    })),\n    continue: continuation,\n  }\n}\n",
          "postContent": "import * as crypto from 'crypto'\nimport { APIError, type APIHandler } from './helpers/endpoint'\nimport { getNewMultiCpmmBetsInfo } from 'common/new-bet'\nimport { ValidatedAPIParams } from 'common/api/schema'\nimport { onCreateBets } from 'api/on-create-bet'\nimport { executeNewBetResult } from 'api/place-bet'\nimport { log } from 'shared/utils'\nimport { runTransactionWithRetries } from 'shared/transact-with-retries'\nimport { betsQueue } from 'shared/helpers/fn-queue'\nimport {\n  fetchContractBetDataAndValidate,\n  getRoundedLimitProb,\n} from 'api/helpers/bets'\n\nexport const placeMultiBet: APIHandler<'multi-bet'> = async (props, auth) => {\n  const isApi = auth.creds.kind === 'key'\n\n  return await betsQueue.enqueueFn(\n    () => placeMultiBetMain(props, auth.uid, isApi),\n    [auth.uid, props.contractId]\n  )\n}\n\n// Note: this returns a continuation function that should be run for consistency.\nexport const placeMultiBetMain = async (\n  body: ValidatedAPIParams<'multi-bet'>,\n  uid: string,\n  isApi: boolean\n) => {\n  const results = await runTransactionWithRetries(async (pgTrans) => {\n    log(\n      `Inside main transaction for ${uid} placing a bet on ${body.contractId}.`\n    )\n\n    const {\n      user,\n      contract,\n      answers,\n      unfilledBets,\n      balanceByUserId,\n      contractMetrics,\n    } = await fetchContractBetDataAndValidate(\n      pgTrans,\n      { ...body, outcome: 'YES' },\n      uid,\n      isApi\n    )\n\n    const { mechanism } = contract\n\n    if (mechanism != 'cpmm-multi-1' || !('shouldAnswersSumToOne' in contract)) {\n      throw new APIError(400, 'Contract type/mechanism not supported')\n    }\n    if (!answers) throw new APIError(404, 'Answers not found')\n\n    const { shouldAnswersSumToOne } = contract\n    const { answerIds, limitProb, expiresAt, deterministic } = body\n    if (expiresAt && expiresAt < Date.now())\n      throw new APIError(403, 'Bet cannot expire in the past.')\n\n    const betOnAnswers = answers.filter((a) => answerIds.includes(a.id))\n    if (!betOnAnswers) throw new APIError(404, 'Answers not found')\n    if ('resolution' in betOnAnswers && betOnAnswers.resolution)\n      throw new APIError(403, 'Answer is resolved and cannot be bet on')\n    if (shouldAnswersSumToOne && answers.length < 2)\n      throw new APIError(\n        403,\n        'Cannot bet until at least two answers are added.'\n      )\n\n    const roundedLimitProb = getRoundedLimitProb(limitProb)\n\n    const newBetResults = getNewMultiCpmmBetsInfo(\n      contract,\n      answers,\n      betOnAnswers,\n      'YES',\n      body.amount,\n      roundedLimitProb,\n      unfilledBets,\n      balanceByUserId,\n      expiresAt\n    )\n\n    const results = []\n    log(`Calculated new bet information for ${user.username} - auth ${uid}.`)\n    const betGroupId = crypto.randomBytes(12).toString('hex')\n    for (const [i, newBetResult] of newBetResults.entries()) {\n      const result = await executeNewBetResult(\n        pgTrans,\n        newBetResult,\n        contract,\n        user,\n        isApi,\n        contractMetrics,\n        balanceByUserId,\n        undefined,\n        betGroupId,\n        deterministic,\n        i === 0\n      )\n      results.push(result)\n    }\n    return results\n  })\n\n  log(`Main transaction finished - auth ${uid}.`)\n  const contract = results[0].contract\n\n  const continuation = async () => {\n    const fullBets = results.flatMap((result) => result.fullBets)\n    const updatedMakers = results.flatMap((result) => result.updatedMakers)\n    const cancelledLimitOrders = results.flatMap(\n      (result) => result.cancelledLimitOrders\n    )\n    const makers = results.flatMap((result) => result.makers ?? [])\n    const user = results[0].user\n    await onCreateBets({\n      fullBets,\n      contract,\n      user,\n      cancelledLimitOrders,\n      makers,\n      updatedMakers,\n      streakIncremented: results.some((r) => r.streakIncremented),\n      bonusTxn: results.find((r) => r.bonusTxn)?.bonusTxn,\n      reloadMetrics: true,\n      updatedMetrics: [],\n      userUpdates: undefined,\n      contractUpdate: undefined,\n      answerUpdates: undefined,\n    })\n  }\n\n  return {\n    result: results.map((result) => ({\n      ...result.newBet,\n      betId: result.betId,\n      betGroupId: result.betGroupId,\n    })),\n    continue: continuation,\n  }\n}\n"
        },
        {
          "path": "backend/api/src/sell-shares.ts",
          "preContent": "import { APIError, type APIHandler } from './helpers/endpoint'\nimport { MarketContract } from 'common/contract'\nimport { getCpmmMultiSellBetInfo, getCpmmSellBetInfo } from 'common/sell-bet'\nimport { floatingLesserEqual } from 'common/util/math'\nimport { executeNewBetResult } from './place-bet'\nimport { onCreateBets } from 'api/on-create-bet'\nimport { log } from 'shared/utils'\nimport { runTransactionWithRetries } from 'shared/transact-with-retries'\nimport { betsQueue } from 'shared/helpers/fn-queue'\nimport { createSupabaseDirectClient } from 'shared/supabase/init'\nimport { LimitBet } from 'common/bet'\nimport { Answer } from 'common/answer'\nimport { ContractMetric } from 'common/contract-metric'\nimport {\n  fetchContractBetDataAndValidate,\n  getMakerIdsFromBetResult,\n  getUserBalancesAndMetrics,\n} from 'api/helpers/bets'\nimport { randomString } from 'common/util/random'\nimport { isEqual } from 'lodash'\n\nconst calculateSellResult = (\n  contract: MarketContract,\n  answers: Answer[] | undefined,\n  unfilledBets: LimitBet[],\n  balanceByUserId: Record<string, number>,\n  answerId: string | undefined,\n  outcome: 'YES' | 'NO',\n  shares: number | undefined,\n  contractMetric: ContractMetric\n) => {\n  const { mechanism } = contract\n  const { totalShares: sharesByOutcome, loan: loanAmount } = contractMetric\n\n  const maxShares = sharesByOutcome[outcome]\n  const sharesToSell = shares ?? maxShares\n\n  if (!maxShares)\n    throw new APIError(403, `You don't have any ${outcome} shares to sell.`)\n\n  if (!floatingLesserEqual(sharesToSell, maxShares))\n    throw new APIError(400, `You can only sell up to ${maxShares} shares.`)\n\n  const soldShares = Math.min(sharesToSell, maxShares)\n  const saleFrac = soldShares / maxShares\n  let loanPaid = saleFrac * loanAmount\n  if (!isFinite(loanPaid)) loanPaid = 0\n\n  let answer\n  if (\n    mechanism === 'cpmm-1' ||\n    (mechanism === 'cpmm-multi-1' && !contract.shouldAnswersSumToOne)\n  ) {\n    if (answerId) {\n      answer = answers?.find((a) => a.id === answerId)\n      if (!answer) {\n        throw new APIError(400, 'Could not find answer ' + answerId)\n      }\n      if (answer.resolution) {\n        throw new APIError(403, 'Answer is resolved and cannot be bet on')\n      }\n    }\n    return {\n      otherBetResults: [],\n      ...getCpmmSellBetInfo(\n        soldShares,\n        outcome,\n        contract,\n        unfilledBets,\n        balanceByUserId,\n        loanPaid,\n        answer\n      ),\n    }\n  } else {\n    if (!answers) throw new APIError(404, 'Should have fetched answers...')\n\n    const answer = answers.find((a) => a.id === answerId)\n    if (!answer) throw new APIError(404, 'Answer not found')\n    if (answers.length < 2)\n      throw new APIError(\n        403,\n        'Cannot bet until at least two answers are added.'\n      )\n\n    return {\n      newP: 0.5,\n      ...getCpmmMultiSellBetInfo(\n        contract,\n        answers,\n        answer,\n        soldShares,\n        outcome,\n        undefined,\n        unfilledBets,\n        balanceByUserId,\n        loanPaid\n      ),\n    }\n  }\n}\n\nexport const sellShares: APIHandler<'market/:contractId/sell'> = async (\n  props,\n  auth,\n  req\n) => {\n  const userId = auth.uid\n  const { contractId, deps } = props\n  const fullDeps = [userId, contractId, ...(deps ?? [])]\n  return await betsQueue.enqueueFn(\n    () => sellSharesMain(props, auth, req),\n    fullDeps\n  )\n}\n\nconst sellSharesMain: APIHandler<'market/:contractId/sell'> = async (\n  props,\n  auth\n) => {\n  const { contractId, shares, outcome, answerId, deterministic } = props\n  const uid = auth.uid\n  const isApi = auth.creds.kind === 'key'\n  const pg = createSupabaseDirectClient()\n  const oppositeOutcome = outcome === 'YES' ? 'NO' : 'YES'\n  const {\n    user,\n    contract,\n    answers,\n    balanceByUserId,\n    unfilledBets,\n    contractMetrics,\n    unfilledBetUserIds,\n  } = await fetchContractBetDataAndValidate(\n    pg,\n    { ...props, amount: undefined, outcome: oppositeOutcome },\n    uid,\n    isApi\n  )\n  const simulatedResult = calculateSellResult(\n    contract,\n    answers,\n    unfilledBets,\n    balanceByUserId,\n    answerId,\n    outcome,\n    shares,\n    contractMetrics.find(\n      (m) => m.answerId == answerId && m.userId === auth.uid\n    )!\n  )\n  const simulatedMakerIds = getMakerIdsFromBetResult(simulatedResult)\n\n  const result = await runTransactionWithRetries(async (pgTrans) => {\n    log(\n      `Inside main transaction for user ${uid} selling ${shares} shares on contract id ${contractId}.`\n    )\n    const { balanceByUserId, contractMetrics } =\n      await getUserBalancesAndMetrics(\n        pgTrans,\n        [uid, ...simulatedMakerIds], // Fetch just the makers that matched in the simulation.\n        contract,\n        answerId\n      )\n    user.balance = balanceByUserId[uid]\n\n    for (const userId of unfilledBetUserIds) {\n      if (!(userId in balanceByUserId)) {\n        // Assume other makers have infinite balance since they are not involved in this bet.\n        balanceByUserId[userId] = Number.MAX_SAFE_INTEGER\n      }\n    }\n\n    const newBetResult = calculateSellResult(\n      contract,\n      answers,\n      unfilledBets,\n      balanceByUserId,\n      answerId,\n      outcome,\n      shares,\n      contractMetrics.find(\n        (m) => m.answerId == answerId && m.userId === auth.uid\n      )!\n    )\n    log(`Calculated sale information for ${user.username} - auth ${uid}.`)\n    const actualMakerIds = getMakerIdsFromBetResult(newBetResult)\n    log(\n      'simulated makerIds',\n      simulatedMakerIds,\n      'actualMakerIds',\n      actualMakerIds\n    )\n    if (!isEqual(simulatedMakerIds, actualMakerIds)) {\n      log.warn('Matched limit orders changed from simulated values.')\n      throw new APIError(503, 'Please try betting again.')\n    }\n    const betGroupId = randomString(12)\n\n    return await executeNewBetResult(\n      pgTrans,\n      newBetResult,\n      contract,\n      user,\n      isApi,\n      contractMetrics,\n      undefined,\n      betGroupId,\n      deterministic\n    )\n  })\n\n  const { newBet, betId } = result\n\n  const continuation = async () => {\n    await onCreateBets(result)\n  }\n  return { result: { ...newBet, betId }, continue: continuation }\n}\n",
          "postContent": "import { APIError, type APIHandler } from './helpers/endpoint'\nimport { MarketContract } from 'common/contract'\nimport { getCpmmMultiSellBetInfo, getCpmmSellBetInfo } from 'common/sell-bet'\nimport { floatingLesserEqual } from 'common/util/math'\nimport { executeNewBetResult } from './place-bet'\nimport { onCreateBets } from 'api/on-create-bet'\nimport { log } from 'shared/utils'\nimport { runTransactionWithRetries } from 'shared/transact-with-retries'\nimport { betsQueue } from 'shared/helpers/fn-queue'\nimport { createSupabaseDirectClient } from 'shared/supabase/init'\nimport { LimitBet } from 'common/bet'\nimport { Answer } from 'common/answer'\nimport { ContractMetric } from 'common/contract-metric'\nimport {\n  fetchContractBetDataAndValidate,\n  getMakerIdsFromBetResult,\n  getUserBalancesAndMetrics,\n} from 'api/helpers/bets'\nimport { randomString } from 'common/util/random'\nimport { isEqual } from 'lodash'\n\nconst calculateSellResult = (\n  contract: MarketContract,\n  answers: Answer[] | undefined,\n  unfilledBets: LimitBet[],\n  balanceByUserId: Record<string, number>,\n  answerId: string | undefined,\n  outcome: 'YES' | 'NO',\n  shares: number | undefined,\n  contractMetric: ContractMetric\n) => {\n  const { mechanism } = contract\n  const { totalShares: sharesByOutcome, loan: loanAmount } = contractMetric\n\n  const maxShares = sharesByOutcome[outcome]\n  const sharesToSell = shares ?? maxShares\n\n  if (!maxShares)\n    throw new APIError(403, `You don't have any ${outcome} shares to sell.`)\n\n  if (!floatingLesserEqual(sharesToSell, maxShares))\n    throw new APIError(400, `You can only sell up to ${maxShares} shares.`)\n\n  const soldShares = Math.min(sharesToSell, maxShares)\n  const saleFrac = soldShares / maxShares\n  let loanPaid = saleFrac * loanAmount\n  if (!isFinite(loanPaid)) loanPaid = 0\n\n  let answer\n  if (\n    mechanism === 'cpmm-1' ||\n    (mechanism === 'cpmm-multi-1' && !contract.shouldAnswersSumToOne)\n  ) {\n    if (answerId) {\n      answer = answers?.find((a) => a.id === answerId)\n      if (!answer) {\n        throw new APIError(400, 'Could not find answer ' + answerId)\n      }\n      if (answer.resolution) {\n        throw new APIError(403, 'Answer is resolved and cannot be bet on')\n      }\n    }\n    return {\n      otherBetResults: [],\n      ...getCpmmSellBetInfo(\n        soldShares,\n        outcome,\n        contract,\n        unfilledBets,\n        balanceByUserId,\n        loanPaid,\n        answer\n      ),\n    }\n  } else {\n    if (!answers) throw new APIError(404, 'Should have fetched answers...')\n\n    const answer = answers.find((a) => a.id === answerId)\n    if (!answer) throw new APIError(404, 'Answer not found')\n    if (answers.length < 2)\n      throw new APIError(\n        403,\n        'Cannot bet until at least two answers are added.'\n      )\n\n    return {\n      newP: 0.5,\n      ...getCpmmMultiSellBetInfo(\n        contract,\n        answers,\n        answer,\n        soldShares,\n        outcome,\n        undefined,\n        unfilledBets,\n        balanceByUserId,\n        loanPaid\n      ),\n    }\n  }\n}\n\nexport const sellShares: APIHandler<'market/:contractId/sell'> = async (\n  props,\n  auth,\n  req\n) => {\n  const userId = auth.uid\n  const { contractId, deps } = props\n  const fullDeps = [userId, contractId, ...(deps ?? [])]\n  return await betsQueue.enqueueFn(\n    () => sellSharesMain(props, auth, req),\n    fullDeps\n  )\n}\n\nconst sellSharesMain: APIHandler<'market/:contractId/sell'> = async (\n  props,\n  auth\n) => {\n  const { contractId, shares, outcome, answerId, deterministic } = props\n  const uid = auth.uid\n  const isApi = auth.creds.kind === 'key'\n  const pg = createSupabaseDirectClient()\n  const oppositeOutcome = outcome === 'YES' ? 'NO' : 'YES'\n  const {\n    user,\n    contract,\n    answers,\n    balanceByUserId,\n    unfilledBets,\n    contractMetrics,\n    unfilledBetUserIds,\n  } = await fetchContractBetDataAndValidate(\n    pg,\n    { ...props, amount: undefined, outcome: oppositeOutcome },\n    uid,\n    isApi\n  )\n  const simulatedResult = calculateSellResult(\n    contract,\n    answers,\n    unfilledBets,\n    balanceByUserId,\n    answerId,\n    outcome,\n    shares,\n    contractMetrics.find(\n      (m) => m.answerId == answerId && m.userId === auth.uid\n    )!\n  )\n  const simulatedMakerIds = getMakerIdsFromBetResult(simulatedResult)\n\n  const result = await runTransactionWithRetries(async (pgTrans) => {\n    log(\n      `Inside main transaction for user ${uid} selling ${shares} shares on contract id ${contractId}.`\n    )\n    const { balanceByUserId, contractMetrics } =\n      await getUserBalancesAndMetrics(\n        pgTrans,\n        [uid, ...simulatedMakerIds], // Fetch just the makers that matched in the simulation.\n        contract,\n        answerId\n      )\n    user.balance = balanceByUserId[uid]\n\n    for (const userId of unfilledBetUserIds) {\n      if (!(userId in balanceByUserId)) {\n        // Assume other makers have infinite balance since they are not involved in this bet.\n        balanceByUserId[userId] = Number.MAX_SAFE_INTEGER\n      }\n    }\n\n    const newBetResult = calculateSellResult(\n      contract,\n      answers,\n      unfilledBets,\n      balanceByUserId,\n      answerId,\n      outcome,\n      shares,\n      contractMetrics.find(\n        (m) => m.answerId == answerId && m.userId === auth.uid\n      )!\n    )\n    log(`Calculated sale information for ${user.username} - auth ${uid}.`)\n    const actualMakerIds = getMakerIdsFromBetResult(newBetResult)\n    log(\n      'simulated makerIds',\n      simulatedMakerIds,\n      'actualMakerIds',\n      actualMakerIds\n    )\n    if (!isEqual(simulatedMakerIds, actualMakerIds)) {\n      log.warn('Matched limit orders changed from simulated values.')\n      throw new APIError(503, 'Please try betting again.')\n    }\n    const betGroupId = randomString(12)\n    return await executeNewBetResult(\n      pgTrans,\n      newBetResult,\n      contract,\n      user,\n      isApi,\n      contractMetrics,\n      balanceByUserId,\n      undefined,\n      betGroupId,\n      deterministic\n    )\n  })\n\n  const { newBet, betId } = result\n\n  const continuation = async () => {\n    await onCreateBets(result)\n  }\n  return { result: { ...newBet, betId }, continue: continuation }\n}\n"
        }
      ]
    },
    {
      "sha": "5372f46804449d40fe8dd8b8cd841a508b482400",
      "author": "Ian Philips",
      "date": "2025-05-13 17:53:41 -0700",
      "message": "Better error message",
      "stats": {
        "filesChanged": 2,
        "insertions": 12,
        "deletions": 6
      },
      "selectionReason": "Improves user experience by providing better error messages - demonstrates UX improvement through clearer feedback",
      "spec": "Define and export a new string constant `CPMM_ARBITRAGE_ERROR_PREFIX` in `common/src/calculate-cpmm.ts` with the value 'calculateAmountToBuySharesFixedP only works for p = 0.5, got '. Modify the `calculateCpmmAmountToBuySharesFixedP` function in the same file to throw an error with a message formed by concatenating this prefix and the value of `state.p` if `state.p` is not approximately 0.5. In `client-common/src/lib/bet.ts`, import this new constant. Update the error handling logic for the `calculationError` variable within the `getLimitBetReturns` function's `catch` block: if a caught error has a message that begins with `CPMM_ARBITRAGE_ERROR_PREFIX`, `calculationError` should be set to `Error buying ${outcome} on this answer, buy ${outcome === 'YES' ? 'NO' : 'YES'} in other answers first.` (where `outcome` is the function's parameter). Otherwise (if the error has no message, or its message does not begin with the prefix), `calculationError` should be set to the caught error's message if one exists, falling back to `An error occurred during ${TRADE_TERM} calculation, try again.` if no error message is present.",
      "fileStates": [
        {
          "path": "client-common/src/lib/bet.ts",
          "preContent": "import { getCpmmProbability } from 'common/calculate-cpmm'\nimport { LimitBet } from 'common/bet'\nimport { Answer } from 'common/answer'\nimport { noFees } from 'common/fees'\nimport { calculateCpmmMultiArbitrageBet } from 'common/calculate-cpmm-arbitrage'\nimport { sumBy } from 'lodash'\nimport { addObjects } from 'common/util/object'\nimport { computeCpmmBet } from 'common/new-bet'\nimport { MAX_CPMM_PROB, MIN_CPMM_PROB } from 'common/contract'\nimport { TRADE_TERM } from 'common/envs/constants'\nimport { MarketContract } from 'common/contract'\nimport { isBinaryMulti } from 'common/contract'\nconst DEFAULT_SLIPPAGE = 0.1\n\nexport const getLimitBetReturns = (\n  binaryOutcome: 'YES' | 'NO',\n  betAmount: number,\n  unfilledBets: LimitBet[],\n  balanceByUserId: { [userId: string]: number },\n  contract: MarketContract,\n  multiProps: MultiBetProps | undefined,\n  manualLimitProb: number | undefined,\n  slippageProtection: boolean\n) => {\n  const shouldAnswersSumToOne =\n    'shouldAnswersSumToOne' in contract ? contract.shouldAnswersSumToOne : false\n  const arbitrageProps = shouldAnswersSumToOne ? multiProps : undefined\n  const isBinaryMC = isBinaryMulti(contract)\n  const outcome =\n    (isBinaryMC && arbitrageProps\n      ? arbitrageProps.answerText === arbitrageProps.answerToBuy.text\n        ? 'YES'\n        : 'NO'\n      : undefined) ?? binaryOutcome\n\n  const isCpmmMulti = contract.mechanism === 'cpmm-multi-1'\n  const cpmmState = isCpmmMulti\n    ? {\n        pool: {\n          YES: multiProps!.answerToBuy.poolYes,\n          NO: multiProps!.answerToBuy.poolNo,\n        },\n        p: 0.5,\n        collectedFees: contract.collectedFees,\n      }\n    : {\n        pool: contract.pool,\n        p: contract.p,\n        collectedFees: contract.collectedFees,\n      }\n  const prob = getCpmmProbability(cpmmState.pool, cpmmState.p)\n  const slippage = slippageProtection ? DEFAULT_SLIPPAGE : 1\n  const floatLimitProb = Math.max(\n    MIN_CPMM_PROB,\n    Math.min(\n      MAX_CPMM_PROB,\n      outcome === 'YES' ? prob + slippage : prob - slippage\n    )\n  )\n\n  const limitProb = Math.round((manualLimitProb ?? floatLimitProb) * 100) / 100\n\n  const orderAmount = betAmount\n  let amount = 0\n  let shares = 0\n  let fees = noFees\n  let betDeps: LimitBet[] = []\n  let probAfter = 0\n  let calculationError: string | undefined = undefined\n  try {\n    if (arbitrageProps) {\n      const { answers, answerToBuy } = arbitrageProps\n      const { newBetResult, otherBetResults } = calculateCpmmMultiArbitrageBet(\n        answers,\n        answerToBuy,\n        outcome,\n        betAmount,\n        limitProb,\n        unfilledBets,\n        balanceByUserId,\n        cpmmState.collectedFees\n      )\n      amount = sumBy(newBetResult.takers, 'amount')\n      shares = sumBy(newBetResult.takers, 'shares')\n      betDeps = newBetResult.makers\n        .map((m) => m.bet)\n        .concat(otherBetResults.flatMap((r) => r.makers.map((m) => m.bet)))\n        .concat(newBetResult.ordersToCancel)\n        .concat(otherBetResults.flatMap((r) => r.ordersToCancel))\n      fees = addObjects(\n        newBetResult.totalFees,\n        otherBetResults.reduce(\n          (feeSum, results) => addObjects(feeSum, results.totalFees),\n          noFees\n        )\n      )\n      probAfter = getCpmmProbability(\n        newBetResult.cpmmState.pool,\n        newBetResult.cpmmState.p\n      )\n    } else {\n      const result = computeCpmmBet(\n        cpmmState,\n        outcome,\n        betAmount,\n        limitProb,\n        unfilledBets,\n        balanceByUserId,\n        !arbitrageProps && { max: MAX_CPMM_PROB, min: MIN_CPMM_PROB }\n      )\n      amount = result.amount\n      shares = result.shares\n      fees = result.fees\n      betDeps = result.makers.map((m) => m.bet).concat(result.ordersToCancel)\n      probAfter = result.probAfter\n    }\n  } catch (err: any) {\n    console.error('Error in getLimitBetReturns:', err)\n    calculationError =\n      err?.message ??\n      `An error occurred during ${TRADE_TERM} calculation, try again.`\n  }\n  const remainingMatched = limitProb\n    ? ((orderAmount ?? 0) - amount) /\n      (outcome === 'YES' ? limitProb : 1 - limitProb)\n    : 0\n  const currentPayout = shares + remainingMatched\n  const currentReturn = betAmount ? (currentPayout - betAmount) / betAmount : 0\n\n  return {\n    orderAmount,\n    amount,\n    shares,\n    currentPayout,\n    currentReturn,\n    fees,\n    betDeps,\n    probAfter,\n    limitProb,\n    prob,\n    calculationError,\n  }\n}\nexport type MultiBetProps = {\n  answers: Answer[]\n  answerToBuy: Answer\n  answerText?: string\n}\n",
          "postContent": "import {\n  CPMM_ARBITRAGE_ERROR_PREFIX,\n  getCpmmProbability,\n} from 'common/calculate-cpmm'\nimport { LimitBet } from 'common/bet'\nimport { Answer } from 'common/answer'\nimport { noFees } from 'common/fees'\nimport { calculateCpmmMultiArbitrageBet } from 'common/calculate-cpmm-arbitrage'\nimport { sumBy } from 'lodash'\nimport { addObjects } from 'common/util/object'\nimport { computeCpmmBet } from 'common/new-bet'\nimport { MAX_CPMM_PROB, MIN_CPMM_PROB } from 'common/contract'\nimport { TRADE_TERM } from 'common/envs/constants'\nimport { MarketContract } from 'common/contract'\nimport { isBinaryMulti } from 'common/contract'\nconst DEFAULT_SLIPPAGE = 0.1\n\nexport const getLimitBetReturns = (\n  binaryOutcome: 'YES' | 'NO',\n  betAmount: number,\n  unfilledBets: LimitBet[],\n  balanceByUserId: { [userId: string]: number },\n  contract: MarketContract,\n  multiProps: MultiBetProps | undefined,\n  manualLimitProb: number | undefined,\n  slippageProtection: boolean\n) => {\n  const shouldAnswersSumToOne =\n    'shouldAnswersSumToOne' in contract ? contract.shouldAnswersSumToOne : false\n  const arbitrageProps = shouldAnswersSumToOne ? multiProps : undefined\n  const isBinaryMC = isBinaryMulti(contract)\n  const outcome =\n    (isBinaryMC && arbitrageProps\n      ? arbitrageProps.answerText === arbitrageProps.answerToBuy.text\n        ? 'YES'\n        : 'NO'\n      : undefined) ?? binaryOutcome\n\n  const isCpmmMulti = contract.mechanism === 'cpmm-multi-1'\n  const cpmmState = isCpmmMulti\n    ? {\n        pool: {\n          YES: multiProps!.answerToBuy.poolYes,\n          NO: multiProps!.answerToBuy.poolNo,\n        },\n        p: 0.5,\n        collectedFees: contract.collectedFees,\n      }\n    : {\n        pool: contract.pool,\n        p: contract.p,\n        collectedFees: contract.collectedFees,\n      }\n  const prob = getCpmmProbability(cpmmState.pool, cpmmState.p)\n  const slippage = slippageProtection ? DEFAULT_SLIPPAGE : 1\n  const floatLimitProb = Math.max(\n    MIN_CPMM_PROB,\n    Math.min(\n      MAX_CPMM_PROB,\n      outcome === 'YES' ? prob + slippage : prob - slippage\n    )\n  )\n\n  const limitProb = Math.round((manualLimitProb ?? floatLimitProb) * 100) / 100\n\n  const orderAmount = betAmount\n  let amount = 0\n  let shares = 0\n  let fees = noFees\n  let betDeps: LimitBet[] = []\n  let probAfter = 0\n  let calculationError: string | undefined = undefined\n  try {\n    if (arbitrageProps) {\n      const { answers, answerToBuy } = arbitrageProps\n      const { newBetResult, otherBetResults } = calculateCpmmMultiArbitrageBet(\n        answers,\n        answerToBuy,\n        outcome,\n        betAmount,\n        limitProb,\n        unfilledBets,\n        balanceByUserId,\n        cpmmState.collectedFees\n      )\n      amount = sumBy(newBetResult.takers, 'amount')\n      shares = sumBy(newBetResult.takers, 'shares')\n      betDeps = newBetResult.makers\n        .map((m) => m.bet)\n        .concat(otherBetResults.flatMap((r) => r.makers.map((m) => m.bet)))\n        .concat(newBetResult.ordersToCancel)\n        .concat(otherBetResults.flatMap((r) => r.ordersToCancel))\n      fees = addObjects(\n        newBetResult.totalFees,\n        otherBetResults.reduce(\n          (feeSum, results) => addObjects(feeSum, results.totalFees),\n          noFees\n        )\n      )\n      probAfter = getCpmmProbability(\n        newBetResult.cpmmState.pool,\n        newBetResult.cpmmState.p\n      )\n    } else {\n      const result = computeCpmmBet(\n        cpmmState,\n        outcome,\n        betAmount,\n        limitProb,\n        unfilledBets,\n        balanceByUserId,\n        !arbitrageProps && { max: MAX_CPMM_PROB, min: MIN_CPMM_PROB }\n      )\n      amount = result.amount\n      shares = result.shares\n      fees = result.fees\n      betDeps = result.makers.map((m) => m.bet).concat(result.ordersToCancel)\n      probAfter = result.probAfter\n    }\n  } catch (err: any) {\n    console.error('Error in getLimitBetReturns:', err)\n    calculationError =\n      (err?.message.startsWith(CPMM_ARBITRAGE_ERROR_PREFIX)\n        ? `Error buying ${outcome} on this answer, buy ${\n            outcome === 'YES' ? 'NO' : 'YES'\n          } in other answers first.`\n        : err?.message) ??\n      `An error occurred during ${TRADE_TERM} calculation, try again.`\n  }\n  const remainingMatched = limitProb\n    ? ((orderAmount ?? 0) - amount) /\n      (outcome === 'YES' ? limitProb : 1 - limitProb)\n    : 0\n  const currentPayout = shares + remainingMatched\n  const currentReturn = betAmount ? (currentPayout - betAmount) / betAmount : 0\n\n  return {\n    orderAmount,\n    amount,\n    shares,\n    currentPayout,\n    currentReturn,\n    fees,\n    betDeps,\n    probAfter,\n    limitProb,\n    prob,\n    calculationError,\n  }\n}\nexport type MultiBetProps = {\n  answers: Answer[]\n  answerToBuy: Answer\n  answerText?: string\n}\n"
        },
        {
          "path": "common/src/calculate-cpmm.ts",
          "preContent": "import { groupBy, mapValues, minBy, omitBy, sortBy, sum, sumBy } from 'lodash'\nimport { fill, LimitBet } from './bet'\nimport { Fees, getFeesSplit, getTakerFee, noFees } from './fees'\nimport { LiquidityProvision } from './liquidity-provision'\nimport { binarySearch } from './util/algos'\nimport {\n  EPSILON,\n  floatingEqual,\n  floatingGreaterEqual,\n  floatingLesserEqual,\n} from './util/math'\nimport {\n  calculateCpmmMultiArbitrageSellNo,\n  calculateCpmmMultiArbitrageSellYes,\n} from './calculate-cpmm-arbitrage'\nimport { Answer } from './answer'\nimport { MarketContract, MAX_CPMM_PROB, MIN_CPMM_PROB } from 'common/contract'\nimport { addObjects } from 'common/util/object'\n\nexport type CpmmState = {\n  pool: { [outcome: string]: number }\n  p: number\n  collectedFees: Fees\n}\n\nexport function getCpmmProbability(\n  pool: { [outcome: string]: number },\n  p: number\n) {\n  const { YES, NO } = pool\n  return (p * NO) / ((1 - p) * YES + p * NO)\n}\n\nexport function getCpmmProbabilityAfterBetBeforeFees(\n  state: CpmmState,\n  outcome: string,\n  bet: number\n) {\n  const { pool, p } = state\n  const shares = calculateCpmmShares(pool, p, bet, outcome)\n  const { YES: y, NO: n } = pool\n\n  const [newY, newN] =\n    outcome === 'YES'\n      ? [y - shares + bet, n + bet]\n      : [y + bet, n - shares + bet]\n\n  return getCpmmProbability({ YES: newY, NO: newN }, p)\n}\n\nexport function getCpmmOutcomeProbabilityAfterBet(\n  state: CpmmState,\n  outcome: string,\n  bet: number\n) {\n  const { newPool } = calculateCpmmPurchase(state, bet, outcome)\n  const p = getCpmmProbability(newPool, state.p)\n  return outcome === 'NO' ? 1 - p : p\n}\n\n// before liquidity fee\nexport function calculateCpmmShares(\n  pool: {\n    [outcome: string]: number\n  },\n  p: number,\n  betAmount: number,\n  betChoice: string\n) {\n  if (betAmount === 0) return 0\n\n  const { YES: y, NO: n } = pool\n  const k = y ** p * n ** (1 - p)\n\n  return betChoice === 'YES'\n    ? // https://www.wolframalpha.com/input?i=%28y%2Bb-s%29%5E%28p%29*%28n%2Bb%29%5E%281-p%29+%3D+k%2C+solve+s\n      y + betAmount - (k * (betAmount + n) ** (p - 1)) ** (1 / p)\n    : n + betAmount - (k * (betAmount + y) ** -p) ** (1 / (1 - p))\n}\n\nexport function getCpmmFees(\n  state: CpmmState,\n  betAmount: number,\n  outcome: string\n) {\n  // Do a few iterations toward average probability of the bet minus fees.\n  // Charging fees means the bet amount is lower and the average probability moves slightly less far.\n  let fee = 0\n  for (let i = 0; i < 10; i++) {\n    const betAmountAfterFee = betAmount - fee\n    const shares = calculateCpmmShares(\n      state.pool,\n      state.p,\n      betAmountAfterFee,\n      outcome\n    )\n    const averageProb = betAmountAfterFee / shares\n    fee = getTakerFee(shares, averageProb)\n  }\n\n  const totalFees = betAmount === 0 ? 0 : fee\n  const fees = getFeesSplit(totalFees)\n\n  const remainingBet = betAmount - totalFees\n\n  return { remainingBet, totalFees, fees }\n}\n\nexport function calculateCpmmSharesAfterFee(\n  state: CpmmState,\n  bet: number,\n  outcome: string\n) {\n  const { pool, p } = state\n  const { remainingBet } = getCpmmFees(state, bet, outcome)\n\n  return calculateCpmmShares(pool, p, remainingBet, outcome)\n}\n\nexport function calculateCpmmPurchase(\n  state: CpmmState,\n  bet: number,\n  outcome: string,\n  freeFees?: boolean\n) {\n  const { pool, p } = state\n  const { remainingBet, fees } = freeFees\n    ? {\n        remainingBet: bet,\n        fees: noFees,\n      }\n    : getCpmmFees(state, bet, outcome)\n\n  const shares = calculateCpmmShares(pool, p, remainingBet, outcome)\n  const { YES: y, NO: n } = pool\n\n  const { liquidityFee: fee } = fees\n\n  const [newY, newN] =\n    outcome === 'YES'\n      ? [y - shares + remainingBet + fee, n + remainingBet + fee]\n      : [y + remainingBet + fee, n - shares + remainingBet + fee]\n\n  const postBetPool = { YES: newY, NO: newN }\n\n  const { newPool, newP } = addCpmmLiquidity(postBetPool, p, fee)\n\n  return { shares, newPool, newP, fees }\n}\n\nexport function calculateCpmmAmountToProb(\n  state: CpmmState,\n  prob: number,\n  outcome: 'YES' | 'NO'\n) {\n  if (prob <= 0 || prob >= 1 || isNaN(prob)) return Infinity\n  if (outcome === 'NO') prob = 1 - prob\n\n  const { pool, p } = state\n  const { YES: y, NO: n } = pool\n  const k = y ** p * n ** (1 - p)\n  return outcome === 'YES'\n    ? // https://www.wolframalpha.com/input?i=-1+%2B+t+-+((-1+%2B+p)+t+(k%2F(n+%2B+b))^(1%2Fp))%2Fp+solve+b\n      ((p * (prob - 1)) / ((p - 1) * prob)) ** -p *\n        (k - n * ((p * (prob - 1)) / ((p - 1) * prob)) ** p)\n    : (((1 - p) * (prob - 1)) / (-p * prob)) ** (p - 1) *\n        (k - y * (((1 - p) * (prob - 1)) / (-p * prob)) ** (1 - p))\n}\n\nexport function calculateCpmmAmountToProbIncludingFees(\n  state: CpmmState,\n  prob: number,\n  outcome: 'YES' | 'NO'\n) {\n  const amount = calculateCpmmAmountToProb(state, prob, outcome)\n  const shares = calculateCpmmShares(state.pool, state.p, amount, outcome)\n  const averageProb = amount / shares\n  const fees = getTakerFee(shares, averageProb)\n  return amount + fees\n}\n\nexport function calculateCpmmAmountToBuySharesFixedP(\n  state: CpmmState,\n  shares: number,\n  outcome: 'YES' | 'NO'\n) {\n  if (!floatingEqual(state.p, 0.5)) {\n    throw new Error(\n      'calculateAmountToBuySharesFixedP only works for p = 0.5, got ' + state.p\n    )\n  }\n\n  const { YES: y, NO: n } = state.pool\n  if (outcome === 'YES') {\n    // https://www.wolframalpha.com/input?i=%28y%2Bb-s%29%5E0.5+*+%28n%2Bb%29%5E0.5+%3D+y+%5E+0.5+*+n+%5E+0.5%2C+solve+b\n    return (\n      (shares - y - n + Math.sqrt(4 * n * shares + (y + n - shares) ** 2)) / 2\n    )\n  }\n  return (\n    (shares - y - n + Math.sqrt(4 * y * shares + (y + n - shares) ** 2)) / 2\n  )\n}\n\nexport const computeFills = (\n  state: CpmmState,\n  outcome: 'YES' | 'NO',\n  betAmount: number,\n  initialLimitProb: number | undefined,\n  unfilledBets: LimitBet[],\n  balanceByUserId: { [userId: string]: number | undefined },\n  limitProbs?: { max: number; min: number },\n  freeFees?: boolean\n) => {\n  if (isNaN(betAmount)) {\n    throw new Error('Invalid bet amount: ${betAmount}')\n  }\n  if (isNaN(initialLimitProb ?? 0)) {\n    throw new Error('Invalid limitProb: ${limitProb}')\n  }\n  const now = Date.now()\n  const { max, min } = limitProbs ?? {}\n  const limit = initialLimitProb ?? (outcome === 'YES' ? max : min)\n  const limitProb = !limit\n    ? undefined\n    : limit > MAX_CPMM_PROB\n    ? MAX_CPMM_PROB\n    : limit < MIN_CPMM_PROB\n    ? MIN_CPMM_PROB\n    : limit\n\n  const sortedBets = sortBy(\n    unfilledBets.filter(\n      (bet) =>\n        bet.outcome !== outcome && (bet.expiresAt ? bet.expiresAt > now : true)\n    ),\n    (bet) => (outcome === 'YES' ? bet.limitProb : -bet.limitProb),\n    (bet) => bet.createdTime\n  )\n\n  const takers: fill[] = []\n  const makers: {\n    bet: LimitBet\n    amount: number\n    shares: number\n    timestamp: number\n  }[] = []\n  const ordersToCancel: LimitBet[] = []\n\n  let amount = betAmount\n  let cpmmState = { ...state }\n  let totalFees = noFees\n  const currentBalanceByUserId = { ...balanceByUserId }\n\n  let i = 0\n  while (true) {\n    const matchedBet: LimitBet | undefined = sortedBets[i]\n    const fill = computeFill(\n      amount,\n      outcome,\n      limitProb,\n      cpmmState,\n      matchedBet,\n      currentBalanceByUserId[matchedBet?.userId ?? ''],\n      freeFees\n    )\n\n    if (!fill) break\n\n    const { taker, maker } = fill\n\n    if (maker.matchedBetId === null) {\n      // Matched against pool.\n      cpmmState = maker.state\n      takers.push(taker)\n    } else {\n      // Matched against bet.\n      i++\n      const { userId } = maker.bet\n      const makerBalance = currentBalanceByUserId[userId]\n      if (makerBalance !== undefined) {\n        if (maker.amount > 0) {\n          currentBalanceByUserId[userId] = makerBalance - maker.amount\n        }\n        const adjustedMakerBalance = currentBalanceByUserId[userId]\n        if (adjustedMakerBalance !== undefined && adjustedMakerBalance <= 0) {\n          // Now they've insufficient balance. Cancel maker bet.\n          ordersToCancel.push(maker.bet)\n        }\n      }\n      if (floatingEqual(maker.amount, 0)) continue\n\n      takers.push(taker)\n      makers.push(maker)\n    }\n\n    totalFees = addObjects(totalFees, taker.fees)\n    amount -= taker.amount\n\n    if (floatingEqual(amount, 0)) break\n  }\n\n  return { takers, makers, totalFees, cpmmState, ordersToCancel }\n}\n\nconst computeFill = (\n  amount: number,\n  outcome: 'YES' | 'NO',\n  limitProb: number | undefined,\n  cpmmState: CpmmState,\n  matchedBet: LimitBet | undefined,\n  matchedBetUserBalance: number | undefined,\n  freeFees?: boolean\n) => {\n  const prob = getCpmmProbability(cpmmState.pool, cpmmState.p)\n\n  if (\n    limitProb !== undefined &&\n    (outcome === 'YES'\n      ? floatingGreaterEqual(prob, limitProb) &&\n        (matchedBet?.limitProb ?? 1) > limitProb\n      : floatingLesserEqual(prob, limitProb) &&\n        (matchedBet?.limitProb ?? 0) < limitProb)\n  ) {\n    // No fill.\n    return undefined\n  }\n\n  const timestamp = Date.now()\n\n  if (\n    !matchedBet ||\n    (outcome === 'YES'\n      ? !floatingGreaterEqual(prob, matchedBet.limitProb)\n      : !floatingLesserEqual(prob, matchedBet.limitProb))\n  ) {\n    // Fill from pool.\n    const limit = !matchedBet\n      ? limitProb\n      : outcome === 'YES'\n      ? Math.min(matchedBet.limitProb, limitProb ?? 1)\n      : Math.max(matchedBet.limitProb, limitProb ?? 0)\n\n    const buyAmount =\n      limit === undefined\n        ? amount\n        : Math.min(\n            amount,\n            freeFees\n              ? calculateCpmmAmountToProb(cpmmState, limit, outcome)\n              : calculateCpmmAmountToProbIncludingFees(\n                  cpmmState,\n                  limit,\n                  outcome\n                )\n          )\n\n    const { shares, newPool, newP, fees } = calculateCpmmPurchase(\n      cpmmState,\n      buyAmount,\n      outcome,\n      freeFees\n    )\n    const newState = {\n      pool: newPool,\n      p: newP,\n      collectedFees: addObjects(fees, cpmmState.collectedFees),\n    }\n\n    return {\n      maker: {\n        matchedBetId: null,\n        shares,\n        amount: buyAmount,\n        state: newState,\n        timestamp,\n      },\n      taker: {\n        matchedBetId: null,\n        shares,\n        amount: buyAmount,\n        timestamp,\n        fees,\n      },\n    }\n  }\n\n  // Fill from matchedBet.\n  const amountRemaining = matchedBet.orderAmount - matchedBet.amount\n  const matchableUserBalance =\n    matchedBetUserBalance && matchedBetUserBalance < 0\n      ? 0\n      : matchedBetUserBalance\n  const amountToFill = Math.min(\n    amountRemaining,\n    matchableUserBalance ?? amountRemaining\n  )\n\n  const takerPrice =\n    outcome === 'YES' ? matchedBet.limitProb : 1 - matchedBet.limitProb\n  const makerPrice =\n    outcome === 'YES' ? 1 - matchedBet.limitProb : matchedBet.limitProb\n\n  const feesOnOneShare = freeFees ? 0 : getTakerFee(1, takerPrice)\n  const maxTakerShares = amount / (takerPrice + feesOnOneShare)\n  const maxMakerShares = amountToFill / makerPrice\n  const shares = Math.min(maxTakerShares, maxMakerShares)\n\n  const takerFee = freeFees ? 0 : getTakerFee(shares, takerPrice)\n  const fees = getFeesSplit(takerFee)\n\n  const maker = {\n    bet: matchedBet,\n    matchedBetId: 'taker',\n    amount: shares * makerPrice,\n    shares,\n    timestamp,\n  }\n  const taker = {\n    matchedBetId: matchedBet.id,\n    amount: shares * takerPrice + takerFee,\n    shares,\n    timestamp,\n    fees,\n  }\n  return { maker, taker }\n}\n\n// Faster version assuming p = 0.5\nexport function calculateAmountToBuySharesFixedP(\n  state: CpmmState,\n  shares: number,\n  outcome: 'YES' | 'NO',\n  unfilledBets: LimitBet[],\n  balanceByUserId: { [userId: string]: number },\n  freeFees?: boolean\n) {\n  const { takers } = computeFills(\n    state,\n    outcome,\n    // First, bet more than required to get shares.\n    shares,\n    undefined,\n    unfilledBets,\n    balanceByUserId,\n    undefined,\n    freeFees\n  )\n\n  let currShares = 0\n  let currAmount = 0\n  for (const fill of takers) {\n    const { amount: fillAmount, shares: fillShares, matchedBetId } = fill\n\n    if (floatingEqual(currShares + fillShares, shares)) {\n      return currAmount + fillAmount\n    }\n    if (currShares + fillShares > shares) {\n      // This is first fill that goes over the required shares.\n      if (matchedBetId) {\n        // Match a portion of the fill to get the exact shares.\n        const remainingShares = shares - currShares\n        const remainingAmount = fillAmount * (remainingShares / fillShares)\n        return currAmount + remainingAmount\n      }\n      // Last fill was from AMM. Break to compute the cpmmState at this point.\n      break\n    }\n\n    currShares += fillShares\n    currAmount += fillAmount\n  }\n\n  const remaningShares = shares - currShares\n\n  // Recompute up to currAmount to get the current cpmmState.\n  const { cpmmState } = computeFills(\n    state,\n    outcome,\n    currAmount,\n    undefined,\n    unfilledBets,\n    balanceByUserId,\n    undefined,\n    freeFees\n  )\n  const fillAmount = calculateCpmmAmountToBuySharesFixedP(\n    cpmmState,\n    remaningShares,\n    outcome\n  )\n  const fillAmountFees = freeFees\n    ? 0\n    : getTakerFee(remaningShares, fillAmount / remaningShares)\n  return currAmount + fillAmount + fillAmountFees\n}\n\nexport function calculateCpmmMultiSumsToOneSale(\n  answers: Answer[],\n  answerToSell: Answer,\n  shares: number,\n  outcome: 'YES' | 'NO',\n  limitProb: number | undefined,\n  unfilledBets: LimitBet[],\n  balanceByUserId: { [userId: string]: number },\n  collectedFees: Fees\n) {\n  if (Math.round(shares) < 0) {\n    throw new Error('Cannot sell non-positive shares')\n  }\n\n  const { newBetResult, otherBetResults } =\n    outcome === 'YES'\n      ? calculateCpmmMultiArbitrageSellYes(\n          answers,\n          answerToSell,\n          shares,\n          limitProb,\n          unfilledBets,\n          balanceByUserId,\n          collectedFees\n        )\n      : calculateCpmmMultiArbitrageSellNo(\n          answers,\n          answerToSell,\n          shares,\n          limitProb,\n          unfilledBets,\n          balanceByUserId,\n          collectedFees\n        )\n\n  const buyAmount = sumBy(newBetResult.takers, (taker) => taker.amount)\n  // Transform buys of opposite outcome into sells.\n  const saleTakers = newBetResult.takers.map((taker) => ({\n    ...taker,\n    // You bought opposite shares, which combine with existing shares, removing them.\n    shares: -taker.shares,\n    // Opposite shares combine with shares you are selling for Ṁ of shares.\n    // You paid taker.amount for the opposite shares.\n    // Take the negative because this is money you gain.\n    amount: -(taker.shares - taker.amount),\n    isSale: true,\n  }))\n\n  const saleValue = -sumBy(saleTakers, (taker) => taker.amount)\n\n  const transformedNewBetResult = {\n    ...newBetResult,\n    takers: saleTakers,\n    outcome,\n  }\n\n  return {\n    saleValue,\n    buyAmount,\n    newBetResult: transformedNewBetResult,\n    otherBetResults,\n  }\n}\n\nexport function calculateAmountToBuyShares(\n  state: CpmmState,\n  shares: number,\n  outcome: 'YES' | 'NO',\n  unfilledBets: LimitBet[],\n  balanceByUserId: { [userId: string]: number }\n) {\n  const prob = getCpmmProbability(state.pool, state.p)\n  const minAmount = shares * (outcome === 'YES' ? prob : 1 - prob)\n\n  // Search for amount between bounds.\n  // Min share price is based on current probability, and max is Ṁ1 each.\n  return binarySearch(minAmount, shares, (amount) => {\n    const { takers } = computeFills(\n      state,\n      outcome,\n      amount,\n      undefined,\n      unfilledBets,\n      balanceByUserId\n    )\n\n    const totalShares = sumBy(takers, (taker) => taker.shares)\n    return totalShares - shares\n  })\n}\n\nexport function calculateCpmmAmountToBuyShares(\n  contract: MarketContract,\n  shares: number,\n  outcome: 'YES' | 'NO',\n  allUnfilledBets: LimitBet[],\n  balanceByUserId: { [userId: string]: number },\n  answer?: Answer\n) {\n  const startCpmmState =\n    contract.mechanism === 'cpmm-1'\n      ? contract\n      : {\n          pool: { YES: answer!.poolYes, NO: answer!.poolNo },\n          p: 0.5,\n          collectedFees: contract.collectedFees,\n        }\n\n  const unfilledBets = answer?.id\n    ? allUnfilledBets.filter((b) => b.answerId === answer.id)\n    : allUnfilledBets\n\n  if (contract.mechanism === 'cpmm-1') {\n    return calculateAmountToBuyShares(\n      startCpmmState,\n      shares,\n      outcome,\n      unfilledBets,\n      balanceByUserId\n    )\n  } else if (contract.mechanism === 'cpmm-multi-1') {\n    return calculateAmountToBuySharesFixedP(\n      startCpmmState,\n      shares,\n      outcome,\n      unfilledBets,\n      balanceByUserId\n    )\n  } else {\n    throw new Error('Only works for cpmm-1 and cpmm-multi-1')\n  }\n}\n\nexport function calculateCpmmSale(\n  state: CpmmState,\n  shares: number,\n  outcome: 'YES' | 'NO',\n  unfilledBets: LimitBet[],\n  balanceByUserId: { [userId: string]: number }\n) {\n  if (Math.round(shares) < 0) {\n    throw new Error('Cannot sell non-positive shares')\n  }\n\n  const oppositeOutcome = outcome === 'YES' ? 'NO' : 'YES'\n  const buyAmount = calculateAmountToBuyShares(\n    state,\n    shares,\n    oppositeOutcome,\n    unfilledBets,\n    balanceByUserId\n  )\n\n  const { cpmmState, makers, takers, totalFees, ordersToCancel } = computeFills(\n    state,\n    oppositeOutcome,\n    buyAmount,\n    undefined,\n    unfilledBets,\n    balanceByUserId\n  )\n\n  // Transform buys of opposite outcome into sells.\n  const saleTakers = takers.map((taker) => ({\n    ...taker,\n    // You bought opposite shares, which combine with existing shares, removing them.\n    shares: -taker.shares,\n    // Opposite shares combine with shares you are selling for Ṁ of shares.\n    // You paid taker.amount for the opposite shares.\n    // Take the negative because this is money you gain.\n    amount: -(taker.shares - taker.amount),\n    isSale: true,\n  }))\n\n  const saleValue = -sumBy(saleTakers, (taker) => taker.amount)\n\n  return {\n    saleValue,\n    buyAmount,\n    cpmmState,\n    fees: totalFees,\n    makers,\n    takers: saleTakers,\n    ordersToCancel,\n  }\n}\n\nexport function getCpmmProbabilityAfterSale(\n  state: CpmmState,\n  shares: number,\n  outcome: 'YES' | 'NO',\n  unfilledBets: LimitBet[],\n  balanceByUserId: { [userId: string]: number }\n) {\n  const { cpmmState } = calculateCpmmSale(\n    state,\n    shares,\n    outcome,\n    unfilledBets,\n    balanceByUserId\n  )\n  return getCpmmProbability(cpmmState.pool, cpmmState.p)\n}\n\nexport function getCpmmLiquidity(\n  pool: { [outcome: string]: number },\n  p: number\n) {\n  const { YES, NO } = pool\n  return YES ** p * NO ** (1 - p)\n}\n\nexport function getMultiCpmmLiquidity(pool: { YES: number; NO: number }) {\n  return getCpmmLiquidity(pool, 0.5)\n}\n\nexport function addCpmmLiquidity(\n  pool: { [outcome: string]: number },\n  p: number,\n  amount: number\n) {\n  const prob = getCpmmProbability(pool, p)\n\n  //https://www.wolframalpha.com/input?i=p%28n%2Bb%29%2F%28%281-p%29%28y%2Bb%29%2Bp%28n%2Bb%29%29%3Dq%2C+solve+p\n  const { YES: y, NO: n } = pool\n  const numerator = prob * (amount + y)\n  const denominator = amount - n * (prob - 1) + prob * y\n  const newP = numerator / denominator\n\n  const newPool = { YES: y + amount, NO: n + amount }\n\n  const oldLiquidity = getCpmmLiquidity(pool, newP)\n  const newLiquidity = getCpmmLiquidity(newPool, newP)\n  const liquidity = newLiquidity - oldLiquidity\n\n  return { newPool, liquidity, newP }\n}\n\nexport function addCpmmLiquidityFixedP(\n  pool: { YES: number; NO: number },\n  amount: number\n) {\n  const prob = getCpmmProbability(pool, 0.5)\n  const newPool = { ...pool }\n  const sharesThrownAway = { YES: 0, NO: 0 }\n\n  // Throws away some shares so that prob is maintained.\n  if (prob < 0.5) {\n    newPool.YES += amount\n    newPool.NO += (prob / (1 - prob)) * amount\n    sharesThrownAway.NO = amount - (prob / (1 - prob)) * amount\n  } else {\n    newPool.NO += amount\n    newPool.YES += ((1 - prob) / prob) * amount\n    sharesThrownAway.YES = amount - ((1 - prob) / prob) * amount\n  }\n\n  const oldLiquidity = getMultiCpmmLiquidity(pool)\n  const newLiquidity = getMultiCpmmLiquidity(newPool)\n  const liquidity = newLiquidity - oldLiquidity\n\n  return { newPool, liquidity, sharesThrownAway }\n}\n\nexport function addCpmmMultiLiquidityToAnswersIndependently(\n  pools: { [answerId: string]: { YES: number; NO: number } },\n  amount: number\n) {\n  const amountPerAnswer = amount / Object.keys(pools).length\n  return mapValues(\n    pools,\n    (pool) => addCpmmLiquidityFixedP(pool, amountPerAnswer).newPool\n  )\n}\n\nexport function addCpmmMultiLiquidityAnswersSumToOne(\n  pools: { [answerId: string]: { YES: number; NO: number } },\n  amount: number\n) {\n  const answerIds = Object.keys(pools)\n  const numAnswers = answerIds.length\n\n  const newPools = { ...pools }\n\n  let amountRemaining = amount\n  while (amountRemaining > EPSILON) {\n    const yesSharesThrownAway: { [answerId: string]: number } =\n      Object.fromEntries(answerIds.map((answerId) => [answerId, 0]))\n\n    for (const [answerId, pool] of Object.entries(newPools)) {\n      const { newPool, sharesThrownAway } = addCpmmLiquidityFixedP(\n        pool,\n        amountRemaining / numAnswers\n      )\n      newPools[answerId] = newPool\n\n      yesSharesThrownAway[answerId] += sharesThrownAway.YES\n      const otherAnswerIds = answerIds.filter((id) => id !== answerId)\n      for (const otherAnswerId of otherAnswerIds) {\n        // Convert NO shares into YES shares for each other answer.\n        yesSharesThrownAway[otherAnswerId] += sharesThrownAway.NO\n      }\n    }\n\n    const minSharesThrownAway = Math.min(...Object.values(yesSharesThrownAway))\n    amountRemaining = minSharesThrownAway\n  }\n  return newPools\n}\n\n// Must be at least this many yes and no shares\nexport const MINIMUM_LIQUIDITY = 100\n\nexport function removeCpmmLiquidity(\n  pool: { [outcome: string]: number },\n  p: number,\n  amount: number\n) {\n  const { newPool, liquidity, newP } = addCpmmLiquidity(pool, p, -1 * amount)\n\n  const error =\n    newPool.YES < MINIMUM_LIQUIDITY || newPool.NO < MINIMUM_LIQUIDITY\n\n  return { newPool, liquidity, newP, error }\n}\n\nexport function maximumRemovableLiquidity(pool: { [outcome: string]: number }) {\n  const { YES: y, NO: n } = pool\n  return Math.max(Math.min(y, n) - MINIMUM_LIQUIDITY, 0)\n}\n\nexport function getCpmmLiquidityPoolWeights(liquidities: LiquidityProvision[]) {\n  if (liquidities.length === 0) return {} // this should never happen\n\n  const liquiditiesByUser = groupBy(liquidities, 'userId')\n\n  // we don't clawback from users that took more liquidity than they gave\n  // instead we count their contribution as 0 and split the rest\n  const userAmounts = mapValues(liquiditiesByUser, (liquidities) =>\n    Math.max(0, sumBy(liquidities, 'amount'))\n  )\n  const totalAmount = sum(Object.values(userAmounts))\n  // ... unless they are all net liquidity leeches, in which case remaining liquidity goes to the first liquidizer (persumably the creator)\n  if (totalAmount === 0) {\n    const firstUser = minBy(liquidities, 'createdTime')!.userId\n    return { [firstUser]: 1 }\n  }\n  const weights = mapValues(userAmounts, (amount) => amount / totalAmount)\n  return omitBy(weights, (w) => w === 0)\n}\n\nconst getK = (pool: { [outcome: string]: number }) => {\n  const values = Object.values(pool)\n  return sumBy(values, Math.log)\n}\n\nexport const getLiquidity = (pool: { [outcome: string]: number }) => {\n  return Math.exp(getK(pool) / Object.keys(pool).length)\n}\n\nexport function getUserLiquidityShares(\n  userId: string,\n  pool: { [outcome: string]: number },\n  liquidities: LiquidityProvision[]\n) {\n  const weights = getCpmmLiquidityPoolWeights(liquidities)\n  const userWeight = weights[userId] ?? 0\n\n  return mapValues(pool, (shares) => userWeight * shares)\n}\n",
          "postContent": "import { groupBy, mapValues, minBy, omitBy, sortBy, sum, sumBy } from 'lodash'\nimport { fill, LimitBet } from './bet'\nimport { Fees, getFeesSplit, getTakerFee, noFees } from './fees'\nimport { LiquidityProvision } from './liquidity-provision'\nimport { binarySearch } from './util/algos'\nimport {\n  EPSILON,\n  floatingEqual,\n  floatingGreaterEqual,\n  floatingLesserEqual,\n} from './util/math'\nimport {\n  calculateCpmmMultiArbitrageSellNo,\n  calculateCpmmMultiArbitrageSellYes,\n} from './calculate-cpmm-arbitrage'\nimport { Answer } from './answer'\nimport { MarketContract, MAX_CPMM_PROB, MIN_CPMM_PROB } from 'common/contract'\nimport { addObjects } from 'common/util/object'\nexport const CPMM_ARBITRAGE_ERROR_PREFIX =\n  'calculateAmountToBuySharesFixedP only works for p = 0.5, got '\nexport type CpmmState = {\n  pool: { [outcome: string]: number }\n  p: number\n  collectedFees: Fees\n}\n\nexport function getCpmmProbability(\n  pool: { [outcome: string]: number },\n  p: number\n) {\n  const { YES, NO } = pool\n  return (p * NO) / ((1 - p) * YES + p * NO)\n}\n\nexport function getCpmmProbabilityAfterBetBeforeFees(\n  state: CpmmState,\n  outcome: string,\n  bet: number\n) {\n  const { pool, p } = state\n  const shares = calculateCpmmShares(pool, p, bet, outcome)\n  const { YES: y, NO: n } = pool\n\n  const [newY, newN] =\n    outcome === 'YES'\n      ? [y - shares + bet, n + bet]\n      : [y + bet, n - shares + bet]\n\n  return getCpmmProbability({ YES: newY, NO: newN }, p)\n}\n\nexport function getCpmmOutcomeProbabilityAfterBet(\n  state: CpmmState,\n  outcome: string,\n  bet: number\n) {\n  const { newPool } = calculateCpmmPurchase(state, bet, outcome)\n  const p = getCpmmProbability(newPool, state.p)\n  return outcome === 'NO' ? 1 - p : p\n}\n\n// before liquidity fee\nexport function calculateCpmmShares(\n  pool: {\n    [outcome: string]: number\n  },\n  p: number,\n  betAmount: number,\n  betChoice: string\n) {\n  if (betAmount === 0) return 0\n\n  const { YES: y, NO: n } = pool\n  const k = y ** p * n ** (1 - p)\n\n  return betChoice === 'YES'\n    ? // https://www.wolframalpha.com/input?i=%28y%2Bb-s%29%5E%28p%29*%28n%2Bb%29%5E%281-p%29+%3D+k%2C+solve+s\n      y + betAmount - (k * (betAmount + n) ** (p - 1)) ** (1 / p)\n    : n + betAmount - (k * (betAmount + y) ** -p) ** (1 / (1 - p))\n}\n\nexport function getCpmmFees(\n  state: CpmmState,\n  betAmount: number,\n  outcome: string\n) {\n  // Do a few iterations toward average probability of the bet minus fees.\n  // Charging fees means the bet amount is lower and the average probability moves slightly less far.\n  let fee = 0\n  for (let i = 0; i < 10; i++) {\n    const betAmountAfterFee = betAmount - fee\n    const shares = calculateCpmmShares(\n      state.pool,\n      state.p,\n      betAmountAfterFee,\n      outcome\n    )\n    const averageProb = betAmountAfterFee / shares\n    fee = getTakerFee(shares, averageProb)\n  }\n\n  const totalFees = betAmount === 0 ? 0 : fee\n  const fees = getFeesSplit(totalFees)\n\n  const remainingBet = betAmount - totalFees\n\n  return { remainingBet, totalFees, fees }\n}\n\nexport function calculateCpmmSharesAfterFee(\n  state: CpmmState,\n  bet: number,\n  outcome: string\n) {\n  const { pool, p } = state\n  const { remainingBet } = getCpmmFees(state, bet, outcome)\n\n  return calculateCpmmShares(pool, p, remainingBet, outcome)\n}\n\nexport function calculateCpmmPurchase(\n  state: CpmmState,\n  bet: number,\n  outcome: string,\n  freeFees?: boolean\n) {\n  const { pool, p } = state\n  const { remainingBet, fees } = freeFees\n    ? {\n        remainingBet: bet,\n        fees: noFees,\n      }\n    : getCpmmFees(state, bet, outcome)\n\n  const shares = calculateCpmmShares(pool, p, remainingBet, outcome)\n  const { YES: y, NO: n } = pool\n\n  const { liquidityFee: fee } = fees\n\n  const [newY, newN] =\n    outcome === 'YES'\n      ? [y - shares + remainingBet + fee, n + remainingBet + fee]\n      : [y + remainingBet + fee, n - shares + remainingBet + fee]\n\n  const postBetPool = { YES: newY, NO: newN }\n\n  const { newPool, newP } = addCpmmLiquidity(postBetPool, p, fee)\n\n  return { shares, newPool, newP, fees }\n}\n\nexport function calculateCpmmAmountToProb(\n  state: CpmmState,\n  prob: number,\n  outcome: 'YES' | 'NO'\n) {\n  if (prob <= 0 || prob >= 1 || isNaN(prob)) return Infinity\n  if (outcome === 'NO') prob = 1 - prob\n\n  const { pool, p } = state\n  const { YES: y, NO: n } = pool\n  const k = y ** p * n ** (1 - p)\n  return outcome === 'YES'\n    ? // https://www.wolframalpha.com/input?i=-1+%2B+t+-+((-1+%2B+p)+t+(k%2F(n+%2B+b))^(1%2Fp))%2Fp+solve+b\n      ((p * (prob - 1)) / ((p - 1) * prob)) ** -p *\n        (k - n * ((p * (prob - 1)) / ((p - 1) * prob)) ** p)\n    : (((1 - p) * (prob - 1)) / (-p * prob)) ** (p - 1) *\n        (k - y * (((1 - p) * (prob - 1)) / (-p * prob)) ** (1 - p))\n}\n\nexport function calculateCpmmAmountToProbIncludingFees(\n  state: CpmmState,\n  prob: number,\n  outcome: 'YES' | 'NO'\n) {\n  const amount = calculateCpmmAmountToProb(state, prob, outcome)\n  const shares = calculateCpmmShares(state.pool, state.p, amount, outcome)\n  const averageProb = amount / shares\n  const fees = getTakerFee(shares, averageProb)\n  return amount + fees\n}\n\nexport function calculateCpmmAmountToBuySharesFixedP(\n  state: CpmmState,\n  shares: number,\n  outcome: 'YES' | 'NO'\n) {\n  if (!floatingEqual(state.p, 0.5)) {\n    throw new Error(CPMM_ARBITRAGE_ERROR_PREFIX + state.p)\n  }\n\n  const { YES: y, NO: n } = state.pool\n  if (outcome === 'YES') {\n    // https://www.wolframalpha.com/input?i=%28y%2Bb-s%29%5E0.5+*+%28n%2Bb%29%5E0.5+%3D+y+%5E+0.5+*+n+%5E+0.5%2C+solve+b\n    return (\n      (shares - y - n + Math.sqrt(4 * n * shares + (y + n - shares) ** 2)) / 2\n    )\n  }\n  return (\n    (shares - y - n + Math.sqrt(4 * y * shares + (y + n - shares) ** 2)) / 2\n  )\n}\n\nexport const computeFills = (\n  state: CpmmState,\n  outcome: 'YES' | 'NO',\n  betAmount: number,\n  initialLimitProb: number | undefined,\n  unfilledBets: LimitBet[],\n  balanceByUserId: { [userId: string]: number | undefined },\n  limitProbs?: { max: number; min: number },\n  freeFees?: boolean\n) => {\n  if (isNaN(betAmount)) {\n    throw new Error('Invalid bet amount: ${betAmount}')\n  }\n  if (isNaN(initialLimitProb ?? 0)) {\n    throw new Error('Invalid limitProb: ${limitProb}')\n  }\n  const now = Date.now()\n  const { max, min } = limitProbs ?? {}\n  const limit = initialLimitProb ?? (outcome === 'YES' ? max : min)\n  const limitProb = !limit\n    ? undefined\n    : limit > MAX_CPMM_PROB\n    ? MAX_CPMM_PROB\n    : limit < MIN_CPMM_PROB\n    ? MIN_CPMM_PROB\n    : limit\n\n  const sortedBets = sortBy(\n    unfilledBets.filter(\n      (bet) =>\n        bet.outcome !== outcome && (bet.expiresAt ? bet.expiresAt > now : true)\n    ),\n    (bet) => (outcome === 'YES' ? bet.limitProb : -bet.limitProb),\n    (bet) => bet.createdTime\n  )\n\n  const takers: fill[] = []\n  const makers: {\n    bet: LimitBet\n    amount: number\n    shares: number\n    timestamp: number\n  }[] = []\n  const ordersToCancel: LimitBet[] = []\n\n  let amount = betAmount\n  let cpmmState = { ...state }\n  let totalFees = noFees\n  const currentBalanceByUserId = { ...balanceByUserId }\n\n  let i = 0\n  while (true) {\n    const matchedBet: LimitBet | undefined = sortedBets[i]\n    const fill = computeFill(\n      amount,\n      outcome,\n      limitProb,\n      cpmmState,\n      matchedBet,\n      currentBalanceByUserId[matchedBet?.userId ?? ''],\n      freeFees\n    )\n\n    if (!fill) break\n\n    const { taker, maker } = fill\n\n    if (maker.matchedBetId === null) {\n      // Matched against pool.\n      cpmmState = maker.state\n      takers.push(taker)\n    } else {\n      // Matched against bet.\n      i++\n      const { userId } = maker.bet\n      const makerBalance = currentBalanceByUserId[userId]\n      if (makerBalance !== undefined) {\n        if (maker.amount > 0) {\n          currentBalanceByUserId[userId] = makerBalance - maker.amount\n        }\n        const adjustedMakerBalance = currentBalanceByUserId[userId]\n        if (adjustedMakerBalance !== undefined && adjustedMakerBalance <= 0) {\n          // Now they've insufficient balance. Cancel maker bet.\n          ordersToCancel.push(maker.bet)\n        }\n      }\n      if (floatingEqual(maker.amount, 0)) continue\n\n      takers.push(taker)\n      makers.push(maker)\n    }\n\n    totalFees = addObjects(totalFees, taker.fees)\n    amount -= taker.amount\n\n    if (floatingEqual(amount, 0)) break\n  }\n\n  return { takers, makers, totalFees, cpmmState, ordersToCancel }\n}\n\nconst computeFill = (\n  amount: number,\n  outcome: 'YES' | 'NO',\n  limitProb: number | undefined,\n  cpmmState: CpmmState,\n  matchedBet: LimitBet | undefined,\n  matchedBetUserBalance: number | undefined,\n  freeFees?: boolean\n) => {\n  const prob = getCpmmProbability(cpmmState.pool, cpmmState.p)\n\n  if (\n    limitProb !== undefined &&\n    (outcome === 'YES'\n      ? floatingGreaterEqual(prob, limitProb) &&\n        (matchedBet?.limitProb ?? 1) > limitProb\n      : floatingLesserEqual(prob, limitProb) &&\n        (matchedBet?.limitProb ?? 0) < limitProb)\n  ) {\n    // No fill.\n    return undefined\n  }\n\n  const timestamp = Date.now()\n\n  if (\n    !matchedBet ||\n    (outcome === 'YES'\n      ? !floatingGreaterEqual(prob, matchedBet.limitProb)\n      : !floatingLesserEqual(prob, matchedBet.limitProb))\n  ) {\n    // Fill from pool.\n    const limit = !matchedBet\n      ? limitProb\n      : outcome === 'YES'\n      ? Math.min(matchedBet.limitProb, limitProb ?? 1)\n      : Math.max(matchedBet.limitProb, limitProb ?? 0)\n\n    const buyAmount =\n      limit === undefined\n        ? amount\n        : Math.min(\n            amount,\n            freeFees\n              ? calculateCpmmAmountToProb(cpmmState, limit, outcome)\n              : calculateCpmmAmountToProbIncludingFees(\n                  cpmmState,\n                  limit,\n                  outcome\n                )\n          )\n\n    const { shares, newPool, newP, fees } = calculateCpmmPurchase(\n      cpmmState,\n      buyAmount,\n      outcome,\n      freeFees\n    )\n    const newState = {\n      pool: newPool,\n      p: newP,\n      collectedFees: addObjects(fees, cpmmState.collectedFees),\n    }\n\n    return {\n      maker: {\n        matchedBetId: null,\n        shares,\n        amount: buyAmount,\n        state: newState,\n        timestamp,\n      },\n      taker: {\n        matchedBetId: null,\n        shares,\n        amount: buyAmount,\n        timestamp,\n        fees,\n      },\n    }\n  }\n\n  // Fill from matchedBet.\n  const amountRemaining = matchedBet.orderAmount - matchedBet.amount\n  const matchableUserBalance =\n    matchedBetUserBalance && matchedBetUserBalance < 0\n      ? 0\n      : matchedBetUserBalance\n  const amountToFill = Math.min(\n    amountRemaining,\n    matchableUserBalance ?? amountRemaining\n  )\n\n  const takerPrice =\n    outcome === 'YES' ? matchedBet.limitProb : 1 - matchedBet.limitProb\n  const makerPrice =\n    outcome === 'YES' ? 1 - matchedBet.limitProb : matchedBet.limitProb\n\n  const feesOnOneShare = freeFees ? 0 : getTakerFee(1, takerPrice)\n  const maxTakerShares = amount / (takerPrice + feesOnOneShare)\n  const maxMakerShares = amountToFill / makerPrice\n  const shares = Math.min(maxTakerShares, maxMakerShares)\n\n  const takerFee = freeFees ? 0 : getTakerFee(shares, takerPrice)\n  const fees = getFeesSplit(takerFee)\n\n  const maker = {\n    bet: matchedBet,\n    matchedBetId: 'taker',\n    amount: shares * makerPrice,\n    shares,\n    timestamp,\n  }\n  const taker = {\n    matchedBetId: matchedBet.id,\n    amount: shares * takerPrice + takerFee,\n    shares,\n    timestamp,\n    fees,\n  }\n  return { maker, taker }\n}\n\n// Faster version assuming p = 0.5\nexport function calculateAmountToBuySharesFixedP(\n  state: CpmmState,\n  shares: number,\n  outcome: 'YES' | 'NO',\n  unfilledBets: LimitBet[],\n  balanceByUserId: { [userId: string]: number },\n  freeFees?: boolean\n) {\n  const { takers } = computeFills(\n    state,\n    outcome,\n    // First, bet more than required to get shares.\n    shares,\n    undefined,\n    unfilledBets,\n    balanceByUserId,\n    undefined,\n    freeFees\n  )\n\n  let currShares = 0\n  let currAmount = 0\n  for (const fill of takers) {\n    const { amount: fillAmount, shares: fillShares, matchedBetId } = fill\n\n    if (floatingEqual(currShares + fillShares, shares)) {\n      return currAmount + fillAmount\n    }\n    if (currShares + fillShares > shares) {\n      // This is first fill that goes over the required shares.\n      if (matchedBetId) {\n        // Match a portion of the fill to get the exact shares.\n        const remainingShares = shares - currShares\n        const remainingAmount = fillAmount * (remainingShares / fillShares)\n        return currAmount + remainingAmount\n      }\n      // Last fill was from AMM. Break to compute the cpmmState at this point.\n      break\n    }\n\n    currShares += fillShares\n    currAmount += fillAmount\n  }\n\n  const remaningShares = shares - currShares\n\n  // Recompute up to currAmount to get the current cpmmState.\n  const { cpmmState } = computeFills(\n    state,\n    outcome,\n    currAmount,\n    undefined,\n    unfilledBets,\n    balanceByUserId,\n    undefined,\n    freeFees\n  )\n  const fillAmount = calculateCpmmAmountToBuySharesFixedP(\n    cpmmState,\n    remaningShares,\n    outcome\n  )\n  const fillAmountFees = freeFees\n    ? 0\n    : getTakerFee(remaningShares, fillAmount / remaningShares)\n  return currAmount + fillAmount + fillAmountFees\n}\n\nexport function calculateCpmmMultiSumsToOneSale(\n  answers: Answer[],\n  answerToSell: Answer,\n  shares: number,\n  outcome: 'YES' | 'NO',\n  limitProb: number | undefined,\n  unfilledBets: LimitBet[],\n  balanceByUserId: { [userId: string]: number },\n  collectedFees: Fees\n) {\n  if (Math.round(shares) < 0) {\n    throw new Error('Cannot sell non-positive shares')\n  }\n\n  const { newBetResult, otherBetResults } =\n    outcome === 'YES'\n      ? calculateCpmmMultiArbitrageSellYes(\n          answers,\n          answerToSell,\n          shares,\n          limitProb,\n          unfilledBets,\n          balanceByUserId,\n          collectedFees\n        )\n      : calculateCpmmMultiArbitrageSellNo(\n          answers,\n          answerToSell,\n          shares,\n          limitProb,\n          unfilledBets,\n          balanceByUserId,\n          collectedFees\n        )\n\n  const buyAmount = sumBy(newBetResult.takers, (taker) => taker.amount)\n  // Transform buys of opposite outcome into sells.\n  const saleTakers = newBetResult.takers.map((taker) => ({\n    ...taker,\n    // You bought opposite shares, which combine with existing shares, removing them.\n    shares: -taker.shares,\n    // Opposite shares combine with shares you are selling for Ṁ of shares.\n    // You paid taker.amount for the opposite shares.\n    // Take the negative because this is money you gain.\n    amount: -(taker.shares - taker.amount),\n    isSale: true,\n  }))\n\n  const saleValue = -sumBy(saleTakers, (taker) => taker.amount)\n\n  const transformedNewBetResult = {\n    ...newBetResult,\n    takers: saleTakers,\n    outcome,\n  }\n\n  return {\n    saleValue,\n    buyAmount,\n    newBetResult: transformedNewBetResult,\n    otherBetResults,\n  }\n}\n\nexport function calculateAmountToBuyShares(\n  state: CpmmState,\n  shares: number,\n  outcome: 'YES' | 'NO',\n  unfilledBets: LimitBet[],\n  balanceByUserId: { [userId: string]: number }\n) {\n  const prob = getCpmmProbability(state.pool, state.p)\n  const minAmount = shares * (outcome === 'YES' ? prob : 1 - prob)\n\n  // Search for amount between bounds.\n  // Min share price is based on current probability, and max is Ṁ1 each.\n  return binarySearch(minAmount, shares, (amount) => {\n    const { takers } = computeFills(\n      state,\n      outcome,\n      amount,\n      undefined,\n      unfilledBets,\n      balanceByUserId\n    )\n\n    const totalShares = sumBy(takers, (taker) => taker.shares)\n    return totalShares - shares\n  })\n}\n\nexport function calculateCpmmAmountToBuyShares(\n  contract: MarketContract,\n  shares: number,\n  outcome: 'YES' | 'NO',\n  allUnfilledBets: LimitBet[],\n  balanceByUserId: { [userId: string]: number },\n  answer?: Answer\n) {\n  const startCpmmState =\n    contract.mechanism === 'cpmm-1'\n      ? contract\n      : {\n          pool: { YES: answer!.poolYes, NO: answer!.poolNo },\n          p: 0.5,\n          collectedFees: contract.collectedFees,\n        }\n\n  const unfilledBets = answer?.id\n    ? allUnfilledBets.filter((b) => b.answerId === answer.id)\n    : allUnfilledBets\n\n  if (contract.mechanism === 'cpmm-1') {\n    return calculateAmountToBuyShares(\n      startCpmmState,\n      shares,\n      outcome,\n      unfilledBets,\n      balanceByUserId\n    )\n  } else if (contract.mechanism === 'cpmm-multi-1') {\n    return calculateAmountToBuySharesFixedP(\n      startCpmmState,\n      shares,\n      outcome,\n      unfilledBets,\n      balanceByUserId\n    )\n  } else {\n    throw new Error('Only works for cpmm-1 and cpmm-multi-1')\n  }\n}\n\nexport function calculateCpmmSale(\n  state: CpmmState,\n  shares: number,\n  outcome: 'YES' | 'NO',\n  unfilledBets: LimitBet[],\n  balanceByUserId: { [userId: string]: number }\n) {\n  if (Math.round(shares) < 0) {\n    throw new Error('Cannot sell non-positive shares')\n  }\n\n  const oppositeOutcome = outcome === 'YES' ? 'NO' : 'YES'\n  const buyAmount = calculateAmountToBuyShares(\n    state,\n    shares,\n    oppositeOutcome,\n    unfilledBets,\n    balanceByUserId\n  )\n\n  const { cpmmState, makers, takers, totalFees, ordersToCancel } = computeFills(\n    state,\n    oppositeOutcome,\n    buyAmount,\n    undefined,\n    unfilledBets,\n    balanceByUserId\n  )\n\n  // Transform buys of opposite outcome into sells.\n  const saleTakers = takers.map((taker) => ({\n    ...taker,\n    // You bought opposite shares, which combine with existing shares, removing them.\n    shares: -taker.shares,\n    // Opposite shares combine with shares you are selling for Ṁ of shares.\n    // You paid taker.amount for the opposite shares.\n    // Take the negative because this is money you gain.\n    amount: -(taker.shares - taker.amount),\n    isSale: true,\n  }))\n\n  const saleValue = -sumBy(saleTakers, (taker) => taker.amount)\n\n  return {\n    saleValue,\n    buyAmount,\n    cpmmState,\n    fees: totalFees,\n    makers,\n    takers: saleTakers,\n    ordersToCancel,\n  }\n}\n\nexport function getCpmmProbabilityAfterSale(\n  state: CpmmState,\n  shares: number,\n  outcome: 'YES' | 'NO',\n  unfilledBets: LimitBet[],\n  balanceByUserId: { [userId: string]: number }\n) {\n  const { cpmmState } = calculateCpmmSale(\n    state,\n    shares,\n    outcome,\n    unfilledBets,\n    balanceByUserId\n  )\n  return getCpmmProbability(cpmmState.pool, cpmmState.p)\n}\n\nexport function getCpmmLiquidity(\n  pool: { [outcome: string]: number },\n  p: number\n) {\n  const { YES, NO } = pool\n  return YES ** p * NO ** (1 - p)\n}\n\nexport function getMultiCpmmLiquidity(pool: { YES: number; NO: number }) {\n  return getCpmmLiquidity(pool, 0.5)\n}\n\nexport function addCpmmLiquidity(\n  pool: { [outcome: string]: number },\n  p: number,\n  amount: number\n) {\n  const prob = getCpmmProbability(pool, p)\n\n  //https://www.wolframalpha.com/input?i=p%28n%2Bb%29%2F%28%281-p%29%28y%2Bb%29%2Bp%28n%2Bb%29%29%3Dq%2C+solve+p\n  const { YES: y, NO: n } = pool\n  const numerator = prob * (amount + y)\n  const denominator = amount - n * (prob - 1) + prob * y\n  const newP = numerator / denominator\n\n  const newPool = { YES: y + amount, NO: n + amount }\n\n  const oldLiquidity = getCpmmLiquidity(pool, newP)\n  const newLiquidity = getCpmmLiquidity(newPool, newP)\n  const liquidity = newLiquidity - oldLiquidity\n\n  return { newPool, liquidity, newP }\n}\n\nexport function addCpmmLiquidityFixedP(\n  pool: { YES: number; NO: number },\n  amount: number\n) {\n  const prob = getCpmmProbability(pool, 0.5)\n  const newPool = { ...pool }\n  const sharesThrownAway = { YES: 0, NO: 0 }\n\n  // Throws away some shares so that prob is maintained.\n  if (prob < 0.5) {\n    newPool.YES += amount\n    newPool.NO += (prob / (1 - prob)) * amount\n    sharesThrownAway.NO = amount - (prob / (1 - prob)) * amount\n  } else {\n    newPool.NO += amount\n    newPool.YES += ((1 - prob) / prob) * amount\n    sharesThrownAway.YES = amount - ((1 - prob) / prob) * amount\n  }\n\n  const oldLiquidity = getMultiCpmmLiquidity(pool)\n  const newLiquidity = getMultiCpmmLiquidity(newPool)\n  const liquidity = newLiquidity - oldLiquidity\n\n  return { newPool, liquidity, sharesThrownAway }\n}\n\nexport function addCpmmMultiLiquidityToAnswersIndependently(\n  pools: { [answerId: string]: { YES: number; NO: number } },\n  amount: number\n) {\n  const amountPerAnswer = amount / Object.keys(pools).length\n  return mapValues(\n    pools,\n    (pool) => addCpmmLiquidityFixedP(pool, amountPerAnswer).newPool\n  )\n}\n\nexport function addCpmmMultiLiquidityAnswersSumToOne(\n  pools: { [answerId: string]: { YES: number; NO: number } },\n  amount: number\n) {\n  const answerIds = Object.keys(pools)\n  const numAnswers = answerIds.length\n\n  const newPools = { ...pools }\n\n  let amountRemaining = amount\n  while (amountRemaining > EPSILON) {\n    const yesSharesThrownAway: { [answerId: string]: number } =\n      Object.fromEntries(answerIds.map((answerId) => [answerId, 0]))\n\n    for (const [answerId, pool] of Object.entries(newPools)) {\n      const { newPool, sharesThrownAway } = addCpmmLiquidityFixedP(\n        pool,\n        amountRemaining / numAnswers\n      )\n      newPools[answerId] = newPool\n\n      yesSharesThrownAway[answerId] += sharesThrownAway.YES\n      const otherAnswerIds = answerIds.filter((id) => id !== answerId)\n      for (const otherAnswerId of otherAnswerIds) {\n        // Convert NO shares into YES shares for each other answer.\n        yesSharesThrownAway[otherAnswerId] += sharesThrownAway.NO\n      }\n    }\n\n    const minSharesThrownAway = Math.min(...Object.values(yesSharesThrownAway))\n    amountRemaining = minSharesThrownAway\n  }\n  return newPools\n}\n\n// Must be at least this many yes and no shares\nexport const MINIMUM_LIQUIDITY = 100\n\nexport function removeCpmmLiquidity(\n  pool: { [outcome: string]: number },\n  p: number,\n  amount: number\n) {\n  const { newPool, liquidity, newP } = addCpmmLiquidity(pool, p, -1 * amount)\n\n  const error =\n    newPool.YES < MINIMUM_LIQUIDITY || newPool.NO < MINIMUM_LIQUIDITY\n\n  return { newPool, liquidity, newP, error }\n}\n\nexport function maximumRemovableLiquidity(pool: { [outcome: string]: number }) {\n  const { YES: y, NO: n } = pool\n  return Math.max(Math.min(y, n) - MINIMUM_LIQUIDITY, 0)\n}\n\nexport function getCpmmLiquidityPoolWeights(liquidities: LiquidityProvision[]) {\n  if (liquidities.length === 0) return {} // this should never happen\n\n  const liquiditiesByUser = groupBy(liquidities, 'userId')\n\n  // we don't clawback from users that took more liquidity than they gave\n  // instead we count their contribution as 0 and split the rest\n  const userAmounts = mapValues(liquiditiesByUser, (liquidities) =>\n    Math.max(0, sumBy(liquidities, 'amount'))\n  )\n  const totalAmount = sum(Object.values(userAmounts))\n  // ... unless they are all net liquidity leeches, in which case remaining liquidity goes to the first liquidizer (persumably the creator)\n  if (totalAmount === 0) {\n    const firstUser = minBy(liquidities, 'createdTime')!.userId\n    return { [firstUser]: 1 }\n  }\n  const weights = mapValues(userAmounts, (amount) => amount / totalAmount)\n  return omitBy(weights, (w) => w === 0)\n}\n\nconst getK = (pool: { [outcome: string]: number }) => {\n  const values = Object.values(pool)\n  return sumBy(values, Math.log)\n}\n\nexport const getLiquidity = (pool: { [outcome: string]: number }) => {\n  return Math.exp(getK(pool) / Object.keys(pool).length)\n}\n\nexport function getUserLiquidityShares(\n  userId: string,\n  pool: { [outcome: string]: number },\n  liquidities: LiquidityProvision[]\n) {\n  const weights = getCpmmLiquidityPoolWeights(liquidities)\n  const userWeight = weights[userId] ?? 0\n\n  return mapValues(pool, (shares) => userWeight * shares)\n}\n"
        }
      ]
    },
    {
      "sha": "d6057e9fbb630694deaf44569c77e05194e8e941",
      "author": "Ian Philips",
      "date": "2025-05-13 16:54:10 -0700",
      "message": "Don't crash on cpmm arbitrage error",
      "stats": {
        "filesChanged": 3,
        "insertions": 15,
        "deletions": 7
      },
      "selectionReason": "Adds error handling to prevent crashes in arbitrage calculations - demonstrates robust error handling in financial calculations",
      "spec": "Refactor the error handling mechanism for limit bet calculations. The `getLimitBetReturns` function in `client-common/src/lib/bet.ts` should no longer accept an `setError` callback parameter. Instead, it must capture any internal calculation errors and return them as a new `calculationError` string property in its result object; this property should be `undefined` if no error occurs. Consuming UI components, specifically `BuyPanelBody` in `web/components/bet/bet-panel.tsx` and `LimitOrderPanel` in `web/components/bet/limit-order-panel.tsx`, must be updated to: 1. Cease passing an `setError` callback to `getLimitBetReturns`. 2. Retrieve the `calculationError` property from the object returned by `getLimitBetReturns`. 3. If `calculationError` has a value, use this value to update their respective local error states. In `LimitOrderPanel`, this update to the local error state should only occur if the received `calculationError` is different from its current error state.",
      "fileStates": [
        {
          "path": "client-common/src/lib/bet.ts",
          "preContent": "import { getCpmmProbability } from 'common/calculate-cpmm'\nimport { LimitBet } from 'common/bet'\nimport { Answer } from 'common/answer'\nimport { noFees } from 'common/fees'\nimport { calculateCpmmMultiArbitrageBet } from 'common/calculate-cpmm-arbitrage'\nimport { sumBy } from 'lodash'\nimport { addObjects } from 'common/util/object'\nimport { computeCpmmBet } from 'common/new-bet'\nimport { MAX_CPMM_PROB, MIN_CPMM_PROB } from 'common/contract'\nimport { TRADE_TERM } from 'common/envs/constants'\nimport { MarketContract } from 'common/contract'\nimport { isBinaryMulti } from 'common/contract'\nconst DEFAULT_SLIPPAGE = 0.1\n\nexport const getLimitBetReturns = (\n  binaryOutcome: 'YES' | 'NO',\n  betAmount: number,\n  unfilledBets: LimitBet[],\n  balanceByUserId: { [userId: string]: number },\n  setError: (error: string) => void,\n  contract: MarketContract,\n  multiProps: MultiBetProps | undefined,\n  manualLimitProb: number | undefined,\n  slippageProtection: boolean\n) => {\n  const shouldAnswersSumToOne =\n    'shouldAnswersSumToOne' in contract ? contract.shouldAnswersSumToOne : false\n  const arbitrageProps = shouldAnswersSumToOne ? multiProps : undefined\n  const isBinaryMC = isBinaryMulti(contract)\n  const outcome =\n    (isBinaryMC && arbitrageProps\n      ? arbitrageProps.answerText === arbitrageProps.answerToBuy.text\n        ? 'YES'\n        : 'NO'\n      : undefined) ?? binaryOutcome\n\n  const isCpmmMulti = contract.mechanism === 'cpmm-multi-1'\n  const cpmmState = isCpmmMulti\n    ? {\n        pool: {\n          YES: multiProps!.answerToBuy.poolYes,\n          NO: multiProps!.answerToBuy.poolNo,\n        },\n        p: 0.5,\n        collectedFees: contract.collectedFees,\n      }\n    : {\n        pool: contract.pool,\n        p: contract.p,\n        collectedFees: contract.collectedFees,\n      }\n  const prob = getCpmmProbability(cpmmState.pool, cpmmState.p)\n  const slippage = slippageProtection ? DEFAULT_SLIPPAGE : 1\n  const floatLimitProb = Math.max(\n    MIN_CPMM_PROB,\n    Math.min(\n      MAX_CPMM_PROB,\n      outcome === 'YES' ? prob + slippage : prob - slippage\n    )\n  )\n\n  const limitProb = Math.round((manualLimitProb ?? floatLimitProb) * 100) / 100\n\n  const orderAmount = betAmount\n  let amount = 0\n  let shares = 0\n  let fees = noFees\n  let betDeps: LimitBet[] = []\n  let probAfter = 0\n  try {\n    if (arbitrageProps) {\n      const { answers, answerToBuy } = arbitrageProps\n      const { newBetResult, otherBetResults } = calculateCpmmMultiArbitrageBet(\n        answers,\n        answerToBuy,\n        outcome,\n        betAmount,\n        limitProb,\n        unfilledBets,\n        balanceByUserId,\n        cpmmState.collectedFees\n      )\n      amount = sumBy(newBetResult.takers, 'amount')\n      shares = sumBy(newBetResult.takers, 'shares')\n      betDeps = newBetResult.makers\n        .map((m) => m.bet)\n        .concat(otherBetResults.flatMap((r) => r.makers.map((m) => m.bet)))\n        .concat(newBetResult.ordersToCancel)\n        .concat(otherBetResults.flatMap((r) => r.ordersToCancel))\n      fees = addObjects(\n        newBetResult.totalFees,\n        otherBetResults.reduce(\n          (feeSum, results) => addObjects(feeSum, results.totalFees),\n          noFees\n        )\n      )\n      probAfter = getCpmmProbability(\n        newBetResult.cpmmState.pool,\n        newBetResult.cpmmState.p\n      )\n    } else {\n      const result = computeCpmmBet(\n        cpmmState,\n        outcome,\n        betAmount,\n        limitProb,\n        unfilledBets,\n        balanceByUserId,\n        !arbitrageProps && { max: MAX_CPMM_PROB, min: MIN_CPMM_PROB }\n      )\n      amount = result.amount\n      shares = result.shares\n      fees = result.fees\n      betDeps = result.makers.map((m) => m.bet).concat(result.ordersToCancel)\n      probAfter = result.probAfter\n    }\n  } catch (err: any) {\n    console.error('Error in getLimitBetReturns:', err)\n    setError(\n      err?.message ??\n        `An error occurred during ${TRADE_TERM} calculation, try again.`\n    )\n  }\n  const remainingMatched = limitProb\n    ? ((orderAmount ?? 0) - amount) /\n      (outcome === 'YES' ? limitProb : 1 - limitProb)\n    : 0\n  const currentPayout = shares + remainingMatched\n  const currentReturn = betAmount ? (currentPayout - betAmount) / betAmount : 0\n\n  return {\n    orderAmount,\n    amount,\n    shares,\n    currentPayout,\n    currentReturn,\n    fees,\n    betDeps,\n    probAfter,\n    limitProb,\n    prob,\n  }\n}\nexport type MultiBetProps = {\n  answers: Answer[]\n  answerToBuy: Answer\n  answerText?: string\n}\n",
          "postContent": "import { getCpmmProbability } from 'common/calculate-cpmm'\nimport { LimitBet } from 'common/bet'\nimport { Answer } from 'common/answer'\nimport { noFees } from 'common/fees'\nimport { calculateCpmmMultiArbitrageBet } from 'common/calculate-cpmm-arbitrage'\nimport { sumBy } from 'lodash'\nimport { addObjects } from 'common/util/object'\nimport { computeCpmmBet } from 'common/new-bet'\nimport { MAX_CPMM_PROB, MIN_CPMM_PROB } from 'common/contract'\nimport { TRADE_TERM } from 'common/envs/constants'\nimport { MarketContract } from 'common/contract'\nimport { isBinaryMulti } from 'common/contract'\nconst DEFAULT_SLIPPAGE = 0.1\n\nexport const getLimitBetReturns = (\n  binaryOutcome: 'YES' | 'NO',\n  betAmount: number,\n  unfilledBets: LimitBet[],\n  balanceByUserId: { [userId: string]: number },\n  contract: MarketContract,\n  multiProps: MultiBetProps | undefined,\n  manualLimitProb: number | undefined,\n  slippageProtection: boolean\n) => {\n  const shouldAnswersSumToOne =\n    'shouldAnswersSumToOne' in contract ? contract.shouldAnswersSumToOne : false\n  const arbitrageProps = shouldAnswersSumToOne ? multiProps : undefined\n  const isBinaryMC = isBinaryMulti(contract)\n  const outcome =\n    (isBinaryMC && arbitrageProps\n      ? arbitrageProps.answerText === arbitrageProps.answerToBuy.text\n        ? 'YES'\n        : 'NO'\n      : undefined) ?? binaryOutcome\n\n  const isCpmmMulti = contract.mechanism === 'cpmm-multi-1'\n  const cpmmState = isCpmmMulti\n    ? {\n        pool: {\n          YES: multiProps!.answerToBuy.poolYes,\n          NO: multiProps!.answerToBuy.poolNo,\n        },\n        p: 0.5,\n        collectedFees: contract.collectedFees,\n      }\n    : {\n        pool: contract.pool,\n        p: contract.p,\n        collectedFees: contract.collectedFees,\n      }\n  const prob = getCpmmProbability(cpmmState.pool, cpmmState.p)\n  const slippage = slippageProtection ? DEFAULT_SLIPPAGE : 1\n  const floatLimitProb = Math.max(\n    MIN_CPMM_PROB,\n    Math.min(\n      MAX_CPMM_PROB,\n      outcome === 'YES' ? prob + slippage : prob - slippage\n    )\n  )\n\n  const limitProb = Math.round((manualLimitProb ?? floatLimitProb) * 100) / 100\n\n  const orderAmount = betAmount\n  let amount = 0\n  let shares = 0\n  let fees = noFees\n  let betDeps: LimitBet[] = []\n  let probAfter = 0\n  let calculationError: string | undefined = undefined\n  try {\n    if (arbitrageProps) {\n      const { answers, answerToBuy } = arbitrageProps\n      const { newBetResult, otherBetResults } = calculateCpmmMultiArbitrageBet(\n        answers,\n        answerToBuy,\n        outcome,\n        betAmount,\n        limitProb,\n        unfilledBets,\n        balanceByUserId,\n        cpmmState.collectedFees\n      )\n      amount = sumBy(newBetResult.takers, 'amount')\n      shares = sumBy(newBetResult.takers, 'shares')\n      betDeps = newBetResult.makers\n        .map((m) => m.bet)\n        .concat(otherBetResults.flatMap((r) => r.makers.map((m) => m.bet)))\n        .concat(newBetResult.ordersToCancel)\n        .concat(otherBetResults.flatMap((r) => r.ordersToCancel))\n      fees = addObjects(\n        newBetResult.totalFees,\n        otherBetResults.reduce(\n          (feeSum, results) => addObjects(feeSum, results.totalFees),\n          noFees\n        )\n      )\n      probAfter = getCpmmProbability(\n        newBetResult.cpmmState.pool,\n        newBetResult.cpmmState.p\n      )\n    } else {\n      const result = computeCpmmBet(\n        cpmmState,\n        outcome,\n        betAmount,\n        limitProb,\n        unfilledBets,\n        balanceByUserId,\n        !arbitrageProps && { max: MAX_CPMM_PROB, min: MIN_CPMM_PROB }\n      )\n      amount = result.amount\n      shares = result.shares\n      fees = result.fees\n      betDeps = result.makers.map((m) => m.bet).concat(result.ordersToCancel)\n      probAfter = result.probAfter\n    }\n  } catch (err: any) {\n    console.error('Error in getLimitBetReturns:', err)\n    calculationError =\n      err?.message ??\n      `An error occurred during ${TRADE_TERM} calculation, try again.`\n  }\n  const remainingMatched = limitProb\n    ? ((orderAmount ?? 0) - amount) /\n      (outcome === 'YES' ? limitProb : 1 - limitProb)\n    : 0\n  const currentPayout = shares + remainingMatched\n  const currentReturn = betAmount ? (currentPayout - betAmount) / betAmount : 0\n\n  return {\n    orderAmount,\n    amount,\n    shares,\n    currentPayout,\n    currentReturn,\n    fees,\n    betDeps,\n    probAfter,\n    limitProb,\n    prob,\n    calculationError,\n  }\n}\nexport type MultiBetProps = {\n  answers: Answer[]\n  answerToBuy: Answer\n  answerText?: string\n}\n"
        },
        {
          "path": "web/components/bet/bet-panel.tsx",
          "preContent": "import {\n  ChevronDownIcon,\n  LockClosedIcon,\n  LockOpenIcon,\n  XIcon,\n} from '@heroicons/react/outline'\nimport clsx from 'clsx'\nimport { capitalize, uniq } from 'lodash'\nimport { useEffect, useState } from 'react'\nimport toast from 'react-hot-toast'\n\nimport {\n  isBinaryMulti,\n  MarketContract,\n  MAX_CPMM_PROB,\n  MAX_STONK_PROB,\n  MIN_CPMM_PROB,\n  MIN_STONK_PROB,\n  MultiContract,\n} from 'common/contract'\nimport {\n  formatLargeNumber,\n  formatMoney,\n  formatOutcomeLabel,\n  formatPercent,\n  formatWithToken,\n} from 'common/util/format'\nimport { api, APIError } from 'web/lib/api/api'\nimport { firebaseLogin } from 'web/lib/firebase/users'\nimport { Col } from '../layout/col'\nimport { Row } from '../layout/row'\nimport { AmountInput, BuyAmountInput } from '../widgets/amount-input'\nimport { LimitBet } from 'common/bet'\nimport { TRADE_TERM } from 'common/envs/constants'\nimport {\n  getVerificationStatus,\n  PROMPT_USER_VERIFICATION_MESSAGES,\n} from 'common/gidx/user'\nimport { getFormattedMappedValue } from 'common/pseudo-numeric'\nimport { getStonkDisplayShares, STONK_NO, STONK_YES } from 'common/stonk'\nimport {\n  getTierIndexFromLiquidity,\n  getTierIndexFromLiquidityAndAnswers,\n} from 'common/tier'\nimport { floatingEqual } from 'common/util/math'\nimport { removeUndefinedProps } from 'common/util/object'\nimport { InfoTooltip } from 'web/components/widgets/info-tooltip'\nimport { useFocus } from 'web/hooks/use-focus'\nimport { useIsAdvancedTrader } from 'web/hooks/use-is-advanced-trader'\nimport { usePrivateUser, useUser } from 'web/hooks/use-user'\nimport { track, withTracking } from 'web/lib/service/analytics'\nimport { isAndroid, isIOS } from 'web/lib/util/device'\nimport { WarningConfirmationButton } from '../buttons/warning-confirmation-button'\nimport { getAnswerColor } from '../charts/contract/choice'\nimport { LocationMonitor } from '../gidx/location-monitor'\nimport { ChoicesToggleGroup } from '../widgets/choices-toggle-group'\nimport LimitOrderPanel from './limit-order-panel'\nimport { MoneyDisplay } from './money-display'\nimport { OrderBookPanel, YourOrders } from './order-book'\nimport { YesNoSelector } from './yes-no-selector'\nimport { sliderColors } from '../widgets/slider'\nimport {\n  useContractBets,\n  useUnfilledBetsAndBalanceByUserId,\n} from 'client-common/hooks/use-bets'\nimport { useIsPageVisible } from 'web/hooks/use-page-visible'\nimport { CandidateBet } from 'common/new-bet'\nimport { APIParams } from 'common/api/schema'\nimport { Button } from '../buttons/button'\nimport { usePersistentLocalState } from 'web/hooks/use-persistent-local-state'\nimport { getLimitBetReturns, MultiBetProps } from 'client-common/lib/bet'\nimport { Tooltip } from '../widgets/tooltip'\nimport { useIsMobile } from 'web/hooks/use-is-mobile'\nimport { ShareBetModal } from './share-bet'\nimport { Bet } from 'common/bet'\nimport { LuShare } from 'react-icons/lu'\nimport { useEvent } from 'client-common/hooks/use-event'\nimport { calculateCpmmAmountToBuyShares } from 'common/calculate-cpmm'\n\nconst WAIT_TO_DISMISS = 3000\nexport type BinaryOutcomes = 'YES' | 'NO' | undefined\ntype BuyPanelProps = {\n  contract: MarketContract\n  multiProps?: MultiBetProps\n  onBuySuccess?: () => void\n  initialOutcome?: BinaryOutcomes\n  location?: string\n  replyToCommentId?: string\n  feedReason?: string\n  pseudonym?: {\n    YES: {\n      pseudonymName: string\n      pseudonymColor: keyof typeof sliderColors\n    }\n    NO: {\n      pseudonymName: string\n      pseudonymColor: keyof typeof sliderColors\n    }\n  }\n  children?: React.ReactNode\n  alwaysShowOutcomeSwitcher?: boolean\n  className?: string\n}\n\nexport function BuyPanel(\n  props: BuyPanelProps & {\n    inModal: boolean\n  }\n) {\n  const {\n    contract,\n    initialOutcome,\n    location = 'bet panel',\n    inModal,\n    alwaysShowOutcomeSwitcher,\n    children,\n    pseudonym,\n    className,\n  } = props\n\n  const isPseudoNumeric = contract.outcomeType === 'PSEUDO_NUMERIC'\n  const isStonk = contract.outcomeType === 'STONK'\n\n  const [outcome, setOutcome] = useState<BinaryOutcomes>(initialOutcome)\n\n  const [isPanelBodyVisible, setIsPanelBodyVisible] = useState(false)\n\n  useEffect(() => {\n    if (initialOutcome) {\n      setOutcome(initialOutcome)\n      setIsPanelBodyVisible(true)\n    }\n  }, [initialOutcome])\n\n  function onOutcomeChoice(choice: 'YES' | 'NO') {\n    if (outcome === choice && !initialOutcome) {\n      setOutcome(undefined)\n      setIsPanelBodyVisible(false)\n    } else {\n      track('bet intent', {\n        location,\n        option: outcome,\n        token: contract.token,\n        boosted: contract.boosted,\n      })\n\n      setOutcome(choice)\n      setIsPanelBodyVisible(true)\n    }\n  }\n  return (\n    <Col>\n      {!isPanelBodyVisible && (\n        <Col>\n          <Row className={clsx('mb-2 w-full items-center gap-2')}>\n            <YesNoSelector\n              className=\"flex-1\"\n              btnClassName=\"flex-1 px-2 sm:px-6\"\n              selected={outcome}\n              highlight\n              onSelect={(choice) => {\n                onOutcomeChoice(choice)\n              }}\n              yesLabel={\n                isPseudoNumeric ? 'HIGHER' : isStonk ? STONK_YES : 'YES'\n              }\n              noLabel={isPseudoNumeric ? 'LOWER' : isStonk ? STONK_NO : 'NO'}\n              includeWordBet={!isStonk}\n            />\n          </Row>\n        </Col>\n      )}\n      {isPanelBodyVisible && (\n        <BuyPanelBody\n          {...props}\n          className={clsx('-mx-2 sm:mx-0', className)}\n          outcome={outcome}\n          setOutcome={setOutcome}\n          onClose={\n            inModal || alwaysShowOutcomeSwitcher\n              ? undefined\n              : () => {\n                  setIsPanelBodyVisible(false)\n                  if (initialOutcome == undefined) {\n                    setOutcome(undefined)\n                  }\n                }\n          }\n          pseudonym={pseudonym}\n        >\n          {children}\n        </BuyPanelBody>\n      )}\n    </Col>\n  )\n}\n\nexport const BuyPanelBody = (\n  props: BuyPanelProps & {\n    outcome?: BinaryOutcomes\n    setOutcome: (outcome: 'YES' | 'NO') => void\n    onClose?: () => void\n  }\n) => {\n  const {\n    contract,\n    multiProps,\n    outcome,\n    setOutcome,\n    alwaysShowOutcomeSwitcher,\n    onBuySuccess,\n    location = 'bet panel',\n    onClose,\n    replyToCommentId,\n    feedReason,\n    className,\n    children,\n  } = props\n\n  const user = useUser()\n  const privateUser = usePrivateUser()\n  const liquidityTier =\n    'answers' in contract\n      ? getTierIndexFromLiquidityAndAnswers(\n          contract.totalLiquidity,\n          contract.answers.length\n        )\n      : getTierIndexFromLiquidity(contract.totalLiquidity)\n\n  const { unfilledBets: allUnfilledBets, balanceByUserId } =\n    useUnfilledBetsAndBalanceByUserId(\n      contract.id,\n      (params) => api('bets', params),\n      (params) => api('users/by-id/balance', params),\n      useIsPageVisible\n    )\n\n  const unfilledBetsMatchingAnswer = allUnfilledBets.filter(\n    (b) => b.answerId === multiProps?.answerToBuy?.id\n  )\n\n  const isBinaryMC = isBinaryMulti(contract)\n  const binaryMCColors = isBinaryMC\n    ? (contract as MultiContract).answers.map(getAnswerColor)\n    : undefined\n\n  const binaryMCOutcomeLabel =\n    isBinaryMC && multiProps\n      ? multiProps.answerText ?? multiProps.answerToBuy.text\n      : undefined\n  const isCashContract = contract.token === 'CASH'\n\n  const quickAddButtonSize =\n    liquidityTier === 0 ||\n    (contract.mechanism === 'cpmm-multi-1' &&\n      liquidityTier === 1 &&\n      !contract.shouldAnswersSumToOne)\n      ? 'small'\n      : undefined\n\n  const initialBetAmount = isCashContract\n    ? 1\n    : quickAddButtonSize === 'small'\n    ? 10\n    : 50\n\n  const [betAmount, setBetAmount] = useState<number | undefined>(\n    initialBetAmount\n  )\n\n  const [error, setError] = useState<string | undefined>()\n  const [isSubmitting, setIsSubmitting] = useState(false)\n  const [submittedBet, setSubmittedBet] = useState<\n    | (LimitBet & {\n        expired: boolean\n        toastId: string\n      })\n    | null\n  >(null)\n\n  const [manaSlippageProtection, setManaSlippageProtection] =\n    usePersistentLocalState(false, 'mana-slippage-protection')\n  const [cashSlippageProtection, setCashSlippageProtection] =\n    usePersistentLocalState(true, 'cash-slippage-protection')\n  const slippageProtection = isCashContract\n    ? cashSlippageProtection\n    : manaSlippageProtection\n  const [inputRef, focusAmountInput] = useFocus()\n\n  // State for share row\n  const [isSharing, setIsSharing] = useState(false)\n  const [lastBetDetails, setLastBetDetails] = useState<Bet | null>(null)\n\n  // State for editing payout\n  const [isEditingPayout, setIsEditingPayout] = useState(false)\n  const [editablePayout, setEditablePayout] = useState<number | undefined>(\n    undefined\n  )\n\n  const isCpmmMulti = contract.mechanism === 'cpmm-multi-1'\n  if (isCpmmMulti && !multiProps) {\n    throw new Error('multiProps must be defined for cpmm-multi-1')\n  }\n\n  const shouldAnswersSumToOne =\n    'shouldAnswersSumToOne' in contract ? contract.shouldAnswersSumToOne : false\n\n  const unfilledBets =\n    isCpmmMulti && !shouldAnswersSumToOne\n      ? unfilledBetsMatchingAnswer\n      : allUnfilledBets\n\n  const isPseudoNumeric = contract.outcomeType === 'PSEUDO_NUMERIC'\n  const isStonk = contract.outcomeType === 'STONK'\n\n  const limitBets = useContractBets(\n    contract.id,\n    removeUndefinedProps({\n      userId: user?.id,\n      enabled: !!user?.id,\n      afterTime: contract?.lastBetTime ?? user?.lastBetTime,\n    }),\n    useIsPageVisible,\n    (params) => api('bets', params)\n  )\n  const updatedBet = limitBets.find((b) => b.id === submittedBet?.id)\n  useEffect(() => {\n    if (!submittedBet) return\n    if (\n      updatedBet?.isFilled ||\n      updatedBet?.isCancelled ||\n      submittedBet.expired ||\n      (updatedBet?.expiresAt && Date.now() > updatedBet.expiresAt)\n    ) {\n      const amountFilled = updatedBet?.amount ?? submittedBet.amount\n      const sharesFilled = updatedBet?.shares ?? submittedBet.shares\n      const orderAmount = updatedBet?.orderAmount ?? submittedBet.orderAmount\n      toast.success(\n        `${formatMoney(amountFilled)}/${formatMoney(\n          orderAmount\n        )} filled for ${formatMoney(sharesFilled)} payout`,\n        {\n          duration: 5000,\n          id: submittedBet.toastId,\n        }\n      )\n      setSubmittedBet(null)\n      setIsSubmitting(false)\n      const finalBetDetails = updatedBet ?? submittedBet\n      if (finalBetDetails) {\n        setLastBetDetails(finalBetDetails)\n        setIsSharing(false)\n        setTimeout(() => {\n          callOnBuySuccess()\n        }, WAIT_TO_DISMISS)\n      } else {\n        setLastBetDetails(null)\n        callOnBuySuccess()\n      }\n    }\n  }, [updatedBet, submittedBet])\n\n  const [justSetAdvancedTrader, setJustSetAdvancedTrader] = useState<boolean>(\n    user?.isAdvancedTrader ?? false\n  )\n  const isAdvancedTrader = useIsAdvancedTrader() || justSetAdvancedTrader\n\n  const [betTypeSetting, setBetTypeSetting] = useState<'Market' | 'Limit'>(\n    'Market'\n  )\n\n  useEffect(() => {\n    if (!isAdvancedTrader && betTypeSetting === 'Limit') {\n      setBetTypeSetting('Market')\n    }\n  }, [isAdvancedTrader])\n\n  useEffect(() => {\n    if (!isIOS() && !isAndroid()) {\n      focusAmountInput()\n    }\n  }, [])\n\n  function onBetChange(newAmount: number | undefined) {\n    setBetAmount(newAmount)\n  }\n\n  const callOnBuySuccess = useEvent(() => {\n    if (onBuySuccess && !isSharing) {\n      onBuySuccess()\n    }\n  })\n\n  const {\n    currentPayout,\n    probAfter: newProbAfter,\n    currentReturn,\n    betDeps,\n    limitProb,\n    prob,\n  } = getLimitBetReturns(\n    outcome ?? 'YES',\n    betAmount ?? 0,\n    unfilledBets,\n    balanceByUserId,\n    setError,\n    contract,\n    multiProps,\n    undefined,\n    slippageProtection\n  )\n  let probBefore = prob\n  let probAfter = newProbAfter\n  if (\n    multiProps &&\n    multiProps.answerToBuy.text !== multiProps.answerText &&\n    isBinaryMC\n  ) {\n    probBefore = 1 - prob\n    probAfter = 1 - newProbAfter\n  }\n\n  async function submitBet() {\n    if (!user || !betAmount) return\n    console.log('betDeps', betDeps)\n    setError(undefined)\n    setIsSubmitting(true)\n    const toastId = slippageProtection\n      ? toast.loading(`Placing ${TRADE_TERM.toLowerCase()}...`, {\n          duration: 10000,\n        })\n      : undefined\n\n    try {\n      const expiresMillisAfter = 1000\n      const bet = await api(\n        'bet',\n        removeUndefinedProps({\n          outcome,\n          amount: betAmount,\n          contractId: contract.id,\n          answerId: multiProps?.answerToBuy.id,\n          replyToCommentId,\n          deps: uniq(betDeps.map((b) => b.userId)),\n          expiresMillisAfter: slippageProtection\n            ? expiresMillisAfter\n            : undefined,\n          silent: slippageProtection,\n          limitProb: slippageProtection ? limitProb : undefined,\n        } as APIParams<'bet'>)\n      )\n      if (bet.isFilled) {\n        if (slippageProtection) {\n          toast.success(\n            `${formatMoney(bet.amount)}/${formatMoney(\n              bet.orderAmount ?? 0\n            )} filled for ${formatMoney(bet.shares)} payout`,\n            {\n              duration: 5000,\n              id: toastId,\n            }\n          )\n        }\n        setSubmittedBet(null)\n        setIsSubmitting(false)\n\n        const fullBet: Bet = {\n          ...(bet as CandidateBet<LimitBet>),\n          id: bet.betId,\n          userId: user.id,\n        }\n        setLastBetDetails(fullBet)\n        setIsSharing(false)\n        // TODO: we could remove the timeout and just not dismiss the modal\n        setTimeout(() => {\n          callOnBuySuccess()\n        }, WAIT_TO_DISMISS)\n        track(\n          'bet',\n          removeUndefinedProps({\n            location,\n            outcomeType: contract.outcomeType,\n            token: contract.token,\n            slug: contract.slug,\n            contractId: contract.id,\n            amount: betAmount,\n            betGroupId: bet.betGroupId,\n            betId: bet.betId,\n            outcome,\n            isLimitOrder: false,\n            answerId: multiProps?.answerToBuy.id,\n            feedReason,\n            boosted: contract.boosted,\n          })\n        )\n      } else {\n        if (!toastId) {\n          console.error('No toastId')\n          return\n        }\n        toast.loading(`Filling ${TRADE_TERM.toLowerCase()}...`, {\n          duration: expiresMillisAfter + 100,\n          id: toastId,\n        })\n        setSubmittedBet({\n          ...(bet as CandidateBet<LimitBet>),\n          userId: user.id,\n          id: bet.betId,\n          expired: false,\n          toastId,\n        })\n        setTimeout(() => {\n          setSubmittedBet((prev) => (prev ? { ...prev, expired: true } : null))\n        }, expiresMillisAfter + 100)\n      }\n      setBetAmount(undefined)\n    } catch (e) {\n      if (e instanceof APIError) {\n        const message = e.message.toString()\n        if (message.includes('could not serialize access')) {\n          setError(`Error placing ${TRADE_TERM} (could not serialize access)`)\n          console.error(`Error placing ${TRADE_TERM}`, e)\n        } else setError(message)\n        toast.error(`Error submitting ${TRADE_TERM}`, { id: toastId })\n      } else {\n        console.error(e)\n        setError(`Error placing ${TRADE_TERM}`)\n        toast.error(`Error submitting ${TRADE_TERM}`, { id: toastId })\n      }\n      setIsSubmitting(false)\n      setLastBetDetails(null)\n    }\n  }\n  const [showLocationMonitor, setShowLocationMonitor] = useState(false)\n\n  const { status: verificationStatus, message: verificationMessage } =\n    getVerificationStatus(user, privateUser)\n\n  const betDisabled =\n    isSubmitting ||\n    !betAmount ||\n    outcome === undefined ||\n    error === 'Insufficient balance' ||\n    showLocationMonitor ||\n    (isCashContract && verificationStatus !== 'success')\n\n  const limits =\n    contract.outcomeType === 'STONK'\n      ? { max: MAX_STONK_PROB, min: MIN_STONK_PROB }\n      : { max: MAX_CPMM_PROB, min: MIN_CPMM_PROB }\n  const maxProb = limits.max\n  const minProb = limits.min\n  const probStayedSame = formatPercent(probAfter) === formatPercent(probBefore)\n  const probChange = Math.abs(probAfter - probBefore)\n  const currentReturnPercent = formatPercent(currentReturn)\n\n  const displayedAfter = isPseudoNumeric\n    ? formatLargeNumber(probAfter)\n    : formatPercent(probAfter)\n\n  const balance = isCashContract ? user?.cashBalance ?? 0 : user?.balance ?? 0\n\n  const bankrollFraction = (betAmount ?? 0) / (balance ?? 1e9)\n\n  // warnings\n  const highBankrollSpend =\n    (betAmount ?? 0) >= 100 && bankrollFraction >= 0.5 && bankrollFraction <= 1\n  const highProbMove =\n    (betAmount ?? 0) > 10 && probChange > 0.299 && bankrollFraction <= 1\n\n  const warning = highBankrollSpend\n    ? `You might not want to spend ${formatPercent(\n        bankrollFraction\n      )} of your balance on a single trade. \\n\\nCurrent balance: ${formatWithToken(\n        {\n          amount: balance,\n          token: isCashContract ? 'CASH' : 'M$',\n        }\n      )}`\n    : highProbMove\n    ? `Are you sure you want to move the market to ${displayedAfter}?`\n    : undefined\n\n  const choicesMap: { [key: string]: string } = isStonk\n    ? { Buy: 'YES', Short: 'NO' }\n    : { Yes: 'YES', No: 'NO' }\n\n  const { pseudonymName, pseudonymColor } =\n    props.pseudonym?.[outcome as 'YES' | 'NO'] ?? {}\n\n  const shouldPromptVerification =\n    isCashContract &&\n    PROMPT_USER_VERIFICATION_MESSAGES.includes(verificationMessage)\n\n  const betType = isStonk ? 'Market' : betTypeSetting\n  const isMobile = useIsMobile()\n\n  const handlePayoutEdited = useEvent(() => {\n    if (\n      !outcome ||\n      !editablePayout ||\n      isNaN(editablePayout) ||\n      editablePayout <= 0\n    ) {\n      setIsEditingPayout(false)\n      return\n    }\n\n    try {\n      const amount = calculateCpmmAmountToBuyShares(\n        contract,\n        editablePayout,\n        outcome,\n        allUnfilledBets,\n        balanceByUserId,\n        multiProps?.answerToBuy\n      )\n\n      if (amount && isFinite(amount) && amount > 0) {\n        setBetAmount(amount)\n        setError(undefined) // Clear potential previous errors\n      } else {\n        toast.error('Could not calculate bet for that payout amount')\n      }\n    } catch (err) {\n      console.error('Error calculating bet amount from shares:', err)\n      toast.error('Error calculating bet amount')\n    } finally {\n      setIsEditingPayout(false)\n    }\n  })\n\n  return (\n    <>\n      <Col className={clsx(className, 'relative rounded-xl px-4 py-2')}>\n        {children}\n        {(isAdvancedTrader || alwaysShowOutcomeSwitcher) && (\n          <Row className={'mb-2 mt-2 justify-between'}>\n            <Row\n              className={clsx(\n                ' gap-1',\n                (isBinaryMC || pseudonymName) && 'invisible'\n              )}\n            >\n              <ChoicesToggleGroup\n                currentChoice={outcome}\n                color={outcome === 'YES' ? 'light-green' : 'light-red'}\n                choicesMap={choicesMap}\n                setChoice={(outcome) => {\n                  setOutcome(outcome as 'YES' | 'NO')\n                }}\n              />\n            </Row>\n            <Row className=\"items-center justify-end gap-2\">\n              {isAdvancedTrader && !isStonk && (\n                <ChoicesToggleGroup\n                  currentChoice={betType}\n                  color=\"gray\"\n                  choicesMap={{\n                    Quick: 'Market',\n                    Limit: 'Limit',\n                  }}\n                  setChoice={(val) => {\n                    setBetTypeSetting(val as 'Market' | 'Limit')\n                  }}\n                />\n              )}\n              {onClose && (\n                <Button\n                  color=\"gray-white\"\n                  size=\"sm\"\n                  onClick={onClose}\n                  className=\"-mr-2\"\n                >\n                  <XIcon className=\"h-5 w-5\" />\n                </Button>\n              )}\n            </Row>\n          </Row>\n        )}\n        {betType === 'Market' ? (\n          <>\n            <Row\n              className={clsx('text-ink-600 mb-2 items-center justify-between')}\n            >\n              <div className=\"space-x-3\">{capitalize(TRADE_TERM)} amount</div>\n              {!isAdvancedTrader && onClose && (\n                <Button\n                  color=\"gray-white\"\n                  size=\"sm\"\n                  onClick={onClose}\n                  className=\"-mr-2\"\n                >\n                  <XIcon className=\"h-5 w-5\" />\n                </Button>\n              )}\n            </Row>\n\n            <Row\n              className={clsx(\n                'mb-2 flex-wrap gap-x-8 gap-y-4',\n                isAdvancedTrader ? 'items-center' : 'items-end'\n              )}\n            >\n              <BuyAmountInput\n                parentClassName=\"max-w-full\"\n                amount={betAmount}\n                onChange={onBetChange}\n                error={error}\n                setError={setError}\n                disabled={isSubmitting}\n                inputRef={inputRef}\n                showSlider={true}\n                token={isCashContract ? 'CASH' : 'M$'}\n                sliderColor={pseudonymColor}\n                disregardUserBalance={shouldPromptVerification}\n                quickButtonAmountSize={quickAddButtonSize}\n              />\n\n              {isAdvancedTrader && (\n                <Col className=\"w-full gap-1\">\n                  <Row className=\"w-full items-baseline justify-between sm:justify-start\">\n                    <span className=\"text-ink-600 mr-2 min-w-[120px] whitespace-nowrap\">\n                      {isPseudoNumeric\n                        ? 'Estimated value'\n                        : isStonk\n                        ? 'New stock price'\n                        : 'New probability'}\n                    </span>\n                    <Row className=\"items-baseline gap-1\">\n                      <span className=\"text-lg font-semibold\">\n                        {getFormattedMappedValue(\n                          contract,\n                          probStayedSame ? probBefore : probAfter\n                        )}\n                      </span>\n                      {!probStayedSame && !isPseudoNumeric && (\n                        <>\n                          <span className={clsx('ml-1', 'text-ink-600')}>\n                            {outcome !== 'NO' || isBinaryMC ? '↑' : '↓'}\n                            {getFormattedMappedValue(\n                              contract,\n                              Math.abs(probAfter - probBefore)\n                            )}\n                            {floatingEqual(probAfter, maxProb)\n                              ? ' (max)'\n                              : floatingEqual(probAfter, minProb)\n                              ? ' (max)'\n                              : ''}\n                          </span>\n\n                          <button\n                            onClick={() => {\n                              toast.success(\n                                `Slippage protection on ${\n                                  isCashContract ? 'cash' : 'mana'\n                                } questions ${\n                                  !slippageProtection ? 'enabled' : 'disabled'\n                                }!`\n                              )\n                              if (isCashContract) {\n                                setCashSlippageProtection(\n                                  !cashSlippageProtection\n                                )\n                              } else {\n                                setManaSlippageProtection(\n                                  !manaSlippageProtection\n                                )\n                              }\n                            }}\n                            className=\"self-center\"\n                          >\n                            <Tooltip\n                              autoHideDuration={isMobile ? 3000 : undefined}\n                              text={\n                                slippageProtection\n                                  ? `Your trades won't move the question probability more than 10 percentage points from displayed probability.`\n                                  : `Slippage protection on ${\n                                      isCashContract ? 'cash' : 'mana'\n                                    } questions is off.`\n                              }\n                            >\n                              {slippageProtection ? (\n                                <LockClosedIcon className=\"h-4 w-4 text-indigo-300 hover:text-indigo-400\" />\n                              ) : (\n                                <LockOpenIcon className=\"text-ink-500 hover:text-ink-600 h-4 w-4\" />\n                              )}\n                            </Tooltip>\n                          </button>\n                        </>\n                      )}\n                    </Row>\n                  </Row>\n                  <Row className=\"min-w-[128px] items-baseline justify-between sm:justify-start\">\n                    <div className=\"text-ink-600 mr-2 min-w-[120px] flex-nowrap whitespace-nowrap\">\n                      {isPseudoNumeric || isStonk ? 'Shares' : <>To win</>}\n                    </div>\n                    <Row className=\"items-baseline\">\n                      <span className=\"mr-1 whitespace-nowrap text-lg\">\n                        {isStonk ? (\n                          getStonkDisplayShares(contract, currentPayout, 2)\n                        ) : isPseudoNumeric ? (\n                          Math.floor(currentPayout)\n                        ) : (\n                          <>\n                            {isEditingPayout ? (\n                              <AmountInput\n                                inputClassName=\"w-32\"\n                                onBlur={handlePayoutEdited}\n                                onKeyDown={(e) => {\n                                  if (e.key === 'Enter') {\n                                    handlePayoutEdited()\n                                  } else if (e.key === 'Escape') {\n                                    setIsEditingPayout(false)\n                                  }\n                                }}\n                                autoFocus\n                                min={1}\n                                step={1}\n                                amount={editablePayout}\n                                onChangeAmount={setEditablePayout}\n                              />\n                            ) : (\n                              <span\n                                className={clsx(\n                                  'cursor-pointer hover:underline'\n                                )}\n                                onClick={() => {\n                                  setEditablePayout(Math.floor(currentPayout))\n                                  setIsEditingPayout(true)\n                                }}\n                              >\n                                {formatWithToken({\n                                  amount: currentPayout,\n                                  token: 'M$',\n                                })}\n                              </span>\n                            )}\n                          </>\n                        )}\n                      </span>\n                      <span className=\"text-green-500 \">\n                        {isStonk || isPseudoNumeric\n                          ? ''\n                          : ' +' + currentReturnPercent}\n                      </span>\n                    </Row>\n                  </Row>\n                </Col>\n              )}\n            </Row>\n          </>\n        ) : (\n          <>\n            <LimitOrderPanel\n              betAmount={betAmount}\n              contract={contract}\n              multiProps={multiProps}\n              user={user}\n              unfilledBets={unfilledBets}\n              balanceByUserId={balanceByUserId}\n              outcome={outcome}\n              pseudonym={props.pseudonym}\n            />\n          </>\n        )}\n\n        {betType !== 'Limit' && (\n          <Col className=\"gap-2\">\n            {user ? (\n              shouldPromptVerification ? (\n                <span className=\"text-error\">\n                  New sweepstakes signups disabled{' '}\n                </span>\n              ) : (\n                <>\n                  <LocationMonitor\n                    contract={contract}\n                    user={user}\n                    setShowPanel={setShowLocationMonitor}\n                    showPanel={showLocationMonitor}\n                  />\n                  {isCashContract && verificationStatus !== 'success' && (\n                    <div className=\"text-error\">{verificationMessage}</div>\n                  )}\n                  <WarningConfirmationButton\n                    marketType=\"binary\"\n                    amount={betAmount}\n                    warning={warning}\n                    userOptedOutOfWarning={user.optOutBetWarnings}\n                    onSubmit={submitBet}\n                    ButtonClassName={clsx('flex-grow')}\n                    actionLabelClassName={'line-clamp-1'}\n                    isSubmitting={isSubmitting}\n                    disabled={betDisabled}\n                    size=\"xl\"\n                    color={\n                      pseudonymColor ??\n                      binaryMCColors?.[outcome == 'YES' ? 0 : 1] ??\n                      (outcome === 'NO' ? 'red' : 'green')\n                    }\n                    actionLabel={\n                      betDisabled && !outcome ? (\n                        `Select ${formatOutcomeLabel(\n                          contract,\n                          'YES'\n                        )} or ${formatOutcomeLabel(contract, 'NO')}`\n                      ) : isStonk ? (\n                        <span>\n                          {formatOutcomeLabel(contract, outcome, pseudonymName)}{' '}\n                          <MoneyDisplay\n                            amount={betAmount ?? 0}\n                            isCashContract={isCashContract}\n                          />\n                        </span>\n                      ) : (\n                        <span>\n                          Buy{' '}\n                          {binaryMCOutcomeLabel ??\n                            formatOutcomeLabel(\n                              contract,\n                              outcome,\n                              pseudonymName\n                            )}{' '}\n                          to win{' '}\n                          <MoneyDisplay\n                            amount={currentPayout}\n                            isCashContract={isCashContract}\n                          />\n                        </span>\n                      )\n                    }\n                    inModal={!!onClose}\n                  />\n                </>\n              )\n            ) : (\n              <Button\n                color={outcome === 'NO' ? 'red' : 'green'}\n                size=\"xl\"\n                onClick={withTracking(firebaseLogin, 'login from bet panel', {\n                  token: contract.token,\n                })}\n                className=\"mb-2 flex-grow\"\n              >\n                Sign up to {TRADE_TERM}\n              </Button>\n            )}\n          </Col>\n        )}\n        {lastBetDetails && (\n          <Row className=\"bg-primary-100 mt-2 items-center justify-between rounded-lg p-3\">\n            <Row className=\"items-baseline gap-2\">\n              <span className=\"text-primary-700 text-sm \">\n                {isSubmitting ? 'Placing trade...' : 'Trade successful!'}\n              </span>\n            </Row>\n            <Button\n              className=\"w-1/2\"\n              color=\"gradient\"\n              onClick={() => setIsSharing(true)}\n            >\n              <Row className=\"items-center gap-1.5\">\n                <LuShare className=\"h-5 w-5\" aria-hidden />\n                Share Bet\n              </Row>\n            </Button>\n          </Row>\n        )}\n\n        {lastBetDetails && isSharing && user && (\n          <ShareBetModal\n            open={isSharing}\n            setOpen={setIsSharing}\n            questionText={contract.question}\n            outcome={formatOutcomeLabel(\n              contract,\n              lastBetDetails.outcome as 'YES' | 'NO'\n            )}\n            answer={multiProps?.answerToBuy.text}\n            avgPrice={formatPercent(\n              lastBetDetails.outcome === 'YES'\n                ? lastBetDetails.amount / lastBetDetails.shares\n                : 1 - lastBetDetails.amount / lastBetDetails.shares\n            )}\n            betAmount={lastBetDetails.amount}\n            winAmount={lastBetDetails.shares}\n            bettor={{\n              id: user.id,\n              name: user.name,\n              username: user.username,\n              avatarUrl: user.avatarUrl,\n            }}\n            isLimitBet={lastBetDetails.limitProb !== undefined}\n            orderAmount={lastBetDetails.orderAmount}\n          />\n        )}\n\n        {user && (\n          <Row className=\"mt-5 items-start justify-between text-sm\">\n            <Row className={''}>\n              <span\n                className={clsx(\n                  'text-ink-600 mr-1 whitespace-nowrap ',\n                  isAdvancedTrader ? '' : 'min-w-[110px]'\n                )}\n              >\n                Your mana balance\n              </span>\n              <span className=\"text-ink-600 font-semibold\">\n                <MoneyDisplay\n                  amount={balance}\n                  isCashContract={isCashContract}\n                />\n              </span>\n            </Row>\n          </Row>\n        )}\n\n        {!isAdvancedTrader && (\n          <Col>\n            <Row className=\"\">\n              <span className=\"text-ink-600 mr-1 min-w-[110px] whitespace-nowrap text-sm\">\n                {isPseudoNumeric\n                  ? 'Estimated value'\n                  : isStonk\n                  ? 'New stock price'\n                  : 'New probability'}\n              </span>\n\n              <span className=\"text-ink-600 text-sm font-semibold\">\n                {getFormattedMappedValue(\n                  contract,\n                  probStayedSame ? probBefore : probAfter\n                )}\n              </span>\n              {!probStayedSame && !isPseudoNumeric && (\n                <span className={clsx('ml-2 text-sm', 'text-ink-600')}>\n                  {outcome !== 'NO' || isBinaryMC ? '↑' : '↓'}\n                  {getFormattedMappedValue(\n                    contract,\n                    Math.abs(probAfter - probBefore)\n                  )}\n                  {floatingEqual(probAfter, maxProb)\n                    ? ' (max)'\n                    : floatingEqual(probAfter, minProb)\n                    ? ' (max)'\n                    : ''}{' '}\n                </span>\n              )}\n\n              {!isPseudoNumeric && !isStonk && !isBinaryMC && (\n                <InfoTooltip\n                  text={`Your ${TRADE_TERM} will move the probability of Yes from ${getFormattedMappedValue(\n                    contract,\n                    probBefore\n                  )} to ${getFormattedMappedValue(contract, probAfter)}.`}\n                  className=\"text-ink-600 ml-1 mt-0.5\"\n                  size=\"sm\"\n                />\n              )}\n\n              {isBinaryMC && (\n                <InfoTooltip\n                  text={`Your ${TRADE_TERM} will move the probability from ${getFormattedMappedValue(\n                    contract,\n                    probBefore\n                  )} to ${getFormattedMappedValue(contract, probAfter)}.`}\n                  className=\"text-ink-600 ml-1 mt-0.5\"\n                  size=\"sm\"\n                />\n              )}\n            </Row>\n          </Col>\n        )}\n\n        {user && (\n          <div className=\"absolute bottom-2 right-0\">\n            <button\n              className=\"text-ink-600 mr-2 flex items-center text-sm hover:underline\"\n              onClick={() => {\n                if (!isAdvancedTrader) {\n                  setBetTypeSetting('Market')\n                }\n                api('me/update', { isAdvancedTrader: !isAdvancedTrader })\n                setJustSetAdvancedTrader(!isAdvancedTrader)\n              }}\n            >\n              <span className=\"hover:underline\">\n                {isAdvancedTrader ? 'Basic' : 'Advanced'}\n              </span>\n              <ChevronDownIcon className=\"ml-1 h-3 w-3\" />\n            </button>\n          </div>\n        )}\n      </Col>\n\n      {contract.mechanism === 'cpmm-multi-1' && (\n        <YourOrders\n          className=\"mt-2 rounded-lg bg-indigo-200/10 py-4\"\n          contract={contract}\n          bets={unfilledBetsMatchingAnswer}\n        />\n      )}\n      {isAdvancedTrader && (\n        <OrderBookPanel\n          contract={contract}\n          limitBets={unfilledBets.filter(\n            (b) => b.answerId === multiProps?.answerToBuy?.id\n          )}\n          answer={multiProps?.answerToBuy}\n          pseudonym={props.pseudonym}\n        />\n      )}\n    </>\n  )\n}\n\nexport const QuickBetAmountsRow = (props: {\n  onAmountChange: (amount: number) => void\n  betAmount: number | undefined\n  className?: string\n}) => {\n  const { onAmountChange, betAmount, className } = props\n  const QUICK_BET_AMOUNTS = [10, 25, 100]\n  return (\n    <Row className={clsx('mb-2 items-center space-x-3', className)}>\n      <div className=\"text-ink-600\">Amount</div>\n      <ChoicesToggleGroup\n        currentChoice={\n          QUICK_BET_AMOUNTS.includes(betAmount ?? 0) ? betAmount : undefined\n        }\n        choicesMap={QUICK_BET_AMOUNTS.reduce<{\n          [key: number]: number\n        }>((map, amount) => {\n          map[amount] = amount\n          return map\n        }, {})}\n        setChoice={(amount) => {\n          if (typeof amount === 'number') {\n            onAmountChange(amount)\n          }\n        }}\n      />\n    </Row>\n  )\n}\n",
          "postContent": "import {\n  ChevronDownIcon,\n  LockClosedIcon,\n  LockOpenIcon,\n  XIcon,\n} from '@heroicons/react/outline'\nimport clsx from 'clsx'\nimport { capitalize, uniq } from 'lodash'\nimport { useEffect, useState } from 'react'\nimport toast from 'react-hot-toast'\n\nimport {\n  isBinaryMulti,\n  MarketContract,\n  MAX_CPMM_PROB,\n  MAX_STONK_PROB,\n  MIN_CPMM_PROB,\n  MIN_STONK_PROB,\n  MultiContract,\n} from 'common/contract'\nimport {\n  formatLargeNumber,\n  formatMoney,\n  formatOutcomeLabel,\n  formatPercent,\n  formatWithToken,\n} from 'common/util/format'\nimport { api, APIError } from 'web/lib/api/api'\nimport { firebaseLogin } from 'web/lib/firebase/users'\nimport { Col } from '../layout/col'\nimport { Row } from '../layout/row'\nimport { AmountInput, BuyAmountInput } from '../widgets/amount-input'\nimport { LimitBet } from 'common/bet'\nimport { TRADE_TERM } from 'common/envs/constants'\nimport {\n  getVerificationStatus,\n  PROMPT_USER_VERIFICATION_MESSAGES,\n} from 'common/gidx/user'\nimport { getFormattedMappedValue } from 'common/pseudo-numeric'\nimport { getStonkDisplayShares, STONK_NO, STONK_YES } from 'common/stonk'\nimport {\n  getTierIndexFromLiquidity,\n  getTierIndexFromLiquidityAndAnswers,\n} from 'common/tier'\nimport { floatingEqual } from 'common/util/math'\nimport { removeUndefinedProps } from 'common/util/object'\nimport { InfoTooltip } from 'web/components/widgets/info-tooltip'\nimport { useFocus } from 'web/hooks/use-focus'\nimport { useIsAdvancedTrader } from 'web/hooks/use-is-advanced-trader'\nimport { usePrivateUser, useUser } from 'web/hooks/use-user'\nimport { track, withTracking } from 'web/lib/service/analytics'\nimport { isAndroid, isIOS } from 'web/lib/util/device'\nimport { WarningConfirmationButton } from '../buttons/warning-confirmation-button'\nimport { getAnswerColor } from '../charts/contract/choice'\nimport { LocationMonitor } from '../gidx/location-monitor'\nimport { ChoicesToggleGroup } from '../widgets/choices-toggle-group'\nimport LimitOrderPanel from './limit-order-panel'\nimport { MoneyDisplay } from './money-display'\nimport { OrderBookPanel, YourOrders } from './order-book'\nimport { YesNoSelector } from './yes-no-selector'\nimport { sliderColors } from '../widgets/slider'\nimport {\n  useContractBets,\n  useUnfilledBetsAndBalanceByUserId,\n} from 'client-common/hooks/use-bets'\nimport { useIsPageVisible } from 'web/hooks/use-page-visible'\nimport { CandidateBet } from 'common/new-bet'\nimport { APIParams } from 'common/api/schema'\nimport { Button } from '../buttons/button'\nimport { usePersistentLocalState } from 'web/hooks/use-persistent-local-state'\nimport { getLimitBetReturns, MultiBetProps } from 'client-common/lib/bet'\nimport { Tooltip } from '../widgets/tooltip'\nimport { useIsMobile } from 'web/hooks/use-is-mobile'\nimport { ShareBetModal } from './share-bet'\nimport { Bet } from 'common/bet'\nimport { LuShare } from 'react-icons/lu'\nimport { useEvent } from 'client-common/hooks/use-event'\nimport { calculateCpmmAmountToBuyShares } from 'common/calculate-cpmm'\n\nconst WAIT_TO_DISMISS = 3000\nexport type BinaryOutcomes = 'YES' | 'NO' | undefined\ntype BuyPanelProps = {\n  contract: MarketContract\n  multiProps?: MultiBetProps\n  onBuySuccess?: () => void\n  initialOutcome?: BinaryOutcomes\n  location?: string\n  replyToCommentId?: string\n  feedReason?: string\n  pseudonym?: {\n    YES: {\n      pseudonymName: string\n      pseudonymColor: keyof typeof sliderColors\n    }\n    NO: {\n      pseudonymName: string\n      pseudonymColor: keyof typeof sliderColors\n    }\n  }\n  children?: React.ReactNode\n  alwaysShowOutcomeSwitcher?: boolean\n  className?: string\n}\n\nexport function BuyPanel(\n  props: BuyPanelProps & {\n    inModal: boolean\n  }\n) {\n  const {\n    contract,\n    initialOutcome,\n    location = 'bet panel',\n    inModal,\n    alwaysShowOutcomeSwitcher,\n    children,\n    pseudonym,\n    className,\n  } = props\n\n  const isPseudoNumeric = contract.outcomeType === 'PSEUDO_NUMERIC'\n  const isStonk = contract.outcomeType === 'STONK'\n\n  const [outcome, setOutcome] = useState<BinaryOutcomes>(initialOutcome)\n\n  const [isPanelBodyVisible, setIsPanelBodyVisible] = useState(false)\n\n  useEffect(() => {\n    if (initialOutcome) {\n      setOutcome(initialOutcome)\n      setIsPanelBodyVisible(true)\n    }\n  }, [initialOutcome])\n\n  function onOutcomeChoice(choice: 'YES' | 'NO') {\n    if (outcome === choice && !initialOutcome) {\n      setOutcome(undefined)\n      setIsPanelBodyVisible(false)\n    } else {\n      track('bet intent', {\n        location,\n        option: outcome,\n        token: contract.token,\n        boosted: contract.boosted,\n      })\n\n      setOutcome(choice)\n      setIsPanelBodyVisible(true)\n    }\n  }\n  return (\n    <Col>\n      {!isPanelBodyVisible && (\n        <Col>\n          <Row className={clsx('mb-2 w-full items-center gap-2')}>\n            <YesNoSelector\n              className=\"flex-1\"\n              btnClassName=\"flex-1 px-2 sm:px-6\"\n              selected={outcome}\n              highlight\n              onSelect={(choice) => {\n                onOutcomeChoice(choice)\n              }}\n              yesLabel={\n                isPseudoNumeric ? 'HIGHER' : isStonk ? STONK_YES : 'YES'\n              }\n              noLabel={isPseudoNumeric ? 'LOWER' : isStonk ? STONK_NO : 'NO'}\n              includeWordBet={!isStonk}\n            />\n          </Row>\n        </Col>\n      )}\n      {isPanelBodyVisible && (\n        <BuyPanelBody\n          {...props}\n          className={clsx('-mx-2 sm:mx-0', className)}\n          outcome={outcome}\n          setOutcome={setOutcome}\n          onClose={\n            inModal || alwaysShowOutcomeSwitcher\n              ? undefined\n              : () => {\n                  setIsPanelBodyVisible(false)\n                  if (initialOutcome == undefined) {\n                    setOutcome(undefined)\n                  }\n                }\n          }\n          pseudonym={pseudonym}\n        >\n          {children}\n        </BuyPanelBody>\n      )}\n    </Col>\n  )\n}\n\nexport const BuyPanelBody = (\n  props: BuyPanelProps & {\n    outcome?: BinaryOutcomes\n    setOutcome: (outcome: 'YES' | 'NO') => void\n    onClose?: () => void\n  }\n) => {\n  const {\n    contract,\n    multiProps,\n    outcome,\n    setOutcome,\n    alwaysShowOutcomeSwitcher,\n    onBuySuccess,\n    location = 'bet panel',\n    onClose,\n    replyToCommentId,\n    feedReason,\n    className,\n    children,\n  } = props\n\n  const user = useUser()\n  const privateUser = usePrivateUser()\n  const liquidityTier =\n    'answers' in contract\n      ? getTierIndexFromLiquidityAndAnswers(\n          contract.totalLiquidity,\n          contract.answers.length\n        )\n      : getTierIndexFromLiquidity(contract.totalLiquidity)\n\n  const { unfilledBets: allUnfilledBets, balanceByUserId } =\n    useUnfilledBetsAndBalanceByUserId(\n      contract.id,\n      (params) => api('bets', params),\n      (params) => api('users/by-id/balance', params),\n      useIsPageVisible\n    )\n\n  const unfilledBetsMatchingAnswer = allUnfilledBets.filter(\n    (b) => b.answerId === multiProps?.answerToBuy?.id\n  )\n\n  const isBinaryMC = isBinaryMulti(contract)\n  const binaryMCColors = isBinaryMC\n    ? (contract as MultiContract).answers.map(getAnswerColor)\n    : undefined\n\n  const binaryMCOutcomeLabel =\n    isBinaryMC && multiProps\n      ? multiProps.answerText ?? multiProps.answerToBuy.text\n      : undefined\n  const isCashContract = contract.token === 'CASH'\n\n  const quickAddButtonSize =\n    liquidityTier === 0 ||\n    (contract.mechanism === 'cpmm-multi-1' &&\n      liquidityTier === 1 &&\n      !contract.shouldAnswersSumToOne)\n      ? 'small'\n      : undefined\n\n  const initialBetAmount = isCashContract\n    ? 1\n    : quickAddButtonSize === 'small'\n    ? 10\n    : 50\n\n  const [betAmount, setBetAmount] = useState<number | undefined>(\n    initialBetAmount\n  )\n\n  const [error, setError] = useState<string | undefined>()\n  const [isSubmitting, setIsSubmitting] = useState(false)\n  const [submittedBet, setSubmittedBet] = useState<\n    | (LimitBet & {\n        expired: boolean\n        toastId: string\n      })\n    | null\n  >(null)\n\n  const [manaSlippageProtection, setManaSlippageProtection] =\n    usePersistentLocalState(false, 'mana-slippage-protection')\n  const [cashSlippageProtection, setCashSlippageProtection] =\n    usePersistentLocalState(true, 'cash-slippage-protection')\n  const slippageProtection = isCashContract\n    ? cashSlippageProtection\n    : manaSlippageProtection\n  const [inputRef, focusAmountInput] = useFocus()\n\n  // State for share row\n  const [isSharing, setIsSharing] = useState(false)\n  const [lastBetDetails, setLastBetDetails] = useState<Bet | null>(null)\n\n  // State for editing payout\n  const [isEditingPayout, setIsEditingPayout] = useState(false)\n  const [editablePayout, setEditablePayout] = useState<number | undefined>(\n    undefined\n  )\n\n  const isCpmmMulti = contract.mechanism === 'cpmm-multi-1'\n  if (isCpmmMulti && !multiProps) {\n    throw new Error('multiProps must be defined for cpmm-multi-1')\n  }\n\n  const shouldAnswersSumToOne =\n    'shouldAnswersSumToOne' in contract ? contract.shouldAnswersSumToOne : false\n\n  const unfilledBets =\n    isCpmmMulti && !shouldAnswersSumToOne\n      ? unfilledBetsMatchingAnswer\n      : allUnfilledBets\n\n  const isPseudoNumeric = contract.outcomeType === 'PSEUDO_NUMERIC'\n  const isStonk = contract.outcomeType === 'STONK'\n\n  const limitBets = useContractBets(\n    contract.id,\n    removeUndefinedProps({\n      userId: user?.id,\n      enabled: !!user?.id,\n      afterTime: contract?.lastBetTime ?? user?.lastBetTime,\n    }),\n    useIsPageVisible,\n    (params) => api('bets', params)\n  )\n  const updatedBet = limitBets.find((b) => b.id === submittedBet?.id)\n  useEffect(() => {\n    if (!submittedBet) return\n    if (\n      updatedBet?.isFilled ||\n      updatedBet?.isCancelled ||\n      submittedBet.expired ||\n      (updatedBet?.expiresAt && Date.now() > updatedBet.expiresAt)\n    ) {\n      const amountFilled = updatedBet?.amount ?? submittedBet.amount\n      const sharesFilled = updatedBet?.shares ?? submittedBet.shares\n      const orderAmount = updatedBet?.orderAmount ?? submittedBet.orderAmount\n      toast.success(\n        `${formatMoney(amountFilled)}/${formatMoney(\n          orderAmount\n        )} filled for ${formatMoney(sharesFilled)} payout`,\n        {\n          duration: 5000,\n          id: submittedBet.toastId,\n        }\n      )\n      setSubmittedBet(null)\n      setIsSubmitting(false)\n      const finalBetDetails = updatedBet ?? submittedBet\n      if (finalBetDetails) {\n        setLastBetDetails(finalBetDetails)\n        setIsSharing(false)\n        setTimeout(() => {\n          callOnBuySuccess()\n        }, WAIT_TO_DISMISS)\n      } else {\n        setLastBetDetails(null)\n        callOnBuySuccess()\n      }\n    }\n  }, [updatedBet, submittedBet])\n\n  const [justSetAdvancedTrader, setJustSetAdvancedTrader] = useState<boolean>(\n    user?.isAdvancedTrader ?? false\n  )\n  const isAdvancedTrader = useIsAdvancedTrader() || justSetAdvancedTrader\n\n  const [betTypeSetting, setBetTypeSetting] = useState<'Market' | 'Limit'>(\n    'Market'\n  )\n\n  useEffect(() => {\n    if (!isAdvancedTrader && betTypeSetting === 'Limit') {\n      setBetTypeSetting('Market')\n    }\n  }, [isAdvancedTrader])\n\n  useEffect(() => {\n    if (!isIOS() && !isAndroid()) {\n      focusAmountInput()\n    }\n  }, [])\n\n  function onBetChange(newAmount: number | undefined) {\n    setBetAmount(newAmount)\n  }\n\n  const callOnBuySuccess = useEvent(() => {\n    if (onBuySuccess && !isSharing) {\n      onBuySuccess()\n    }\n  })\n\n  const {\n    currentPayout,\n    probAfter: newProbAfter,\n    currentReturn,\n    betDeps,\n    limitProb,\n    prob,\n    calculationError,\n  } = getLimitBetReturns(\n    outcome ?? 'YES',\n    betAmount ?? 0,\n    unfilledBets,\n    balanceByUserId,\n    contract,\n    multiProps,\n    undefined,\n    slippageProtection\n  )\n  let probBefore = prob\n  let probAfter = newProbAfter\n  if (\n    multiProps &&\n    multiProps.answerToBuy.text !== multiProps.answerText &&\n    isBinaryMC\n  ) {\n    probBefore = 1 - prob\n    probAfter = 1 - newProbAfter\n  }\n\n  useEffect(() => {\n    if (calculationError) {\n      setError(calculationError)\n    }\n  }, [calculationError, setError])\n\n  async function submitBet() {\n    if (!user || !betAmount) return\n    console.log('betDeps', betDeps)\n    setError(undefined)\n    setIsSubmitting(true)\n    const toastId = slippageProtection\n      ? toast.loading(`Placing ${TRADE_TERM.toLowerCase()}...`, {\n          duration: 10000,\n        })\n      : undefined\n\n    try {\n      const expiresMillisAfter = 1000\n      const bet = await api(\n        'bet',\n        removeUndefinedProps({\n          outcome,\n          amount: betAmount,\n          contractId: contract.id,\n          answerId: multiProps?.answerToBuy.id,\n          replyToCommentId,\n          deps: uniq(betDeps.map((b) => b.userId)),\n          expiresMillisAfter: slippageProtection\n            ? expiresMillisAfter\n            : undefined,\n          silent: slippageProtection,\n          limitProb: slippageProtection ? limitProb : undefined,\n        } as APIParams<'bet'>)\n      )\n      if (bet.isFilled) {\n        if (slippageProtection) {\n          toast.success(\n            `${formatMoney(bet.amount)}/${formatMoney(\n              bet.orderAmount ?? 0\n            )} filled for ${formatMoney(bet.shares)} payout`,\n            {\n              duration: 5000,\n              id: toastId,\n            }\n          )\n        }\n        setSubmittedBet(null)\n        setIsSubmitting(false)\n\n        const fullBet: Bet = {\n          ...(bet as CandidateBet<LimitBet>),\n          id: bet.betId,\n          userId: user.id,\n        }\n        setLastBetDetails(fullBet)\n        setIsSharing(false)\n        // TODO: we could remove the timeout and just not dismiss the modal\n        setTimeout(() => {\n          callOnBuySuccess()\n        }, WAIT_TO_DISMISS)\n        track(\n          'bet',\n          removeUndefinedProps({\n            location,\n            outcomeType: contract.outcomeType,\n            token: contract.token,\n            slug: contract.slug,\n            contractId: contract.id,\n            amount: betAmount,\n            betGroupId: bet.betGroupId,\n            betId: bet.betId,\n            outcome,\n            isLimitOrder: false,\n            answerId: multiProps?.answerToBuy.id,\n            feedReason,\n            boosted: contract.boosted,\n          })\n        )\n      } else {\n        if (!toastId) {\n          console.error('No toastId')\n          return\n        }\n        toast.loading(`Filling ${TRADE_TERM.toLowerCase()}...`, {\n          duration: expiresMillisAfter + 100,\n          id: toastId,\n        })\n        setSubmittedBet({\n          ...(bet as CandidateBet<LimitBet>),\n          userId: user.id,\n          id: bet.betId,\n          expired: false,\n          toastId,\n        })\n        setTimeout(() => {\n          setSubmittedBet((prev) => (prev ? { ...prev, expired: true } : null))\n        }, expiresMillisAfter + 100)\n      }\n      setBetAmount(undefined)\n    } catch (e) {\n      if (e instanceof APIError) {\n        const message = e.message.toString()\n        if (message.includes('could not serialize access')) {\n          setError(`Error placing ${TRADE_TERM} (could not serialize access)`)\n          console.error(`Error placing ${TRADE_TERM}`, e)\n        } else setError(message)\n        toast.error(`Error submitting ${TRADE_TERM}`, { id: toastId })\n      } else {\n        console.error(e)\n        setError(`Error placing ${TRADE_TERM}`)\n        toast.error(`Error submitting ${TRADE_TERM}`, { id: toastId })\n      }\n      setIsSubmitting(false)\n      setLastBetDetails(null)\n    }\n  }\n  const [showLocationMonitor, setShowLocationMonitor] = useState(false)\n\n  const { status: verificationStatus, message: verificationMessage } =\n    getVerificationStatus(user, privateUser)\n\n  const betDisabled =\n    isSubmitting ||\n    !betAmount ||\n    outcome === undefined ||\n    error === 'Insufficient balance' ||\n    showLocationMonitor ||\n    (isCashContract && verificationStatus !== 'success')\n\n  const limits =\n    contract.outcomeType === 'STONK'\n      ? { max: MAX_STONK_PROB, min: MIN_STONK_PROB }\n      : { max: MAX_CPMM_PROB, min: MIN_CPMM_PROB }\n  const maxProb = limits.max\n  const minProb = limits.min\n  const probStayedSame = formatPercent(probAfter) === formatPercent(probBefore)\n  const probChange = Math.abs(probAfter - probBefore)\n  const currentReturnPercent = formatPercent(currentReturn)\n\n  const displayedAfter = isPseudoNumeric\n    ? formatLargeNumber(probAfter)\n    : formatPercent(probAfter)\n\n  const balance = isCashContract ? user?.cashBalance ?? 0 : user?.balance ?? 0\n\n  const bankrollFraction = (betAmount ?? 0) / (balance ?? 1e9)\n\n  // warnings\n  const highBankrollSpend =\n    (betAmount ?? 0) >= 100 && bankrollFraction >= 0.5 && bankrollFraction <= 1\n  const highProbMove =\n    (betAmount ?? 0) > 10 && probChange > 0.299 && bankrollFraction <= 1\n\n  const warning = highBankrollSpend\n    ? `You might not want to spend ${formatPercent(\n        bankrollFraction\n      )} of your balance on a single trade. \\n\\nCurrent balance: ${formatWithToken(\n        {\n          amount: balance,\n          token: isCashContract ? 'CASH' : 'M$',\n        }\n      )}`\n    : highProbMove\n    ? `Are you sure you want to move the market to ${displayedAfter}?`\n    : undefined\n\n  const choicesMap: { [key: string]: string } = isStonk\n    ? { Buy: 'YES', Short: 'NO' }\n    : { Yes: 'YES', No: 'NO' }\n\n  const { pseudonymName, pseudonymColor } =\n    props.pseudonym?.[outcome as 'YES' | 'NO'] ?? {}\n\n  const shouldPromptVerification =\n    isCashContract &&\n    PROMPT_USER_VERIFICATION_MESSAGES.includes(verificationMessage)\n\n  const betType = isStonk ? 'Market' : betTypeSetting\n  const isMobile = useIsMobile()\n\n  const handlePayoutEdited = useEvent(() => {\n    if (\n      !outcome ||\n      !editablePayout ||\n      isNaN(editablePayout) ||\n      editablePayout <= 0\n    ) {\n      setIsEditingPayout(false)\n      return\n    }\n\n    try {\n      const amount = calculateCpmmAmountToBuyShares(\n        contract,\n        editablePayout,\n        outcome,\n        allUnfilledBets,\n        balanceByUserId,\n        multiProps?.answerToBuy\n      )\n\n      if (amount && isFinite(amount) && amount > 0) {\n        setBetAmount(amount)\n        setError(undefined) // Clear potential previous errors\n      } else {\n        toast.error('Could not calculate bet for that payout amount')\n      }\n    } catch (err) {\n      console.error('Error calculating bet amount from shares:', err)\n      toast.error('Error calculating bet amount')\n    } finally {\n      setIsEditingPayout(false)\n    }\n  })\n\n  return (\n    <>\n      <Col className={clsx(className, 'relative rounded-xl px-4 py-2')}>\n        {children}\n        {(isAdvancedTrader || alwaysShowOutcomeSwitcher) && (\n          <Row className={'mb-2 mt-2 justify-between'}>\n            <Row\n              className={clsx(\n                ' gap-1',\n                (isBinaryMC || pseudonymName) && 'invisible'\n              )}\n            >\n              <ChoicesToggleGroup\n                currentChoice={outcome}\n                color={outcome === 'YES' ? 'light-green' : 'light-red'}\n                choicesMap={choicesMap}\n                setChoice={(outcome) => {\n                  setOutcome(outcome as 'YES' | 'NO')\n                }}\n              />\n            </Row>\n            <Row className=\"items-center justify-end gap-2\">\n              {isAdvancedTrader && !isStonk && (\n                <ChoicesToggleGroup\n                  currentChoice={betType}\n                  color=\"gray\"\n                  choicesMap={{\n                    Quick: 'Market',\n                    Limit: 'Limit',\n                  }}\n                  setChoice={(val) => {\n                    setBetTypeSetting(val as 'Market' | 'Limit')\n                  }}\n                />\n              )}\n              {onClose && (\n                <Button\n                  color=\"gray-white\"\n                  size=\"sm\"\n                  onClick={onClose}\n                  className=\"-mr-2\"\n                >\n                  <XIcon className=\"h-5 w-5\" />\n                </Button>\n              )}\n            </Row>\n          </Row>\n        )}\n        {betType === 'Market' ? (\n          <>\n            <Row\n              className={clsx('text-ink-600 mb-2 items-center justify-between')}\n            >\n              <div className=\"space-x-3\">{capitalize(TRADE_TERM)} amount</div>\n              {!isAdvancedTrader && onClose && (\n                <Button\n                  color=\"gray-white\"\n                  size=\"sm\"\n                  onClick={onClose}\n                  className=\"-mr-2\"\n                >\n                  <XIcon className=\"h-5 w-5\" />\n                </Button>\n              )}\n            </Row>\n\n            <Row\n              className={clsx(\n                'mb-2 flex-wrap gap-x-8 gap-y-4',\n                isAdvancedTrader ? 'items-center' : 'items-end'\n              )}\n            >\n              <BuyAmountInput\n                parentClassName=\"max-w-full\"\n                amount={betAmount}\n                onChange={onBetChange}\n                error={error}\n                setError={setError}\n                disabled={isSubmitting}\n                inputRef={inputRef}\n                showSlider={true}\n                token={isCashContract ? 'CASH' : 'M$'}\n                sliderColor={pseudonymColor}\n                disregardUserBalance={shouldPromptVerification}\n                quickButtonAmountSize={quickAddButtonSize}\n              />\n\n              {isAdvancedTrader && (\n                <Col className=\"w-full gap-1\">\n                  <Row className=\"w-full items-baseline justify-between sm:justify-start\">\n                    <span className=\"text-ink-600 mr-2 min-w-[120px] whitespace-nowrap\">\n                      {isPseudoNumeric\n                        ? 'Estimated value'\n                        : isStonk\n                        ? 'New stock price'\n                        : 'New probability'}\n                    </span>\n                    <Row className=\"items-baseline gap-1\">\n                      <span className=\"text-lg font-semibold\">\n                        {getFormattedMappedValue(\n                          contract,\n                          probStayedSame ? probBefore : probAfter\n                        )}\n                      </span>\n                      {!probStayedSame && !isPseudoNumeric && (\n                        <>\n                          <span className={clsx('ml-1', 'text-ink-600')}>\n                            {outcome !== 'NO' || isBinaryMC ? '↑' : '↓'}\n                            {getFormattedMappedValue(\n                              contract,\n                              Math.abs(probAfter - probBefore)\n                            )}\n                            {floatingEqual(probAfter, maxProb)\n                              ? ' (max)'\n                              : floatingEqual(probAfter, minProb)\n                              ? ' (max)'\n                              : ''}\n                          </span>\n\n                          <button\n                            onClick={() => {\n                              toast.success(\n                                `Slippage protection on ${\n                                  isCashContract ? 'cash' : 'mana'\n                                } questions ${\n                                  !slippageProtection ? 'enabled' : 'disabled'\n                                }!`\n                              )\n                              if (isCashContract) {\n                                setCashSlippageProtection(\n                                  !cashSlippageProtection\n                                )\n                              } else {\n                                setManaSlippageProtection(\n                                  !manaSlippageProtection\n                                )\n                              }\n                            }}\n                            className=\"self-center\"\n                          >\n                            <Tooltip\n                              autoHideDuration={isMobile ? 3000 : undefined}\n                              text={\n                                slippageProtection\n                                  ? `Your trades won't move the question probability more than 10 percentage points from displayed probability.`\n                                  : `Slippage protection on ${\n                                      isCashContract ? 'cash' : 'mana'\n                                    } questions is off.`\n                              }\n                            >\n                              {slippageProtection ? (\n                                <LockClosedIcon className=\"h-4 w-4 text-indigo-300 hover:text-indigo-400\" />\n                              ) : (\n                                <LockOpenIcon className=\"text-ink-500 hover:text-ink-600 h-4 w-4\" />\n                              )}\n                            </Tooltip>\n                          </button>\n                        </>\n                      )}\n                    </Row>\n                  </Row>\n                  <Row className=\"min-w-[128px] items-baseline justify-between sm:justify-start\">\n                    <div className=\"text-ink-600 mr-2 min-w-[120px] flex-nowrap whitespace-nowrap\">\n                      {isPseudoNumeric || isStonk ? 'Shares' : <>To win</>}\n                    </div>\n                    <Row className=\"items-baseline\">\n                      <span className=\"mr-1 whitespace-nowrap text-lg\">\n                        {isStonk ? (\n                          getStonkDisplayShares(contract, currentPayout, 2)\n                        ) : isPseudoNumeric ? (\n                          Math.floor(currentPayout)\n                        ) : (\n                          <>\n                            {isEditingPayout ? (\n                              <AmountInput\n                                inputClassName=\"w-32\"\n                                onBlur={handlePayoutEdited}\n                                onKeyDown={(e) => {\n                                  if (e.key === 'Enter') {\n                                    handlePayoutEdited()\n                                  } else if (e.key === 'Escape') {\n                                    setIsEditingPayout(false)\n                                  }\n                                }}\n                                autoFocus\n                                min={1}\n                                step={1}\n                                amount={editablePayout}\n                                onChangeAmount={setEditablePayout}\n                              />\n                            ) : (\n                              <span\n                                className={clsx(\n                                  'cursor-pointer hover:underline'\n                                )}\n                                onClick={() => {\n                                  setEditablePayout(Math.floor(currentPayout))\n                                  setIsEditingPayout(true)\n                                }}\n                              >\n                                {formatWithToken({\n                                  amount: currentPayout,\n                                  token: 'M$',\n                                })}\n                              </span>\n                            )}\n                          </>\n                        )}\n                      </span>\n                      <span className=\"text-green-500 \">\n                        {isStonk || isPseudoNumeric\n                          ? ''\n                          : ' +' + currentReturnPercent}\n                      </span>\n                    </Row>\n                  </Row>\n                </Col>\n              )}\n            </Row>\n          </>\n        ) : (\n          <>\n            <LimitOrderPanel\n              betAmount={betAmount}\n              contract={contract}\n              multiProps={multiProps}\n              user={user}\n              unfilledBets={unfilledBets}\n              balanceByUserId={balanceByUserId}\n              outcome={outcome}\n              pseudonym={props.pseudonym}\n            />\n          </>\n        )}\n\n        {betType !== 'Limit' && (\n          <Col className=\"gap-2\">\n            {user ? (\n              shouldPromptVerification ? (\n                <span className=\"text-error\">\n                  New sweepstakes signups disabled{' '}\n                </span>\n              ) : (\n                <>\n                  <LocationMonitor\n                    contract={contract}\n                    user={user}\n                    setShowPanel={setShowLocationMonitor}\n                    showPanel={showLocationMonitor}\n                  />\n                  {isCashContract && verificationStatus !== 'success' && (\n                    <div className=\"text-error\">{verificationMessage}</div>\n                  )}\n                  <WarningConfirmationButton\n                    marketType=\"binary\"\n                    amount={betAmount}\n                    warning={warning}\n                    userOptedOutOfWarning={user.optOutBetWarnings}\n                    onSubmit={submitBet}\n                    ButtonClassName={clsx('flex-grow')}\n                    actionLabelClassName={'line-clamp-1'}\n                    isSubmitting={isSubmitting}\n                    disabled={betDisabled}\n                    size=\"xl\"\n                    color={\n                      pseudonymColor ??\n                      binaryMCColors?.[outcome == 'YES' ? 0 : 1] ??\n                      (outcome === 'NO' ? 'red' : 'green')\n                    }\n                    actionLabel={\n                      betDisabled && !outcome ? (\n                        `Select ${formatOutcomeLabel(\n                          contract,\n                          'YES'\n                        )} or ${formatOutcomeLabel(contract, 'NO')}`\n                      ) : isStonk ? (\n                        <span>\n                          {formatOutcomeLabel(contract, outcome, pseudonymName)}{' '}\n                          <MoneyDisplay\n                            amount={betAmount ?? 0}\n                            isCashContract={isCashContract}\n                          />\n                        </span>\n                      ) : (\n                        <span>\n                          Buy{' '}\n                          {binaryMCOutcomeLabel ??\n                            formatOutcomeLabel(\n                              contract,\n                              outcome,\n                              pseudonymName\n                            )}{' '}\n                          to win{' '}\n                          <MoneyDisplay\n                            amount={currentPayout}\n                            isCashContract={isCashContract}\n                          />\n                        </span>\n                      )\n                    }\n                    inModal={!!onClose}\n                  />\n                </>\n              )\n            ) : (\n              <Button\n                color={outcome === 'NO' ? 'red' : 'green'}\n                size=\"xl\"\n                onClick={withTracking(firebaseLogin, 'login from bet panel', {\n                  token: contract.token,\n                })}\n                className=\"mb-2 flex-grow\"\n              >\n                Sign up to {TRADE_TERM}\n              </Button>\n            )}\n          </Col>\n        )}\n        {lastBetDetails && (\n          <Row className=\"bg-primary-100 mt-2 items-center justify-between rounded-lg p-3\">\n            <Row className=\"items-baseline gap-2\">\n              <span className=\"text-primary-700 text-sm \">\n                {isSubmitting ? 'Placing trade...' : 'Trade successful!'}\n              </span>\n            </Row>\n            <Button\n              className=\"w-1/2\"\n              color=\"gradient\"\n              onClick={() => setIsSharing(true)}\n            >\n              <Row className=\"items-center gap-1.5\">\n                <LuShare className=\"h-5 w-5\" aria-hidden />\n                Share Bet\n              </Row>\n            </Button>\n          </Row>\n        )}\n\n        {lastBetDetails && isSharing && user && (\n          <ShareBetModal\n            open={isSharing}\n            setOpen={setIsSharing}\n            questionText={contract.question}\n            outcome={formatOutcomeLabel(\n              contract,\n              lastBetDetails.outcome as 'YES' | 'NO'\n            )}\n            answer={multiProps?.answerToBuy.text}\n            avgPrice={formatPercent(\n              lastBetDetails.outcome === 'YES'\n                ? lastBetDetails.amount / lastBetDetails.shares\n                : 1 - lastBetDetails.amount / lastBetDetails.shares\n            )}\n            betAmount={lastBetDetails.amount}\n            winAmount={lastBetDetails.shares}\n            bettor={{\n              id: user.id,\n              name: user.name,\n              username: user.username,\n              avatarUrl: user.avatarUrl,\n            }}\n            isLimitBet={lastBetDetails.limitProb !== undefined}\n            orderAmount={lastBetDetails.orderAmount}\n          />\n        )}\n\n        {user && (\n          <Row className=\"mt-5 items-start justify-between text-sm\">\n            <Row className={''}>\n              <span\n                className={clsx(\n                  'text-ink-600 mr-1 whitespace-nowrap ',\n                  isAdvancedTrader ? '' : 'min-w-[110px]'\n                )}\n              >\n                Your mana balance\n              </span>\n              <span className=\"text-ink-600 font-semibold\">\n                <MoneyDisplay\n                  amount={balance}\n                  isCashContract={isCashContract}\n                />\n              </span>\n            </Row>\n          </Row>\n        )}\n\n        {!isAdvancedTrader && (\n          <Col>\n            <Row className=\"\">\n              <span className=\"text-ink-600 mr-1 min-w-[110px] whitespace-nowrap text-sm\">\n                {isPseudoNumeric\n                  ? 'Estimated value'\n                  : isStonk\n                  ? 'New stock price'\n                  : 'New probability'}\n              </span>\n\n              <span className=\"text-ink-600 text-sm font-semibold\">\n                {getFormattedMappedValue(\n                  contract,\n                  probStayedSame ? probBefore : probAfter\n                )}\n              </span>\n              {!probStayedSame && !isPseudoNumeric && (\n                <span className={clsx('ml-2 text-sm', 'text-ink-600')}>\n                  {outcome !== 'NO' || isBinaryMC ? '↑' : '↓'}\n                  {getFormattedMappedValue(\n                    contract,\n                    Math.abs(probAfter - probBefore)\n                  )}\n                  {floatingEqual(probAfter, maxProb)\n                    ? ' (max)'\n                    : floatingEqual(probAfter, minProb)\n                    ? ' (max)'\n                    : ''}{' '}\n                </span>\n              )}\n\n              {!isPseudoNumeric && !isStonk && !isBinaryMC && (\n                <InfoTooltip\n                  text={`Your ${TRADE_TERM} will move the probability of Yes from ${getFormattedMappedValue(\n                    contract,\n                    probBefore\n                  )} to ${getFormattedMappedValue(contract, probAfter)}.`}\n                  className=\"text-ink-600 ml-1 mt-0.5\"\n                  size=\"sm\"\n                />\n              )}\n\n              {isBinaryMC && (\n                <InfoTooltip\n                  text={`Your ${TRADE_TERM} will move the probability from ${getFormattedMappedValue(\n                    contract,\n                    probBefore\n                  )} to ${getFormattedMappedValue(contract, probAfter)}.`}\n                  className=\"text-ink-600 ml-1 mt-0.5\"\n                  size=\"sm\"\n                />\n              )}\n            </Row>\n          </Col>\n        )}\n\n        {user && (\n          <div className=\"absolute bottom-2 right-0\">\n            <button\n              className=\"text-ink-600 mr-2 flex items-center text-sm hover:underline\"\n              onClick={() => {\n                if (!isAdvancedTrader) {\n                  setBetTypeSetting('Market')\n                }\n                api('me/update', { isAdvancedTrader: !isAdvancedTrader })\n                setJustSetAdvancedTrader(!isAdvancedTrader)\n              }}\n            >\n              <span className=\"hover:underline\">\n                {isAdvancedTrader ? 'Basic' : 'Advanced'}\n              </span>\n              <ChevronDownIcon className=\"ml-1 h-3 w-3\" />\n            </button>\n          </div>\n        )}\n      </Col>\n\n      {contract.mechanism === 'cpmm-multi-1' && (\n        <YourOrders\n          className=\"mt-2 rounded-lg bg-indigo-200/10 py-4\"\n          contract={contract}\n          bets={unfilledBetsMatchingAnswer}\n        />\n      )}\n      {isAdvancedTrader && (\n        <OrderBookPanel\n          contract={contract}\n          limitBets={unfilledBets.filter(\n            (b) => b.answerId === multiProps?.answerToBuy?.id\n          )}\n          answer={multiProps?.answerToBuy}\n          pseudonym={props.pseudonym}\n        />\n      )}\n    </>\n  )\n}\n\nexport const QuickBetAmountsRow = (props: {\n  onAmountChange: (amount: number) => void\n  betAmount: number | undefined\n  className?: string\n}) => {\n  const { onAmountChange, betAmount, className } = props\n  const QUICK_BET_AMOUNTS = [10, 25, 100]\n  return (\n    <Row className={clsx('mb-2 items-center space-x-3', className)}>\n      <div className=\"text-ink-600\">Amount</div>\n      <ChoicesToggleGroup\n        currentChoice={\n          QUICK_BET_AMOUNTS.includes(betAmount ?? 0) ? betAmount : undefined\n        }\n        choicesMap={QUICK_BET_AMOUNTS.reduce<{\n          [key: number]: number\n        }>((map, amount) => {\n          map[amount] = amount\n          return map\n        }, {})}\n        setChoice={(amount) => {\n          if (typeof amount === 'number') {\n            onAmountChange(amount)\n          }\n        }}\n      />\n    </Row>\n  )\n}\n"
        },
        {
          "path": "web/components/bet/limit-order-panel.tsx",
          "preContent": "import dayjs from 'dayjs'\nimport { capitalize, clamp } from 'lodash'\nimport { useEffect, useRef, useState } from 'react'\nimport { LimitBet } from 'common/bet'\nimport { getProbability } from 'common/calculate'\nimport {\n  getBinaryMCProb,\n  isBinaryMulti,\n  MarketContract,\n  MultiContract,\n} from 'common/contract'\nimport { formatOutcomeLabel, formatPercent } from 'common/util/format'\nimport { DAY_MS, HOUR_MS, MINUTE_MS, MONTH_MS, WEEK_MS } from 'common/util/time'\nimport { Input } from 'web/components/widgets/input'\nimport { firebaseLogin, User } from 'web/lib/firebase/users'\nimport { Button } from '../buttons/button'\nimport { Col } from '../layout/col'\nimport { Row } from '../layout/row'\nimport { BinaryOutcomeLabel, PseudoNumericOutcomeLabel } from '../outcome-label'\nimport { BuyAmountInput } from '../widgets/amount-input'\nimport { getPseudoProbability } from 'common/pseudo-numeric'\nimport { track, withTracking } from 'web/lib/service/analytics'\nimport { APIError } from 'common/api/utils'\nimport { removeUndefinedProps } from 'common/util/object'\nimport { api } from 'web/lib/api/api'\nimport clsx from 'clsx'\nimport { getAnswerColor } from '../charts/contract/choice'\nimport { MoneyDisplay } from './money-display'\nimport { TRADE_TERM } from 'common/envs/constants'\nimport { sliderColors } from '../widgets/slider'\nimport { ProbabilitySlider } from '../widgets/probability-input'\nimport { usePersistentLocalState } from 'web/hooks/use-persistent-local-state'\nimport { APIParams } from 'common/api/schema'\nimport { getLimitBetReturns, MultiBetProps } from 'client-common/lib/bet'\nimport DropdownMenu from '../widgets/dropdown-menu'\nimport { SelectorIcon } from '@heroicons/react/solid'\nimport { InfoTooltip } from '../widgets/info-tooltip'\nimport { LuShare } from 'react-icons/lu'\nimport { ShareBetModal } from './share-bet'\nimport { Bet } from 'common/bet'\nimport { useEvent } from 'client-common/hooks/use-event'\nimport { CandidateBet } from 'common/new-bet'\n\nconst expirationOptions = [\n  { label: 'Never expires', value: 0 },\n  { label: 'Expires immediately', value: 1 },\n  { label: 'Expires in 1 hour', value: HOUR_MS },\n  { label: 'Expires in 1 day', value: DAY_MS },\n  { label: 'Expires in 1 week', value: WEEK_MS },\n  { label: 'Expires in 1 month', value: MONTH_MS },\n  { label: 'Custom time...', value: -1 },\n]\n\nconst WAIT_TO_DISMISS = 3000\n\nexport default function LimitOrderPanel(props: {\n  contract: MarketContract\n  multiProps?: MultiBetProps\n  user: User | null | undefined\n  unfilledBets: LimitBet[]\n  balanceByUserId: { [userId: string]: number }\n  onBuySuccess?: () => void\n  className?: string\n  betAmount?: number\n  outcome: 'YES' | 'NO' | undefined\n  pseudonym?: {\n    YES: {\n      pseudonymName: string\n      pseudonymColor: keyof typeof sliderColors\n    }\n    NO: {\n      pseudonymName: string\n      pseudonymColor: keyof typeof sliderColors\n    }\n  }\n  initialProb?: number\n  expiration?: number\n}) {\n  const {\n    contract,\n    multiProps,\n    unfilledBets,\n    balanceByUserId,\n    user,\n    outcome,\n    onBuySuccess,\n    pseudonym,\n    expiration,\n  } = props\n  const { pseudonymName, pseudonymColor } =\n    pseudonym?.[outcome as 'YES' | 'NO'] ?? {}\n  const isBinaryMC = isBinaryMulti(contract)\n  const binaryMCColors = isBinaryMC\n    ? (contract as MultiContract).answers.map(getAnswerColor)\n    : undefined\n\n  const binaryMCOutcome =\n    isBinaryMC && multiProps\n      ? multiProps.answerText === multiProps.answerToBuy.text\n        ? 'YES'\n        : 'NO'\n      : undefined\n  const isCpmmMulti = contract.mechanism === 'cpmm-multi-1'\n  if (isCpmmMulti && !multiProps) {\n    throw new Error('multiProps must be defined for cpmm-multi-1')\n  }\n  const isPseudoNumeric = contract.outcomeType === 'PSEUDO_NUMERIC'\n\n  const isCashContract = contract.token === 'CASH'\n\n  const [betAmount, setBetAmount] = useState<number | undefined>(\n    props.betAmount\n  )\n  const [error, setError] = useState<string | undefined>()\n  const [isSubmitting, setIsSubmitting] = useState(false)\n  const betDeps = useRef<LimitBet[]>()\n  const initTimeInMs = Number(Date.now() + (expiration ?? 5 * MINUTE_MS))\n  const initDate = dayjs(initTimeInMs).format('YYYY-MM-DD')\n  const initTime = dayjs(initTimeInMs).format('HH:mm')\n  const [expirationDate, setExpirationDate] = usePersistentLocalState<string>(\n    initDate,\n    'limit-order-expiration-date'\n  )\n  const [expirationHoursMinutes, setExpirationHoursMinutes] =\n    usePersistentLocalState<string>(initTime, 'limit-order-expiration-time')\n\n  const [selectedExpiration, setSelectedExpiration] =\n    usePersistentLocalState<number>(0, 'limit-order-expiration')\n\n  const [isSharing, setIsSharing] = useState(false)\n  const [lastBetDetails, setLastBetDetails] = useState<Bet | null>(null)\n\n  const callOnBuySuccess = useEvent(() => {\n    if (onBuySuccess && !isSharing) {\n      onBuySuccess()\n    }\n  })\n\n  useEffect(() => {\n    if (expiration === 0) {\n      setSelectedExpiration(0)\n    } else if (expiration) {\n      const matchingOption = expirationOptions.find(\n        (option) => option.value === expiration && option.value !== -1\n      )\n      if (matchingOption) {\n        setSelectedExpiration(matchingOption.value)\n      }\n    }\n  }, [expiration, setSelectedExpiration])\n\n  const addCustomExpiration = selectedExpiration === -1\n  const expiresAt = addCustomExpiration\n    ? dayjs(`${expirationDate}T${expirationHoursMinutes}`).valueOf()\n    : undefined\n\n  const expiresMillisAfter =\n    !addCustomExpiration && selectedExpiration > 0\n      ? selectedExpiration\n      : undefined\n\n  const initialProb =\n    props.initialProb ??\n    (isBinaryMC && outcome === 'YES'\n      ? multiProps!.answerToBuy.prob\n      : isBinaryMC && outcome === 'NO'\n      ? 1 - multiProps!.answerToBuy.prob\n      : isCpmmMulti\n      ? multiProps!.answerToBuy.prob\n      : getProbability(contract))\n\n  const [limitProbInt, setLimitProbInt] = useState<number | undefined>(\n    Math.round(initialProb * 100)\n  )\n\n  const hasLimitBet = !!limitProbInt && !!betAmount\n\n  const betDisabled =\n    isSubmitting ||\n    !outcome ||\n    !betAmount ||\n    !hasLimitBet ||\n    error === 'Insufficient balance'\n\n  const preLimitProb =\n    limitProbInt === undefined\n      ? undefined\n      : clamp(\n          isPseudoNumeric\n            ? getPseudoProbability(\n                limitProbInt,\n                contract.min,\n                contract.max,\n                contract.isLogScale\n              )\n            : limitProbInt / 100,\n          0.001,\n          0.999\n        )\n  const limitProb =\n    !preLimitProb || !isBinaryMC\n      ? preLimitProb\n      : getBinaryMCProb(preLimitProb, outcome as 'YES' | 'NO')\n\n  const amount = betAmount ?? 0\n\n  function onBetChange(newAmount: number | undefined) {\n    setBetAmount(newAmount)\n  }\n\n  async function submitBet() {\n    if (!user || betDisabled) return\n\n    setError(undefined)\n    setIsSubmitting(true)\n\n    const answerId = multiProps?.answerToBuy.id\n\n    try {\n      const bet = await api(\n        'bet',\n        removeUndefinedProps({\n          outcome,\n          amount,\n          contractId: contract.id,\n          answerId,\n          limitProb,\n          expiresAt: addCustomExpiration ? expiresAt : undefined,\n          expiresMillisAfter,\n          deps: betDeps.current?.map((b) => b.userId),\n          silent: expiresMillisAfter && expiresMillisAfter <= 1000,\n        } as APIParams<'bet'>)\n      )\n      console.log(`placed ${TRADE_TERM}. Result:`, bet)\n\n      const fullBet: Bet = {\n        ...(bet as CandidateBet<LimitBet>),\n        id: bet.betId,\n        userId: user.id,\n      }\n      track('bet', {\n        location: 'bet panel',\n        outcomeType: contract.outcomeType,\n        slug: contract.slug,\n        contractId: contract.id,\n        amount,\n        outcome,\n        limitProb,\n        isLimitOrder: true,\n        answerId: multiProps?.answerToBuy.id,\n        token: contract.token,\n      })\n      setLastBetDetails(fullBet)\n      setIsSharing(false)\n      setTimeout(() => {\n        callOnBuySuccess()\n      }, WAIT_TO_DISMISS)\n    } catch (e) {\n      setLastBetDetails(null)\n      if (e instanceof APIError) {\n        setError(e.message.toString())\n      } else {\n        console.error(e)\n        setError(`Error placing ${TRADE_TERM}`)\n      }\n    } finally {\n      setIsSubmitting(false)\n    }\n  }\n\n  let currentPayout = 0\n  let currentReturn = 0\n  let orderAmount = 0\n  let filledAmount = 0\n  try {\n    const result = getLimitBetReturns(\n      outcome ?? 'YES',\n      amount,\n      unfilledBets,\n      balanceByUserId,\n      setError,\n      contract,\n      multiProps,\n      limitProb,\n      false\n    )\n    currentPayout = result.currentPayout\n    currentReturn = result.currentReturn\n    orderAmount = result.orderAmount\n    filledAmount = result.amount\n    // fees = result.fees\n    betDeps.current = result.betDeps\n  } catch (err: any) {\n    console.error('Error in calculateCpmmMultiArbitrageBet:', err)\n    setError(\n      err?.message ??\n        `An error occurred during ${TRADE_TERM} calculation, try again.`\n    )\n  }\n  const returnPercent = formatPercent(currentReturn)\n\n  const hideYesNo = isBinaryMC || !!pseudonym\n\n  const expirationItems = expirationOptions.map((option) => ({\n    name: option.label,\n    onClick: () => setSelectedExpiration(option.value),\n  }))\n\n  return (\n    <>\n      <Col className=\" gap-1\">\n        <Row className={'text-ink-600 items-center space-x-3'}>\n          {capitalize(TRADE_TERM)} amount\n        </Row>\n        <BuyAmountInput\n          parentClassName=\"max-w-full mt-1\"\n          amount={betAmount}\n          onChange={onBetChange}\n          error={error}\n          setError={setError}\n          disabled={isSubmitting}\n          showSlider\n          token={isCashContract ? 'CASH' : 'M$'}\n          sliderColor={pseudonymColor}\n        />\n      </Col>\n      <Col className=\"relative mt-6 w-full gap-1\">\n        <div className=\"text-ink-600\">\n          {isPseudoNumeric ? 'Value' : `Probability (%)`}\n        </div>\n        <Row>\n          <label className=\"font-sm md:font-lg relative w-full\">\n            <Input\n              type=\"number\"\n              min={0}\n              max={100}\n              step={1}\n              className=\"h-[60px] w-full !text-xl\"\n              value={limitProbInt ?? ''}\n              onChange={(e) => {\n                const val =\n                  e.target.value === '' ? undefined : Number(e.target.value)\n                if (val === undefined || (val >= 0 && val <= 100)) {\n                  setLimitProbInt(val)\n                }\n              }}\n            />\n            <Row className=\"absolute right-2 top-3.5 gap-1.5 sm:gap-2\">\n              <button\n                className=\"hover:bg-ink-200 bg-canvas-100 rounded-md px-2 py-1.5 text-sm sm:px-3\"\n                onClick={() => {\n                  if (limitProbInt !== undefined) {\n                    setLimitProbInt(limitProbInt - 5)\n                  }\n                }}\n              >\n                -5\n              </button>\n              <button\n                className=\"hover:bg-ink-200 bg-canvas-100 rounded-md px-2 py-1.5 text-sm sm:px-3\"\n                onClick={() => {\n                  if (limitProbInt !== undefined) {\n                    setLimitProbInt(limitProbInt - 1)\n                  }\n                }}\n              >\n                -1\n              </button>\n              <button\n                className=\"hover:bg-ink-200 bg-canvas-100 rounded-md px-2 py-1.5 text-sm sm:px-3\"\n                onClick={() => {\n                  if (limitProbInt !== undefined) {\n                    setLimitProbInt(limitProbInt + 1)\n                  }\n                }}\n              >\n                +1\n              </button>\n              <button\n                className=\"hover:bg-ink-200 bg-canvas-100 rounded-md px-2 py-1.5 text-sm sm:px-3\"\n                onClick={() => {\n                  if (limitProbInt !== undefined) {\n                    setLimitProbInt(limitProbInt + 5)\n                  }\n                }}\n              >\n                +5\n              </button>\n            </Row>\n          </label>\n        </Row>\n\n        <ProbabilitySlider\n          prob={limitProbInt}\n          onProbChange={setLimitProbInt}\n          disabled={isSubmitting}\n          color={pseudonymColor}\n          outcome={isBinaryMC ? 'YES' : outcome}\n        />\n      </Col>\n\n      <Col className=\"mt-6 gap-2\">\n        <DropdownMenu\n          buttonContent={\n            <Row className=\"items-center gap-1\">\n              <span>\n                {expirationOptions.find(\n                  (opt) => opt.value === selectedExpiration\n                )?.label ?? expirationOptions[0].label}\n              </span>\n              <SelectorIcon className=\"text-ink-400 h-4 w-4\" />\n            </Row>\n          }\n          closeOnClick\n          items={expirationItems}\n          buttonClass=\"text-ink-600 hover:text-ink-900 p-0 bg-transparent\"\n          menuWidth=\"w-48\"\n        />\n\n        {addCustomExpiration && (\n          <Col className=\"gap-2\">\n            <Row className=\"gap-2\">\n              <Input\n                type={'date'}\n                className=\"dark:date-range-input-white\"\n                onClick={(e) => e.stopPropagation()}\n                onChange={(e) => {\n                  setExpirationDate(e.target.value)\n                  if (!expirationHoursMinutes) {\n                    setExpirationHoursMinutes(initTime)\n                  }\n                }}\n                min={dayjs().format('YYYY-MM-DD')}\n                max=\"9999-12-31\"\n                disabled={isSubmitting}\n                value={expirationDate}\n              />\n              <Input\n                type={'time'}\n                className=\"dark:date-range-input-white\"\n                onClick={(e) => e.stopPropagation()}\n                onChange={(e) => setExpirationHoursMinutes(e.target.value)}\n                disabled={isSubmitting}\n                value={expirationHoursMinutes}\n                step={60}\n              />\n            </Row>\n          </Col>\n        )}\n      </Col>\n\n      <Col className=\"mt-2 w-full gap-2\">\n        {outcome && hasLimitBet && filledAmount > 0 && (\n          <Row className=\"items-center justify-between gap-2 \">\n            <div className=\"text-ink-600 whitespace-nowrap\">\n              {isPseudoNumeric ? (\n                <PseudoNumericOutcomeLabel outcome={outcome} />\n              ) : (\n                !hideYesNo && <BinaryOutcomeLabel outcome={outcome} />\n              )}{' '}\n              {hideYesNo ? 'Filled' : 'filled'} now\n            </div>\n            <div className=\"whitespace-nowrap\">\n              <MoneyDisplay\n                amount={filledAmount}\n                isCashContract={isCashContract}\n              />{' '}\n              of{' '}\n              <MoneyDisplay\n                amount={orderAmount}\n                isCashContract={isCashContract}\n              />\n            </div>\n          </Row>\n        )}\n\n        {outcome && hasLimitBet && (\n          <Row className=\"mb-2 items-center justify-between gap-2\">\n            <Row className=\"text-ink-600 flex-nowrap items-center gap-2 whitespace-nowrap\">\n              <div>\n                {isPseudoNumeric ? (\n                  'Shares'\n                ) : (\n                  <>\n                    Max {!hideYesNo && <BinaryOutcomeLabel outcome={outcome} />}{' '}\n                    payout\n                    {isCashContract && (\n                      <InfoTooltip\n                        text=\"Manifold takes a 10% cut of profits on sweepstakes markets.\"\n                        className=\"text-ink-600 ml-1 mt-0.5\"\n                        size=\"sm\"\n                      />\n                    )}\n                  </>\n                )}\n              </div>\n            </Row>\n            <div>\n              <span className=\"mr-2 whitespace-nowrap\">\n                <MoneyDisplay\n                  amount={currentPayout}\n                  isCashContract={isCashContract}\n                />\n              </span>\n              ({returnPercent})\n            </div>\n          </Row>\n        )}\n\n        <Col className=\"gap-2\">\n          {user ? (\n            <>\n              <Row className=\"items-center justify-between gap-2\">\n                <Button\n                  size=\"xl\"\n                  disabled={betDisabled}\n                  color={\n                    (pseudonymColor as any) ??\n                    (hideYesNo ? 'none' : outcome === 'YES' ? 'green' : 'red')\n                  }\n                  loading={isSubmitting}\n                  className={clsx('flex-1 text-white')}\n                  style={{\n                    backgroundColor: binaryMCColors?.[outcome == 'YES' ? 0 : 1],\n                  }}\n                  onClick={submitBet}\n                >\n                  {isSubmitting ? (\n                    'Submitting...'\n                  ) : !outcome ? (\n                    'Choose YES or NO'\n                  ) : !limitProb ? (\n                    'Enter a probability'\n                  ) : !betAmount ? (\n                    'Enter an amount'\n                  ) : (\n                    <span>\n                      Buy{' '}\n                      <MoneyDisplay\n                        amount={betAmount}\n                        isCashContract={isCashContract}\n                      />{' '}\n                      {!binaryMCOutcome && !pseudonymName ? outcome : ''} at{' '}\n                      {formatPercent(\n                        binaryMCOutcome || pseudonymName\n                          ? preLimitProb ?? 0\n                          : limitProb\n                      )}\n                    </span>\n                  )}\n                </Button>\n              </Row>\n\n              {lastBetDetails && (\n                <Row className=\"bg-primary-100 mt-2 items-center justify-between rounded-lg p-3\">\n                  <Row className=\"items-baseline gap-2\">\n                    <span className=\"text-primary-700 text-sm \">\n                      {isSubmitting ? 'Placing trade...' : 'Trade successful!'}\n                    </span>\n                  </Row>\n                  <Button\n                    className=\"w-1/2\"\n                    color=\"gradient\"\n                    onClick={() => setIsSharing(true)}\n                  >\n                    <Row className=\"items-center gap-1.5\">\n                      <LuShare className=\"h-5 w-5\" aria-hidden />\n                      Share Bet\n                    </Row>\n                  </Button>\n                </Row>\n              )}\n\n              {lastBetDetails && isSharing && user && (\n                <ShareBetModal\n                  open={isSharing}\n                  setOpen={setIsSharing}\n                  questionText={contract.question}\n                  outcome={formatOutcomeLabel(\n                    contract,\n                    lastBetDetails.outcome as 'YES' | 'NO'\n                  )}\n                  answer={multiProps?.answerToBuy.text}\n                  avgPrice={formatPercent(lastBetDetails.limitProb ?? 0)}\n                  betAmount={\n                    lastBetDetails.orderAmount ?? lastBetDetails.amount\n                  }\n                  winAmount={\n                    lastBetDetails.limitProb !== undefined &&\n                    lastBetDetails.orderAmount !== undefined\n                      ? lastBetDetails.outcome === 'YES'\n                        ? lastBetDetails.orderAmount / lastBetDetails.limitProb\n                        : lastBetDetails.orderAmount /\n                          (1 - lastBetDetails.limitProb)\n                      : lastBetDetails.shares\n                  }\n                  bettor={{\n                    id: user.id,\n                    name: user.name,\n                    username: user.username,\n                    avatarUrl: user.avatarUrl,\n                  }}\n                  isLimitBet={true}\n                  orderAmount={lastBetDetails.orderAmount}\n                />\n              )}\n            </>\n          ) : (\n            <Button\n              color={outcome === 'NO' ? 'red' : 'green'}\n              size=\"xl\"\n              onClick={withTracking(firebaseLogin, 'login from bet panel', {\n                token: contract.token,\n              })}\n              className=\"mb-2 flex-grow\"\n            >\n              Sign up to {TRADE_TERM}\n            </Button>\n          )}\n        </Col>\n      </Col>\n    </>\n  )\n}\n",
          "postContent": "import dayjs from 'dayjs'\nimport { capitalize, clamp } from 'lodash'\nimport { useEffect, useRef, useState } from 'react'\nimport { LimitBet } from 'common/bet'\nimport { getProbability } from 'common/calculate'\nimport {\n  getBinaryMCProb,\n  isBinaryMulti,\n  MarketContract,\n  MultiContract,\n} from 'common/contract'\nimport { formatOutcomeLabel, formatPercent } from 'common/util/format'\nimport { DAY_MS, HOUR_MS, MINUTE_MS, MONTH_MS, WEEK_MS } from 'common/util/time'\nimport { Input } from 'web/components/widgets/input'\nimport { firebaseLogin, User } from 'web/lib/firebase/users'\nimport { Button } from '../buttons/button'\nimport { Col } from '../layout/col'\nimport { Row } from '../layout/row'\nimport { BinaryOutcomeLabel, PseudoNumericOutcomeLabel } from '../outcome-label'\nimport { BuyAmountInput } from '../widgets/amount-input'\nimport { getPseudoProbability } from 'common/pseudo-numeric'\nimport { track, withTracking } from 'web/lib/service/analytics'\nimport { APIError } from 'common/api/utils'\nimport { removeUndefinedProps } from 'common/util/object'\nimport { api } from 'web/lib/api/api'\nimport clsx from 'clsx'\nimport { getAnswerColor } from '../charts/contract/choice'\nimport { MoneyDisplay } from './money-display'\nimport { TRADE_TERM } from 'common/envs/constants'\nimport { sliderColors } from '../widgets/slider'\nimport { ProbabilitySlider } from '../widgets/probability-input'\nimport { usePersistentLocalState } from 'web/hooks/use-persistent-local-state'\nimport { APIParams } from 'common/api/schema'\nimport { getLimitBetReturns, MultiBetProps } from 'client-common/lib/bet'\nimport DropdownMenu from '../widgets/dropdown-menu'\nimport { SelectorIcon } from '@heroicons/react/solid'\nimport { InfoTooltip } from '../widgets/info-tooltip'\nimport { LuShare } from 'react-icons/lu'\nimport { ShareBetModal } from './share-bet'\nimport { Bet } from 'common/bet'\nimport { useEvent } from 'client-common/hooks/use-event'\nimport { CandidateBet } from 'common/new-bet'\n\nconst expirationOptions = [\n  { label: 'Never expires', value: 0 },\n  { label: 'Expires immediately', value: 1 },\n  { label: 'Expires in 1 hour', value: HOUR_MS },\n  { label: 'Expires in 1 day', value: DAY_MS },\n  { label: 'Expires in 1 week', value: WEEK_MS },\n  { label: 'Expires in 1 month', value: MONTH_MS },\n  { label: 'Custom time...', value: -1 },\n]\n\nconst WAIT_TO_DISMISS = 3000\n\nexport default function LimitOrderPanel(props: {\n  contract: MarketContract\n  multiProps?: MultiBetProps\n  user: User | null | undefined\n  unfilledBets: LimitBet[]\n  balanceByUserId: { [userId: string]: number }\n  onBuySuccess?: () => void\n  className?: string\n  betAmount?: number\n  outcome: 'YES' | 'NO' | undefined\n  pseudonym?: {\n    YES: {\n      pseudonymName: string\n      pseudonymColor: keyof typeof sliderColors\n    }\n    NO: {\n      pseudonymName: string\n      pseudonymColor: keyof typeof sliderColors\n    }\n  }\n  initialProb?: number\n  expiration?: number\n}) {\n  const {\n    contract,\n    multiProps,\n    unfilledBets,\n    balanceByUserId,\n    user,\n    outcome,\n    onBuySuccess,\n    pseudonym,\n    expiration,\n  } = props\n  const { pseudonymName, pseudonymColor } =\n    pseudonym?.[outcome as 'YES' | 'NO'] ?? {}\n  const isBinaryMC = isBinaryMulti(contract)\n  const binaryMCColors = isBinaryMC\n    ? (contract as MultiContract).answers.map(getAnswerColor)\n    : undefined\n\n  const binaryMCOutcome =\n    isBinaryMC && multiProps\n      ? multiProps.answerText === multiProps.answerToBuy.text\n        ? 'YES'\n        : 'NO'\n      : undefined\n  const isCpmmMulti = contract.mechanism === 'cpmm-multi-1'\n  if (isCpmmMulti && !multiProps) {\n    throw new Error('multiProps must be defined for cpmm-multi-1')\n  }\n  const isPseudoNumeric = contract.outcomeType === 'PSEUDO_NUMERIC'\n\n  const isCashContract = contract.token === 'CASH'\n\n  const [betAmount, setBetAmount] = useState<number | undefined>(\n    props.betAmount\n  )\n  const [error, setError] = useState<string | undefined>()\n  const [isSubmitting, setIsSubmitting] = useState(false)\n  const betDeps = useRef<LimitBet[]>()\n  const initTimeInMs = Number(Date.now() + (expiration ?? 5 * MINUTE_MS))\n  const initDate = dayjs(initTimeInMs).format('YYYY-MM-DD')\n  const initTime = dayjs(initTimeInMs).format('HH:mm')\n  const [expirationDate, setExpirationDate] = usePersistentLocalState<string>(\n    initDate,\n    'limit-order-expiration-date'\n  )\n  const [expirationHoursMinutes, setExpirationHoursMinutes] =\n    usePersistentLocalState<string>(initTime, 'limit-order-expiration-time')\n\n  const [selectedExpiration, setSelectedExpiration] =\n    usePersistentLocalState<number>(0, 'limit-order-expiration')\n\n  const [isSharing, setIsSharing] = useState(false)\n  const [lastBetDetails, setLastBetDetails] = useState<Bet | null>(null)\n\n  const callOnBuySuccess = useEvent(() => {\n    if (onBuySuccess && !isSharing) {\n      onBuySuccess()\n    }\n  })\n\n  useEffect(() => {\n    if (expiration === 0) {\n      setSelectedExpiration(0)\n    } else if (expiration) {\n      const matchingOption = expirationOptions.find(\n        (option) => option.value === expiration && option.value !== -1\n      )\n      if (matchingOption) {\n        setSelectedExpiration(matchingOption.value)\n      }\n    }\n  }, [expiration, setSelectedExpiration])\n\n  const addCustomExpiration = selectedExpiration === -1\n  const expiresAt = addCustomExpiration\n    ? dayjs(`${expirationDate}T${expirationHoursMinutes}`).valueOf()\n    : undefined\n\n  const expiresMillisAfter =\n    !addCustomExpiration && selectedExpiration > 0\n      ? selectedExpiration\n      : undefined\n\n  const initialProb =\n    props.initialProb ??\n    (isBinaryMC && outcome === 'YES'\n      ? multiProps!.answerToBuy.prob\n      : isBinaryMC && outcome === 'NO'\n      ? 1 - multiProps!.answerToBuy.prob\n      : isCpmmMulti\n      ? multiProps!.answerToBuy.prob\n      : getProbability(contract))\n\n  const [limitProbInt, setLimitProbInt] = useState<number | undefined>(\n    Math.round(initialProb * 100)\n  )\n\n  const hasLimitBet = !!limitProbInt && !!betAmount\n\n  const betDisabled =\n    isSubmitting ||\n    !outcome ||\n    !betAmount ||\n    !hasLimitBet ||\n    error === 'Insufficient balance'\n\n  const preLimitProb =\n    limitProbInt === undefined\n      ? undefined\n      : clamp(\n          isPseudoNumeric\n            ? getPseudoProbability(\n                limitProbInt,\n                contract.min,\n                contract.max,\n                contract.isLogScale\n              )\n            : limitProbInt / 100,\n          0.001,\n          0.999\n        )\n  const limitProb =\n    !preLimitProb || !isBinaryMC\n      ? preLimitProb\n      : getBinaryMCProb(preLimitProb, outcome as 'YES' | 'NO')\n\n  const amount = betAmount ?? 0\n\n  function onBetChange(newAmount: number | undefined) {\n    setBetAmount(newAmount)\n  }\n\n  async function submitBet() {\n    if (!user || betDisabled) return\n\n    setError(undefined)\n    setIsSubmitting(true)\n\n    const answerId = multiProps?.answerToBuy.id\n\n    try {\n      const bet = await api(\n        'bet',\n        removeUndefinedProps({\n          outcome,\n          amount,\n          contractId: contract.id,\n          answerId,\n          limitProb,\n          expiresAt: addCustomExpiration ? expiresAt : undefined,\n          expiresMillisAfter,\n          deps: betDeps.current?.map((b) => b.userId),\n          silent: expiresMillisAfter && expiresMillisAfter <= 1000,\n        } as APIParams<'bet'>)\n      )\n      console.log(`placed ${TRADE_TERM}. Result:`, bet)\n\n      const fullBet: Bet = {\n        ...(bet as CandidateBet<LimitBet>),\n        id: bet.betId,\n        userId: user.id,\n      }\n      track('bet', {\n        location: 'bet panel',\n        outcomeType: contract.outcomeType,\n        slug: contract.slug,\n        contractId: contract.id,\n        amount,\n        outcome,\n        limitProb,\n        isLimitOrder: true,\n        answerId: multiProps?.answerToBuy.id,\n        token: contract.token,\n      })\n      setLastBetDetails(fullBet)\n      setIsSharing(false)\n      setTimeout(() => {\n        callOnBuySuccess()\n      }, WAIT_TO_DISMISS)\n    } catch (e) {\n      setLastBetDetails(null)\n      if (e instanceof APIError) {\n        setError(e.message.toString())\n      } else {\n        console.error(e)\n        setError(`Error placing ${TRADE_TERM}`)\n      }\n    } finally {\n      setIsSubmitting(false)\n    }\n  }\n\n  let currentPayout = 0\n  let currentReturn = 0\n  let orderAmount = 0\n  let filledAmount = 0\n  try {\n    const result = getLimitBetReturns(\n      outcome ?? 'YES',\n      amount,\n      unfilledBets,\n      balanceByUserId,\n      contract,\n      multiProps,\n      limitProb,\n      false\n    )\n    currentPayout = result.currentPayout\n    currentReturn = result.currentReturn\n    orderAmount = result.orderAmount\n    filledAmount = result.amount\n    // fees = result.fees\n    betDeps.current = result.betDeps\n    if (result.calculationError && error !== result.calculationError) {\n      setError(result.calculationError)\n    }\n  } catch (err: any) {\n    console.error('Error in calculateCpmmMultiArbitrage:', err)\n    setError(\n      err?.message ??\n        `An error occurred during ${TRADE_TERM} calculation, try again.`\n    )\n  }\n  const returnPercent = formatPercent(currentReturn)\n\n  const hideYesNo = isBinaryMC || !!pseudonym\n\n  const expirationItems = expirationOptions.map((option) => ({\n    name: option.label,\n    onClick: () => setSelectedExpiration(option.value),\n  }))\n\n  return (\n    <>\n      <Col className=\" gap-1\">\n        <Row className={'text-ink-600 items-center space-x-3'}>\n          {capitalize(TRADE_TERM)} amount\n        </Row>\n        <BuyAmountInput\n          parentClassName=\"max-w-full mt-1\"\n          amount={betAmount}\n          onChange={onBetChange}\n          error={error}\n          setError={setError}\n          disabled={isSubmitting}\n          showSlider\n          token={isCashContract ? 'CASH' : 'M$'}\n          sliderColor={pseudonymColor}\n        />\n      </Col>\n      <Col className=\"relative mt-6 w-full gap-1\">\n        <div className=\"text-ink-600\">\n          {isPseudoNumeric ? 'Value' : `Probability (%)`}\n        </div>\n        <Row>\n          <label className=\"font-sm md:font-lg relative w-full\">\n            <Input\n              type=\"number\"\n              min={0}\n              max={100}\n              step={1}\n              className=\"h-[60px] w-full !text-xl\"\n              value={limitProbInt ?? ''}\n              onChange={(e) => {\n                const val =\n                  e.target.value === '' ? undefined : Number(e.target.value)\n                if (val === undefined || (val >= 0 && val <= 100)) {\n                  setLimitProbInt(val)\n                }\n              }}\n            />\n            <Row className=\"absolute right-2 top-3.5 gap-1.5 sm:gap-2\">\n              <button\n                className=\"hover:bg-ink-200 bg-canvas-100 rounded-md px-2 py-1.5 text-sm sm:px-3\"\n                onClick={() => {\n                  if (limitProbInt !== undefined) {\n                    setLimitProbInt(limitProbInt - 5)\n                  }\n                }}\n              >\n                -5\n              </button>\n              <button\n                className=\"hover:bg-ink-200 bg-canvas-100 rounded-md px-2 py-1.5 text-sm sm:px-3\"\n                onClick={() => {\n                  if (limitProbInt !== undefined) {\n                    setLimitProbInt(limitProbInt - 1)\n                  }\n                }}\n              >\n                -1\n              </button>\n              <button\n                className=\"hover:bg-ink-200 bg-canvas-100 rounded-md px-2 py-1.5 text-sm sm:px-3\"\n                onClick={() => {\n                  if (limitProbInt !== undefined) {\n                    setLimitProbInt(limitProbInt + 1)\n                  }\n                }}\n              >\n                +1\n              </button>\n              <button\n                className=\"hover:bg-ink-200 bg-canvas-100 rounded-md px-2 py-1.5 text-sm sm:px-3\"\n                onClick={() => {\n                  if (limitProbInt !== undefined) {\n                    setLimitProbInt(limitProbInt + 5)\n                  }\n                }}\n              >\n                +5\n              </button>\n            </Row>\n          </label>\n        </Row>\n\n        <ProbabilitySlider\n          prob={limitProbInt}\n          onProbChange={setLimitProbInt}\n          disabled={isSubmitting}\n          color={pseudonymColor}\n          outcome={isBinaryMC ? 'YES' : outcome}\n        />\n      </Col>\n\n      <Col className=\"mt-6 gap-2\">\n        <DropdownMenu\n          buttonContent={\n            <Row className=\"items-center gap-1\">\n              <span>\n                {expirationOptions.find(\n                  (opt) => opt.value === selectedExpiration\n                )?.label ?? expirationOptions[0].label}\n              </span>\n              <SelectorIcon className=\"text-ink-400 h-4 w-4\" />\n            </Row>\n          }\n          closeOnClick\n          items={expirationItems}\n          buttonClass=\"text-ink-600 hover:text-ink-900 p-0 bg-transparent\"\n          menuWidth=\"w-48\"\n        />\n\n        {addCustomExpiration && (\n          <Col className=\"gap-2\">\n            <Row className=\"gap-2\">\n              <Input\n                type={'date'}\n                className=\"dark:date-range-input-white\"\n                onClick={(e) => e.stopPropagation()}\n                onChange={(e) => {\n                  setExpirationDate(e.target.value)\n                  if (!expirationHoursMinutes) {\n                    setExpirationHoursMinutes(initTime)\n                  }\n                }}\n                min={dayjs().format('YYYY-MM-DD')}\n                max=\"9999-12-31\"\n                disabled={isSubmitting}\n                value={expirationDate}\n              />\n              <Input\n                type={'time'}\n                className=\"dark:date-range-input-white\"\n                onClick={(e) => e.stopPropagation()}\n                onChange={(e) => setExpirationHoursMinutes(e.target.value)}\n                disabled={isSubmitting}\n                value={expirationHoursMinutes}\n                step={60}\n              />\n            </Row>\n          </Col>\n        )}\n      </Col>\n\n      <Col className=\"mt-2 w-full gap-2\">\n        {outcome && hasLimitBet && filledAmount > 0 && (\n          <Row className=\"items-center justify-between gap-2 \">\n            <div className=\"text-ink-600 whitespace-nowrap\">\n              {isPseudoNumeric ? (\n                <PseudoNumericOutcomeLabel outcome={outcome} />\n              ) : (\n                !hideYesNo && <BinaryOutcomeLabel outcome={outcome} />\n              )}{' '}\n              {hideYesNo ? 'Filled' : 'filled'} now\n            </div>\n            <div className=\"whitespace-nowrap\">\n              <MoneyDisplay\n                amount={filledAmount}\n                isCashContract={isCashContract}\n              />{' '}\n              of{' '}\n              <MoneyDisplay\n                amount={orderAmount}\n                isCashContract={isCashContract}\n              />\n            </div>\n          </Row>\n        )}\n\n        {outcome && hasLimitBet && (\n          <Row className=\"mb-2 items-center justify-between gap-2\">\n            <Row className=\"text-ink-600 flex-nowrap items-center gap-2 whitespace-nowrap\">\n              <div>\n                {isPseudoNumeric ? (\n                  'Shares'\n                ) : (\n                  <>\n                    Max {!hideYesNo && <BinaryOutcomeLabel outcome={outcome} />}{' '}\n                    payout\n                    {isCashContract && (\n                      <InfoTooltip\n                        text=\"Manifold takes a 10% cut of profits on sweepstakes markets.\"\n                        className=\"text-ink-600 ml-1 mt-0.5\"\n                        size=\"sm\"\n                      />\n                    )}\n                  </>\n                )}\n              </div>\n            </Row>\n            <div>\n              <span className=\"mr-2 whitespace-nowrap\">\n                <MoneyDisplay\n                  amount={currentPayout}\n                  isCashContract={isCashContract}\n                />\n              </span>\n              ({returnPercent})\n            </div>\n          </Row>\n        )}\n\n        <Col className=\"gap-2\">\n          {user ? (\n            <>\n              <Row className=\"items-center justify-between gap-2\">\n                <Button\n                  size=\"xl\"\n                  disabled={betDisabled}\n                  color={\n                    (pseudonymColor as any) ??\n                    (hideYesNo ? 'none' : outcome === 'YES' ? 'green' : 'red')\n                  }\n                  loading={isSubmitting}\n                  className={clsx('flex-1 text-white')}\n                  style={{\n                    backgroundColor: binaryMCColors?.[outcome == 'YES' ? 0 : 1],\n                  }}\n                  onClick={submitBet}\n                >\n                  {isSubmitting ? (\n                    'Submitting...'\n                  ) : !outcome ? (\n                    'Choose YES or NO'\n                  ) : !limitProb ? (\n                    'Enter a probability'\n                  ) : !betAmount ? (\n                    'Enter an amount'\n                  ) : (\n                    <span>\n                      Buy{' '}\n                      <MoneyDisplay\n                        amount={betAmount}\n                        isCashContract={isCashContract}\n                      />{' '}\n                      {!binaryMCOutcome && !pseudonymName ? outcome : ''} at{' '}\n                      {formatPercent(\n                        binaryMCOutcome || pseudonymName\n                          ? preLimitProb ?? 0\n                          : limitProb\n                      )}\n                    </span>\n                  )}\n                </Button>\n              </Row>\n\n              {lastBetDetails && (\n                <Row className=\"bg-primary-100 mt-2 items-center justify-between rounded-lg p-3\">\n                  <Row className=\"items-baseline gap-2\">\n                    <span className=\"text-primary-700 text-sm \">\n                      {isSubmitting ? 'Placing trade...' : 'Trade successful!'}\n                    </span>\n                  </Row>\n                  <Button\n                    className=\"w-1/2\"\n                    color=\"gradient\"\n                    onClick={() => setIsSharing(true)}\n                  >\n                    <Row className=\"items-center gap-1.5\">\n                      <LuShare className=\"h-5 w-5\" aria-hidden />\n                      Share Bet\n                    </Row>\n                  </Button>\n                </Row>\n              )}\n\n              {lastBetDetails && isSharing && user && (\n                <ShareBetModal\n                  open={isSharing}\n                  setOpen={setIsSharing}\n                  questionText={contract.question}\n                  outcome={formatOutcomeLabel(\n                    contract,\n                    lastBetDetails.outcome as 'YES' | 'NO'\n                  )}\n                  answer={multiProps?.answerToBuy.text}\n                  avgPrice={formatPercent(lastBetDetails.limitProb ?? 0)}\n                  betAmount={\n                    lastBetDetails.orderAmount ?? lastBetDetails.amount\n                  }\n                  winAmount={\n                    lastBetDetails.limitProb !== undefined &&\n                    lastBetDetails.orderAmount !== undefined\n                      ? lastBetDetails.outcome === 'YES'\n                        ? lastBetDetails.orderAmount / lastBetDetails.limitProb\n                        : lastBetDetails.orderAmount /\n                          (1 - lastBetDetails.limitProb)\n                      : lastBetDetails.shares\n                  }\n                  bettor={{\n                    id: user.id,\n                    name: user.name,\n                    username: user.username,\n                    avatarUrl: user.avatarUrl,\n                  }}\n                  isLimitBet={true}\n                  orderAmount={lastBetDetails.orderAmount}\n                />\n              )}\n            </>\n          ) : (\n            <Button\n              color={outcome === 'NO' ? 'red' : 'green'}\n              size=\"xl\"\n              onClick={withTracking(firebaseLogin, 'login from bet panel', {\n                token: contract.token,\n              })}\n              className=\"mb-2 flex-grow\"\n            >\n              Sign up to {TRADE_TERM}\n            </Button>\n          )}\n        </Col>\n      </Col>\n    </>\n  )\n}\n"
        }
      ]
    },
    {
      "sha": "793b764a2b28fdfe5fda932f2caf0e58d96795bb",
      "author": "Ian Philips",
      "date": "2025-05-12 20:17:18 -0700",
      "message": "Commenting triggers a post follow",
      "stats": {
        "filesChanged": 3,
        "insertions": 19,
        "deletions": 6
      },
      "selectionReason": "Implements automatic following when commenting - a clear behavioral feature that connects user actions",
      "spec": "Modify the post commenting feature such that when a user adds a comment to a post, they are automatically made a follower of that post. Additionally, update the notification system's configuration: for the 'all_comments_on_followed_posts' notification type, set the action verb to 'commented'.",
      "fileStates": [
        {
          "path": "backend/api/src/create-post-comment.ts",
          "preContent": "import { APIError, APIHandler } from './helpers/endpoint'\nimport { PostComment } from 'common/comment'\nimport { createSupabaseDirectClient } from 'shared/supabase/init'\nimport { getUser, getPrivateUser, revalidateStaticProps } from 'shared/utils'\nimport { getPost } from 'shared/supabase/posts'\nimport { removeUndefinedProps } from 'common/util/object'\nimport { log } from 'shared/monitoring/log'\nimport { broadcastNewPostComment } from 'shared/websockets/helpers'\nimport { nanoid } from 'common/util/random'\nimport { isAdminId, isModId } from 'common/envs/constants'\nimport { updateData } from 'shared/supabase/utils'\nimport { compact } from 'lodash'\nimport { parseMentions } from 'common/util/parse'\nimport { createCommentOnPostNotification } from 'shared/notifications/create-new-contract-comment-notif'\nimport { TopLevelPost } from 'common/top-level-post'\n\nexport const createPostComment: APIHandler<'create-post-comment'> = async (\n  props,\n  auth\n) => {\n  const { postId, content, replyToCommentId } = props\n\n  const creator = await getUser(auth.uid)\n  if (!creator) throw new APIError(401, 'Your account was not found')\n  if (creator.isBannedFromPosting)\n    throw new APIError(403, 'You are banned from posting')\n  if (creator.userDeleted) throw new APIError(403, 'Your account is deleted')\n\n  const pg = createSupabaseDirectClient()\n  const post = await getPost(pg, postId)\n  if (!post) throw new APIError(404, 'Post not found')\n\n  // Check if commenter is blocked by post creator or has blocked post creator\n  const privateUser = await getPrivateUser(auth.uid)\n  if (!privateUser) throw new APIError(401, 'Private user data not found')\n\n  if (privateUser.blockedUserIds.includes(post.creatorId)) {\n    throw new APIError(403, `You have blocked the creator of this post`)\n  }\n  if (privateUser.blockedByUserIds.includes(post.creatorId)) {\n    throw new APIError(403, `You have been blocked by the creator of this post`)\n  }\n\n  const commentObjectForDataColumn: Omit<PostComment, 'createdTime'> = {\n    id: nanoid(8),\n    userId: creator.id,\n    content,\n    userName: creator.name,\n    userUsername: creator.username,\n    userAvatarUrl: creator.avatarUrl,\n    replyToCommentId,\n    visibility: post.visibility,\n    postId: post.id,\n    commentType: 'post',\n  }\n\n  const cleanedCommentData = removeUndefinedProps(commentObjectForDataColumn)\n\n  try {\n    const result = await pg.one(\n      `INSERT INTO old_post_comments (comment_id, post_id, user_id, data)\n       VALUES ($1, $2, $3, $4)\n       RETURNING comment_id, created_time, data`,\n      [commentObjectForDataColumn.id, post.id, creator.id, cleanedCommentData]\n    )\n\n    const comment: PostComment = {\n      ...(result.data as Omit<PostComment, 'id' | 'createdTime'>),\n      id: result.comment_id,\n      createdTime: new Date(result.created_time).getTime(),\n    }\n    broadcastNewPostComment(post.id, post.visibility, creator, comment)\n\n    return {\n      result: { comment },\n      continue: async () => {\n        await revalidatePost(post)\n        // Handle notifications\n        try {\n          let repliedUserId: string | undefined = undefined\n          if (comment.replyToCommentId) {\n            const repliedCommentData = await pg.oneOrNone<{\n              data: PostComment\n            }>(`SELECT data FROM old_post_comments WHERE comment_id = $1`, [\n              comment.replyToCommentId,\n            ])\n            if (repliedCommentData) {\n              repliedUserId = repliedCommentData.data.userId\n            }\n          }\n\n          const mentionedUserIds = compact(parseMentions(comment.content))\n\n          await createCommentOnPostNotification(\n            pg,\n            comment,\n            post,\n            creator,\n            repliedUserId,\n            mentionedUserIds\n          )\n        } catch (notificationError) {\n          log.error('Failed to send post comment notifications', {\n            error: notificationError,\n            postId: post.id,\n            commentId: comment.id,\n            creatorId: creator.id,\n          })\n        }\n      },\n    }\n  } catch (error) {\n    log.error('Failed to create post comment', {\n      error,\n      postId,\n      userId: creator.id,\n    })\n    throw new APIError(500, 'Failed to create comment')\n  }\n}\n\nexport const updatePostComment: APIHandler<'update-post-comment'> = async (\n  props,\n  auth\n) => {\n  const { commentId, postId, hidden } = props\n  if (!isAdminId(auth.uid) && !isModId(auth.uid))\n    throw new APIError(403, 'You are not authorized to update this comment')\n  const pg = createSupabaseDirectClient()\n  const comment = await pg.oneOrNone(\n    `SELECT data FROM old_post_comments WHERE comment_id = $1 AND post_id = $2`,\n    [commentId, postId],\n    (row) => row.data as PostComment\n  )\n  if (!comment) throw new APIError(404, 'Comment not found')\n\n  await updateData(pg, 'old_post_comments', 'comment_id', {\n    comment_id: commentId,\n    hidden,\n  })\n\n  return {\n    comment: {\n      ...comment,\n      hidden,\n    },\n  }\n}\n\nexport const revalidatePost = async (post: TopLevelPost) => {\n  // Revalidate the post page\n  const path = `/post/${post.slug}`\n  revalidateStaticProps(path)\n}\n",
          "postContent": "import { APIError, APIHandler } from './helpers/endpoint'\nimport { PostComment } from 'common/comment'\nimport { createSupabaseDirectClient } from 'shared/supabase/init'\nimport { getUser, getPrivateUser, revalidateStaticProps } from 'shared/utils'\nimport { getPost } from 'shared/supabase/posts'\nimport { removeUndefinedProps } from 'common/util/object'\nimport { log } from 'shared/monitoring/log'\nimport { broadcastNewPostComment } from 'shared/websockets/helpers'\nimport { nanoid } from 'common/util/random'\nimport { isAdminId, isModId } from 'common/envs/constants'\nimport { updateData } from 'shared/supabase/utils'\nimport { compact } from 'lodash'\nimport { parseMentions } from 'common/util/parse'\nimport { createCommentOnPostNotification } from 'shared/notifications/create-new-contract-comment-notif'\nimport { TopLevelPost } from 'common/top-level-post'\nimport { followPostInternal } from './follow-post'\nexport const createPostComment: APIHandler<'create-post-comment'> = async (\n  props,\n  auth\n) => {\n  const { postId, content, replyToCommentId } = props\n\n  const creator = await getUser(auth.uid)\n  if (!creator) throw new APIError(401, 'Your account was not found')\n  if (creator.isBannedFromPosting)\n    throw new APIError(403, 'You are banned from posting')\n  if (creator.userDeleted) throw new APIError(403, 'Your account is deleted')\n\n  const pg = createSupabaseDirectClient()\n  const post = await getPost(pg, postId)\n  if (!post) throw new APIError(404, 'Post not found')\n\n  // Check if commenter is blocked by post creator or has blocked post creator\n  const privateUser = await getPrivateUser(auth.uid)\n  if (!privateUser) throw new APIError(401, 'Private user data not found')\n\n  if (privateUser.blockedUserIds.includes(post.creatorId)) {\n    throw new APIError(403, `You have blocked the creator of this post`)\n  }\n  if (privateUser.blockedByUserIds.includes(post.creatorId)) {\n    throw new APIError(403, `You have been blocked by the creator of this post`)\n  }\n\n  const commentObjectForDataColumn: Omit<PostComment, 'createdTime'> = {\n    id: nanoid(8),\n    userId: creator.id,\n    content,\n    userName: creator.name,\n    userUsername: creator.username,\n    userAvatarUrl: creator.avatarUrl,\n    replyToCommentId,\n    visibility: post.visibility,\n    postId: post.id,\n    commentType: 'post',\n  }\n\n  const cleanedCommentData = removeUndefinedProps(commentObjectForDataColumn)\n\n  try {\n    const result = await pg.one(\n      `INSERT INTO old_post_comments (comment_id, post_id, user_id, data)\n       VALUES ($1, $2, $3, $4)\n       RETURNING comment_id, created_time, data`,\n      [commentObjectForDataColumn.id, post.id, creator.id, cleanedCommentData]\n    )\n\n    const comment: PostComment = {\n      ...(result.data as Omit<PostComment, 'id' | 'createdTime'>),\n      id: result.comment_id,\n      createdTime: new Date(result.created_time).getTime(),\n    }\n    broadcastNewPostComment(post.id, post.visibility, creator, comment)\n\n    return {\n      result: { comment },\n      continue: async () => {\n        await followPostInternal(pg, post.id, creator.id)\n        await revalidatePost(post)\n        // Handle notifications\n        try {\n          let repliedUserId: string | undefined = undefined\n          if (comment.replyToCommentId) {\n            const repliedCommentData = await pg.oneOrNone<{\n              data: PostComment\n            }>(`SELECT data FROM old_post_comments WHERE comment_id = $1`, [\n              comment.replyToCommentId,\n            ])\n            if (repliedCommentData) {\n              repliedUserId = repliedCommentData.data.userId\n            }\n          }\n\n          const mentionedUserIds = compact(parseMentions(comment.content))\n\n          await createCommentOnPostNotification(\n            pg,\n            comment,\n            post,\n            creator,\n            repliedUserId,\n            mentionedUserIds\n          )\n        } catch (notificationError) {\n          log.error('Failed to send post comment notifications', {\n            error: notificationError,\n            postId: post.id,\n            commentId: comment.id,\n            creatorId: creator.id,\n          })\n        }\n      },\n    }\n  } catch (error) {\n    log.error('Failed to create post comment', {\n      error,\n      postId,\n      userId: creator.id,\n    })\n    throw new APIError(500, 'Failed to create comment')\n  }\n}\n\nexport const updatePostComment: APIHandler<'update-post-comment'> = async (\n  props,\n  auth\n) => {\n  const { commentId, postId, hidden } = props\n  if (!isAdminId(auth.uid) && !isModId(auth.uid))\n    throw new APIError(403, 'You are not authorized to update this comment')\n  const pg = createSupabaseDirectClient()\n  const comment = await pg.oneOrNone(\n    `SELECT data FROM old_post_comments WHERE comment_id = $1 AND post_id = $2`,\n    [commentId, postId],\n    (row) => row.data as PostComment\n  )\n  if (!comment) throw new APIError(404, 'Comment not found')\n\n  await updateData(pg, 'old_post_comments', 'comment_id', {\n    comment_id: commentId,\n    hidden,\n  })\n\n  return {\n    comment: {\n      ...comment,\n      hidden,\n    },\n  }\n}\n\nexport const revalidatePost = async (post: TopLevelPost) => {\n  // Revalidate the post page\n  const path = `/post/${post.slug}`\n  revalidateStaticProps(path)\n}\n"
        },
        {
          "path": "backend/api/src/follow-post.ts",
          "preContent": "import { APIError, APIHandler } from './helpers/endpoint'\nimport { createSupabaseDirectClient } from 'shared/supabase/init'\nimport { log } from 'shared/monitoring/log'\n\nexport const followPost: APIHandler<'follow-post'> = async (props, auth) => {\n  const { postId, follow } = props\n  const userId = auth.uid\n\n  const pg = createSupabaseDirectClient()\n\n  try {\n    if (follow) {\n      // Add a new follow relationship\n      await pg.none(\n        'INSERT INTO post_follows (post_id, user_id) VALUES ($1, $2) ON CONFLICT (post_id, user_id) DO NOTHING',\n        [postId, userId]\n      )\n    } else {\n      // Remove the follow relationship\n      await pg.none(\n        'DELETE FROM post_follows WHERE post_id = $1 AND user_id = $2',\n        [postId, userId]\n      )\n    }\n\n    // We could potentially broadcast this change via websockets if live updates on the button are needed immediately for other users viewing the same post.\n    // For now, the button's local state handles the immediate feedback for the acting user.\n\n    return { success: true }\n  } catch (error) {\n    log.error('Failed to update post follow status', {\n      error,\n      postId,\n      userId,\n      follow,\n    })\n    throw new APIError(500, 'Failed to update post follow status')\n  }\n}\n",
          "postContent": "import { APIError, APIHandler } from './helpers/endpoint'\nimport {\n  createSupabaseDirectClient,\n  SupabaseDirectClient,\n} from 'shared/supabase/init'\nimport { log } from 'shared/monitoring/log'\n\nexport const followPost: APIHandler<'follow-post'> = async (props, auth) => {\n  const { postId, follow } = props\n  const userId = auth.uid\n\n  const pg = createSupabaseDirectClient()\n\n  try {\n    if (follow) {\n      // Add a new follow relationship\n      await followPostInternal(pg, postId, userId)\n    } else {\n      // Remove the follow relationship\n      await pg.none(\n        'DELETE FROM post_follows WHERE post_id = $1 AND user_id = $2',\n        [postId, userId]\n      )\n    }\n\n    // We could potentially broadcast this change via websockets if live updates on the button are needed immediately for other users viewing the same post.\n    // For now, the button's local state handles the immediate feedback for the acting user.\n\n    return { success: true }\n  } catch (error) {\n    log.error('Failed to update post follow status', {\n      error,\n      postId,\n      userId,\n      follow,\n    })\n    throw new APIError(500, 'Failed to update post follow status')\n  }\n}\n\nexport const followPostInternal = async (\n  pg: SupabaseDirectClient,\n  postId: string,\n  userId: string\n) => {\n  await pg.none(\n    'INSERT INTO post_follows (post_id, user_id) VALUES ($1, $2) ON CONFLICT (post_id, user_id) DO NOTHING',\n    [postId, userId]\n  )\n}\n"
        },
        {
          "path": "common/src/notification.ts",
          "preContent": "import { ContractToken, OutcomeType } from 'common/contract'\nimport { groupPath } from './group'\nimport { PAST_BET } from './user'\nimport { notification_preference } from './user-notification-preferences'\nimport { Bet } from 'common/bet'\nimport { league_user_info } from './leagues'\nimport { groupBy } from 'lodash'\n\nexport type NotificationGroup = {\n  notifications: Notification[]\n  groupedById: string\n  isSeen: boolean\n  latestCreatedTime: number\n}\n\nexport type Notification = {\n  id: string\n  userId: string\n  reasonText?: string\n  reason: NotificationReason\n  createdTime: number\n  viewTime?: number\n  isSeen: boolean\n\n  sourceId: string\n  sourceType: notification_source_types\n  sourceUpdateType?: notification_source_update_types\n\n  // sourceContractId is used to group notifications on the same contract together\n  sourceContractId?: string\n  sourceUserName: string\n  sourceUserUsername: string\n  sourceUserAvatarUrl: string\n  sourceText: string\n  data?: { [key: string]: any }\n\n  sourceContractTitle?: string\n  sourceContractCreatorUsername?: string\n  sourceContractSlug?: string\n\n  sourceSlug?: string\n  sourceTitle?: string\n\n  isSeenOnHref?: string\n  markedAsRead?: boolean\n}\n\nexport type NotificationReason =\n  | notification_reason_types\n  | notification_preference\n\nexport type notification_source_types =\n  | 'contract'\n  | 'comment'\n  | 'bet'\n  | 'answer'\n  | 'liquidity'\n  | 'follow'\n  | 'tip'\n  | 'admin_message'\n  | 'group'\n  | 'user'\n  | 'bonus' // strictly unique bettor bonuses atm\n  | 'challenge'\n  | 'betting_streak_bonus'\n  | 'betting_streak_expiring'\n  | 'loan'\n  | 'tip_and_like'\n  | 'badge'\n  | 'signup_bonus'\n  | 'comment_like'\n  | 'contract_like'\n  | 'weekly_portfolio_update'\n  | 'quest_reward'\n  | 'league_change'\n  | 'bounty_added'\n  | 'mana_payment'\n  | 'referral_program'\n  | 'follow_suggestion'\n  | 'market_review'\n  | 'comment_on_lover'\n  | 'new_match'\n  | 'bet_reply'\n  | 'new_message'\n  | 'post'\n  | 'post_like'\n  | 'post_comment_like'\n  | love_notification_source_types\n  | 'push_notification_bonus'\n  | 'airdrop'\n  | 'manifest_airdrop'\n  | 'extra_purchased_mana'\n  | 'payment_status'\n\nexport type love_notification_source_types =\n  | 'love_contract'\n  | 'love_comment'\n  | 'love_answer'\n  | 'love_like'\n  | 'love_ship'\n\nexport type notification_source_update_types =\n  | 'created'\n  | 'updated'\n  | 'resolved'\n  | 'deleted'\n  | 'closed'\n  | 'canceled'\n  | 'expired'\n\n/** @deprecated - use a notification_preference (in user-notification-preferences.ts) */\nexport type notification_reason_types =\n  | 'on_new_follow'\n  | 'contract_from_followed_user'\n  | 'you_referred_user'\n  | 'user_joined_to_bet_on_your_market'\n  | 'bet_fill'\n  | 'limit_order_cancelled'\n  | 'user_joined_from_your_group_invite'\n  | 'betting_streak_incremented'\n  | 'loan_income'\n  | 'comment_on_your_contract'\n  | 'answer_on_your_contract'\n  | 'comment_on_contract_you_follow'\n  | 'answer_on_contract_you_follow'\n  | 'update_on_contract_you_follow'\n  | 'resolution_on_contract_you_follow'\n  | 'comment_on_contract_with_users_shares_in'\n  | 'update_on_contract_with_users_shares_in'\n  | 'resolution_on_contract_with_users_shares_in'\n  | 'comment_on_contract_with_users_answer'\n  | 'update_on_contract_with_users_answer'\n  | 'resolution_on_contract_with_users_answer'\n  | 'answer_on_contract_with_users_answer'\n  | 'comment_on_contract_with_users_comment'\n  | 'answer_on_contract_with_users_comment'\n  | 'update_on_contract_with_users_comment'\n  | 'resolution_on_contract_with_users_comment'\n  | 'reply_to_users_answer'\n  | 'reply_to_users_comment'\n  | 'your_contract_closed'\n  | 'subsidized_your_market'\n  | 'bounty_awarded'\n  | 'bounty_added'\n  | 'bounty_canceled'\n  | 'mana_payment_received'\n\ntype notification_descriptions = {\n  [key in notification_preference]: {\n    simple: string\n    detailed: string\n    necessary?: boolean\n    verb?: string\n  }\n}\nexport const NOTIFICATION_DESCRIPTIONS: notification_descriptions = {\n  all_answers_on_my_markets: {\n    simple: 'Answers on your questions',\n    detailed: 'Answers on your own questions',\n    verb: 'answered your question',\n  },\n  all_comments_on_my_markets: {\n    simple: 'Comments on your questions',\n    detailed: 'Comments on your own questions',\n    verb: 'commented on your market',\n  },\n  betting_streaks: {\n    simple: `Prediction streak bonuses & expirations`,\n    detailed: `Bonuses and expiration notices for prediction streaks made over consecutive days`,\n  },\n  all_answers_on_watched_markets: {\n    simple: 'All new answers',\n    detailed: \"All new answers on questions you're watching\",\n  },\n  quest_payout: {\n    simple: `Quest completion rewards`,\n    detailed: `Bonuses paid out for completing quests`,\n  },\n  contract_from_followed_user: {\n    simple: 'New questions from users you follow',\n    detailed: 'New questions from users you follow',\n  },\n  limit_order_fills: {\n    simple: 'Limit order fills, expirations, and cancellations',\n    detailed: 'When your limit order fills, cancels, or expires',\n  },\n  loan_income: {\n    simple: 'Automatic loans from your predictions in unresolved questions',\n    detailed:\n      'Automatic loans from your predictions that are locked in unresolved questions',\n  },\n\n  on_new_follow: {\n    simple: 'A user followed you',\n    detailed: 'A user followed you',\n  },\n  onboarding_flow: {\n    simple: 'Emails to help you get started using Manifold',\n    detailed: 'Emails to help you learn how to use Manifold',\n  },\n  probability_updates_on_watched_markets: {\n    simple: 'Large changes in probability on questions that you watch',\n    detailed: 'Large changes in probability on questions that you watch',\n  },\n  profit_loss_updates: {\n    simple: 'Weekly portfolio updates',\n    detailed: 'Weekly portfolio updates',\n  },\n  referral_bonuses: {\n    simple: 'Referring new users',\n    detailed: 'Bonuses you receive from referring a new user',\n  },\n  resolutions_on_watched_markets: {\n    simple: 'All question resolutions',\n    detailed: \"All resolutions on questions that you're watching\",\n  },\n  resolutions_on_watched_markets_with_shares_in: {\n    simple: `Only question resolutions that you've ${PAST_BET}`,\n    detailed: `Only resolutions of questions you're watching and that you've ${PAST_BET}`,\n  },\n  subsidized_your_market: {\n    simple: 'Your question was subsidized',\n    detailed: 'When someone subsidizes your market',\n  },\n  tagged_user: {\n    simple: 'A user tagged you',\n    detailed: 'When another use tags you',\n    verb: 'tagged you',\n  },\n  league_changed: {\n    simple: 'Your league changed',\n    detailed: 'When you join, move up, or move down a league',\n  },\n  thank_you_for_purchases: {\n    simple: 'Thank you notes for your purchases',\n    detailed: 'Thank you notes for your purchases',\n  },\n  trending_markets: {\n    simple: 'Weekly interesting questions',\n    detailed: 'Weekly interesting questions',\n  },\n  unique_bettors_on_your_contract: {\n    simple: 'Unique predictors on your questions',\n    detailed: 'Bonuses for unique predictors on your questions',\n  },\n  your_contract_closed: {\n    simple: 'Your question has closed and you need to resolve it (necessary)',\n    detailed: 'Your question has closed and you need to resolve it (necessary)',\n    necessary: true,\n  },\n  all_comments_on_watched_markets: {\n    simple: 'All new comments',\n    detailed: 'All new comments on questions you follow',\n  },\n  all_comments_on_contracts_with_shares_in_on_watched_markets: {\n    simple: `Only on questions you've ${PAST_BET}`,\n    detailed: `Comments on questions that you're watching and you've ${PAST_BET}`,\n  },\n  all_replies_to_my_comments_on_watched_markets: {\n    simple: 'Only replies to your comments',\n    detailed: \"Only replies to your comments on questions you're watching\",\n    verb: 'replied to you',\n  },\n  all_replies_to_my_answers_on_watched_markets: {\n    simple: 'Only replies to your answers',\n    detailed: \"Only replies to your answers on questions you're watching\",\n    verb: 'replied to you',\n  },\n  opt_out_all: {\n    simple: 'Opt out of all notifications (excludes when your questions close)',\n    detailed:\n      'Opt out of all notifications excluding your own question closure notifications',\n  },\n  user_liked_your_content: {\n    simple: 'A user liked your content',\n    detailed: 'A user liked your comment, market, or other content',\n  },\n  bounty_awarded: {\n    simple: 'Bounties you receive',\n    detailed: 'When the creator awards you a bounty for your comment',\n  },\n  bounty_added: {\n    simple: 'Bounties added to your question',\n    detailed: 'When another user adds a bounty to your question',\n  },\n  bounty_canceled: {\n    simple: 'A bounty you follow is canceled',\n    detailed: 'When the creator of a bounty cancels it',\n  },\n  all_votes_on_watched_markets: {\n    simple: 'Votes on polls you follow',\n    detailed: 'When a user votes on a poll you follow',\n  },\n  vote_on_your_contract: {\n    simple: 'Votes on your polls',\n    detailed: 'When a user votes on a poll you created',\n  },\n  poll_close_on_watched_markets: {\n    simple: 'Polls you follow close',\n    detailed: 'When a poll you follow closes',\n  },\n  your_poll_closed: {\n    simple: 'Your poll closes',\n    detailed: 'When a poll you created closes',\n  },\n  review_on_your_market: {\n    simple: 'Reviews on your questions',\n    detailed: 'When a user reviews your question after resolution',\n  },\n  new_match: {\n    simple: 'New matches',\n    detailed: 'When you match with another user',\n  },\n  new_message: {\n    simple: 'New messages',\n    detailed: 'When another user messages you',\n  },\n  new_endorsement: {\n    simple: 'New endorsements',\n    detailed: 'When another user endorses you',\n  },\n  new_love_like: {\n    simple: 'New likes',\n    detailed: 'When another user likes you',\n  },\n  new_love_ship: {\n    simple: 'New ships',\n    detailed:\n      'When another user supports a relationship between you and someone else',\n  },\n  airdrop: {\n    simple: 'You received a gift of mana',\n    detailed: 'Manifold has sent you a gift of mana',\n  },\n  manifest_airdrop: {\n    simple: 'You received a gift for attending Manifest',\n    detailed: 'Manifold has sent you a gift for attending Manifest',\n  },\n  extra_purchased_mana: {\n    simple: 'You just received 9x your purchased mana in 2024',\n    detailed: 'Manifold has sent you a gift of 9x your purchased mana in 2024.',\n  },\n  payment_status: {\n    simple: 'Payment updates',\n    detailed: 'Updates on your payment statuses',\n  },\n  market_movements: {\n    simple: 'Market movements',\n    detailed:\n      'When the probability of a market that you follow changes by a large amount',\n  },\n  market_follows: {\n    simple: 'Someone followed your market',\n    detailed: 'Get notified when someone follows one of your markets',\n    verb: 'followed your market',\n  },\n  admin: {\n    simple: 'Admin notifications',\n    detailed: 'Notifications from the Manifold team',\n  },\n  all_comments_on_followed_posts: {\n    simple: 'All new comments on posts you follow',\n    detailed: 'All new comments on posts you follow',\n  },\n}\n\nexport type BettingStreakData = {\n  streak: number\n  bonusAmount: number\n  cashAmount?: number\n}\nexport type LeagueChangeData = {\n  previousLeague: league_user_info | undefined\n  newLeague: { season: number; division: number; cohort: string }\n  bonusAmount: number\n}\n\nexport type BetFillData = {\n  betAnswer?: string\n  creatorOutcome: string\n  probability: number\n  limitOrderTotal?: number\n  limitOrderRemaining?: number\n  limitAt?: string\n  mechanism: 'cpmm-1' | 'cpmm-multi-1'\n  outcomeType: OutcomeType\n  betAnswerId?: string\n  expiresAt?: number\n  createdTime?: number\n}\n\nexport type ContractResolutionData = {\n  outcome: string\n  userPayout: number\n  userInvestment: number\n  profitRank?: number\n  totalShareholders?: number\n  profit?: number\n  answerId?: string\n  token?: ContractToken\n}\n\nexport type UniqueBettorData = {\n  bet: Bet\n  outcomeType: OutcomeType\n  answerText?: string\n  min?: number\n  max?: number\n  isLogScale?: boolean\n  isPartner?: boolean\n  totalUniqueBettors?: number\n  totalAmountBet?: number\n  token?: ContractToken\n  bonusAmount?: number\n}\n\nexport type ReviewNotificationData = {\n  rating: number\n  review: string\n}\n\nexport type CommentNotificationData = {\n  isReply: boolean\n}\n\nexport type BetReplyNotificationData = {\n  betAmount: number\n  betOutcome: string\n  commentText: string\n}\n\nexport type MarketMovementData = {\n  val_start: number\n  val_end: number\n  val_start_time: string\n  val_end_time: string\n  answerText?: string\n}\n\nexport type AirdropData = {\n  amount: number\n}\n\nexport type ManaPaymentData = {\n  message: string\n  token?: 'M$' | 'CASH'\n}\n\nexport type ExtraPurchasedManaData = {\n  amount: number\n}\n\nexport type PaymentCompletedData = {\n  userId: string\n  amount: number\n  currency: string\n  paymentMethodType: string\n  paymentAmountType: string\n}\n\nexport type ReferralData = {\n  manaAmount: number\n  cashAmount: number\n}\n\nexport function getSourceIdForLinkComponent(\n  sourceId: string,\n  sourceType?: notification_source_types\n) {\n  switch (sourceType) {\n    case 'answer':\n      return `answer-${sourceId}`\n    case 'comment':\n      return sourceId\n    case 'contract':\n      return ''\n    case 'bet':\n      return ''\n    default:\n      return sourceId\n  }\n}\n\nexport function getSourceUrl(notification: Notification) {\n  const {\n    sourceType,\n    sourceId,\n    sourceUserUsername,\n    sourceContractCreatorUsername,\n    sourceContractSlug,\n    sourceSlug,\n    reason,\n  } = notification\n\n  if (sourceType === 'weekly_portfolio_update')\n    return `/week/${sourceUserUsername}/${sourceSlug}`\n  if (reason === 'market_follows')\n    return `/${sourceContractCreatorUsername}/${sourceContractSlug}`\n  if (sourceType === 'follow') return `/${sourceUserUsername}`\n  if (sourceType === 'group' && sourceSlug) return `${groupPath(sourceSlug)}`\n  // User referral via contract:\n  if (\n    sourceContractCreatorUsername &&\n    sourceContractSlug &&\n    sourceType === 'user'\n  )\n    return `/${sourceContractCreatorUsername}/${sourceContractSlug}`\n  // User referral:\n  if (sourceType === 'user' && !sourceContractSlug)\n    return `/${sourceUserUsername}`\n  if (\n    sourceType === 'challenge' ||\n    ReactionNotificationTypes.includes(sourceType)\n  )\n    return `${sourceSlug}`\n  if (sourceContractCreatorUsername && sourceContractSlug) {\n    return `/${sourceContractCreatorUsername}/${sourceContractSlug}#${getSourceIdForLinkComponent(\n      sourceId ?? '',\n      sourceType\n    )}`\n  }\n  if (sourceSlug) {\n    return `${\n      sourceSlug.startsWith('/') ? sourceSlug : '/' + sourceSlug\n    }#${getSourceIdForLinkComponent(sourceId ?? '', sourceType)}`\n  }\n  return ''\n}\n\nexport const ReactionNotificationTypes: Partial<notification_source_types>[] = [\n  'comment_like',\n  'contract_like',\n  'post_like',\n  'post_comment_like',\n]\n\nexport const BalanceChangeNotificationTypes: NotificationReason[] = [\n  'loan_income',\n  // bonuses\n  'betting_streak_incremented',\n  'unique_bettors_on_your_contract',\n  // resolutions\n  'resolution_on_contract_with_users_shares_in',\n  'resolutions_on_watched_markets_with_shares_in',\n  // referrals\n  'you_referred_user',\n  'user_joined_to_bet_on_your_market',\n  'user_joined_from_your_group_invite',\n  'quest_payout',\n  'bet_fill',\n  'mana_payment_received',\n]\n\nexport const DELETE_PUSH_TOKEN = 'delete'\n\nexport function combineReactionNotifications(notifications: Notification[]) {\n  const groupedNotificationsBySourceType = groupBy(\n    notifications,\n    (n) =>\n      `${n.sourceType}-${\n        n.sourceTitle ?? n.sourceContractTitle ?? n.sourceContractId\n      }-${n.sourceText}`\n  )\n\n  const newNotifications = Object.values(groupedNotificationsBySourceType).map(\n    (notifications) => {\n      const mostRecentNotification = notifications[0]\n\n      return {\n        ...mostRecentNotification,\n        data: {\n          ...mostRecentNotification.data,\n          relatedNotifications: notifications,\n        },\n      }\n    }\n  )\n\n  return newNotifications as Notification[]\n}\n\n// Loop through the contracts and combine the notification items into one\nexport function combineAndSumIncomeNotifications(\n  notifications: Notification[]\n) {\n  const newNotifications: Notification[] = []\n  const groupedNotificationsBySourceType = groupBy(\n    notifications,\n    (n) => n.sourceType\n  )\n  const titleForNotification = (notification: Notification) => {\n    const outcomeType = notification.data?.outcomeType\n    return (\n      (notification.sourceTitle ?? notification.sourceContractTitle) +\n      (outcomeType !== 'NUMBER' ? notification.data?.answerText ?? '' : '') +\n      notification.data?.isPartner\n    )\n  }\n\n  for (const sourceType in groupedNotificationsBySourceType) {\n    // Source title splits by contracts, groups, betting streak bonus\n    const groupedNotificationsBySourceTitle = groupBy(\n      groupedNotificationsBySourceType[sourceType],\n      (notification) => titleForNotification(notification)\n    )\n    for (const sourceTitle in groupedNotificationsBySourceTitle) {\n      const notificationsForSourceTitle =\n        groupedNotificationsBySourceTitle[sourceTitle]\n\n      let sum = 0\n      notificationsForSourceTitle.forEach((notification) => {\n        sum += parseFloat(notification.sourceText ?? '0')\n      })\n\n      const { bet: _, ...otherData } =\n        notificationsForSourceTitle[0]?.data ?? {}\n\n      const newNotification = {\n        ...notificationsForSourceTitle[0],\n        sourceText: sum.toString(),\n        sourceUserUsername: notificationsForSourceTitle[0].sourceUserUsername,\n        data: {\n          relatedNotifications: notificationsForSourceTitle,\n          ...otherData,\n        },\n      }\n      newNotifications.push(newNotification)\n    }\n  }\n  return newNotifications\n}\n",
          "postContent": "import { ContractToken, OutcomeType } from 'common/contract'\nimport { groupPath } from './group'\nimport { PAST_BET } from './user'\nimport { notification_preference } from './user-notification-preferences'\nimport { Bet } from 'common/bet'\nimport { league_user_info } from './leagues'\nimport { groupBy } from 'lodash'\n\nexport type NotificationGroup = {\n  notifications: Notification[]\n  groupedById: string\n  isSeen: boolean\n  latestCreatedTime: number\n}\n\nexport type Notification = {\n  id: string\n  userId: string\n  reasonText?: string\n  reason: NotificationReason\n  createdTime: number\n  viewTime?: number\n  isSeen: boolean\n\n  sourceId: string\n  sourceType: notification_source_types\n  sourceUpdateType?: notification_source_update_types\n\n  // sourceContractId is used to group notifications on the same contract together\n  sourceContractId?: string\n  sourceUserName: string\n  sourceUserUsername: string\n  sourceUserAvatarUrl: string\n  sourceText: string\n  data?: { [key: string]: any }\n\n  sourceContractTitle?: string\n  sourceContractCreatorUsername?: string\n  sourceContractSlug?: string\n\n  sourceSlug?: string\n  sourceTitle?: string\n\n  isSeenOnHref?: string\n  markedAsRead?: boolean\n}\n\nexport type NotificationReason =\n  | notification_reason_types\n  | notification_preference\n\nexport type notification_source_types =\n  | 'contract'\n  | 'comment'\n  | 'bet'\n  | 'answer'\n  | 'liquidity'\n  | 'follow'\n  | 'tip'\n  | 'admin_message'\n  | 'group'\n  | 'user'\n  | 'bonus' // strictly unique bettor bonuses atm\n  | 'challenge'\n  | 'betting_streak_bonus'\n  | 'betting_streak_expiring'\n  | 'loan'\n  | 'tip_and_like'\n  | 'badge'\n  | 'signup_bonus'\n  | 'comment_like'\n  | 'contract_like'\n  | 'weekly_portfolio_update'\n  | 'quest_reward'\n  | 'league_change'\n  | 'bounty_added'\n  | 'mana_payment'\n  | 'referral_program'\n  | 'follow_suggestion'\n  | 'market_review'\n  | 'comment_on_lover'\n  | 'new_match'\n  | 'bet_reply'\n  | 'new_message'\n  | 'post'\n  | 'post_like'\n  | 'post_comment_like'\n  | love_notification_source_types\n  | 'push_notification_bonus'\n  | 'airdrop'\n  | 'manifest_airdrop'\n  | 'extra_purchased_mana'\n  | 'payment_status'\n\nexport type love_notification_source_types =\n  | 'love_contract'\n  | 'love_comment'\n  | 'love_answer'\n  | 'love_like'\n  | 'love_ship'\n\nexport type notification_source_update_types =\n  | 'created'\n  | 'updated'\n  | 'resolved'\n  | 'deleted'\n  | 'closed'\n  | 'canceled'\n  | 'expired'\n\n/** @deprecated - use a notification_preference (in user-notification-preferences.ts) */\nexport type notification_reason_types =\n  | 'on_new_follow'\n  | 'contract_from_followed_user'\n  | 'you_referred_user'\n  | 'user_joined_to_bet_on_your_market'\n  | 'bet_fill'\n  | 'limit_order_cancelled'\n  | 'user_joined_from_your_group_invite'\n  | 'betting_streak_incremented'\n  | 'loan_income'\n  | 'comment_on_your_contract'\n  | 'answer_on_your_contract'\n  | 'comment_on_contract_you_follow'\n  | 'answer_on_contract_you_follow'\n  | 'update_on_contract_you_follow'\n  | 'resolution_on_contract_you_follow'\n  | 'comment_on_contract_with_users_shares_in'\n  | 'update_on_contract_with_users_shares_in'\n  | 'resolution_on_contract_with_users_shares_in'\n  | 'comment_on_contract_with_users_answer'\n  | 'update_on_contract_with_users_answer'\n  | 'resolution_on_contract_with_users_answer'\n  | 'answer_on_contract_with_users_answer'\n  | 'comment_on_contract_with_users_comment'\n  | 'answer_on_contract_with_users_comment'\n  | 'update_on_contract_with_users_comment'\n  | 'resolution_on_contract_with_users_comment'\n  | 'reply_to_users_answer'\n  | 'reply_to_users_comment'\n  | 'your_contract_closed'\n  | 'subsidized_your_market'\n  | 'bounty_awarded'\n  | 'bounty_added'\n  | 'bounty_canceled'\n  | 'mana_payment_received'\n\ntype notification_descriptions = {\n  [key in notification_preference]: {\n    simple: string\n    detailed: string\n    necessary?: boolean\n    verb?: string\n  }\n}\nexport const NOTIFICATION_DESCRIPTIONS: notification_descriptions = {\n  all_answers_on_my_markets: {\n    simple: 'Answers on your questions',\n    detailed: 'Answers on your own questions',\n    verb: 'answered your question',\n  },\n  all_comments_on_my_markets: {\n    simple: 'Comments on your questions',\n    detailed: 'Comments on your own questions',\n    verb: 'commented on your market',\n  },\n  betting_streaks: {\n    simple: `Prediction streak bonuses & expirations`,\n    detailed: `Bonuses and expiration notices for prediction streaks made over consecutive days`,\n  },\n  all_answers_on_watched_markets: {\n    simple: 'All new answers',\n    detailed: \"All new answers on questions you're watching\",\n  },\n  quest_payout: {\n    simple: `Quest completion rewards`,\n    detailed: `Bonuses paid out for completing quests`,\n  },\n  contract_from_followed_user: {\n    simple: 'New questions from users you follow',\n    detailed: 'New questions from users you follow',\n  },\n  limit_order_fills: {\n    simple: 'Limit order fills, expirations, and cancellations',\n    detailed: 'When your limit order fills, cancels, or expires',\n  },\n  loan_income: {\n    simple: 'Automatic loans from your predictions in unresolved questions',\n    detailed:\n      'Automatic loans from your predictions that are locked in unresolved questions',\n  },\n\n  on_new_follow: {\n    simple: 'A user followed you',\n    detailed: 'A user followed you',\n  },\n  onboarding_flow: {\n    simple: 'Emails to help you get started using Manifold',\n    detailed: 'Emails to help you learn how to use Manifold',\n  },\n  probability_updates_on_watched_markets: {\n    simple: 'Large changes in probability on questions that you watch',\n    detailed: 'Large changes in probability on questions that you watch',\n  },\n  profit_loss_updates: {\n    simple: 'Weekly portfolio updates',\n    detailed: 'Weekly portfolio updates',\n  },\n  referral_bonuses: {\n    simple: 'Referring new users',\n    detailed: 'Bonuses you receive from referring a new user',\n  },\n  resolutions_on_watched_markets: {\n    simple: 'All question resolutions',\n    detailed: \"All resolutions on questions that you're watching\",\n  },\n  resolutions_on_watched_markets_with_shares_in: {\n    simple: `Only question resolutions that you've ${PAST_BET}`,\n    detailed: `Only resolutions of questions you're watching and that you've ${PAST_BET}`,\n  },\n  subsidized_your_market: {\n    simple: 'Your question was subsidized',\n    detailed: 'When someone subsidizes your market',\n  },\n  tagged_user: {\n    simple: 'A user tagged you',\n    detailed: 'When another use tags you',\n    verb: 'tagged you',\n  },\n  league_changed: {\n    simple: 'Your league changed',\n    detailed: 'When you join, move up, or move down a league',\n  },\n  thank_you_for_purchases: {\n    simple: 'Thank you notes for your purchases',\n    detailed: 'Thank you notes for your purchases',\n  },\n  trending_markets: {\n    simple: 'Weekly interesting questions',\n    detailed: 'Weekly interesting questions',\n  },\n  unique_bettors_on_your_contract: {\n    simple: 'Unique predictors on your questions',\n    detailed: 'Bonuses for unique predictors on your questions',\n  },\n  your_contract_closed: {\n    simple: 'Your question has closed and you need to resolve it (necessary)',\n    detailed: 'Your question has closed and you need to resolve it (necessary)',\n    necessary: true,\n  },\n  all_comments_on_watched_markets: {\n    simple: 'All new comments',\n    detailed: 'All new comments on questions you follow',\n  },\n  all_comments_on_contracts_with_shares_in_on_watched_markets: {\n    simple: `Only on questions you've ${PAST_BET}`,\n    detailed: `Comments on questions that you're watching and you've ${PAST_BET}`,\n  },\n  all_replies_to_my_comments_on_watched_markets: {\n    simple: 'Only replies to your comments',\n    detailed: \"Only replies to your comments on questions you're watching\",\n    verb: 'replied to you',\n  },\n  all_replies_to_my_answers_on_watched_markets: {\n    simple: 'Only replies to your answers',\n    detailed: \"Only replies to your answers on questions you're watching\",\n    verb: 'replied to you',\n  },\n  opt_out_all: {\n    simple: 'Opt out of all notifications (excludes when your questions close)',\n    detailed:\n      'Opt out of all notifications excluding your own question closure notifications',\n  },\n  user_liked_your_content: {\n    simple: 'A user liked your content',\n    detailed: 'A user liked your comment, market, or other content',\n  },\n  bounty_awarded: {\n    simple: 'Bounties you receive',\n    detailed: 'When the creator awards you a bounty for your comment',\n  },\n  bounty_added: {\n    simple: 'Bounties added to your question',\n    detailed: 'When another user adds a bounty to your question',\n  },\n  bounty_canceled: {\n    simple: 'A bounty you follow is canceled',\n    detailed: 'When the creator of a bounty cancels it',\n  },\n  all_votes_on_watched_markets: {\n    simple: 'Votes on polls you follow',\n    detailed: 'When a user votes on a poll you follow',\n  },\n  vote_on_your_contract: {\n    simple: 'Votes on your polls',\n    detailed: 'When a user votes on a poll you created',\n  },\n  poll_close_on_watched_markets: {\n    simple: 'Polls you follow close',\n    detailed: 'When a poll you follow closes',\n  },\n  your_poll_closed: {\n    simple: 'Your poll closes',\n    detailed: 'When a poll you created closes',\n  },\n  review_on_your_market: {\n    simple: 'Reviews on your questions',\n    detailed: 'When a user reviews your question after resolution',\n  },\n  new_match: {\n    simple: 'New matches',\n    detailed: 'When you match with another user',\n  },\n  new_message: {\n    simple: 'New messages',\n    detailed: 'When another user messages you',\n  },\n  new_endorsement: {\n    simple: 'New endorsements',\n    detailed: 'When another user endorses you',\n  },\n  new_love_like: {\n    simple: 'New likes',\n    detailed: 'When another user likes you',\n  },\n  new_love_ship: {\n    simple: 'New ships',\n    detailed:\n      'When another user supports a relationship between you and someone else',\n  },\n  airdrop: {\n    simple: 'You received a gift of mana',\n    detailed: 'Manifold has sent you a gift of mana',\n  },\n  manifest_airdrop: {\n    simple: 'You received a gift for attending Manifest',\n    detailed: 'Manifold has sent you a gift for attending Manifest',\n  },\n  extra_purchased_mana: {\n    simple: 'You just received 9x your purchased mana in 2024',\n    detailed: 'Manifold has sent you a gift of 9x your purchased mana in 2024.',\n  },\n  payment_status: {\n    simple: 'Payment updates',\n    detailed: 'Updates on your payment statuses',\n  },\n  market_movements: {\n    simple: 'Market movements',\n    detailed:\n      'When the probability of a market that you follow changes by a large amount',\n  },\n  market_follows: {\n    simple: 'Someone followed your market',\n    detailed: 'Get notified when someone follows one of your markets',\n    verb: 'followed your market',\n  },\n  admin: {\n    simple: 'Admin notifications',\n    detailed: 'Notifications from the Manifold team',\n  },\n  all_comments_on_followed_posts: {\n    simple: 'All new comments on posts you follow',\n    detailed: 'All new comments on posts you follow',\n    verb: 'commented',\n  },\n}\n\nexport type BettingStreakData = {\n  streak: number\n  bonusAmount: number\n  cashAmount?: number\n}\nexport type LeagueChangeData = {\n  previousLeague: league_user_info | undefined\n  newLeague: { season: number; division: number; cohort: string }\n  bonusAmount: number\n}\n\nexport type BetFillData = {\n  betAnswer?: string\n  creatorOutcome: string\n  probability: number\n  limitOrderTotal?: number\n  limitOrderRemaining?: number\n  limitAt?: string\n  mechanism: 'cpmm-1' | 'cpmm-multi-1'\n  outcomeType: OutcomeType\n  betAnswerId?: string\n  expiresAt?: number\n  createdTime?: number\n}\n\nexport type ContractResolutionData = {\n  outcome: string\n  userPayout: number\n  userInvestment: number\n  profitRank?: number\n  totalShareholders?: number\n  profit?: number\n  answerId?: string\n  token?: ContractToken\n}\n\nexport type UniqueBettorData = {\n  bet: Bet\n  outcomeType: OutcomeType\n  answerText?: string\n  min?: number\n  max?: number\n  isLogScale?: boolean\n  isPartner?: boolean\n  totalUniqueBettors?: number\n  totalAmountBet?: number\n  token?: ContractToken\n  bonusAmount?: number\n}\n\nexport type ReviewNotificationData = {\n  rating: number\n  review: string\n}\n\nexport type CommentNotificationData = {\n  isReply: boolean\n}\n\nexport type BetReplyNotificationData = {\n  betAmount: number\n  betOutcome: string\n  commentText: string\n}\n\nexport type MarketMovementData = {\n  val_start: number\n  val_end: number\n  val_start_time: string\n  val_end_time: string\n  answerText?: string\n}\n\nexport type AirdropData = {\n  amount: number\n}\n\nexport type ManaPaymentData = {\n  message: string\n  token?: 'M$' | 'CASH'\n}\n\nexport type ExtraPurchasedManaData = {\n  amount: number\n}\n\nexport type PaymentCompletedData = {\n  userId: string\n  amount: number\n  currency: string\n  paymentMethodType: string\n  paymentAmountType: string\n}\n\nexport type ReferralData = {\n  manaAmount: number\n  cashAmount: number\n}\n\nexport function getSourceIdForLinkComponent(\n  sourceId: string,\n  sourceType?: notification_source_types\n) {\n  switch (sourceType) {\n    case 'answer':\n      return `answer-${sourceId}`\n    case 'comment':\n      return sourceId\n    case 'contract':\n      return ''\n    case 'bet':\n      return ''\n    default:\n      return sourceId\n  }\n}\n\nexport function getSourceUrl(notification: Notification) {\n  const {\n    sourceType,\n    sourceId,\n    sourceUserUsername,\n    sourceContractCreatorUsername,\n    sourceContractSlug,\n    sourceSlug,\n    reason,\n  } = notification\n\n  if (sourceType === 'weekly_portfolio_update')\n    return `/week/${sourceUserUsername}/${sourceSlug}`\n  if (reason === 'market_follows')\n    return `/${sourceContractCreatorUsername}/${sourceContractSlug}`\n  if (sourceType === 'follow') return `/${sourceUserUsername}`\n  if (sourceType === 'group' && sourceSlug) return `${groupPath(sourceSlug)}`\n  // User referral via contract:\n  if (\n    sourceContractCreatorUsername &&\n    sourceContractSlug &&\n    sourceType === 'user'\n  )\n    return `/${sourceContractCreatorUsername}/${sourceContractSlug}`\n  // User referral:\n  if (sourceType === 'user' && !sourceContractSlug)\n    return `/${sourceUserUsername}`\n  if (\n    sourceType === 'challenge' ||\n    ReactionNotificationTypes.includes(sourceType)\n  )\n    return `${sourceSlug}`\n  if (sourceContractCreatorUsername && sourceContractSlug) {\n    return `/${sourceContractCreatorUsername}/${sourceContractSlug}#${getSourceIdForLinkComponent(\n      sourceId ?? '',\n      sourceType\n    )}`\n  }\n  if (sourceSlug) {\n    return `${\n      sourceSlug.startsWith('/') ? sourceSlug : '/' + sourceSlug\n    }#${getSourceIdForLinkComponent(sourceId ?? '', sourceType)}`\n  }\n  return ''\n}\n\nexport const ReactionNotificationTypes: Partial<notification_source_types>[] = [\n  'comment_like',\n  'contract_like',\n  'post_like',\n  'post_comment_like',\n]\n\nexport const BalanceChangeNotificationTypes: NotificationReason[] = [\n  'loan_income',\n  // bonuses\n  'betting_streak_incremented',\n  'unique_bettors_on_your_contract',\n  // resolutions\n  'resolution_on_contract_with_users_shares_in',\n  'resolutions_on_watched_markets_with_shares_in',\n  // referrals\n  'you_referred_user',\n  'user_joined_to_bet_on_your_market',\n  'user_joined_from_your_group_invite',\n  'quest_payout',\n  'bet_fill',\n  'mana_payment_received',\n]\n\nexport const DELETE_PUSH_TOKEN = 'delete'\n\nexport function combineReactionNotifications(notifications: Notification[]) {\n  const groupedNotificationsBySourceType = groupBy(\n    notifications,\n    (n) =>\n      `${n.sourceType}-${\n        n.sourceTitle ?? n.sourceContractTitle ?? n.sourceContractId\n      }-${n.sourceText}`\n  )\n\n  const newNotifications = Object.values(groupedNotificationsBySourceType).map(\n    (notifications) => {\n      const mostRecentNotification = notifications[0]\n\n      return {\n        ...mostRecentNotification,\n        data: {\n          ...mostRecentNotification.data,\n          relatedNotifications: notifications,\n        },\n      }\n    }\n  )\n\n  return newNotifications as Notification[]\n}\n\n// Loop through the contracts and combine the notification items into one\nexport function combineAndSumIncomeNotifications(\n  notifications: Notification[]\n) {\n  const newNotifications: Notification[] = []\n  const groupedNotificationsBySourceType = groupBy(\n    notifications,\n    (n) => n.sourceType\n  )\n  const titleForNotification = (notification: Notification) => {\n    const outcomeType = notification.data?.outcomeType\n    return (\n      (notification.sourceTitle ?? notification.sourceContractTitle) +\n      (outcomeType !== 'NUMBER' ? notification.data?.answerText ?? '' : '') +\n      notification.data?.isPartner\n    )\n  }\n\n  for (const sourceType in groupedNotificationsBySourceType) {\n    // Source title splits by contracts, groups, betting streak bonus\n    const groupedNotificationsBySourceTitle = groupBy(\n      groupedNotificationsBySourceType[sourceType],\n      (notification) => titleForNotification(notification)\n    )\n    for (const sourceTitle in groupedNotificationsBySourceTitle) {\n      const notificationsForSourceTitle =\n        groupedNotificationsBySourceTitle[sourceTitle]\n\n      let sum = 0\n      notificationsForSourceTitle.forEach((notification) => {\n        sum += parseFloat(notification.sourceText ?? '0')\n      })\n\n      const { bet: _, ...otherData } =\n        notificationsForSourceTitle[0]?.data ?? {}\n\n      const newNotification = {\n        ...notificationsForSourceTitle[0],\n        sourceText: sum.toString(),\n        sourceUserUsername: notificationsForSourceTitle[0].sourceUserUsername,\n        data: {\n          relatedNotifications: notificationsForSourceTitle,\n          ...otherData,\n        },\n      }\n      newNotifications.push(newNotification)\n    }\n  }\n  return newNotifications\n}\n"
        }
      ]
    },
    {
      "sha": "2bebb167da9975e3ca755759f245a6170bca74da",
      "author": "Ian Philips",
      "date": "2025-05-12 17:50:51 -0700",
      "message": "Edit post comments and add to user profile",
      "stats": {
        "filesChanged": 10,
        "insertions": 358,
        "deletions": 56
      },
      "selectionReason": "Adds post comment editing and profile integration - implements comprehensive commenting system with multiple touchpoints",
      "spec": "Implement functionality for users to edit their comments on posts and enhance user profiles to display a unified list of all their comments. For post comment editing: 1. Enable users to modify the content of their own comments on posts. 2. Allow administrators and moderators to modify the content of any post comment. 3. When a comment is edited, update its content and store the timestamp of the edit. 4. Create a system to log the history of edits for each post comment, including the previous content, the user who made the edit, and the time of the edit. 5. Modify the user interface for post comments to indicate when a comment has been edited (e.g., display an \"(edited)\" label and use the edit timestamp). For unified user comment display on profiles: 1. Modify the user profile page to list all comments made by the user, encompassing both comments on contracts (markets) and comments on posts. 2. Group these comments by the parent contract or post. 3. The title of each group should link to the respective contract or post page. 4. Each comment listed should link directly to its specific location on the contract or post page.",
      "fileStates": [
        {
          "path": "backend/api/src/edit-post-comment.ts",
          "preContent": "[NEW FILE]",
          "postContent": "import { type APIHandler, APIError } from 'api/helpers/endpoint'\nimport { createSupabaseDirectClient } from 'shared/supabase/init'\nimport { isAdminId } from 'common/envs/constants'\nimport { updateData } from 'shared/supabase/utils'\nimport { getUser } from 'shared/utils' // Changed import for getUser\nimport { getPost } from 'shared/supabase/posts' // TODO: Need this function\nimport { PostComment } from 'common/comment'\nimport { revalidatePost } from './create-post-comment'\n\nexport const editPostComment: APIHandler<'edit-post-comment'> = async (\n  props,\n  auth\n) => {\n  const { commentId, postId, content } = props\n\n  if (!content) {\n    throw new APIError(400, 'Must provide content')\n  }\n  const contentJson = content\n\n  const editor = await getUser(auth.uid)\n  if (!editor) throw new APIError(401, 'Your account was not found')\n\n  const pg = createSupabaseDirectClient()\n\n  const comment = await pg.oneOrNone(\n    'SELECT data FROM old_post_comments WHERE comment_id = $1',\n    [commentId],\n    (row) => row.data as PostComment\n  )\n  if (!comment) throw new APIError(404, `Comment ${commentId} not found`)\n\n  const post = await getPost(pg, postId)\n  if (!post) throw new APIError(404, `Post ${postId} not found`)\n\n  if (editor.id !== comment.userId && !isAdminId(editor.id))\n    throw new APIError(403, 'User is not the creator of the comment.')\n\n  await updateData(pg, 'old_post_comments' as any, 'comment_id', {\n    comment_id: commentId,\n    content: contentJson,\n    editedTime: Date.now(),\n  })\n\n  await pg.none(\n    `\n    insert into post_comment_edits (post_id, editor_id, comment_id, data)\n    values ($1, $2, $3, $4)\n    `,\n    [post.id, editor.id, comment.id, comment]\n  )\n\n  return {\n    result: { success: true },\n    continue: async () => {\n      await revalidatePost(post)\n    },\n  }\n}\n"
        },
        {
          "path": "backend/api/src/get-comments.ts",
          "preContent": "import { APIError, type APIHandler } from './helpers/endpoint'\nimport { createSupabaseDirectClient } from 'shared/supabase/init'\nimport { getContractFromSlugSupabase } from 'shared/utils'\nimport { getCommentsDirect } from 'shared/supabase/contract-comments'\n\nexport const getComments: APIHandler<'comments'> = async (props) => {\n  const { userId, contractSlug } = props\n\n  if (!props.contractId && !contractSlug && !userId) {\n    throw new APIError(400, 'You must specify a contract or user')\n  }\n  const contractId =\n    props.contractId ?? (await getContractFromSlugSupabase(contractSlug!))?.id\n  const pg = createSupabaseDirectClient()\n\n  return await getCommentsDirect(pg, {\n    ...props,\n    contractId,\n  })\n}\n",
          "postContent": "import { APIError, type APIHandler } from './helpers/endpoint'\nimport { createSupabaseDirectClient } from 'shared/supabase/init'\nimport { getContractFromSlugSupabase } from 'shared/utils'\nimport { getCommentsDirect } from 'shared/supabase/contract-comments'\nimport { ContractComment, Comment } from 'common/comment'\n\nexport const getComments: APIHandler<'comments'> = async (props) => {\n  const { userId, contractSlug } = props\n\n  if (!props.contractId && !contractSlug && !userId) {\n    throw new APIError(400, 'You must specify a contract or user')\n  }\n  const contractId =\n    props.contractId ?? (await getContractFromSlugSupabase(contractSlug!))?.id\n  const pg = createSupabaseDirectClient()\n\n  return await getCommentsDirect<ContractComment>(pg, {\n    ...props,\n    contractId,\n  })\n}\n\nexport const getUserComments: APIHandler<'user-comments'> = async (props) => {\n  const pg = createSupabaseDirectClient()\n\n  return await getCommentsDirect<Comment>(pg, props)\n}\n"
        },
        {
          "path": "backend/api/src/on-create-comment-on-contract.ts",
          "preContent": "import { compact } from 'lodash'\nimport { isProd, log, revalidateStaticProps } from 'shared/utils'\nimport { ContractComment } from 'common/comment'\nimport { Bet } from 'common/bet'\nimport {\n  replied_users_info,\n  createAIDescriptionUpdateNotification,\n} from 'shared/create-notification'\nimport { createCommentOnContractNotification } from 'shared/notifications/create-new-contract-comment-notif'\nimport {\n  parseJsonContentToText,\n  parseMentions,\n  richTextToString,\n} from 'common/util/parse'\nimport { Contract, contractPath } from 'common/contract'\nimport { User } from 'common/user'\nimport {\n  createSupabaseDirectClient,\n  SupabaseDirectClient,\n} from 'shared/supabase/init'\nimport { insertModReport } from 'shared/create-mod-report'\nimport { updateContract } from 'shared/supabase/contracts'\nimport { followContractInternal } from 'api/follow-contract'\nimport { getAnswer } from 'shared/supabase/answers'\nimport { anythingToRichText } from 'shared/tiptap'\nimport { getCommentsDirect } from 'shared/supabase/contract-comments'\nimport { updateMarketContinuation } from './update-market'\nimport { JSONContent } from '@tiptap/core'\nimport { cloneDeep } from 'lodash'\nimport { track } from 'shared/analytics'\nimport { DEV_HOUSE_LIQUIDITY_PROVIDER_ID } from 'common/antes'\nimport { parseGeminiResponseAsJson, promptGemini } from 'shared/helpers/gemini'\n\ntype ClarificationResponse = {\n  isClarification: boolean\n  description?: string\n}\n\nexport const onCreateCommentOnContract = async (props: {\n  contract: Contract\n  comment: ContractComment\n  creator: User\n  bet?: Bet\n}) => {\n  const { contract, comment, creator, bet } = props\n  const pg = createSupabaseDirectClient()\n  const lastCommentTime = comment.createdTime\n  await updateContract(pg, contract.id, {\n    lastCommentTime,\n    lastUpdatedTime: Date.now(),\n  })\n  await revalidateStaticProps(contractPath(contract)).catch((e) =>\n    log.error('Failed to revalidate contract after comment', {\n      e,\n      comment,\n      creator,\n    })\n  )\n\n  await followContractInternal(pg, contract.id, true, creator.id)\n\n  if (\n    creator.id === contract.creatorId &&\n    !contract.isResolved &&\n    contract.outcomeType !== 'POLL'\n  ) {\n    await checkForClarification(pg, contract, comment)\n  }\n\n  await handleCommentNotifications(pg, comment, contract, creator, bet)\n}\n\nconst getReplyInfo = async (\n  pg: SupabaseDirectClient,\n  comment: ContractComment,\n  contract: Contract\n) => {\n  if (comment.answerOutcome && contract.outcomeType === 'MULTIPLE_CHOICE') {\n    const answer = await getAnswer(pg, comment.answerOutcome)\n    const comments = await pg.manyOrNone<{\n      user_id: string\n      data: ContractComment // Need data for context\n    }>(\n      `select user_id, data\n      from contract_comments\n      where contract_id = $1 and coalesce(data->>'answerOutcome', '') = $2\n      order by created_time asc`,\n      [contract.id, answer?.id ?? '']\n    )\n    return {\n      repliedToAnswer: answer,\n      repliedToType: 'answer',\n      repliedUserId: answer?.userId,\n      commentsInSameReplyChain: comments, // Comments replying to the same answer\n    } as const\n  } else if (comment.replyToCommentId) {\n    const comments = await pg.manyOrNone<{\n      user_id: string\n      data: ContractComment\n    }>(\n      `select user_id, data\n      from contract_comments where contract_id = $1\n        and (coalesce(data->>'replyToCommentId', '') = $2\n            or comment_id = $2)\n      order by created_time asc`,\n      [contract.id, comment.replyToCommentId]\n    )\n    return {\n      repliedToAnswer: null,\n      repliedToType: 'comment',\n      repliedUserId: comments.find(\n        (c) => c.data.id === comment.replyToCommentId\n      )?.user_id,\n      commentsInSameReplyChain: comments,\n    } as const\n  } else {\n    return null\n  }\n}\n\nexport const handleCommentNotifications = async (\n  pg: SupabaseDirectClient,\n  comment: ContractComment,\n  contract: Contract,\n  commentCreator: User,\n  bet: Bet | undefined\n) => {\n  const replyInfo = await getReplyInfo(pg, comment, contract)\n\n  const modsId = 'WQJ92QkoqDPuyj6DAZ5lR6g1x573'\n  const mentionedUsers = compact(parseMentions(comment.content))\n  const mentionedMods = mentionedUsers.includes(modsId)\n\n  const repliedUsers: replied_users_info = {}\n  if (replyInfo) {\n    const {\n      repliedToType,\n      repliedUserId,\n      repliedToAnswer,\n      commentsInSameReplyChain,\n    } = replyInfo\n\n    // The parent of the reply chain could be a comment or an answer\n    if (repliedUserId && repliedToType)\n      repliedUsers[repliedUserId] = {\n        repliedToType,\n        repliedToAnswerText: repliedToAnswer?.text,\n        repliedToAnswerId: repliedToAnswer?.id,\n        bet: bet,\n      }\n\n    if (commentsInSameReplyChain) {\n      // Add users from the reply chain (parent and siblings) to notifications,\n      // excluding the commenter and the direct recipient (already added)\n      commentsInSameReplyChain.forEach((c) => {\n        if (c.user_id !== comment.userId && c.user_id !== repliedUserId) {\n          repliedUsers[c.user_id] = {\n            repliedToType: 'comment',\n            repliedToAnswerText: undefined,\n            repliedToAnswerId: undefined,\n            bet: undefined,\n          }\n        }\n      })\n    }\n  }\n  if (mentionedMods) {\n    await insertModReport(comment)\n  }\n\n  // Prepare context for Gemini check\n  let threadContext: string | null = null\n  let newCommentText = ''\n  if (replyInfo?.commentsInSameReplyChain) {\n    // Build the thread context: comments in the same chain + the new comment\n    const threadComments = [\n      ...replyInfo.commentsInSameReplyChain\n        .filter((c) => c.data.id !== comment.id) // Filter out the new comment itself\n        .map((c) => ({\n          userId: c.user_id,\n          userName: c.data.userName,\n          userUsername: c.data.userUsername,\n          content: c.data.content,\n        })),\n    ]\n\n    threadContext = threadComments\n      .map((c) => {\n        const authorTag =\n          c.userId === contract.creatorId ? '[CREATOR]' : '[USER]'\n        const name = c.userName\n          ? `${c.userName} (@${c.userUsername})`\n          : `User ${c.userId.substring(0, 4)}`\n        return `${authorTag} ${name}: ${richTextToString(c.content)}`\n      })\n      .join('\\n---\\n') // Separator between comments\n  }\n\n  // Format the new comment text\n  const newCommentAuthorTag =\n    comment.userId === contract.creatorId ? '[CREATOR]' : '[USER]'\n  newCommentText = `${newCommentAuthorTag} ${\n    commentCreator.name\n      ? `${commentCreator.name} (@${commentCreator.username})`\n      : `User ${commentCreator.id.substring(0, 4)}`\n  }: ${richTextToString(comment.content)}`\n\n  // Check if comment needs response using Gemini, now with context\n  const checkResult =\n    comment.userId === contract.creatorId\n      ? { needsResponse: false }\n      : await checkCommentNeedsResponse(contract, threadContext, newCommentText)\n  const needsResponse = checkResult.needsResponse\n\n  await createCommentOnContractNotification(\n    comment.id,\n    commentCreator,\n    richTextToString(comment.content),\n    contract,\n    repliedUsers,\n    mentionedUsers,\n    needsResponse\n  )\n  return [...mentionedUsers, ...Object.keys(repliedUsers)]\n}\n\nconst checkForClarification = async (\n  pg: SupabaseDirectClient,\n  contract: Contract,\n  comment: ContractComment\n) => {\n  let commentsContext = ''\n  let answerContext = ''\n\n  if (comment.replyToCommentId) {\n    const originalComment = await getCommentsDirect(pg, {\n      contractId: contract.id,\n      commentId: comment.replyToCommentId,\n    })\n    const relatedComments = await getCommentsDirect(pg, {\n      contractId: contract.id,\n      replyToCommentId: comment.replyToCommentId,\n    })\n\n    const replyToAnswerId =\n      comment.answerOutcome ||\n      originalComment.find((c) => c.answerOutcome)?.answerOutcome\n    // Get answer context if this is a reply to an answer\n    if (replyToAnswerId) {\n      const answer = await getAnswer(pg, replyToAnswerId)\n      if (answer) {\n        const isCreatorAnswer = answer.userId === contract.creatorId\n        answerContext = `ANSWER (submitted by ${\n          isCreatorAnswer ? 'creator' : 'user'\n        }) BEING DISCUSSED:\n${answer.text}`\n      }\n    }\n\n    commentsContext = [...originalComment, ...relatedComments]\n      .filter((c) => c.id !== comment.id)\n      .map((c) => {\n        const isCreator = c.userId === contract.creatorId\n        return `${isCreator ? 'Creator' : 'User'}: ${richTextToString(\n          c.content\n        )}`\n      })\n      .join('\\n')\n  }\n\n  const closeTimeDetail = contract.closeTime\n    ? `Market is set to close on ${new Date(contract.closeTime).toISOString()}`\n    : ''\n\n  const prompt = `SYSTEM: You are analyzing a ${\n    commentsContext ? 'comment thread' : 'comment'\n  } on a prediction market (that is managed by a creator) to determine if the creator's latest comment clarifies the resolution criteria.\n\nCONTEXT:\nMarket question: ${contract.question}\n${closeTimeDetail}\nMarket description: ${\n    typeof contract.description === 'string'\n      ? contract.description\n      : richTextToString(contract.description)\n  }\n\n${answerContext}\n${commentsContext ? `COMMENT THREAD:\\n${commentsContext}` : ''}\n\nCREATOR'S LATEST COMMENT:\n${richTextToString(comment.content)}\n\nSYSTEM: Please analyze if the creator's latest comment ${\n    commentsContext ? '(in context of the comment thread)' : ''\n  } is clarifying or adding important details about how the market will be resolved, that is not already covered by the market's description/question title. \nOnly choose to issue a clarification if the creator's comment is unambiguously changing the resolution criteria as outlined in the description/question.\nIf the creator says that they're going to update the description themselves, or they indicate their comment ${\n    commentsContext ? '(or their comments in the thread)' : ''\n  } shouldn't be used to update the description, do not issue a clarification.\n\nReturn a JSON response with:\n{\n  \"isClarification\": boolean, // true if the comment clarifies resolution criteria\n  \"description\": string // If isClarification is true, provide markdown formatted text to append to the current description. Use bold for important terms and bullet points for lists. Otherwise, return an empty string.\n}\n\nFormat the description in markdown, sticking to just the following:\n- Use **bold** for important terms\n- Use bullet points for lists\n\nI will append the title of 'Update from creator' to the beginning of the description. You do not need to include this in your response.\nBe as concise as possible. I will link your clarification to the creator's comment, so when in doubt, err on the side of brevity and let the user check out the comment for more details.\nNOTE: If the creator explicitly states that their comment is not a clarification, such as saying \"these comments are not a clarification,\" then you must not treat it as clarifying or changing the resolution criteria. In that case, return {\"isClarification\": false, \"description\": \"\"}.\nOnly return the raw JSON object without any markdown code blocks, backticks, additional formatting, or anything else.`\n\n  try {\n    const response = await promptGemini(prompt, {\n      model: 'gemini-2.5-pro-preview-03-25',\n    })\n    log('Clarification response:', {\n      question: contract.question,\n      contractId: contract.id,\n      slug: contract.slug,\n      response,\n    })\n    if (!response) {\n      log.error('No response from ai clarification')\n      return\n    }\n    const clarification = parseGeminiResponseAsJson(\n      response\n    ) as ClarificationResponse\n\n    if (clarification.isClarification && clarification.description) {\n      const dateParts = new Date()\n        .toLocaleDateString('en-US', {\n          timeZone: 'America/Los_Angeles',\n          year: 'numeric',\n          month: '2-digit',\n          day: '2-digit',\n        })\n        .split('/')\n      const date = `${dateParts[2]}-${dateParts[0]}-${dateParts[1]}`\n      const timeZone = new Date()\n        .toLocaleDateString('en-US', { timeZoneName: 'short' })\n        .includes('PDT')\n        ? 'PDT'\n        : 'PST'\n\n      const formattedDescription = clarification.description.replace(\n        /\\n[•\\-*] /g,\n        '\\n   - '\n      )\n      const summaryNote = `(AI summary of [creator comment](${contractPath(\n        contract\n      )}#${comment.id}))`\n\n      const markdownToAppend = `- Update ${date} (${timeZone}) ${summaryNote}: ${formattedDescription} `\n\n      const appendDescription = anythingToRichText({\n        markdown: markdownToAppend,\n      })\n      // Create deep copy of the old description to update history correctly\n      const oldDescription = cloneDeep(contract.description)\n      let newDescription: JSONContent | undefined\n\n      if (typeof oldDescription === 'string') {\n        newDescription = anythingToRichText({\n          markdown: `${oldDescription}${appendDescription}`,\n        })\n      } else {\n        oldDescription.content?.push(\n          { type: 'paragraph' }, // acts as newline\n          ...(appendDescription?.content ?? [])\n        )\n        newDescription = oldDescription\n      }\n      await updateContract(pg, contract.id, {\n        description: newDescription,\n      })\n      const editorID = isProd()\n        ? '8lZo8X5lewh4hnCoreI7iSc0GxK2' // ManifoldAI user id, lol\n        : DEV_HOUSE_LIQUIDITY_PROVIDER_ID\n      await updateMarketContinuation(\n        contract,\n        editorID,\n        undefined,\n        undefined,\n        undefined,\n        undefined,\n        newDescription\n      )\n      track(editorID, 'ai clarification added', {\n        contractId: contract.id,\n        slug: contract.slug,\n        question: contract.question,\n      })\n\n      await createAIDescriptionUpdateNotification(contract, markdownToAppend)\n    }\n  } catch (e) {\n    log.error('Error checking for clarification:', { e })\n  }\n}\n\nexport const checkCommentNeedsResponse = async (\n  contract: Contract,\n  threadContext: string | null,\n  newCommentText: string\n) => {\n  const prompt = `\n  Analyze the NEWEST COMMENT on a prediction market and determine if it requires a response from the market creator.\n\n  The creator is a user of Manifold Markets that created the market and resolves it using their judgement, along with the title and description of the market.\n\n  The NEWEST COMMENT should be considered as needing a response if it:\n  1. Asks for clarification about the market or its resolution criteria\n  2. Requests the market to be resolved\n  3. Points out potential issues that need to be addressed\n  4. (If relevant to the market) Requests an update on the status of the market from the creator\n  5. Asks a direct question to the market creator and the question is related to the market\n\n  Market title: ${contract.question}\n  Market description: ${parseJsonContentToText(contract.description)}\n\n  ${\n    threadContext\n      ? `COMMENT THREAD CONTEXT (previous messages):\\n\\`\\`\\`\\n${threadContext}\\n\\`\\`\\`\\nThe thread context uses [USER] and [CREATOR] tags. Discussions between users not addressing the creator should NOT be considered as needing a response.`\n      : 'This is a top-level comment (not a reply).'\n  }\n\n  NEWEST COMMENT (Analyze this comment for whether a response is needed):\n  \\`\\`\\`\n  ${newCommentText}\n  \\`\\`\\`\n\n  Return a JSON object with:\n  - needsResponse: boolean // True if the *newest comment* requires a response based ONLY on its content and the criteria above.\n  - reason: string (brief explanation why, or empty if no response needed)\n\n  Only return the JSON object, no other text.`\n\n  try {\n    const response = await promptGemini(prompt)\n    const result = parseGeminiResponseAsJson(response)\n    return result as { needsResponse: boolean; reason: string }\n  } catch (error) {\n    log.error(`Error checking if comment needs response: ${error}`)\n    // Default to false if there's an error\n    return { needsResponse: false, reason: '' }\n  }\n}\n",
          "postContent": "import { compact } from 'lodash'\nimport { isProd, log, revalidateStaticProps } from 'shared/utils'\nimport { ContractComment } from 'common/comment'\nimport { Bet } from 'common/bet'\nimport {\n  replied_users_info,\n  createAIDescriptionUpdateNotification,\n} from 'shared/create-notification'\nimport { createCommentOnContractNotification } from 'shared/notifications/create-new-contract-comment-notif'\nimport {\n  parseJsonContentToText,\n  parseMentions,\n  richTextToString,\n} from 'common/util/parse'\nimport { Contract, contractPath } from 'common/contract'\nimport { User } from 'common/user'\nimport {\n  createSupabaseDirectClient,\n  SupabaseDirectClient,\n} from 'shared/supabase/init'\nimport { insertModReport } from 'shared/create-mod-report'\nimport { updateContract } from 'shared/supabase/contracts'\nimport { followContractInternal } from 'api/follow-contract'\nimport { getAnswer } from 'shared/supabase/answers'\nimport { anythingToRichText } from 'shared/tiptap'\nimport { getCommentsDirect } from 'shared/supabase/contract-comments'\nimport { updateMarketContinuation } from './update-market'\nimport { JSONContent } from '@tiptap/core'\nimport { cloneDeep } from 'lodash'\nimport { track } from 'shared/analytics'\nimport { DEV_HOUSE_LIQUIDITY_PROVIDER_ID } from 'common/antes'\nimport { parseGeminiResponseAsJson, promptGemini } from 'shared/helpers/gemini'\n\ntype ClarificationResponse = {\n  isClarification: boolean\n  description?: string\n}\n\nexport const onCreateCommentOnContract = async (props: {\n  contract: Contract\n  comment: ContractComment\n  creator: User\n  bet?: Bet\n}) => {\n  const { contract, comment, creator, bet } = props\n  const pg = createSupabaseDirectClient()\n  const lastCommentTime = comment.createdTime\n  await updateContract(pg, contract.id, {\n    lastCommentTime,\n    lastUpdatedTime: Date.now(),\n  })\n  await revalidateStaticProps(contractPath(contract)).catch((e) =>\n    log.error('Failed to revalidate contract after comment', {\n      e,\n      comment,\n      creator,\n    })\n  )\n\n  await followContractInternal(pg, contract.id, true, creator.id)\n\n  if (\n    creator.id === contract.creatorId &&\n    !contract.isResolved &&\n    contract.outcomeType !== 'POLL'\n  ) {\n    await checkForClarification(pg, contract, comment)\n  }\n\n  await handleCommentNotifications(pg, comment, contract, creator, bet)\n}\n\nconst getReplyInfo = async (\n  pg: SupabaseDirectClient,\n  comment: ContractComment,\n  contract: Contract\n) => {\n  if (comment.answerOutcome && contract.outcomeType === 'MULTIPLE_CHOICE') {\n    const answer = await getAnswer(pg, comment.answerOutcome)\n    const comments = await pg.manyOrNone<{\n      user_id: string\n      data: ContractComment // Need data for context\n    }>(\n      `select user_id, data\n      from contract_comments\n      where contract_id = $1 and coalesce(data->>'answerOutcome', '') = $2\n      order by created_time asc`,\n      [contract.id, answer?.id ?? '']\n    )\n    return {\n      repliedToAnswer: answer,\n      repliedToType: 'answer',\n      repliedUserId: answer?.userId,\n      commentsInSameReplyChain: comments, // Comments replying to the same answer\n    } as const\n  } else if (comment.replyToCommentId) {\n    const comments = await pg.manyOrNone<{\n      user_id: string\n      data: ContractComment\n    }>(\n      `select user_id, data\n      from contract_comments where contract_id = $1\n        and (coalesce(data->>'replyToCommentId', '') = $2\n            or comment_id = $2)\n      order by created_time asc`,\n      [contract.id, comment.replyToCommentId]\n    )\n    return {\n      repliedToAnswer: null,\n      repliedToType: 'comment',\n      repliedUserId: comments.find(\n        (c) => c.data.id === comment.replyToCommentId\n      )?.user_id,\n      commentsInSameReplyChain: comments,\n    } as const\n  } else {\n    return null\n  }\n}\n\nexport const handleCommentNotifications = async (\n  pg: SupabaseDirectClient,\n  comment: ContractComment,\n  contract: Contract,\n  commentCreator: User,\n  bet: Bet | undefined\n) => {\n  const replyInfo = await getReplyInfo(pg, comment, contract)\n\n  const modsId = 'WQJ92QkoqDPuyj6DAZ5lR6g1x573'\n  const mentionedUsers = compact(parseMentions(comment.content))\n  const mentionedMods = mentionedUsers.includes(modsId)\n\n  const repliedUsers: replied_users_info = {}\n  if (replyInfo) {\n    const {\n      repliedToType,\n      repliedUserId,\n      repliedToAnswer,\n      commentsInSameReplyChain,\n    } = replyInfo\n\n    // The parent of the reply chain could be a comment or an answer\n    if (repliedUserId && repliedToType)\n      repliedUsers[repliedUserId] = {\n        repliedToType,\n        repliedToAnswerText: repliedToAnswer?.text,\n        repliedToAnswerId: repliedToAnswer?.id,\n        bet: bet,\n      }\n\n    if (commentsInSameReplyChain) {\n      // Add users from the reply chain (parent and siblings) to notifications,\n      // excluding the commenter and the direct recipient (already added)\n      commentsInSameReplyChain.forEach((c) => {\n        if (c.user_id !== comment.userId && c.user_id !== repliedUserId) {\n          repliedUsers[c.user_id] = {\n            repliedToType: 'comment',\n            repliedToAnswerText: undefined,\n            repliedToAnswerId: undefined,\n            bet: undefined,\n          }\n        }\n      })\n    }\n  }\n  if (mentionedMods) {\n    await insertModReport(comment)\n  }\n\n  // Prepare context for Gemini check\n  let threadContext: string | null = null\n  let newCommentText = ''\n  if (replyInfo?.commentsInSameReplyChain) {\n    // Build the thread context: comments in the same chain + the new comment\n    const threadComments = [\n      ...replyInfo.commentsInSameReplyChain\n        .filter((c) => c.data.id !== comment.id) // Filter out the new comment itself\n        .map((c) => ({\n          userId: c.user_id,\n          userName: c.data.userName,\n          userUsername: c.data.userUsername,\n          content: c.data.content,\n        })),\n    ]\n\n    threadContext = threadComments\n      .map((c) => {\n        const authorTag =\n          c.userId === contract.creatorId ? '[CREATOR]' : '[USER]'\n        const name = c.userName\n          ? `${c.userName} (@${c.userUsername})`\n          : `User ${c.userId.substring(0, 4)}`\n        return `${authorTag} ${name}: ${richTextToString(c.content)}`\n      })\n      .join('\\n---\\n') // Separator between comments\n  }\n\n  // Format the new comment text\n  const newCommentAuthorTag =\n    comment.userId === contract.creatorId ? '[CREATOR]' : '[USER]'\n  newCommentText = `${newCommentAuthorTag} ${\n    commentCreator.name\n      ? `${commentCreator.name} (@${commentCreator.username})`\n      : `User ${commentCreator.id.substring(0, 4)}`\n  }: ${richTextToString(comment.content)}`\n\n  // Check if comment needs response using Gemini, now with context\n  const checkResult =\n    comment.userId === contract.creatorId\n      ? { needsResponse: false }\n      : await checkCommentNeedsResponse(contract, threadContext, newCommentText)\n  const needsResponse = checkResult.needsResponse\n\n  await createCommentOnContractNotification(\n    comment.id,\n    commentCreator,\n    richTextToString(comment.content),\n    contract,\n    repliedUsers,\n    mentionedUsers,\n    needsResponse\n  )\n  return [...mentionedUsers, ...Object.keys(repliedUsers)]\n}\n\nconst checkForClarification = async (\n  pg: SupabaseDirectClient,\n  contract: Contract,\n  comment: ContractComment\n) => {\n  let commentsContext = ''\n  let answerContext = ''\n\n  if (comment.replyToCommentId) {\n    const originalComment = await getCommentsDirect<ContractComment>(pg, {\n      contractId: contract.id,\n      commentId: comment.replyToCommentId,\n    })\n    const relatedComments = await getCommentsDirect<ContractComment>(pg, {\n      contractId: contract.id,\n      replyToCommentId: comment.replyToCommentId,\n    })\n\n    const replyToAnswerId =\n      comment.answerOutcome ||\n      originalComment.find((c) => c.answerOutcome)?.answerOutcome\n    // Get answer context if this is a reply to an answer\n    if (replyToAnswerId) {\n      const answer = await getAnswer(pg, replyToAnswerId)\n      if (answer) {\n        const isCreatorAnswer = answer.userId === contract.creatorId\n        answerContext = `ANSWER (submitted by ${\n          isCreatorAnswer ? 'creator' : 'user'\n        }) BEING DISCUSSED:\n${answer.text}`\n      }\n    }\n\n    commentsContext = [...originalComment, ...relatedComments]\n      .filter((c) => c.id !== comment.id)\n      .map((c) => {\n        const isCreator = c.userId === contract.creatorId\n        return `${isCreator ? 'Creator' : 'User'}: ${richTextToString(\n          c.content\n        )}`\n      })\n      .join('\\n')\n  }\n\n  const closeTimeDetail = contract.closeTime\n    ? `Market is set to close on ${new Date(contract.closeTime).toISOString()}`\n    : ''\n\n  const prompt = `SYSTEM: You are analyzing a ${\n    commentsContext ? 'comment thread' : 'comment'\n  } on a prediction market (that is managed by a creator) to determine if the creator's latest comment clarifies the resolution criteria.\n\nCONTEXT:\nMarket question: ${contract.question}\n${closeTimeDetail}\nMarket description: ${\n    typeof contract.description === 'string'\n      ? contract.description\n      : richTextToString(contract.description)\n  }\n\n${answerContext}\n${commentsContext ? `COMMENT THREAD:\\n${commentsContext}` : ''}\n\nCREATOR'S LATEST COMMENT:\n${richTextToString(comment.content)}\n\nSYSTEM: Please analyze if the creator's latest comment ${\n    commentsContext ? '(in context of the comment thread)' : ''\n  } is clarifying or adding important details about how the market will be resolved, that is not already covered by the market's description/question title. \nOnly choose to issue a clarification if the creator's comment is unambiguously changing the resolution criteria as outlined in the description/question.\nIf the creator says that they're going to update the description themselves, or they indicate their comment ${\n    commentsContext ? '(or their comments in the thread)' : ''\n  } shouldn't be used to update the description, do not issue a clarification.\n\nReturn a JSON response with:\n{\n  \"isClarification\": boolean, // true if the comment clarifies resolution criteria\n  \"description\": string // If isClarification is true, provide markdown formatted text to append to the current description. Use bold for important terms and bullet points for lists. Otherwise, return an empty string.\n}\n\nFormat the description in markdown, sticking to just the following:\n- Use **bold** for important terms\n- Use bullet points for lists\n\nI will append the title of 'Update from creator' to the beginning of the description. You do not need to include this in your response.\nBe as concise as possible. I will link your clarification to the creator's comment, so when in doubt, err on the side of brevity and let the user check out the comment for more details.\nNOTE: If the creator explicitly states that their comment is not a clarification, such as saying \"these comments are not a clarification,\" then you must not treat it as clarifying or changing the resolution criteria. In that case, return {\"isClarification\": false, \"description\": \"\"}.\nOnly return the raw JSON object without any markdown code blocks, backticks, additional formatting, or anything else.`\n\n  try {\n    const response = await promptGemini(prompt, {\n      model: 'gemini-2.5-pro-preview-03-25',\n    })\n    log('Clarification response:', {\n      question: contract.question,\n      contractId: contract.id,\n      slug: contract.slug,\n      response,\n    })\n    if (!response) {\n      log.error('No response from ai clarification')\n      return\n    }\n    const clarification = parseGeminiResponseAsJson(\n      response\n    ) as ClarificationResponse\n\n    if (clarification.isClarification && clarification.description) {\n      const dateParts = new Date()\n        .toLocaleDateString('en-US', {\n          timeZone: 'America/Los_Angeles',\n          year: 'numeric',\n          month: '2-digit',\n          day: '2-digit',\n        })\n        .split('/')\n      const date = `${dateParts[2]}-${dateParts[0]}-${dateParts[1]}`\n      const timeZone = new Date()\n        .toLocaleDateString('en-US', { timeZoneName: 'short' })\n        .includes('PDT')\n        ? 'PDT'\n        : 'PST'\n\n      const formattedDescription = clarification.description.replace(\n        /\\n[•\\-*] /g,\n        '\\n   - '\n      )\n      const summaryNote = `(AI summary of [creator comment](${contractPath(\n        contract\n      )}#${comment.id}))`\n\n      const markdownToAppend = `- Update ${date} (${timeZone}) ${summaryNote}: ${formattedDescription} `\n\n      const appendDescription = anythingToRichText({\n        markdown: markdownToAppend,\n      })\n      // Create deep copy of the old description to update history correctly\n      const oldDescription = cloneDeep(contract.description)\n      let newDescription: JSONContent | undefined\n\n      if (typeof oldDescription === 'string') {\n        newDescription = anythingToRichText({\n          markdown: `${oldDescription}${appendDescription}`,\n        })\n      } else {\n        oldDescription.content?.push(\n          { type: 'paragraph' }, // acts as newline\n          ...(appendDescription?.content ?? [])\n        )\n        newDescription = oldDescription\n      }\n      await updateContract(pg, contract.id, {\n        description: newDescription,\n      })\n      const editorID = isProd()\n        ? '8lZo8X5lewh4hnCoreI7iSc0GxK2' // ManifoldAI user id, lol\n        : DEV_HOUSE_LIQUIDITY_PROVIDER_ID\n      await updateMarketContinuation(\n        contract,\n        editorID,\n        undefined,\n        undefined,\n        undefined,\n        undefined,\n        newDescription\n      )\n      track(editorID, 'ai clarification added', {\n        contractId: contract.id,\n        slug: contract.slug,\n        question: contract.question,\n      })\n\n      await createAIDescriptionUpdateNotification(contract, markdownToAppend)\n    }\n  } catch (e) {\n    log.error('Error checking for clarification:', { e })\n  }\n}\n\nexport const checkCommentNeedsResponse = async (\n  contract: Contract,\n  threadContext: string | null,\n  newCommentText: string\n) => {\n  const prompt = `\n  Analyze the NEWEST COMMENT on a prediction market and determine if it requires a response from the market creator.\n\n  The creator is a user of Manifold Markets that created the market and resolves it using their judgement, along with the title and description of the market.\n\n  The NEWEST COMMENT should be considered as needing a response if it:\n  1. Asks for clarification about the market or its resolution criteria\n  2. Requests the market to be resolved\n  3. Points out potential issues that need to be addressed\n  4. (If relevant to the market) Requests an update on the status of the market from the creator\n  5. Asks a direct question to the market creator and the question is related to the market\n\n  Market title: ${contract.question}\n  Market description: ${parseJsonContentToText(contract.description)}\n\n  ${\n    threadContext\n      ? `COMMENT THREAD CONTEXT (previous messages):\\n\\`\\`\\`\\n${threadContext}\\n\\`\\`\\`\\nThe thread context uses [USER] and [CREATOR] tags. Discussions between users not addressing the creator should NOT be considered as needing a response.`\n      : 'This is a top-level comment (not a reply).'\n  }\n\n  NEWEST COMMENT (Analyze this comment for whether a response is needed):\n  \\`\\`\\`\n  ${newCommentText}\n  \\`\\`\\`\n\n  Return a JSON object with:\n  - needsResponse: boolean // True if the *newest comment* requires a response based ONLY on its content and the criteria above.\n  - reason: string (brief explanation why, or empty if no response needed)\n\n  Only return the JSON object, no other text.`\n\n  try {\n    const response = await promptGemini(prompt)\n    const result = parseGeminiResponseAsJson(response)\n    return result as { needsResponse: boolean; reason: string }\n  } catch (error) {\n    log.error(`Error checking if comment needs response: ${error}`)\n    // Default to false if there's an error\n    return { needsResponse: false, reason: '' }\n  }\n}\n"
        },
        {
          "path": "backend/api/src/routes.ts",
          "preContent": "import { updateMe } from './update-me'\nimport { placeBet } from './place-bet'\nimport { cancelBet } from './cancel-bet'\nimport { sellShares } from './sell-shares'\nimport { createMarket } from './create-market'\nimport { createComment } from './create-comment'\nimport { resolveMarket } from './resolve-market'\nimport { closeMarket } from './close-market'\nimport { getMe } from './get-me'\nimport { saveTwitchCredentials } from './save-twitch-credentials'\nimport { addLiquidity } from './add-liquidity'\nimport { removeLiquidity } from './remove-liquidity'\nimport { searchGroups, searchMyGroups } from './search-groups'\nimport { awardBounty } from './award-bounty'\nimport { addBounty } from './add-bounty'\nimport { createAnswerCPMM } from './create-answer-cpmm'\nimport { managram } from './managram'\nimport { setnews } from './set-news'\nimport { getDashboardFromSlug } from './get-dashboard-from-slug'\nimport { unresolve } from './unresolve'\nimport { updateMarket } from 'api/update-market'\nimport { getCompatibleLovers } from './love/compatible-lovers'\nimport { type APIPath } from 'common/api/schema'\nimport { getMarkets } from 'api/markets'\nimport { hideComment } from './hide-comment'\nimport { pinComment } from './pin-comment'\nimport { getManagrams } from './get-managrams'\nimport { getGroups } from './get-groups'\nimport { getComments } from './get-comments'\nimport { getBetPointsBetween, getBets } from './get-bets'\nimport { getLiteUser, getUser } from './get-user'\nimport { getUsers } from './get-users'\nimport { getUserBalancesByIds, getUsersByIds } from './get-users-by-ids'\nimport { getMarket } from './get-market'\nimport { getMarketProb } from './get-market-prob'\nimport { getMarketProbs } from './get-market-probs'\nimport { getGroup } from './get-group'\nimport { getPositions } from './get-positions'\nimport { getLeagues } from './get-leagues'\nimport { getContract } from './get-contract'\nimport { getSingleAnswer } from './get-answer'\nimport { getContractAnswers } from './get-contract-answers'\nimport { addOrRemoveTopicFromContract } from './add-topic-to-market'\nimport { addOrRemoveTopicFromTopic } from './add-topic-to-topic'\nimport { searchUsers } from './search-users'\nimport { searchMarketsLite, searchMarketsFull } from './search-contracts'\nimport { post } from 'api/post'\nimport { fetchLinkPreview } from './fetch-link-preview'\nimport { type APIHandler } from './helpers/endpoint'\nimport { requestLoan } from 'api/request-loan'\nimport { removePinnedPhoto } from './love/remove-pinned-photo'\nimport { getHeadlines, getPoliticsHeadlines } from './get-headlines'\nimport { getBoostAnalytics } from 'api/get-boost-analytics'\nimport { getCompatibilityQuestions } from './love/get-compatibililty-questions'\nimport { addOrRemoveReaction } from './reaction'\nimport { likeLover } from './love/like-lover'\nimport { shipLovers } from './love/ship-lovers'\nimport { createManalink } from './create-manalink'\nimport { getLikesAndShips } from './love/get-likes-and-ships'\nimport { hasFreeLike } from './love/has-free-like'\nimport { starLover } from './love/star-lover'\nimport { getLovers } from './love/get-lovers'\nimport { unlistAndCancelUserContracts } from './unlist-and-cancel-user-contracts'\nimport { getGroupsWithTopContracts } from 'api/get-topics-with-markets'\nimport { getBalanceChanges } from 'api/get-balance-changes'\nimport { getLoverAnswers } from './love/get-lover-answers'\nimport { placeMultiBet } from 'api/place-multi-bet'\nimport { getPartnerStats } from './get-partner-stats'\nimport { getSeenMarketIds } from 'api/get-seen-market-ids'\nimport { recordContractView } from 'api/record-contract-view'\nimport { createPublicChatMessage } from 'api/create-public-chat-message'\nimport { getFollowedGroups } from './get-followed-groups'\nimport { getUniqueBetGroupCount } from 'api/get-unique-bet-groups'\nimport { deleteGroup } from './delete-group'\nimport { recordContractInteraction } from 'api/record-contract-interaction'\nimport { getUserPortfolio } from './get-user-portfolio'\nimport { createuser } from 'api/create-user'\nimport { verifyPhoneNumber } from 'api/verify-phone-number'\nimport { requestOTP } from 'api/request-phone-otp'\nimport { multiSell } from 'api/multi-sell'\nimport { convertCashToMana } from './convert-cash-to-mana'\nimport { convertSpiceToMana } from './convert-sp-to-mana'\nimport { donate } from './donate'\nimport { getFeed } from 'api/get-feed'\nimport { getManaSupply } from './get-mana-supply'\nimport { getUserPortfolioHistory } from './get-user-portfolio-history'\nimport { deleteMe } from './delete-me'\nimport { updateModReport } from './update-mod-report'\nimport { getModReports } from './get-mod-reports'\nimport { searchContractPositions } from 'api/search-contract-positions'\nimport { blockUser, unblockUser } from './block-user'\nimport { blockGroup, unblockGroup } from './block-group'\nimport { blockMarket, unblockMarket } from './block-market'\nimport { getTxnSummaryStats } from 'api/get-txn-summary-stats'\nimport { getManaSummaryStats } from 'api/get-mana-summary-stats'\nimport { register } from 'api/gidx/register'\nimport { uploadDocument } from 'api/gidx/upload-document'\nimport { identityCallbackGIDX, paymentCallbackGIDX } from 'api/gidx/callback'\nimport { getVerificationStatus } from 'api/gidx/get-verification-status'\nimport { getCurrentPrivateUser } from './get-current-private-user'\nimport { updatePrivateUser } from './update-private-user'\nimport { setPushToken } from './push-token'\nimport { updateNotifSettings } from './update-notif-settings'\nimport { getVerificationDocuments } from 'api/gidx/get-verification-documents'\nimport { getRedeemablePrizeCash } from './get-redeemable-prize-cash'\nimport { getTotalRedeemablePrizeCash } from './get-total-redeemable-prize-cash'\nimport { getMonitorStatus } from 'api/gidx/get-monitor-status'\nimport { getBestComments } from 'api/get-best-comments'\nimport { recordCommentView } from 'api/record-comment-view'\nimport {\n  getChannelMemberships,\n  getChannelMessages,\n  getLastSeenChannelTime,\n  setChannelLastSeenTime,\n} from 'api/get-private-messages'\nimport { getNotifications } from 'api/get-notifications'\nimport { getCheckoutSession } from 'api/gidx/get-checkout-session'\nimport { completeCheckoutSession } from 'api/gidx/complete-checkout-session'\nimport { getContractTopics } from './get-contract-topics'\nimport { getRelatedMarkets } from './get-related-markets'\nimport { getRelatedMarketsByGroup } from './get-related-markets-by-group'\nimport { followContract } from './follow-contract'\nimport { getUserLimitOrdersWithContracts } from 'api/get-user-limit-orders-with-contracts'\nimport { getInterestingGroupsFromViews } from 'api/get-interesting-groups-from-views'\nimport { completeCashoutSession } from 'api/gidx/complete-cashout-session'\nimport { getCashouts } from './get-cashouts'\nimport { getKYCStats } from './get-kyc-stats'\nimport { getTxns } from './get-txns'\nimport { refreshAllClients } from './refresh-all-clients'\nimport { getLeaderboard } from './get-leaderboard'\nimport { toggleSystemTradingStatus } from './toggle-system-status'\nimport { completeCashoutRequest } from './gidx/complete-cashout-request'\nimport { getDailyChangedMetricsAndContracts } from './get-daily-changed-metrics-and-contracts'\nimport { getMarketsByIds } from './get-markets'\nimport { getTopicTopics } from './get-topic-topics'\nimport { getTopicDashboards } from './get-topic-dashboards'\nimport { generateAIMarketSuggestions } from './generate-ai-market-suggestions'\nimport { generateAIDescription } from './generate-ai-description'\nimport { generateAIAnswers } from './generate-ai-answers'\nimport { getmonthlybets2024 } from './get-monthly-bets-2024'\nimport { getmaxminprofit2024 } from './get-max-min-profit-2024'\nimport { getNextLoanAmount } from './get-next-loan-amount'\nimport { checkSportsEvent } from './check-sports-event'\n\nimport { createTask } from './create-task'\nimport { updateTask } from './update-task'\nimport { createCategory } from './create-category'\nimport { getCategories } from './get-categories'\nimport { updateCategory } from './update-category'\nimport { getTasks } from './get-tasks'\n\nimport { getSiteActivity } from './get-site-activity'\nimport { isSportsInterested } from './is-sports-bettor'\nimport { getSportsGames } from './get-sports-games'\nimport { getMarketProps } from './get-market-props'\nimport { getUserContractMetricsWithContracts } from './get-user-contract-metrics-with-contracts'\nimport { validateiap } from './validate-iap'\nimport { getReactions } from './get-reactions'\nimport { markallnotificationsnew } from './mark-all-notifications-new'\nimport {\n  getContractOptionVoters,\n  getContractVoters,\n} from './get-contract-voters'\nimport { purchaseContractBoost } from './purchase-contract-boost'\nimport {\n  generateAINumericRanges,\n  regenerateNumericMidpoints,\n} from './generate-ai-numeric-ranges'\nimport {\n  generateAIDateRanges,\n  regenerateDateMidpoints,\n} from './generate-ai-date-ranges'\nimport { inferNumericUnit } from './infer-numeric-unit'\nimport { generateConciseTitle } from './generate-concise-title'\nimport { getCloseDateEndpoint } from './get-close-date'\nimport { referUser } from './refer-user'\nimport {\n  saveMarketDraft,\n  getMarketDrafts,\n  deleteMarketDraft,\n} from './market-drafts'\nimport { getSeasonInfo } from './get-season-info'\nimport { markNotificationRead } from './mark-all-notifications'\nimport { createPostComment, updatePostComment } from './create-post-comment'\nimport { createPost, updatePost } from './create-post'\nimport { getPosts } from './get-posts'\nimport { dismissUserReport } from './dismiss-user-report'\nimport { followPost } from './follow-post'\n\nexport const handlers: { [k in APIPath]: APIHandler<k> } = {\n  'refresh-all-clients': refreshAllClients,\n  bet: placeBet,\n  'multi-bet': placeMultiBet,\n  'follow-contract': followContract,\n  'bet/cancel/:betId': cancelBet,\n  'market/:contractId/sell': sellShares,\n  bets: getBets,\n  'bet-points': getBetPointsBetween,\n  'get-notifications': getNotifications,\n  'get-channel-memberships': getChannelMemberships,\n  'get-channel-messages': getChannelMessages,\n  'get-channel-seen-time': getLastSeenChannelTime,\n  'set-channel-seen-time': setChannelLastSeenTime,\n  'get-contract': getContract,\n  comment: createComment,\n  'hide-comment': hideComment,\n  'pin-comment': pinComment,\n  comments: getComments,\n  market: createMarket,\n  'market/:contractId/group': addOrRemoveTopicFromContract,\n  'market/:contractId/groups': getContractTopics,\n  'group/:slug': getGroup,\n  'group/by-id/:id': getGroup,\n  'group/by-id/:id/markets': ({ id, limit }, ...rest) =>\n    getMarkets({ groupId: id, limit }, ...rest),\n  'group/:slug/delete': deleteGroup,\n  'group/by-id/:id/delete': deleteGroup,\n  'group/:slug/block': blockGroup,\n  'group/:slug/unblock': unblockGroup,\n  'group/by-id/:topId/group/:bottomId': addOrRemoveTopicFromTopic,\n  'group/:slug/groups': getTopicTopics,\n  'group/:slug/dashboards': getTopicDashboards,\n  'group/by-id/:id/groups': getTopicTopics,\n  groups: getGroups,\n  'market/:id': getMarket,\n  'market/:id/lite': ({ id }) => getMarket({ id, lite: true }),\n  'market/:id/prob': getMarketProb,\n  'market-probs': getMarketProbs,\n  'answer/:answerId': getSingleAnswer,\n  'market/:contractId/answers': getContractAnswers,\n  'markets-by-ids': getMarketsByIds,\n  'slug/:slug': getMarket,\n  'market/:contractId/update': updateMarket,\n  'market/:contractId/close': closeMarket,\n  'market/:contractId/resolve': resolveMarket,\n  'market/:contractId/add-liquidity': addLiquidity,\n  'market/:contractId/remove-liquidity': removeLiquidity,\n  'market/:contractId/add-bounty': addBounty,\n  'market/:contractId/award-bounty': awardBounty,\n  'market/:contractId/answer': createAnswerCPMM,\n  'market/:contractId/block': blockMarket,\n  'market/:contractId/unblock': unblockMarket,\n  'get-user-limit-orders-with-contracts': getUserLimitOrdersWithContracts,\n  'get-interesting-groups-from-views': getInterestingGroupsFromViews,\n  leagues: getLeagues,\n  markets: getMarkets,\n  'search-markets': searchMarketsLite,\n  'search-markets-full': searchMarketsFull,\n  managram: managram,\n  managrams: getManagrams,\n  manalink: createManalink,\n  donate: donate,\n  'convert-cash-to-mana': convertCashToMana,\n  'convert-sp-to-mana': convertSpiceToMana,\n  'market/:id/positions': getPositions,\n  me: getMe,\n  'me/update': updateMe,\n  'me/delete': deleteMe,\n  'me/private': getCurrentPrivateUser,\n  'me/private/update': updatePrivateUser,\n  'user/by-id/:id': getUser,\n  'user/by-id/:id/lite': getLiteUser,\n  'user/:username': getUser,\n  'user/:username/lite': getLiteUser,\n  'user/:username/bets': (...props) => getBets(...props),\n  'user/by-id/:id/block': blockUser,\n  'user/by-id/:id/unblock': unblockUser,\n  users: getUsers,\n  'users/by-id': getUsersByIds,\n  'users/by-id/balance': getUserBalancesByIds,\n  'search-users': searchUsers,\n  react: addOrRemoveReaction,\n  'save-twitch': saveTwitchCredentials,\n  'set-push-token': setPushToken,\n  'update-notif-settings': updateNotifSettings,\n  headlines: getHeadlines,\n  'politics-headlines': getPoliticsHeadlines,\n  'compatible-lovers': getCompatibleLovers,\n  post: post,\n  'fetch-link-preview': fetchLinkPreview,\n  'request-loan': requestLoan,\n  'remove-pinned-photo': removePinnedPhoto,\n  'get-related-markets': getRelatedMarkets,\n  'get-related-markets-by-group': getRelatedMarketsByGroup,\n  'unlist-and-cancel-user-contracts': unlistAndCancelUserContracts,\n  'get-boost-analytics': getBoostAnalytics,\n  'get-compatibility-questions': getCompatibilityQuestions,\n  'like-lover': likeLover,\n  'ship-lovers': shipLovers,\n  'get-likes-and-ships': getLikesAndShips,\n  'has-free-like': hasFreeLike,\n  'star-lover': starLover,\n  'get-lovers': getLovers,\n  'get-lover-answers': getLoverAnswers,\n  'set-news': setnews,\n  'search-groups': searchGroups,\n  'search-my-groups': searchMyGroups,\n  'get-groups-with-top-contracts': getGroupsWithTopContracts,\n  'get-balance-changes': getBalanceChanges,\n  'get-partner-stats': getPartnerStats,\n  'get-posts': getPosts,\n  'get-seen-market-ids': getSeenMarketIds,\n  'record-contract-view': recordContractView,\n  'get-dashboard-from-slug': getDashboardFromSlug,\n  'create-public-chat-message': createPublicChatMessage,\n  unresolve: unresolve,\n  'get-followed-groups': getFollowedGroups,\n  'unique-bet-group-count': getUniqueBetGroupCount,\n  'record-contract-interaction': recordContractInteraction,\n  'get-user-portfolio': getUserPortfolio,\n  'get-user-portfolio-history': getUserPortfolioHistory,\n  createuser: createuser,\n  'verify-phone-number': verifyPhoneNumber,\n  'request-otp': requestOTP,\n  'multi-sell': multiSell,\n  'get-feed': getFeed,\n  'get-mana-supply': getManaSupply,\n  'update-mod-report': updateModReport,\n  'get-mod-reports': getModReports,\n  'search-contract-positions': searchContractPositions,\n  'get-txn-summary-stats': getTxnSummaryStats,\n  'get-mana-summary-stats': getManaSummaryStats,\n  'register-gidx': register,\n  'get-checkout-session-gidx': getCheckoutSession,\n  'complete-checkout-session-gidx': completeCheckoutSession,\n  'complete-cashout-session-gidx': completeCashoutSession,\n  'complete-cashout-request': completeCashoutRequest,\n  'get-verification-status-gidx': getVerificationStatus,\n  'upload-document-gidx': uploadDocument,\n  'identity-callback-gidx': identityCallbackGIDX,\n  'payment-callback-gidx': paymentCallbackGIDX,\n  'get-verification-documents-gidx': getVerificationDocuments,\n  'get-redeemable-prize-cash': getRedeemablePrizeCash,\n  'get-total-redeemable-prize-cash': getTotalRedeemablePrizeCash,\n  'get-monitor-status-gidx': getMonitorStatus,\n  'get-best-comments': getBestComments,\n  'record-comment-view': recordCommentView,\n  'get-cashouts': getCashouts,\n  'get-kyc-stats': getKYCStats,\n  txns: getTxns,\n  'toggle-system-trading-status': toggleSystemTradingStatus,\n  leaderboard: getLeaderboard,\n  'get-daily-changed-metrics-and-contracts': getDailyChangedMetricsAndContracts,\n  'generate-ai-market-suggestions': generateAIMarketSuggestions,\n  'generate-ai-description': generateAIDescription,\n  'generate-ai-answers': generateAIAnswers,\n  'get-monthly-bets-2024': getmonthlybets2024,\n  'get-max-min-profit-2024': getmaxminprofit2024,\n  'get-next-loan-amount': getNextLoanAmount,\n  'check-sports-event': checkSportsEvent,\n  'create-task': createTask,\n  'update-task': updateTask,\n  'create-category': createCategory,\n  'get-categories': getCategories,\n  'update-category': updateCategory,\n  'get-tasks': getTasks,\n  'get-site-activity': getSiteActivity,\n  'is-sports-interested': isSportsInterested,\n  'get-sports-games': getSportsGames,\n  'get-market-props': getMarketProps,\n  'get-user-contract-metrics-with-contracts':\n    getUserContractMetricsWithContracts,\n  validateIap: validateiap,\n  'comment-reactions': getReactions,\n  'mark-all-notifications-new': markallnotificationsnew,\n  'get-contract-voters': getContractVoters,\n  'get-contract-option-voters': getContractOptionVoters,\n  'purchase-contract-boost': purchaseContractBoost,\n  'generate-ai-numeric-ranges': generateAINumericRanges,\n  'regenerate-numeric-midpoints': regenerateNumericMidpoints,\n  'infer-numeric-unit': inferNumericUnit,\n  'generate-ai-date-ranges': generateAIDateRanges,\n  'regenerate-date-midpoints': regenerateDateMidpoints,\n  'generate-concise-title': generateConciseTitle,\n  'get-close-date': getCloseDateEndpoint,\n  'refer-user': referUser,\n  'create-post-comment': createPostComment,\n  'create-post': createPost,\n  'update-post': updatePost,\n  'update-post-comment': updatePostComment,\n  'save-market-draft': saveMarketDraft,\n  'get-market-drafts': getMarketDrafts,\n  'delete-market-draft': deleteMarketDraft,\n  'get-season-info': getSeasonInfo,\n  'mark-notification-read': markNotificationRead,\n  'dismiss-user-report': dismissUserReport,\n  'follow-post': followPost,\n} as const\n",
          "postContent": "import { updateMe } from './update-me'\nimport { placeBet } from './place-bet'\nimport { cancelBet } from './cancel-bet'\nimport { sellShares } from './sell-shares'\nimport { createMarket } from './create-market'\nimport { createComment } from './create-comment'\nimport { resolveMarket } from './resolve-market'\nimport { closeMarket } from './close-market'\nimport { getMe } from './get-me'\nimport { saveTwitchCredentials } from './save-twitch-credentials'\nimport { addLiquidity } from './add-liquidity'\nimport { removeLiquidity } from './remove-liquidity'\nimport { searchGroups, searchMyGroups } from './search-groups'\nimport { awardBounty } from './award-bounty'\nimport { addBounty } from './add-bounty'\nimport { createAnswerCPMM } from './create-answer-cpmm'\nimport { managram } from './managram'\nimport { setnews } from './set-news'\nimport { getDashboardFromSlug } from './get-dashboard-from-slug'\nimport { unresolve } from './unresolve'\nimport { updateMarket } from 'api/update-market'\nimport { getCompatibleLovers } from './love/compatible-lovers'\nimport { type APIPath } from 'common/api/schema'\nimport { getMarkets } from 'api/markets'\nimport { hideComment } from './hide-comment'\nimport { pinComment } from './pin-comment'\nimport { getManagrams } from './get-managrams'\nimport { getGroups } from './get-groups'\nimport { getComments } from './get-comments'\nimport { getBetPointsBetween, getBets } from './get-bets'\nimport { getLiteUser, getUser } from './get-user'\nimport { getUsers } from './get-users'\nimport { getUserBalancesByIds, getUsersByIds } from './get-users-by-ids'\nimport { getMarket } from './get-market'\nimport { getMarketProb } from './get-market-prob'\nimport { getMarketProbs } from './get-market-probs'\nimport { getGroup } from './get-group'\nimport { getPositions } from './get-positions'\nimport { getLeagues } from './get-leagues'\nimport { getContract } from './get-contract'\nimport { getSingleAnswer } from './get-answer'\nimport { getContractAnswers } from './get-contract-answers'\nimport { addOrRemoveTopicFromContract } from './add-topic-to-market'\nimport { addOrRemoveTopicFromTopic } from './add-topic-to-topic'\nimport { searchUsers } from './search-users'\nimport { searchMarketsLite, searchMarketsFull } from './search-contracts'\nimport { post } from 'api/post'\nimport { fetchLinkPreview } from './fetch-link-preview'\nimport { type APIHandler } from './helpers/endpoint'\nimport { requestLoan } from 'api/request-loan'\nimport { removePinnedPhoto } from './love/remove-pinned-photo'\nimport { getHeadlines, getPoliticsHeadlines } from './get-headlines'\nimport { getBoostAnalytics } from 'api/get-boost-analytics'\nimport { getCompatibilityQuestions } from './love/get-compatibililty-questions'\nimport { addOrRemoveReaction } from './reaction'\nimport { likeLover } from './love/like-lover'\nimport { shipLovers } from './love/ship-lovers'\nimport { createManalink } from './create-manalink'\nimport { getLikesAndShips } from './love/get-likes-and-ships'\nimport { hasFreeLike } from './love/has-free-like'\nimport { starLover } from './love/star-lover'\nimport { getLovers } from './love/get-lovers'\nimport { unlistAndCancelUserContracts } from './unlist-and-cancel-user-contracts'\nimport { getGroupsWithTopContracts } from 'api/get-topics-with-markets'\nimport { getBalanceChanges } from 'api/get-balance-changes'\nimport { getLoverAnswers } from './love/get-lover-answers'\nimport { placeMultiBet } from 'api/place-multi-bet'\nimport { getPartnerStats } from './get-partner-stats'\nimport { getSeenMarketIds } from 'api/get-seen-market-ids'\nimport { recordContractView } from 'api/record-contract-view'\nimport { createPublicChatMessage } from 'api/create-public-chat-message'\nimport { getFollowedGroups } from './get-followed-groups'\nimport { getUniqueBetGroupCount } from 'api/get-unique-bet-groups'\nimport { deleteGroup } from './delete-group'\nimport { recordContractInteraction } from 'api/record-contract-interaction'\nimport { getUserPortfolio } from './get-user-portfolio'\nimport { createuser } from 'api/create-user'\nimport { verifyPhoneNumber } from 'api/verify-phone-number'\nimport { requestOTP } from 'api/request-phone-otp'\nimport { multiSell } from 'api/multi-sell'\nimport { convertCashToMana } from './convert-cash-to-mana'\nimport { convertSpiceToMana } from './convert-sp-to-mana'\nimport { donate } from './donate'\nimport { getFeed } from 'api/get-feed'\nimport { getManaSupply } from './get-mana-supply'\nimport { getUserPortfolioHistory } from './get-user-portfolio-history'\nimport { deleteMe } from './delete-me'\nimport { updateModReport } from './update-mod-report'\nimport { getModReports } from './get-mod-reports'\nimport { searchContractPositions } from 'api/search-contract-positions'\nimport { blockUser, unblockUser } from './block-user'\nimport { blockGroup, unblockGroup } from './block-group'\nimport { blockMarket, unblockMarket } from './block-market'\nimport { getTxnSummaryStats } from 'api/get-txn-summary-stats'\nimport { getManaSummaryStats } from 'api/get-mana-summary-stats'\nimport { register } from 'api/gidx/register'\nimport { uploadDocument } from 'api/gidx/upload-document'\nimport { identityCallbackGIDX, paymentCallbackGIDX } from 'api/gidx/callback'\nimport { getVerificationStatus } from 'api/gidx/get-verification-status'\nimport { getCurrentPrivateUser } from './get-current-private-user'\nimport { updatePrivateUser } from './update-private-user'\nimport { setPushToken } from './push-token'\nimport { updateNotifSettings } from './update-notif-settings'\nimport { getVerificationDocuments } from 'api/gidx/get-verification-documents'\nimport { getRedeemablePrizeCash } from './get-redeemable-prize-cash'\nimport { getTotalRedeemablePrizeCash } from './get-total-redeemable-prize-cash'\nimport { getMonitorStatus } from 'api/gidx/get-monitor-status'\nimport { getBestComments } from 'api/get-best-comments'\nimport { recordCommentView } from 'api/record-comment-view'\nimport {\n  getChannelMemberships,\n  getChannelMessages,\n  getLastSeenChannelTime,\n  setChannelLastSeenTime,\n} from 'api/get-private-messages'\nimport { getNotifications } from 'api/get-notifications'\nimport { getCheckoutSession } from 'api/gidx/get-checkout-session'\nimport { completeCheckoutSession } from 'api/gidx/complete-checkout-session'\nimport { getContractTopics } from './get-contract-topics'\nimport { getRelatedMarkets } from './get-related-markets'\nimport { getRelatedMarketsByGroup } from './get-related-markets-by-group'\nimport { followContract } from './follow-contract'\nimport { getUserLimitOrdersWithContracts } from 'api/get-user-limit-orders-with-contracts'\nimport { getInterestingGroupsFromViews } from 'api/get-interesting-groups-from-views'\nimport { completeCashoutSession } from 'api/gidx/complete-cashout-session'\nimport { getCashouts } from './get-cashouts'\nimport { getKYCStats } from './get-kyc-stats'\nimport { getTxns } from './get-txns'\nimport { refreshAllClients } from './refresh-all-clients'\nimport { getLeaderboard } from './get-leaderboard'\nimport { toggleSystemTradingStatus } from './toggle-system-status'\nimport { completeCashoutRequest } from './gidx/complete-cashout-request'\nimport { getDailyChangedMetricsAndContracts } from './get-daily-changed-metrics-and-contracts'\nimport { getMarketsByIds } from './get-markets'\nimport { getTopicTopics } from './get-topic-topics'\nimport { getTopicDashboards } from './get-topic-dashboards'\nimport { generateAIMarketSuggestions } from './generate-ai-market-suggestions'\nimport { generateAIDescription } from './generate-ai-description'\nimport { generateAIAnswers } from './generate-ai-answers'\nimport { getmonthlybets2024 } from './get-monthly-bets-2024'\nimport { getmaxminprofit2024 } from './get-max-min-profit-2024'\nimport { getNextLoanAmount } from './get-next-loan-amount'\nimport { checkSportsEvent } from './check-sports-event'\n\nimport { createTask } from './create-task'\nimport { updateTask } from './update-task'\nimport { createCategory } from './create-category'\nimport { getCategories } from './get-categories'\nimport { updateCategory } from './update-category'\nimport { getTasks } from './get-tasks'\n\nimport { getSiteActivity } from './get-site-activity'\nimport { isSportsInterested } from './is-sports-bettor'\nimport { getSportsGames } from './get-sports-games'\nimport { getMarketProps } from './get-market-props'\nimport { getUserContractMetricsWithContracts } from './get-user-contract-metrics-with-contracts'\nimport { validateiap } from './validate-iap'\nimport { getReactions } from './get-reactions'\nimport { markallnotificationsnew } from './mark-all-notifications-new'\nimport {\n  getContractOptionVoters,\n  getContractVoters,\n} from './get-contract-voters'\nimport { purchaseContractBoost } from './purchase-contract-boost'\nimport {\n  generateAINumericRanges,\n  regenerateNumericMidpoints,\n} from './generate-ai-numeric-ranges'\nimport {\n  generateAIDateRanges,\n  regenerateDateMidpoints,\n} from './generate-ai-date-ranges'\nimport { inferNumericUnit } from './infer-numeric-unit'\nimport { generateConciseTitle } from './generate-concise-title'\nimport { getCloseDateEndpoint } from './get-close-date'\nimport { referUser } from './refer-user'\nimport {\n  saveMarketDraft,\n  getMarketDrafts,\n  deleteMarketDraft,\n} from './market-drafts'\nimport { getSeasonInfo } from './get-season-info'\nimport { markNotificationRead } from './mark-all-notifications'\nimport { createPostComment, updatePostComment } from './create-post-comment'\nimport { createPost, updatePost } from './create-post'\nimport { getPosts } from './get-posts'\nimport { dismissUserReport } from './dismiss-user-report'\nimport { followPost } from './follow-post'\nimport { editPostComment } from './edit-post-comment'\nimport { getUserComments } from './get-comments'\nexport const handlers: { [k in APIPath]: APIHandler<k> } = {\n  'refresh-all-clients': refreshAllClients,\n  bet: placeBet,\n  'multi-bet': placeMultiBet,\n  'follow-contract': followContract,\n  'bet/cancel/:betId': cancelBet,\n  'market/:contractId/sell': sellShares,\n  bets: getBets,\n  'bet-points': getBetPointsBetween,\n  'get-notifications': getNotifications,\n  'get-channel-memberships': getChannelMemberships,\n  'get-channel-messages': getChannelMessages,\n  'get-channel-seen-time': getLastSeenChannelTime,\n  'set-channel-seen-time': setChannelLastSeenTime,\n  'get-contract': getContract,\n  comment: createComment,\n  'hide-comment': hideComment,\n  'pin-comment': pinComment,\n  comments: getComments,\n  market: createMarket,\n  'market/:contractId/group': addOrRemoveTopicFromContract,\n  'market/:contractId/groups': getContractTopics,\n  'group/:slug': getGroup,\n  'group/by-id/:id': getGroup,\n  'group/by-id/:id/markets': ({ id, limit }, ...rest) =>\n    getMarkets({ groupId: id, limit }, ...rest),\n  'group/:slug/delete': deleteGroup,\n  'group/by-id/:id/delete': deleteGroup,\n  'group/:slug/block': blockGroup,\n  'group/:slug/unblock': unblockGroup,\n  'group/by-id/:topId/group/:bottomId': addOrRemoveTopicFromTopic,\n  'group/:slug/groups': getTopicTopics,\n  'group/:slug/dashboards': getTopicDashboards,\n  'group/by-id/:id/groups': getTopicTopics,\n  groups: getGroups,\n  'market/:id': getMarket,\n  'market/:id/lite': ({ id }) => getMarket({ id, lite: true }),\n  'market/:id/prob': getMarketProb,\n  'market-probs': getMarketProbs,\n  'answer/:answerId': getSingleAnswer,\n  'market/:contractId/answers': getContractAnswers,\n  'markets-by-ids': getMarketsByIds,\n  'slug/:slug': getMarket,\n  'market/:contractId/update': updateMarket,\n  'market/:contractId/close': closeMarket,\n  'market/:contractId/resolve': resolveMarket,\n  'market/:contractId/add-liquidity': addLiquidity,\n  'market/:contractId/remove-liquidity': removeLiquidity,\n  'market/:contractId/add-bounty': addBounty,\n  'market/:contractId/award-bounty': awardBounty,\n  'market/:contractId/answer': createAnswerCPMM,\n  'market/:contractId/block': blockMarket,\n  'market/:contractId/unblock': unblockMarket,\n  'get-user-limit-orders-with-contracts': getUserLimitOrdersWithContracts,\n  'get-interesting-groups-from-views': getInterestingGroupsFromViews,\n  leagues: getLeagues,\n  markets: getMarkets,\n  'search-markets': searchMarketsLite,\n  'search-markets-full': searchMarketsFull,\n  managram: managram,\n  managrams: getManagrams,\n  manalink: createManalink,\n  donate: donate,\n  'convert-cash-to-mana': convertCashToMana,\n  'convert-sp-to-mana': convertSpiceToMana,\n  'market/:id/positions': getPositions,\n  me: getMe,\n  'me/update': updateMe,\n  'me/delete': deleteMe,\n  'me/private': getCurrentPrivateUser,\n  'me/private/update': updatePrivateUser,\n  'user/by-id/:id': getUser,\n  'user/by-id/:id/lite': getLiteUser,\n  'user/:username': getUser,\n  'user/:username/lite': getLiteUser,\n  'user/:username/bets': (...props) => getBets(...props),\n  'user/by-id/:id/block': blockUser,\n  'user/by-id/:id/unblock': unblockUser,\n  users: getUsers,\n  'users/by-id': getUsersByIds,\n  'users/by-id/balance': getUserBalancesByIds,\n  'search-users': searchUsers,\n  react: addOrRemoveReaction,\n  'save-twitch': saveTwitchCredentials,\n  'set-push-token': setPushToken,\n  'update-notif-settings': updateNotifSettings,\n  headlines: getHeadlines,\n  'politics-headlines': getPoliticsHeadlines,\n  'compatible-lovers': getCompatibleLovers,\n  post: post,\n  'fetch-link-preview': fetchLinkPreview,\n  'request-loan': requestLoan,\n  'remove-pinned-photo': removePinnedPhoto,\n  'get-related-markets': getRelatedMarkets,\n  'get-related-markets-by-group': getRelatedMarketsByGroup,\n  'unlist-and-cancel-user-contracts': unlistAndCancelUserContracts,\n  'get-boost-analytics': getBoostAnalytics,\n  'get-compatibility-questions': getCompatibilityQuestions,\n  'like-lover': likeLover,\n  'ship-lovers': shipLovers,\n  'get-likes-and-ships': getLikesAndShips,\n  'has-free-like': hasFreeLike,\n  'star-lover': starLover,\n  'get-lovers': getLovers,\n  'get-lover-answers': getLoverAnswers,\n  'set-news': setnews,\n  'search-groups': searchGroups,\n  'search-my-groups': searchMyGroups,\n  'get-groups-with-top-contracts': getGroupsWithTopContracts,\n  'get-balance-changes': getBalanceChanges,\n  'get-partner-stats': getPartnerStats,\n  'get-posts': getPosts,\n  'get-seen-market-ids': getSeenMarketIds,\n  'record-contract-view': recordContractView,\n  'get-dashboard-from-slug': getDashboardFromSlug,\n  'create-public-chat-message': createPublicChatMessage,\n  unresolve: unresolve,\n  'get-followed-groups': getFollowedGroups,\n  'unique-bet-group-count': getUniqueBetGroupCount,\n  'record-contract-interaction': recordContractInteraction,\n  'get-user-portfolio': getUserPortfolio,\n  'get-user-portfolio-history': getUserPortfolioHistory,\n  createuser: createuser,\n  'verify-phone-number': verifyPhoneNumber,\n  'request-otp': requestOTP,\n  'multi-sell': multiSell,\n  'get-feed': getFeed,\n  'get-mana-supply': getManaSupply,\n  'update-mod-report': updateModReport,\n  'get-mod-reports': getModReports,\n  'search-contract-positions': searchContractPositions,\n  'get-txn-summary-stats': getTxnSummaryStats,\n  'get-mana-summary-stats': getManaSummaryStats,\n  'register-gidx': register,\n  'get-checkout-session-gidx': getCheckoutSession,\n  'complete-checkout-session-gidx': completeCheckoutSession,\n  'complete-cashout-session-gidx': completeCashoutSession,\n  'complete-cashout-request': completeCashoutRequest,\n  'get-verification-status-gidx': getVerificationStatus,\n  'upload-document-gidx': uploadDocument,\n  'identity-callback-gidx': identityCallbackGIDX,\n  'payment-callback-gidx': paymentCallbackGIDX,\n  'get-verification-documents-gidx': getVerificationDocuments,\n  'get-redeemable-prize-cash': getRedeemablePrizeCash,\n  'get-total-redeemable-prize-cash': getTotalRedeemablePrizeCash,\n  'get-monitor-status-gidx': getMonitorStatus,\n  'get-best-comments': getBestComments,\n  'record-comment-view': recordCommentView,\n  'get-cashouts': getCashouts,\n  'get-kyc-stats': getKYCStats,\n  txns: getTxns,\n  'toggle-system-trading-status': toggleSystemTradingStatus,\n  leaderboard: getLeaderboard,\n  'get-daily-changed-metrics-and-contracts': getDailyChangedMetricsAndContracts,\n  'generate-ai-market-suggestions': generateAIMarketSuggestions,\n  'generate-ai-description': generateAIDescription,\n  'generate-ai-answers': generateAIAnswers,\n  'get-monthly-bets-2024': getmonthlybets2024,\n  'get-max-min-profit-2024': getmaxminprofit2024,\n  'get-next-loan-amount': getNextLoanAmount,\n  'check-sports-event': checkSportsEvent,\n  'create-task': createTask,\n  'update-task': updateTask,\n  'create-category': createCategory,\n  'get-categories': getCategories,\n  'update-category': updateCategory,\n  'get-tasks': getTasks,\n  'get-site-activity': getSiteActivity,\n  'is-sports-interested': isSportsInterested,\n  'get-sports-games': getSportsGames,\n  'get-market-props': getMarketProps,\n  'get-user-contract-metrics-with-contracts':\n    getUserContractMetricsWithContracts,\n  validateIap: validateiap,\n  'comment-reactions': getReactions,\n  'mark-all-notifications-new': markallnotificationsnew,\n  'get-contract-voters': getContractVoters,\n  'get-contract-option-voters': getContractOptionVoters,\n  'purchase-contract-boost': purchaseContractBoost,\n  'generate-ai-numeric-ranges': generateAINumericRanges,\n  'regenerate-numeric-midpoints': regenerateNumericMidpoints,\n  'infer-numeric-unit': inferNumericUnit,\n  'generate-ai-date-ranges': generateAIDateRanges,\n  'regenerate-date-midpoints': regenerateDateMidpoints,\n  'generate-concise-title': generateConciseTitle,\n  'get-close-date': getCloseDateEndpoint,\n  'refer-user': referUser,\n  'create-post-comment': createPostComment,\n  'create-post': createPost,\n  'update-post': updatePost,\n  'update-post-comment': updatePostComment,\n  'save-market-draft': saveMarketDraft,\n  'get-market-drafts': getMarketDrafts,\n  'delete-market-draft': deleteMarketDraft,\n  'get-season-info': getSeasonInfo,\n  'mark-notification-read': markNotificationRead,\n  'dismiss-user-report': dismissUserReport,\n  'follow-post': followPost,\n  'edit-post-comment': editPostComment,\n  'user-comments': getUserComments,\n} as const\n"
        },
        {
          "path": "backend/shared/src/supabase/contract-comments.ts",
          "preContent": "import { convertContractComment } from 'common/supabase/comments'\nimport { SupabaseDirectClient } from 'shared/supabase/init'\nimport { APIError } from 'common/api/utils'\nimport { millisToTs } from 'common/supabase/utils'\n\nexport async function getCommentSafe(\n  pg: SupabaseDirectClient,\n  commentId: string\n) {\n  return pg.oneOrNone(\n    `select data from contract_comments where comment_id = $1`,\n    [commentId],\n    (r) => (r ? convertContractComment(r.data) : null)\n  )\n}\n\nexport async function getComment(pg: SupabaseDirectClient, commentId: string) {\n  const comment = await pg.oneOrNone(\n    `select data from contract_comments where comment_id = $1`,\n    [commentId],\n    (r) => (r ? convertContractComment(r.data) : null)\n  )\n  if (!comment) {\n    throw new APIError(404, 'Comment not found')\n  }\n  return comment\n}\n\nexport async function getCommentsDirect(\n  pg: SupabaseDirectClient,\n  filters: {\n    userId?: string\n    contractId?: string\n    limit?: number\n    page?: number\n    replyToCommentId?: string\n    commentId?: string\n    afterTime?: number\n  }\n) {\n  const {\n    userId,\n    contractId,\n    limit = 5000,\n    page = 0,\n    replyToCommentId,\n    commentId,\n    afterTime,\n  } = filters\n  return await pg.map(\n    `\n        select cc.data, likes, dislikes from contract_comments cc\n          join contracts on cc.contract_id = contracts.id\n        where contracts.visibility = 'public'\n          and ($3 is null or contract_id = $3)\n          and ($4 is null or user_id = $4)\n          and ($5 is null or cc.data->>'replyToCommentId' = $5)\n          and ($6 is null or cc.comment_id = $6)\n          and ($7 is null or cc.created_time > $7)\n        order by cc.created_time desc\n        limit $1\n        offset $2\n    `,\n    [\n      limit,\n      page * limit,\n      contractId,\n      userId,\n      replyToCommentId,\n      commentId,\n      afterTime ? millisToTs(afterTime) : null,\n    ],\n    (r) => convertContractComment(r)\n  )\n}\n",
          "postContent": "import { convertContractComment } from 'common/supabase/comments'\nimport { SupabaseDirectClient } from 'shared/supabase/init'\nimport { APIError } from 'common/api/utils'\nimport { millisToTs } from 'common/supabase/utils'\nimport { Comment } from 'common/comment'\n\nexport async function getCommentSafe(\n  pg: SupabaseDirectClient,\n  commentId: string\n) {\n  return pg.oneOrNone(\n    `select data from contract_comments where comment_id = $1`,\n    [commentId],\n    (r) => (r ? convertContractComment(r.data) : null)\n  )\n}\n\nexport async function getComment(pg: SupabaseDirectClient, commentId: string) {\n  const comment = await pg.oneOrNone(\n    `select data from contract_comments where comment_id = $1`,\n    [commentId],\n    (r) => (r ? convertContractComment(r.data) : null)\n  )\n  if (!comment) {\n    throw new APIError(404, 'Comment not found')\n  }\n  return comment\n}\n\nexport async function getCommentsDirect<T extends Comment>(\n  pg: SupabaseDirectClient,\n  filters: {\n    userId?: string\n    contractId?: string\n    limit?: number\n    page?: number\n    replyToCommentId?: string\n    commentId?: string\n    afterTime?: number\n  }\n): Promise<T[]> {\n  const {\n    userId,\n    contractId,\n    limit = 5000,\n    page = 0,\n    replyToCommentId,\n    commentId,\n    afterTime,\n  } = filters\n\n  let query: string\n  const params: any[] = [\n    limit,\n    page * limit,\n    contractId,\n    userId,\n    replyToCommentId,\n    commentId,\n    afterTime ? millisToTs(afterTime) : null,\n  ]\n\n  // Combine contract comments and old post comments for a user's page\n  if (userId) {\n    query = `\n      SELECT * FROM (\n        -- Contract Comments\n        SELECT\n            cc.data,\n            cc.created_time,\n            cc.comment_id,\n            c.slug,\n            c.question as title\n        FROM contract_comments cc\n        JOIN contracts c ON cc.contract_id = c.id\n        WHERE\n            c.visibility = 'public'\n            AND ($3 IS NULL OR cc.contract_id = $3) -- contractId (can be null when querying by user)\n            AND cc.user_id = $4                   -- userId (must be present here)\n            AND ($5 IS NULL OR cc.data->>'replyToCommentId' = $5) -- replyToCommentId\n            AND ($6 IS NULL OR cc.comment_id = $6)   -- commentId\n            AND ($7 IS NULL OR cc.created_time > $7) -- afterTime\n\n        UNION ALL\n\n        -- Old Post Comments\n        SELECT\n            opc.data,\n            opc.created_time,\n            opc.comment_id,\n            op.data->>'slug' as slug,\n            op.data->>'title' as title\n        FROM old_post_comments opc\n        join old_posts op on opc.post_id = op.id\n        WHERE\n             opc.user_id = $4\n            AND ($7 IS NULL OR opc.created_time > $7)\n            and op.visibility = 'public'\n      ) AS combined_comments\n      ORDER BY created_time DESC\n      LIMIT $1 -- limit\n      OFFSET $2 -- offset\n    `\n  } else {\n    if (!contractId) {\n      throw new APIError(400, 'Either contractId or userId must be provided')\n    }\n    query = `\n        select cc.data from contract_comments cc\n          join contracts c on cc.contract_id = c.id\n        where c.visibility = 'public'\n          and cc.contract_id = $3 -- contractId (must be present here)\n          -- userId ($4) is ignored in this branch\n          and ($5 is null or cc.data->>'replyToCommentId' = $5) -- replyToCommentId\n          and ($6 is null or cc.comment_id = $6)           -- commentId\n          and ($7 is null or cc.created_time > $7)        -- afterTime\n        order by cc.created_time desc\n        limit $1\n        offset $2\n    `\n  }\n\n  return await pg.map(query, params, (r) => {\n    const comment = r.data as T\n    if (comment.commentType === 'post') {\n      comment.postSlug = r.slug\n      comment.postTitle = r.title\n    }\n    return comment\n  })\n}\n"
        },
        {
          "path": "backend/supabase/post_comment_edits.sql",
          "preContent": "[NEW FILE]",
          "postContent": "-- This file is autogenerated from regen-schema.ts\ncreate table if not exists\n  post_comment_edits (\n    comment_id text not null,\n    post_id text not null,\n    created_time timestamp with time zone default now() not null,\n    data jsonb not null,\n    editor_id text not null,\n    id bigint generated always as identity\n  );\n\n-- Row Level Security\nalter table post_comment_edits enable row level security;\n\n-- Policies\ndrop policy if exists \"public read\" on post_comment_edits;\n\ncreate policy \"public read\" on post_comment_edits for\nselect\n  using (true);\n\n-- Indexes\ndrop index if exists post_comment_edits_comment_id_idx;\n\ncreate index post_comment_edits_comment_id_idx on public.post_comment_edits using btree (comment_id);\n"
        },
        {
          "path": "common/src/api/schema.ts",
          "preContent": "import { z } from 'zod'\nimport {\n  Group,\n  MAX_ID_LENGTH,\n  MySearchGroupShape,\n  LiteGroup,\n  SearchGroupParams,\n  SearchGroupShape,\n  Topic,\n} from 'common/group'\nimport {\n  createMarketProps,\n  resolveMarketProps,\n  type LiteMarket,\n  FullMarket,\n  updateMarketProps,\n} from './market-types'\nimport { type Answer } from 'common/answer'\nimport {\n  CommentWithTotalReplies,\n  MAX_COMMENT_LENGTH,\n  PostComment,\n  type ContractComment,\n} from 'common/comment'\nimport { CandidateBet } from 'common/new-bet'\nimport type { Bet, LimitBet } from 'common/bet'\nimport { coerceBoolean, contentSchema } from 'common/api/zod-types'\nimport { Lover } from 'common/love/lover'\nimport { AIGeneratedMarket, Contract, MarketContract } from 'common/contract'\nimport { CompatibilityScore } from 'common/love/compatibility-score'\nimport type { Txn, ManaPayTxn } from 'common/txn'\nimport { LiquidityProvision } from 'common/liquidity-provision'\nimport { DisplayUser, FullUser } from './user-types'\nimport { League } from 'common/leagues'\nimport { searchProps } from './market-search-types'\nimport { MAX_ANSWER_LENGTH } from 'common/answer'\nimport { type LinkPreview } from 'common/link-preview'\nimport { Headline } from 'common/news'\nimport { Row } from 'common/supabase/utils'\nimport { LikeData, ShipData } from './love-types'\nimport { AnyBalanceChangeType } from 'common/balance-change'\nimport { Dashboard } from 'common/dashboard'\nimport { ChatMessage, PrivateChatMessage } from 'common/chat-message'\nimport { PrivateUser, User } from '../user'\nimport { ManaSupply } from 'common/stats'\nimport { Repost } from 'common/repost'\nimport { PERIODS } from 'common/period'\nimport { SWEEPS_MIN_BET } from 'common/economy'\nimport {\n  LivePortfolioMetrics,\n  PortfolioMetrics,\n} from 'common/portfolio-metrics'\nimport { ModReport } from '../mod-report'\n\nimport { RegistrationReturnType } from 'common/reason-codes'\nimport {\n  CheckoutSession,\n  GIDXDocument,\n  GPSProps,\n  PaymentDetail,\n  checkoutParams,\n  verificationParams,\n  cashoutRequestParams,\n  PendingCashoutStatusData,\n  cashoutParams,\n} from 'common/gidx/gidx'\nimport { notification_preference } from 'common/user-notification-preferences'\nimport { PrivateMessageChannel } from 'common/supabase/private-messages'\nimport { Notification } from 'common/notification'\nimport { NON_POINTS_BETS_LIMIT } from 'common/supabase/bets'\nimport { ContractMetric } from 'common/contract-metric'\n\nimport { JSONContent } from '@tiptap/core'\nimport { Task, TaskCategory } from 'common/todo'\nimport { ChartAnnotation } from 'common/supabase/chart-annotations'\nimport { Dictionary } from 'lodash'\nimport { Reaction } from 'common/reaction'\nimport { YEAR_MS } from 'common/util/time'\nimport { MarketDraft } from 'common/drafts'\nimport { TopLevelPost } from 'common/top-level-post'\n// mqp: very unscientific, just balancing our willingness to accept load\n// with user willingness to put up with stale data\nexport const DEFAULT_CACHE_STRATEGY =\n  'public, max-age=5, stale-while-revalidate=10'\nconst MAX_EXPIRES_AT = 1_000 * YEAR_MS\n\ntype APIGenericSchema = {\n  // GET is for retrieval, POST is to mutate something, PUT is idempotent mutation (can be repeated safely)\n  method: 'GET' | 'POST' | 'PUT'\n  //private APIs can only be called from manifold. undocumented endpoints can change or be deleted at any time!\n  visibility: 'public' | 'undocumented' | 'private'\n  // whether the endpoint requires authentication\n  authed: boolean\n  // zod schema for the request body (or for params for GET requests)\n  props: z.ZodType\n  // note this has to be JSON serializable\n  returns?: Record<string, any>\n  // Cache-Control header. like, 'max-age=60'\n  cache?: string\n  // whether the endpoint should prefer authentication even if not required\n  preferAuth?: boolean\n}\n\nlet _apiTypeCheck: { [x: string]: APIGenericSchema }\nexport const API = (_apiTypeCheck = {\n  'refresh-all-clients': {\n    method: 'POST',\n    visibility: 'public',\n    props: z.object({ message: z.string().optional() }),\n    authed: true,\n  },\n  'toggle-system-trading-status': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        token: z.enum(['MANA', 'CASH']),\n      })\n      .strict(),\n    returns: {} as { status: boolean },\n  },\n  comment: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as ContractComment,\n    props: z\n      .object({\n        contractId: z.string(),\n        content: contentSchema.optional(),\n        html: z.string().optional(),\n        markdown: z.string().optional(),\n        replyToCommentId: z.string().optional(),\n        replyToAnswerId: z.string().optional(),\n        replyToBetId: z.string().optional(),\n      })\n      .strict(),\n  },\n\n  'follow-contract': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: true },\n    props: z\n      .object({\n        contractId: z.string(),\n        follow: z.boolean(),\n      })\n      .strict(),\n  },\n  'get-contract': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as Contract,\n    props: z\n      .object({\n        contractId: z.string(),\n      })\n      .strict(),\n  },\n  'answer/:answerId': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as Answer,\n    props: z.object({ answerId: z.string() }).strict(),\n  },\n  'market/:contractId/answers': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: [] as Answer[],\n    props: z.object({ contractId: z.string() }).strict(),\n  },\n  'hide-comment': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ commentPath: z.string() }).strict(),\n  },\n  'pin-comment': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({ commentPath: z.string() }).strict(),\n  },\n  comments: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    // cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as ContractComment[],\n    props: z\n      .object({\n        contractId: z.string().optional(),\n        contractSlug: z.string().optional(),\n        afterTime: z.coerce.number().optional(),\n        limit: z.coerce.number().gte(0).lte(1000).default(1000),\n        page: z.coerce.number().gte(0).default(0),\n        userId: z.string().optional(),\n        isPolitics: coerceBoolean.optional(),\n      })\n      .strict(),\n  },\n  bet: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as CandidateBet & { betId: string },\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gte(SWEEPS_MIN_BET),\n        replyToCommentId: z.string().optional(),\n        limitProb: z.number().gte(0.01).lte(0.99).optional(),\n        expiresMillisAfter: z.number().lt(MAX_EXPIRES_AT).optional(),\n        silent: z.boolean().optional(),\n        expiresAt: z.number().lt(MAX_EXPIRES_AT).optional(),\n        // Used for binary and new multiple choice contracts (cpmm-multi-1).\n        outcome: z.enum(['YES', 'NO']).default('YES'),\n        //Multi\n        answerId: z.string().optional(),\n        dryRun: z.boolean().optional(),\n        deps: z.array(z.string()).optional(),\n        deterministic: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  createuser: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { user: User; privateUser: PrivateUser },\n    props: z\n      .object({\n        deviceToken: z.string().optional(),\n        adminToken: z.string().optional(),\n        visitedContractIds: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'multi-bet': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as (CandidateBet & { betId: string })[],\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gte(1),\n        limitProb: z.number().gte(0).lte(1).optional(),\n        expiresAt: z.number().lt(MAX_EXPIRES_AT).optional(),\n        answerIds: z.array(z.string()).min(1),\n        deterministic: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  'multi-sell': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as (CandidateBet & { betId: string })[],\n    props: z\n      .object({\n        contractId: z.string(),\n        answerIds: z.array(z.string()).min(1),\n        deterministic: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  leaderboard: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as { userId: string; score: number }[],\n    props: z\n      .object({\n        groupId: z.string().optional(),\n        limit: z.coerce.number().min(1).max(100).default(50),\n        token: z.enum(['MANA', 'CASH']).default('MANA'),\n        kind: z.enum(['creator', 'profit', 'loss', 'volume', 'referral']),\n      })\n      .strict(),\n  },\n  'verify-phone-number': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { status: string },\n    props: z\n      .object({\n        phoneNumber: z.string(),\n        code: z.string(),\n      })\n      .strict(),\n  },\n  'request-otp': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { status: string },\n    props: z\n      .object({\n        phoneNumber: z.string(),\n      })\n      .strict(),\n  },\n  'bet/cancel/:betId': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ betId: z.string() }).strict(),\n    returns: {} as LimitBet,\n  },\n  // sell shares\n  'market/:contractId/sell': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as CandidateBet & { betId: string },\n    props: z\n      .object({\n        contractId: z.string(),\n        shares: z.number().positive().optional(), // leave it out to sell all shares\n        outcome: z.enum(['YES', 'NO']),\n        answerId: z.string().optional(), // Required for multi binary markets\n        deterministic: z.boolean().optional(),\n        deps: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'get-user-limit-orders-with-contracts': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as {\n      bets: LimitBet[]\n      contracts: MarketContract[]\n    },\n    props: z\n      .object({\n        userId: z.string(),\n        count: z.coerce.number().lte(5000),\n        includeExpired: coerceBoolean.optional().default(false),\n        includeCancelled: coerceBoolean.optional().default(false),\n        includeFilled: coerceBoolean.optional().default(false),\n      })\n      .strict(),\n  },\n  'get-interesting-groups-from-views': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as (Group & { hasBet: boolean })[],\n    props: z\n      .object({\n        userId: z.string(),\n        contractIds: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  bets: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Bet[],\n    props: z\n      .object({\n        id: z.string().optional(),\n        userId: z.string().optional(),\n        username: z.string().optional(),\n        contractId: z.string().or(z.array(z.string())).optional(),\n        contractSlug: z.string().optional(),\n        answerId: z.string().optional(),\n        // market: z.string().optional(), // deprecated, synonym for `contractSlug`\n        limit: z.coerce\n          .number()\n          .gte(0)\n          .lte(50000)\n          .default(NON_POINTS_BETS_LIMIT),\n        before: z.string().optional(),\n        after: z.string().optional(),\n        beforeTime: z.coerce.number().optional(),\n        afterTime: z.coerce.number().optional(),\n        order: z.enum(['asc', 'desc']).optional(),\n        kinds: z.enum(['open-limit']).optional(),\n        // undocumented fields. idk what a good api interface would be\n        filterRedemptions: coerceBoolean.optional(),\n        includeZeroShareRedemptions: coerceBoolean.optional(),\n        commentRepliesOnly: coerceBoolean.optional(),\n        count: coerceBoolean.optional(),\n        points: coerceBoolean.optional(),\n      })\n      .strict(),\n  },\n  'bet-points': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: 'public, max-age=600, stale-while-revalidate=60',\n    returns: [] as Bet[],\n    props: z\n      .object({\n        contractId: z.string(),\n        answerId: z.string().optional(),\n        limit: z.coerce.number().gte(0).lte(50000).default(5000),\n        beforeTime: z.coerce.number(),\n        afterTime: z.coerce.number(),\n        filterRedemptions: coerceBoolean.optional(),\n        includeZeroShareRedemptions: coerceBoolean.optional(),\n      })\n      .strict(),\n  },\n  'unique-bet-group-count': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as { count: number },\n    props: z\n      .object({\n        contractId: z.string(),\n      })\n      .strict(),\n  },\n  'get-daily-changed-metrics-and-contracts': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    cache: 'public, max-age=900, stale-while-revalidate=90', // 15 minute cache\n    props: z\n      .object({\n        limit: z.coerce.number(),\n        userId: z.string(),\n        balance: z.coerce.number(),\n      })\n      .strict(),\n    returns: {} as {\n      manaMetrics: ContractMetric[]\n      contracts: MarketContract[]\n      manaProfit: number\n      manaInvestmentValue: number\n      balance: number\n    },\n  },\n  // deprecated. use /bets?username= instead\n  'user/:username/bets': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Bet[],\n    props: z\n      .object({\n        username: z.string(),\n        limit: z.coerce.number().gte(0).lte(1000).default(1000),\n      })\n      .strict(),\n  },\n  'group/:slug': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as Group,\n    props: z.object({ slug: z.string() }),\n  },\n  'group/:slug/groups': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as { above: LiteGroup[]; below: LiteGroup[] },\n    props: z.object({ slug: z.string() }).strict(),\n  },\n  'group/:slug/dashboards': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as {\n      id: string\n      title: string\n      slug: string\n      creatorId: string\n    }[],\n    props: z.object({ slug: z.string() }).strict(),\n  },\n  'group/by-id/:id/groups': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as { above: LiteGroup[]; below: LiteGroup[] },\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'group/by-id/:id': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as Group,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  // deprecated. use /markets?groupId= instead\n  'group/by-id/:id/markets': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as LiteMarket[],\n    props: z\n      .object({\n        id: z.string(),\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n      })\n      .strict(),\n  },\n  'group/:slug/delete': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ slug: z.string() }),\n  },\n  'group/by-id/:id/delete': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ id: z.string() }),\n  },\n  'group/:slug/block': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ slug: z.string() }),\n  },\n  'group/:slug/unblock': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ slug: z.string() }).strict(),\n  },\n  'group/by-id/:topId/group/:bottomId': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        topId: z.string(),\n        bottomId: z.string(),\n        remove: z.boolean().optional(),\n      })\n      .strict(),\n    returns: {} as { status: 'success' },\n  },\n  groups: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Group[],\n    props: z\n      .object({\n        availableToUserId: z.string().optional(),\n        beforeTime: z.coerce.number().int().optional(),\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n      })\n      .strict(),\n  },\n  'market/:id': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as LiteMarket | FullMarket,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z.object({ id: z.string(), lite: coerceBoolean.optional() }),\n  },\n  'market/:id/prob': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as {\n      prob?: number\n      answerProbs?: { [answerId: string]: number }\n    },\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'market-probs': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as {\n      [contractId: string]: {\n        prob?: number\n        answerProbs?: { [answerId: string]: number }\n      }\n    },\n    props: z\n      .object({\n        ids: z.array(z.string()).max(100),\n      })\n      .strict(),\n  },\n  'markets-by-ids': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: [] as Contract[],\n    props: z\n      .object({\n        ids: z.array(z.string()).max(100),\n      })\n      .strict(),\n  },\n  // deprecated. use /market/:id?lite=true instead\n  'market/:id/lite': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as LiteMarket,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z.object({ id: z.string() }),\n  },\n  'slug/:slug': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as LiteMarket | FullMarket,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z.object({ slug: z.string(), lite: coerceBoolean.optional() }),\n  },\n  market: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as LiteMarket,\n    props: createMarketProps,\n  },\n  'market/:contractId/update': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: updateMarketProps,\n    returns: {} as { success: true },\n  },\n  'market/:contractId/close': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    // returns: {} as LiteMarket,\n    props: z\n      .object({\n        contractId: z.string(),\n        closeTime: z.number().int().nonnegative().optional(),\n      })\n      .strict(),\n  },\n  'market/:contractId/resolve': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { message: string },\n    props: resolveMarketProps,\n  },\n  'market/:contractId/add-liquidity': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as LiquidityProvision,\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gt(0).finite(),\n      })\n      .strict(),\n  },\n  'market/:contractId/remove-liquidity': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as LiquidityProvision,\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gt(0).finite(),\n      })\n      .strict(),\n  },\n  'market/:contractId/add-bounty': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as Txn,\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gt(0).finite(),\n      })\n      .strict(),\n  },\n  'market/:contractId/award-bounty': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as Txn,\n    props: z\n      .object({\n        contractId: z.string(),\n        commentId: z.string(),\n        amount: z.number().gt(0).finite(),\n      })\n      .strict(),\n  },\n  'market/:contractId/group': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        contractId: z.string(),\n        groupId: z.string(),\n        remove: z.boolean().default(false),\n      })\n      .strict(),\n    returns: {} as { success: true },\n  },\n  'market/:contractId/groups': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({ contractId: z.string() }),\n    returns: [] as LiteGroup[],\n  },\n  'market/:contractId/answer': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { newAnswerId: string },\n    props: z\n      .object({\n        contractId: z.string().max(MAX_ANSWER_LENGTH),\n        text: z.string().min(1).max(MAX_ANSWER_LENGTH),\n      })\n      .strict(),\n  },\n  'market/:contractId/block': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ contractId: z.string() }).strict(),\n  },\n  'market/:contractId/unblock': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ contractId: z.string() }).strict(),\n  },\n  unresolve: {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { success: true },\n    props: z\n      .object({\n        contractId: z.string().max(MAX_ANSWER_LENGTH),\n        answerId: z.string().max(MAX_ANSWER_LENGTH).optional(),\n      })\n      .strict(),\n  },\n  leagues: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as League[],\n    props: z\n      .object({\n        userId: z.string().optional(),\n        cohort: z.string().optional(),\n        season: z.coerce.number().optional(),\n      })\n      .strict(),\n  },\n  markets: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as LiteMarket[],\n    props: z\n      .object({\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n        sort: z\n          .enum([\n            'created-time',\n            'updated-time',\n            'last-bet-time',\n            'last-comment-time',\n          ])\n          .optional(),\n        order: z.enum(['asc', 'desc']).optional(),\n        before: z.string().optional(),\n        userId: z.string().optional(),\n        groupId: z.string().optional(),\n      })\n      .strict(),\n  },\n  'search-markets': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as LiteMarket[],\n    props: searchProps,\n  },\n  'search-markets-full': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    preferAuth: true,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Contract[],\n    props: searchProps,\n  },\n  managram: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        amount: z.number().finite(),\n        toIds: z.array(z.string()),\n        message: z.string().max(MAX_COMMENT_LENGTH),\n        groupId: z.string().max(MAX_ID_LENGTH).optional(),\n        token: z.enum(['M$', 'CASH']).default('M$'),\n      })\n      .strict(),\n  },\n  manalink: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { slug: string },\n    props: z\n      .object({\n        amount: z.number().positive().finite().safe(),\n        expiresTime: z.number().lt(MAX_EXPIRES_AT).optional(),\n        maxUses: z.number().optional(),\n        message: z.string().optional(),\n      })\n      .strict(),\n  },\n  donate: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        amount: z.number().positive().finite().safe(),\n        to: z.string(),\n      })\n      .strict(),\n  },\n  'convert-sp-to-mana': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ amount: z.number().positive().finite().safe() }).strict(),\n  },\n  'convert-cash-to-mana': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ amount: z.number().positive().finite().safe() }).strict(),\n  },\n  'request-loan': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({}),\n    returns: {} as { payout: number },\n  },\n  // deprecated. use /txns instead\n  managrams: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: [] as ManaPayTxn[],\n    props: z\n      .object({\n        toId: z.string().optional(),\n        fromId: z.string().optional(),\n        limit: z.coerce.number().gte(0).lte(100).default(100),\n        before: z.coerce.number().optional(),\n        after: z.coerce.number().optional(),\n      })\n      .strict(),\n  },\n  'market/:id/positions': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as ContractMetric[],\n    props: z\n      .object({\n        id: z.string(),\n        userId: z.string().optional(),\n        answerId: z.string().optional(),\n        summaryOnly: z.boolean().optional(),\n        top: z.undefined().or(z.coerce.number()),\n        bottom: z.undefined().or(z.coerce.number()),\n        order: z.enum(['shares', 'profit']).optional(),\n      })\n      .strict(),\n  },\n  me: {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z.object({}),\n    returns: {} as FullUser,\n  },\n  'me/update': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({\n      name: z.string().trim().min(1).optional(),\n      username: z.string().trim().min(1).optional(),\n      avatarUrl: z.string().optional(),\n      bio: z.string().optional(),\n      website: z.string().optional(),\n      twitterHandle: z.string().optional(),\n      discordHandle: z.string().optional(),\n      // settings\n      optOutBetWarnings: z.boolean().optional(),\n      isAdvancedTrader: z.boolean().optional(),\n      //internal\n      seenStreakModal: z.boolean().optional(),\n      shouldShowWelcome: z.boolean().optional(),\n      hasSeenContractFollowModal: z.boolean().optional(),\n      hasSeenLoanModal: z.boolean().optional(),\n    }),\n    returns: {} as FullUser,\n  },\n  'me/delete': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({\n      username: z.string(), // just so you're sure\n    }),\n  },\n  'me/private': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z.object({}),\n    returns: {} as PrivateUser,\n  },\n  'me/private/update': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    props: z\n      .object({\n        email: z.string().email().optional(),\n        apiKey: z.string().optional(),\n        pushToken: z.string().optional(),\n        rejectedPushNotificationsOn: z.number().optional(),\n        lastPromptedToEnablePushNotifications: z.number().optional(),\n        interestedInPushNotifications: z.boolean().optional(),\n        hasSeenAppBannerInNotificationsOn: z.number().optional(),\n        installedAppPlatforms: z.array(z.string()).optional(),\n        paymentInfo: z.string().optional(),\n        lastAppReviewTime: z.number().optional(),\n      })\n      .strict(),\n  },\n  'user/:username': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as FullUser,\n    props: z.object({ username: z.string() }).strict(),\n  },\n  'user/:username/lite': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as DisplayUser,\n    props: z.object({ username: z.string() }).strict(),\n  },\n  'user/by-id/:id': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    // Do not add a caching strategy here. New users need up-to-date data.\n    returns: {} as FullUser,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'user/by-id/:id/lite': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as DisplayUser,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'users/by-id': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as DisplayUser[],\n    props: z.object({ ids: z.array(z.string()) }).strict(),\n  },\n  'users/by-id/balance': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as { id: string; balance: number }[],\n    props: z.object({ ids: z.array(z.string()) }).strict(),\n  },\n  'user/by-id/:id/block': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'user/by-id/:id/unblock': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  users: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as FullUser[],\n    props: z\n      .object({\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n        before: z.string().optional(),\n      })\n      .strict(),\n  },\n  'search-users': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as FullUser[],\n    props: z\n      .object({\n        term: z.string(),\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n        page: z.coerce.number().gte(0).default(0),\n      })\n      .strict(),\n  },\n  'search-contract-positions': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as DisplayUser[],\n    props: z\n      .object({\n        term: z.string(),\n        contractId: z.string(),\n        limit: z.coerce.number().gte(0).lte(100).default(10),\n      })\n      .strict(),\n  },\n  'save-twitch': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        twitchInfo: z.object({\n          twitchName: z.string().optional(),\n          controlToken: z.string().optional(),\n          botEnabled: z.boolean().optional(),\n          needsRelinking: z.boolean().optional(),\n        }),\n      })\n      .strict(),\n  },\n  'set-push-token': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({ pushToken: z.string() }).strict(),\n  },\n  'update-notif-settings': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      type: z.string() as z.ZodType<notification_preference>,\n      medium: z.enum(['email', 'browser', 'mobile']),\n      enabled: z.boolean(),\n    }),\n  },\n  headlines: {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: [] as Headline[],\n    props: z.object({\n      slug: z.enum(['politics', 'ai', 'news']).optional(),\n    }),\n  },\n  'politics-headlines': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: [] as Headline[],\n    props: z.object({}),\n  },\n  'set-news': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { success: true },\n    props: z\n      .object({\n        dashboardIds: z.array(z.string()),\n        endpoint: z.enum(['politics', 'ai', 'news']),\n      })\n      .strict(),\n  },\n  react: {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        contentId: z.string(),\n        contentType: z.enum(['comment', 'contract', 'post']),\n        commentParentType: z.enum(['post']).optional(),\n        remove: z.boolean().optional(),\n        reactionType: z.enum(['like', 'dislike']).optional().default('like'),\n      })\n      .strict(),\n    returns: { success: true },\n  },\n  'compatible-lovers': {\n    method: 'GET',\n    visibility: 'private',\n    authed: false,\n    props: z.object({ userId: z.string() }),\n    returns: {} as {\n      lover: Lover\n      compatibleLovers: Lover[]\n      loverCompatibilityScores: {\n        [userId: string]: CompatibilityScore\n      }\n    },\n  },\n  post: {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    returns: {} as ContractComment,\n    props: z\n      .object({\n        contractId: z.string(),\n        betId: z.string().optional(),\n        commentId: z.string().optional(),\n        content: contentSchema.optional(),\n      })\n      .strict(),\n  },\n  'fetch-link-preview': {\n    method: 'GET',\n    visibility: 'private',\n    authed: false,\n    props: z.object({ url: z.string() }).strict(),\n    cache: 'max-age=86400, stale-while-revalidate=86400',\n    returns: {} as LinkPreview,\n  },\n  'remove-pinned-photo': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    returns: { success: true },\n    props: z\n      .object({\n        userId: z.string(),\n      })\n      .strict(),\n  },\n  'get-related-markets': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    props: z\n      .object({\n        contractId: z.string(),\n        limit: z.coerce.number().gte(0).lte(100),\n        userId: z.string().optional(),\n        question: z.string().optional(),\n        uniqueBettorCount: z.coerce.number().gte(0).optional(),\n      })\n      .strict(),\n    returns: {} as {\n      marketsFromEmbeddings: Contract[]\n    },\n    cache: 'public, max-age=3600, stale-while-revalidate=10',\n  },\n  'get-related-markets-by-group': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: 'public, max-age=3600, stale-while-revalidate=10',\n    returns: {} as {\n      groupContracts: Contract[]\n    },\n    props: z\n      .object({\n        contractId: z.string(),\n        limit: z.coerce.number().gte(0).lte(100),\n        offset: z.coerce.number().gte(0),\n      })\n      .strict(),\n  },\n  'unlist-and-cancel-user-contracts': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        userId: z.string(),\n      })\n      .strict(),\n  },\n  'get-boost-analytics': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: false,\n    props: z\n      .object({\n        contractId: z.string(),\n      })\n      .strict(),\n    returns: {} as {\n      uniqueViewers: number\n      totalViews: number\n      uniquePromotedViewers: number\n      totalPromotedViews: number\n      boostPeriods: {\n        startTime: string\n        endTime: string\n      }[]\n    },\n  },\n  'get-seen-market-ids': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      contractIds: z.array(z.string()),\n      types: z.array(z.enum(['page', 'card', 'promoted'])).optional(),\n      since: z.number(),\n    }),\n    returns: [] as string[],\n  },\n  'get-compatibility-questions': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({}),\n    returns: {} as {\n      status: 'success'\n      questions: (Row<'love_questions'> & {\n        answer_count: number\n        score: number\n      })[]\n    },\n  },\n  'like-lover': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    props: z.object({\n      targetUserId: z.string(),\n      remove: z.boolean().optional(),\n    }),\n    returns: {} as {\n      status: 'success'\n    },\n  },\n  'ship-lovers': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    props: z.object({\n      targetUserId1: z.string(),\n      targetUserId2: z.string(),\n      remove: z.boolean().optional(),\n    }),\n    returns: {} as {\n      status: 'success'\n    },\n  },\n\n  'get-likes-and-ships': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z\n      .object({\n        userId: z.string(),\n      })\n      .strict(),\n    returns: {} as {\n      status: 'success'\n      likesReceived: LikeData[]\n      likesGiven: LikeData[]\n      ships: ShipData[]\n    },\n  },\n  'has-free-like': {\n    method: 'GET',\n    visibility: 'private',\n    authed: true,\n    props: z.object({}).strict(),\n    returns: {} as {\n      status: 'success'\n      hasFreeLike: boolean\n    },\n  },\n  'star-lover': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    props: z.object({\n      targetUserId: z.string(),\n      remove: z.boolean().optional(),\n    }),\n    returns: {} as {\n      status: 'success'\n    },\n  },\n  'get-lovers': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({}).strict(),\n    returns: {} as {\n      status: 'success'\n      lovers: Lover[]\n    },\n  },\n  'get-lover-answers': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({ userId: z.string() }).strict(),\n    returns: {} as {\n      status: 'success'\n      answers: Row<'love_compatibility_answers'>[]\n    },\n  },\n  'search-groups': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    // Is there a way to infer return { lite:[] as LiteGroup[] } if type is 'lite'?\n    returns: {\n      full: [] as Group[],\n      lite: [] as LiteGroup[],\n    },\n    props: SearchGroupParams(SearchGroupShape),\n  },\n  'search-my-groups': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {\n      full: [] as Group[],\n      lite: [] as LiteGroup[],\n    },\n    props: SearchGroupParams(MySearchGroupShape),\n  },\n  'get-groups-with-top-contracts': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as { topic: Topic; contracts: Contract[] }[],\n    props: z.object({}),\n  },\n  'get-balance-changes': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: [] as AnyBalanceChangeType[],\n    props: z\n      .object({\n        before: z.coerce.number().optional(),\n        after: z.coerce.number().default(0),\n        userId: z.string(),\n      })\n      .strict(),\n  },\n  'get-partner-stats': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z\n      .object({\n        userId: z.string(),\n      })\n      .strict(),\n    returns: {} as {\n      status: 'success' | 'error'\n      username: string\n      numContractsCreated: number\n      numUniqueBettors: number\n      numReferrals: number\n      numReferralsWhoRetained: number\n      totalTraderIncome: number\n      totalReferralIncome: number\n      dollarsEarned: number\n    },\n  },\n  'record-contract-view': {\n    method: 'POST',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      userId: z.string().optional(),\n      contractId: z.string(),\n      kind: z.enum(['page', 'card', 'promoted']),\n    }),\n    returns: {} as { status: 'success' },\n  },\n  'record-comment-view': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({\n      contractId: z.string(),\n      commentId: z.string(),\n    }),\n    returns: {} as { status: 'success' },\n  },\n  'record-contract-interaction': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({\n      contractId: z.string(),\n      kind: z.enum([\n        'page bet',\n        'page comment',\n        'page repost',\n        'page like',\n        'card bet',\n        'card click',\n        'promoted click',\n        'card like',\n        'page share',\n        'browse click',\n      ]),\n      commentId: z.string().optional(),\n      feedReasons: z.array(z.string()).optional(),\n      feedType: z.string().optional(),\n      betGroupId: z.string().optional(),\n      betId: z.string().optional(),\n    }),\n    returns: {} as { status: 'success' },\n  },\n  'get-dashboard-from-slug': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      dashboardSlug: z.string(),\n    }),\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as Dashboard,\n  },\n  'get-posts': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    preferAuth: true,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z\n      .object({\n        sortBy: z\n          .enum(['created_time', 'importance_score'])\n          .optional()\n          .default('created_time'),\n        term: z.string().optional(),\n        limit: z.coerce.number().gte(0).lte(200).default(100),\n        userId: z.string().optional(),\n        offset: z.coerce.number().gte(0).default(0),\n      })\n      .strict(),\n    returns: [] as TopLevelPost[],\n  },\n  'create-public-chat-message': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as ChatMessage,\n    props: z.object({\n      content: contentSchema,\n      channelId: z.string(),\n    }),\n  },\n  'get-followed-groups': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      userId: z.string(),\n    }),\n    returns: {} as {\n      groups: Group[]\n    },\n  },\n  'get-user-portfolio': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      userId: z.string(),\n    }),\n    returns: {} as LivePortfolioMetrics,\n  },\n  'get-user-portfolio-history': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      userId: z.string(),\n      period: z.enum(PERIODS),\n    }),\n    returns: {} as PortfolioMetrics[],\n  },\n  'get-channel-memberships': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      channelId: z.coerce.number().optional(),\n      createdTime: z.string().optional(),\n      lastUpdatedTime: z.string().optional(),\n      limit: z.coerce.number(),\n    }),\n    returns: {\n      channels: [] as PrivateMessageChannel[],\n      memberIdsByChannelId: {} as { [channelId: string]: string[] },\n    },\n  },\n  'get-channel-messages': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      channelId: z.coerce.number(),\n      limit: z.coerce.number(),\n      id: z.coerce.number().optional(),\n    }),\n    returns: [] as PrivateChatMessage[],\n  },\n  'get-channel-seen-time': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      channelIds: z.array(z.coerce.number()),\n    }),\n    returns: [] as [number, string][],\n  },\n  'set-channel-seen-time': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      channelId: z.coerce.number(),\n    }),\n  },\n  'get-feed': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as {\n      contracts: Contract[]\n      comments: ContractComment[]\n      bets: Bet[]\n      reposts: Repost[]\n      idsToReason: { [id: string]: string }\n    },\n    props: z\n      .object({\n        userId: z.string(),\n        limit: z.coerce.number().gt(0).lte(100).default(100),\n        offset: z.coerce.number().gte(0).default(0),\n        ignoreContractIds: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'get-mana-supply': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as ManaSupply,\n    props: z.object({}).strict(),\n  },\n  'get-notifications': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as Notification[],\n    props: z\n      .object({\n        after: z.coerce.number().optional(),\n        limit: z.coerce.number().gte(0).lte(1000).default(100),\n      })\n      .strict(),\n  },\n  'update-mod-report': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        reportId: z.number(),\n        updates: z\n          .object({\n            status: z\n              .enum(['new', 'under review', 'resolved', 'needs admin'])\n              .optional(),\n            mod_note: z.string().optional(),\n          })\n          .partial(),\n      })\n      .strict(),\n    returns: {} as { status: string; report: ModReport },\n  },\n  'get-mod-reports': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        statuses: z.array(\n          z.enum(['new', 'under review', 'resolved', 'needs admin'])\n        ),\n        limit: z.coerce.number().gte(0).lte(100).default(25),\n        offset: z.coerce.number().gte(0).default(0),\n        count: coerceBoolean.optional(),\n      })\n      .strict(),\n    returns: {} as {\n      status: string\n      count?: number\n      reports: ModReport[]\n    },\n  },\n  'get-txn-summary-stats': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as Row<'txn_summary_stats'>[],\n    props: z\n      .object({\n        ignoreCategories: z.array(z.string()).optional(),\n        fromType: z.string().optional(),\n        toType: z.string().optional(),\n        limitDays: z.coerce.number(),\n      })\n      .strict(),\n  },\n  'get-mana-summary-stats': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as Row<'mana_supply_stats'>[],\n    props: z\n      .object({\n        limitDays: z.coerce.number(),\n      })\n      .strict(),\n  },\n  'register-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: verificationParams,\n    returns: {} as RegistrationReturnType,\n  },\n  'get-verification-status-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      documents?: GIDXDocument[]\n      message?: string\n      documentStatus?: string\n    },\n    props: z.object({}),\n  },\n  'get-monitor-status-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n    },\n    props: z.object({\n      DeviceGPS: GPSProps,\n    }),\n  },\n  'get-checkout-session-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n      session?: CheckoutSession\n    },\n    props: z.object({\n      PayActionCode: z.enum(['PAY', 'PAYOUT']).default('PAY'),\n      DeviceGPS: GPSProps,\n      userId: z.string().optional(),\n      ip: z.string().optional(),\n    }),\n  },\n  'complete-checkout-session-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n      gidxMessage?: string | null\n      details?: PaymentDetail[]\n    },\n    props: z.object(checkoutParams),\n  },\n  'complete-cashout-session-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n      gidxMessage?: string | null\n      details?: PaymentDetail[]\n    },\n    props: z.object(cashoutParams),\n  },\n  'complete-cashout-request': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n      gidxMessage?: string | null\n      details?: PaymentDetail[]\n    },\n    props: z.object(cashoutRequestParams),\n  },\n  'get-verification-documents-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      documents: GIDXDocument[]\n      utilityDocuments: GIDXDocument[]\n      idDocuments: GIDXDocument[]\n      rejectedDocuments: GIDXDocument[]\n    },\n    props: z.object({}),\n  },\n  'upload-document-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { status: string },\n    props: z.object({\n      CategoryType: z.number().gte(1).lte(7),\n      fileName: z.string(),\n      fileUrl: z.string(),\n    }),\n  },\n  'identity-callback-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as { Accepted: boolean },\n    props: z.object({\n      MerchantCustomerID: z.string(),\n      NotificationType: z.string(),\n    }),\n  },\n  'payment-callback-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as { MerchantTransactionID: string },\n    props: z\n      .object({\n        MerchantTransactionID: z.string(),\n        TransactionStatusCode: z.coerce.number(),\n        TransactionStatusMessage: z.string(),\n        StatusCode: z.coerce.number(),\n        SessionID: z.string(),\n        MerchantSessionID: z.string(),\n        SessionScore: z.coerce.number(),\n        ReasonCodes: z.array(z.string()).optional(),\n        ServiceType: z.string(),\n        StatusMessage: z.string(),\n      })\n      .strict(),\n  },\n  'get-best-comments': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { comments: ContractComment[]; contracts: Contract[] },\n    props: z.object({\n      limit: z.coerce.number().gte(0).lte(100).default(20),\n      offset: z.coerce.number().gte(0).default(0),\n      ignoreContractIds: z.array(z.string()).optional(),\n      justLikes: z.coerce.number().optional(),\n    }),\n  },\n  'get-redeemable-prize-cash': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { redeemablePrizeCash: number },\n    props: z.object({}),\n  },\n  'get-total-redeemable-prize-cash': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as { total: number },\n    props: z.object({}),\n  },\n  'get-cashouts': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as PendingCashoutStatusData[],\n    props: z\n      .object({\n        limit: z.coerce.number().gte(0).lte(100).default(10),\n        offset: z.coerce.number().gte(0).default(0),\n        userId: z.string().optional(),\n      })\n      .strict(),\n  },\n  'get-kyc-stats': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({}),\n    returns: {} as {\n      initialVerifications: {\n        count: number\n        day: string\n      }[]\n      phoneVerifications: {\n        count: number\n        day: string\n      }[]\n    },\n  },\n  txns: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z\n      .object({\n        token: z.string().optional(),\n        offset: z.coerce.number().default(0),\n        limit: z.coerce.number().gte(0).lte(100).default(100),\n        before: z.coerce.number().optional(),\n        after: z.coerce.number().optional(),\n        toId: z.string().optional(),\n        fromId: z.string().optional(),\n        category: z.string().optional(),\n        ignoreCategories: z.array(z.string()).optional(),\n      })\n      .strict(),\n    returns: [] as Txn[],\n  },\n  'generate-ai-market-suggestions': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: [] as AIGeneratedMarket[],\n    props: z\n      .object({\n        prompt: z.string(),\n        existingTitles: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'generate-ai-description': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { description: JSONContent | undefined },\n    props: z\n      .object({\n        question: z.string(),\n        description: z.string().optional(),\n        answers: z.array(z.string()).optional(),\n        outcomeType: z.string().optional(),\n        shouldAnswersSumToOne: coerceBoolean.optional(),\n        addAnswersMode: z\n          .enum(['DISABLED', 'ONLY_CREATOR', 'ANYONE'])\n          .optional(),\n      })\n      .strict(),\n  },\n  'generate-ai-answers': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as {\n      answers: string[]\n      addAnswersMode: 'DISABLED' | 'ONLY_CREATOR' | 'ANYONE'\n    },\n    props: z\n      .object({\n        question: z.string(),\n        answers: z.array(z.string()),\n        shouldAnswersSumToOne: coerceBoolean,\n        description: z.string().optional(),\n      })\n      .strict(),\n  },\n  'get-monthly-bets-2024': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ userId: z.string() }),\n    returns: [] as { month: string; bet_count: number; total_amount: number }[],\n  },\n  'get-max-min-profit-2024': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ userId: z.string() }),\n    returns: [] as {\n      profit: number\n      data: Contract\n      answer_id: string | null\n      has_no_shares: boolean\n      has_yes_shares: boolean\n    }[],\n  },\n  'get-next-loan-amount': {\n    method: 'GET',\n    visibility: 'undocumented',\n    cache: DEFAULT_CACHE_STRATEGY,\n    authed: false,\n    returns: {} as { amount: number },\n    props: z.object({\n      userId: z.string(),\n    }),\n  },\n  'create-task': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as Task,\n    props: z\n      .object({\n        text: z.string(),\n        category_id: z.number().optional(),\n        priority: z.number().default(0),\n        assignee_id: z.string().optional(),\n      })\n      .strict(),\n  },\n  'update-task': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z\n      .object({\n        id: z.number(),\n        text: z.string().optional(),\n        completed: z.boolean().optional(),\n        priority: z.number().optional(),\n        category_id: z.number().optional(),\n        archived: z.boolean().optional(),\n        assignee_id: z.string().optional(),\n      })\n      .strict(),\n  },\n  'create-category': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { id: number },\n    props: z\n      .object({\n        name: z.string(),\n        color: z.string().optional(),\n        displayOrder: z.number().optional(),\n      })\n      .strict(),\n  },\n  'get-categories': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { categories: TaskCategory[] },\n    props: z.object({}).strict(),\n  },\n  'update-category': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z\n      .object({\n        categoryId: z.number(),\n        name: z.string().optional(),\n        color: z.string().optional(),\n        displayOrder: z.number().optional(),\n        archived: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  'get-tasks': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { tasks: Task[] },\n    props: z.object({}).strict(),\n  },\n  'is-sports-interested': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { isSportsInterested: boolean },\n    props: z.object({}).strict(),\n  },\n  'get-site-activity': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as {\n      bets: Bet[]\n      comments: CommentWithTotalReplies[]\n      newContracts: Contract[]\n      relatedContracts: Contract[]\n    },\n    props: z\n      .object({\n        limit: z.coerce.number().default(10),\n        offset: z.coerce.number().default(0),\n        blockedUserIds: z.array(z.string()).optional(),\n        blockedGroupSlugs: z.array(z.string()).optional(),\n        blockedContractIds: z.array(z.string()).optional(),\n        topicIds: z.array(z.string()).optional(),\n        types: z\n          .array(z.enum(['bets', 'comments', 'markets', 'limit-orders']))\n          .optional(),\n        minBetAmount: z.coerce.number().optional(),\n        onlyFollowedTopics: coerceBoolean.optional(),\n        onlyFollowedContracts: coerceBoolean.optional(),\n        onlyFollowedUsers: coerceBoolean.optional(),\n        userId: z.string().optional(),\n      })\n      .strict(),\n  },\n  'get-sports-games': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { schedule: any[] },\n    props: z.object({}).strict(),\n  },\n  'get-market-props': {\n    method: 'GET',\n    visibility: 'public',\n    cache: DEFAULT_CACHE_STRATEGY,\n    // Could set authed false and preferAuth with an api secret if we want it to replace static props\n    authed: true,\n    returns: {} as {\n      manaContract: MarketContract\n      chartAnnotations: ChartAnnotation[]\n      topics: Topic[]\n      comments: ContractComment[]\n      pinnedComments: ContractComment[]\n      userPositionsByOutcome: {\n        YES: ContractMetric[]\n        NO: ContractMetric[]\n      }\n      topContractMetrics: ContractMetric[]\n      totalPositions: number\n      dashboards: Dashboard[]\n      cashContract: MarketContract\n      totalManaBets: number\n      totalCashBets: number\n    },\n    props: z.object({\n      slug: z.string().optional(),\n      id: z.string().optional(),\n    }),\n  },\n  'get-user-contract-metrics-with-contracts': {\n    method: 'GET',\n    visibility: 'public',\n    preferAuth: true,\n    authed: false,\n    returns: {} as {\n      metricsByContract: Dictionary<ContractMetric[]>\n      contracts: MarketContract[]\n    },\n    props: z.object({\n      userId: z.string(),\n      limit: z.coerce.number(),\n      offset: z.coerce.number().gte(0).optional(),\n      perAnswer: coerceBoolean.optional(),\n      inMani: coerceBoolean.optional(),\n    }),\n  },\n  validateIap: {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z.object({\n      receipt: z.string(),\n    }),\n  },\n  'check-sports-event': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as { exists: boolean; existingMarket?: LiteMarket },\n    props: z\n      .object({\n        sportsEventId: z.string(),\n      })\n      .strict(),\n  },\n  'comment-reactions': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Reaction[],\n    props: z\n      .object({\n        contentIds: z.array(z.string()),\n        contentType: z.enum(['comment', 'contract']),\n      })\n      .strict(),\n  },\n  'mark-all-notifications-new': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({}).strict(),\n    returns: {} as { success: boolean },\n  },\n  'get-contract-voters': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        contractId: z.string(),\n      })\n      .strict(),\n    returns: [] as DisplayUser[],\n  },\n  'get-contract-option-voters': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ contractId: z.string(), optionId: z.string() }),\n    returns: [] as DisplayUser[],\n  },\n  'purchase-contract-boost': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        contractId: z.string(),\n        startTime: z.number().positive().finite().safe(),\n        method: z.enum(['mana', 'cash']),\n      })\n      .strict(),\n    returns: {} as { success: boolean; checkoutUrl?: string },\n  },\n  'generate-ai-numeric-ranges': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as {\n      thresholds: { answers: string[]; midpoints: number[] }\n      buckets: { answers: string[]; midpoints: number[] }\n    },\n    props: z\n      .object({\n        question: z.string(),\n        min: z.number(),\n        max: z.number(),\n        description: z.string().optional(),\n        unit: z.string(),\n      })\n      .strict(),\n  },\n  'infer-numeric-unit': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as {\n      unit: string\n    },\n    props: z\n      .object({\n        question: z.string(),\n        description: z.string().optional(),\n      })\n      .strict(),\n  },\n  'generate-ai-date-ranges': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as {\n      buckets: { answers: string[]; midpoints: number[] }\n      thresholds: { answers: string[]; midpoints: number[] }\n    },\n    props: z\n      .object({\n        question: z.string(),\n        min: z.string(),\n        max: z.string(),\n        description: z.string().optional(),\n      })\n      .strict(),\n  },\n  'regenerate-numeric-midpoints': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { midpoints: number[] },\n    props: z\n      .object({\n        description: z.string().optional(),\n        question: z.string(),\n        answers: z.array(z.string()),\n        min: z.number(),\n        max: z.number(),\n        unit: z.string(),\n        tab: z.enum(['thresholds', 'buckets']),\n      })\n      .strict(),\n  },\n  'regenerate-date-midpoints': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { midpoints: number[] },\n    props: z\n      .object({\n        description: z.string().optional(),\n        question: z.string(),\n        answers: z.array(z.string()),\n        min: z.string(),\n        max: z.string(),\n        tab: z.enum(['thresholds', 'buckets']),\n      })\n      .strict(),\n  },\n\n  'generate-concise-title': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        question: z.string(),\n      })\n      .strict(),\n    returns: {} as { title: string },\n  },\n  'get-close-date': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        question: z.string(),\n        utcOffset: z.number().optional(),\n      })\n      .strict(),\n    returns: {} as { closeTime: number },\n  },\n  'refer-user': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        referredByUsername: z.string(),\n        contractId: z.string().optional(),\n      })\n      .strict(),\n    returns: {} as { success: boolean },\n  },\n\n  'save-market-draft': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { id: number },\n    props: z\n      .object({\n        data: z.object({\n          question: z.string(),\n          description: z.any().optional(),\n          outcomeType: z.string(),\n          answers: z.array(z.string()).optional(),\n          closeDate: z.string().optional(),\n          closeHoursMinutes: z.string().optional(),\n          visibility: z.string(),\n          selectedGroups: z.array(z.any()),\n          savedAt: z.number(),\n        }),\n      })\n      .strict(),\n  },\n\n  'get-market-drafts': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: [] as MarketDraft[],\n    props: z.object({}).strict(),\n  },\n\n  'delete-market-draft': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z\n      .object({\n        id: z.coerce.number(),\n      })\n      .strict(),\n  },\n  'get-season-info': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      season: z.coerce.number().int().positive().optional(),\n    }),\n    returns: {} as {\n      season: number\n      startTime: number // epoch ms\n      endTime: number | null // epoch ms, null if a *mystery* for clients\n      status: 'active' | 'processing' | 'complete'\n    },\n  },\n  'mark-notification-read': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z\n      .object({\n        notificationId: z.string(),\n      })\n      .strict(),\n  },\n  'dismiss-user-report': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        reportId: z.string(),\n      })\n      .strict(),\n    returns: {} as { success: boolean },\n  },\n  'create-post': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { post: TopLevelPost },\n    props: z\n      .object({\n        title: z.string().min(1).max(120),\n        content: contentSchema,\n        isAnnouncement: z.boolean().optional(),\n        visibility: z.enum(['public', 'unlisted']).optional(),\n      })\n      .strict(),\n  },\n  'update-post': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { post: TopLevelPost },\n    props: z\n      .object({\n        id: z.string(),\n        title: z.string().min(1).max(480).optional(),\n        content: contentSchema.optional(),\n        visibility: z.enum(['public', 'unlisted']).optional(),\n      })\n      .strict(),\n  },\n  'create-post-comment': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { comment: PostComment },\n    props: z\n      .object({\n        postId: z.string(),\n        content: contentSchema,\n        replyToCommentId: z.string().optional(),\n      })\n      .strict(),\n  },\n  'update-post-comment': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { comment: PostComment },\n    props: z\n      .object({\n        commentId: z.string(),\n        postId: z.string(),\n        hidden: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  'follow-post': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: true },\n    props: z\n      .object({\n        postId: z.string(),\n        follow: z.boolean(),\n      })\n      .strict(),\n  },\n} as const)\n\nexport type APIPath = keyof typeof API\nexport type APISchema<N extends APIPath> = (typeof API)[N]\n\nexport type APIParams<N extends APIPath> = z.input<APISchema<N>['props']>\nexport type ValidatedAPIParams<N extends APIPath> = z.output<\n  APISchema<N>['props']\n>\n\nexport type APIResponse<N extends APIPath> = APISchema<N> extends {\n  returns: Record<string, any>\n}\n  ? APISchema<N>['returns']\n  : void\n\nexport type APIResponseOptionalContinue<N extends APIPath> =\n  | { continue: () => Promise<void>; result: APIResponse<N> }\n  | APIResponse<N>\n",
          "postContent": "import { z } from 'zod'\nimport {\n  Group,\n  MAX_ID_LENGTH,\n  MySearchGroupShape,\n  LiteGroup,\n  SearchGroupParams,\n  SearchGroupShape,\n  Topic,\n} from 'common/group'\nimport {\n  createMarketProps,\n  resolveMarketProps,\n  type LiteMarket,\n  FullMarket,\n  updateMarketProps,\n} from './market-types'\nimport { type Answer } from 'common/answer'\nimport {\n  Comment,\n  CommentWithTotalReplies,\n  MAX_COMMENT_LENGTH,\n  PostComment,\n  type ContractComment,\n} from 'common/comment'\nimport { CandidateBet } from 'common/new-bet'\nimport type { Bet, LimitBet } from 'common/bet'\nimport { coerceBoolean, contentSchema } from 'common/api/zod-types'\nimport { Lover } from 'common/love/lover'\nimport { AIGeneratedMarket, Contract, MarketContract } from 'common/contract'\nimport { CompatibilityScore } from 'common/love/compatibility-score'\nimport type { Txn, ManaPayTxn } from 'common/txn'\nimport { LiquidityProvision } from 'common/liquidity-provision'\nimport { DisplayUser, FullUser } from './user-types'\nimport { League } from 'common/leagues'\nimport { searchProps } from './market-search-types'\nimport { MAX_ANSWER_LENGTH } from 'common/answer'\nimport { type LinkPreview } from 'common/link-preview'\nimport { Headline } from 'common/news'\nimport { Row } from 'common/supabase/utils'\nimport { LikeData, ShipData } from './love-types'\nimport { AnyBalanceChangeType } from 'common/balance-change'\nimport { Dashboard } from 'common/dashboard'\nimport { ChatMessage, PrivateChatMessage } from 'common/chat-message'\nimport { PrivateUser, User } from '../user'\nimport { ManaSupply } from 'common/stats'\nimport { Repost } from 'common/repost'\nimport { PERIODS } from 'common/period'\nimport { SWEEPS_MIN_BET } from 'common/economy'\nimport {\n  LivePortfolioMetrics,\n  PortfolioMetrics,\n} from 'common/portfolio-metrics'\nimport { ModReport } from '../mod-report'\n\nimport { RegistrationReturnType } from 'common/reason-codes'\nimport {\n  CheckoutSession,\n  GIDXDocument,\n  GPSProps,\n  PaymentDetail,\n  checkoutParams,\n  verificationParams,\n  cashoutRequestParams,\n  PendingCashoutStatusData,\n  cashoutParams,\n} from 'common/gidx/gidx'\nimport { notification_preference } from 'common/user-notification-preferences'\nimport { PrivateMessageChannel } from 'common/supabase/private-messages'\nimport { Notification } from 'common/notification'\nimport { NON_POINTS_BETS_LIMIT } from 'common/supabase/bets'\nimport { ContractMetric } from 'common/contract-metric'\n\nimport { JSONContent } from '@tiptap/core'\nimport { Task, TaskCategory } from 'common/todo'\nimport { ChartAnnotation } from 'common/supabase/chart-annotations'\nimport { Dictionary } from 'lodash'\nimport { Reaction } from 'common/reaction'\nimport { YEAR_MS } from 'common/util/time'\nimport { MarketDraft } from 'common/drafts'\nimport { TopLevelPost } from 'common/top-level-post'\n// mqp: very unscientific, just balancing our willingness to accept load\n// with user willingness to put up with stale data\nexport const DEFAULT_CACHE_STRATEGY =\n  'public, max-age=5, stale-while-revalidate=10'\nconst MAX_EXPIRES_AT = 1_000 * YEAR_MS\n\ntype APIGenericSchema = {\n  // GET is for retrieval, POST is to mutate something, PUT is idempotent mutation (can be repeated safely)\n  method: 'GET' | 'POST' | 'PUT'\n  //private APIs can only be called from manifold. undocumented endpoints can change or be deleted at any time!\n  visibility: 'public' | 'undocumented' | 'private'\n  // whether the endpoint requires authentication\n  authed: boolean\n  // zod schema for the request body (or for params for GET requests)\n  props: z.ZodType\n  // note this has to be JSON serializable\n  returns?: Record<string, any>\n  // Cache-Control header. like, 'max-age=60'\n  cache?: string\n  // whether the endpoint should prefer authentication even if not required\n  preferAuth?: boolean\n}\n\nlet _apiTypeCheck: { [x: string]: APIGenericSchema }\nexport const API = (_apiTypeCheck = {\n  'refresh-all-clients': {\n    method: 'POST',\n    visibility: 'public',\n    props: z.object({ message: z.string().optional() }),\n    authed: true,\n  },\n  'toggle-system-trading-status': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        token: z.enum(['MANA', 'CASH']),\n      })\n      .strict(),\n    returns: {} as { status: boolean },\n  },\n  comment: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as ContractComment,\n    props: z\n      .object({\n        contractId: z.string(),\n        content: contentSchema.optional(),\n        html: z.string().optional(),\n        markdown: z.string().optional(),\n        replyToCommentId: z.string().optional(),\n        replyToAnswerId: z.string().optional(),\n        replyToBetId: z.string().optional(),\n      })\n      .strict(),\n  },\n\n  'follow-contract': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: true },\n    props: z\n      .object({\n        contractId: z.string(),\n        follow: z.boolean(),\n      })\n      .strict(),\n  },\n  'get-contract': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as Contract,\n    props: z\n      .object({\n        contractId: z.string(),\n      })\n      .strict(),\n  },\n  'answer/:answerId': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as Answer,\n    props: z.object({ answerId: z.string() }).strict(),\n  },\n  'market/:contractId/answers': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: [] as Answer[],\n    props: z.object({ contractId: z.string() }).strict(),\n  },\n  'hide-comment': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ commentPath: z.string() }).strict(),\n  },\n  'pin-comment': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({ commentPath: z.string() }).strict(),\n  },\n  comments: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    // cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as ContractComment[],\n    props: z\n      .object({\n        contractId: z.string().optional(),\n        contractSlug: z.string().optional(),\n        afterTime: z.coerce.number().optional(),\n        limit: z.coerce.number().gte(0).lte(1000).default(1000),\n        page: z.coerce.number().gte(0).default(0),\n        userId: z.string().optional(),\n        isPolitics: coerceBoolean.optional(),\n      })\n      .strict(),\n  },\n  'user-comments': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: [] as Comment[],\n    props: z\n      .object({\n        afterTime: z.coerce.number().optional(),\n        limit: z.coerce.number().gte(0).lte(1000).default(1000),\n        page: z.coerce.number().gte(0).default(0),\n        userId: z.string(),\n      })\n      .strict(),\n  },\n  bet: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as CandidateBet & { betId: string },\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gte(SWEEPS_MIN_BET),\n        replyToCommentId: z.string().optional(),\n        limitProb: z.number().gte(0.01).lte(0.99).optional(),\n        expiresMillisAfter: z.number().lt(MAX_EXPIRES_AT).optional(),\n        silent: z.boolean().optional(),\n        expiresAt: z.number().lt(MAX_EXPIRES_AT).optional(),\n        // Used for binary and new multiple choice contracts (cpmm-multi-1).\n        outcome: z.enum(['YES', 'NO']).default('YES'),\n        //Multi\n        answerId: z.string().optional(),\n        dryRun: z.boolean().optional(),\n        deps: z.array(z.string()).optional(),\n        deterministic: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  createuser: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { user: User; privateUser: PrivateUser },\n    props: z\n      .object({\n        deviceToken: z.string().optional(),\n        adminToken: z.string().optional(),\n        visitedContractIds: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'multi-bet': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as (CandidateBet & { betId: string })[],\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gte(1),\n        limitProb: z.number().gte(0).lte(1).optional(),\n        expiresAt: z.number().lt(MAX_EXPIRES_AT).optional(),\n        answerIds: z.array(z.string()).min(1),\n        deterministic: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  'multi-sell': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as (CandidateBet & { betId: string })[],\n    props: z\n      .object({\n        contractId: z.string(),\n        answerIds: z.array(z.string()).min(1),\n        deterministic: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  leaderboard: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as { userId: string; score: number }[],\n    props: z\n      .object({\n        groupId: z.string().optional(),\n        limit: z.coerce.number().min(1).max(100).default(50),\n        token: z.enum(['MANA', 'CASH']).default('MANA'),\n        kind: z.enum(['creator', 'profit', 'loss', 'volume', 'referral']),\n      })\n      .strict(),\n  },\n  'verify-phone-number': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { status: string },\n    props: z\n      .object({\n        phoneNumber: z.string(),\n        code: z.string(),\n      })\n      .strict(),\n  },\n  'request-otp': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { status: string },\n    props: z\n      .object({\n        phoneNumber: z.string(),\n      })\n      .strict(),\n  },\n  'bet/cancel/:betId': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ betId: z.string() }).strict(),\n    returns: {} as LimitBet,\n  },\n  // sell shares\n  'market/:contractId/sell': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as CandidateBet & { betId: string },\n    props: z\n      .object({\n        contractId: z.string(),\n        shares: z.number().positive().optional(), // leave it out to sell all shares\n        outcome: z.enum(['YES', 'NO']),\n        answerId: z.string().optional(), // Required for multi binary markets\n        deterministic: z.boolean().optional(),\n        deps: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'get-user-limit-orders-with-contracts': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as {\n      bets: LimitBet[]\n      contracts: MarketContract[]\n    },\n    props: z\n      .object({\n        userId: z.string(),\n        count: z.coerce.number().lte(5000),\n        includeExpired: coerceBoolean.optional().default(false),\n        includeCancelled: coerceBoolean.optional().default(false),\n        includeFilled: coerceBoolean.optional().default(false),\n      })\n      .strict(),\n  },\n  'get-interesting-groups-from-views': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as (Group & { hasBet: boolean })[],\n    props: z\n      .object({\n        userId: z.string(),\n        contractIds: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  bets: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Bet[],\n    props: z\n      .object({\n        id: z.string().optional(),\n        userId: z.string().optional(),\n        username: z.string().optional(),\n        contractId: z.string().or(z.array(z.string())).optional(),\n        contractSlug: z.string().optional(),\n        answerId: z.string().optional(),\n        // market: z.string().optional(), // deprecated, synonym for `contractSlug`\n        limit: z.coerce\n          .number()\n          .gte(0)\n          .lte(50000)\n          .default(NON_POINTS_BETS_LIMIT),\n        before: z.string().optional(),\n        after: z.string().optional(),\n        beforeTime: z.coerce.number().optional(),\n        afterTime: z.coerce.number().optional(),\n        order: z.enum(['asc', 'desc']).optional(),\n        kinds: z.enum(['open-limit']).optional(),\n        // undocumented fields. idk what a good api interface would be\n        filterRedemptions: coerceBoolean.optional(),\n        includeZeroShareRedemptions: coerceBoolean.optional(),\n        commentRepliesOnly: coerceBoolean.optional(),\n        count: coerceBoolean.optional(),\n        points: coerceBoolean.optional(),\n      })\n      .strict(),\n  },\n  'bet-points': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: 'public, max-age=600, stale-while-revalidate=60',\n    returns: [] as Bet[],\n    props: z\n      .object({\n        contractId: z.string(),\n        answerId: z.string().optional(),\n        limit: z.coerce.number().gte(0).lte(50000).default(5000),\n        beforeTime: z.coerce.number(),\n        afterTime: z.coerce.number(),\n        filterRedemptions: coerceBoolean.optional(),\n        includeZeroShareRedemptions: coerceBoolean.optional(),\n      })\n      .strict(),\n  },\n  'unique-bet-group-count': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as { count: number },\n    props: z\n      .object({\n        contractId: z.string(),\n      })\n      .strict(),\n  },\n  'get-daily-changed-metrics-and-contracts': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    cache: 'public, max-age=900, stale-while-revalidate=90', // 15 minute cache\n    props: z\n      .object({\n        limit: z.coerce.number(),\n        userId: z.string(),\n        balance: z.coerce.number(),\n      })\n      .strict(),\n    returns: {} as {\n      manaMetrics: ContractMetric[]\n      contracts: MarketContract[]\n      manaProfit: number\n      manaInvestmentValue: number\n      balance: number\n    },\n  },\n  // deprecated. use /bets?username= instead\n  'user/:username/bets': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Bet[],\n    props: z\n      .object({\n        username: z.string(),\n        limit: z.coerce.number().gte(0).lte(1000).default(1000),\n      })\n      .strict(),\n  },\n  'group/:slug': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as Group,\n    props: z.object({ slug: z.string() }),\n  },\n  'group/:slug/groups': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as { above: LiteGroup[]; below: LiteGroup[] },\n    props: z.object({ slug: z.string() }).strict(),\n  },\n  'group/:slug/dashboards': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as {\n      id: string\n      title: string\n      slug: string\n      creatorId: string\n    }[],\n    props: z.object({ slug: z.string() }).strict(),\n  },\n  'group/by-id/:id/groups': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as { above: LiteGroup[]; below: LiteGroup[] },\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'group/by-id/:id': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as Group,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  // deprecated. use /markets?groupId= instead\n  'group/by-id/:id/markets': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as LiteMarket[],\n    props: z\n      .object({\n        id: z.string(),\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n      })\n      .strict(),\n  },\n  'group/:slug/delete': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ slug: z.string() }),\n  },\n  'group/by-id/:id/delete': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ id: z.string() }),\n  },\n  'group/:slug/block': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ slug: z.string() }),\n  },\n  'group/:slug/unblock': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ slug: z.string() }).strict(),\n  },\n  'group/by-id/:topId/group/:bottomId': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        topId: z.string(),\n        bottomId: z.string(),\n        remove: z.boolean().optional(),\n      })\n      .strict(),\n    returns: {} as { status: 'success' },\n  },\n  groups: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Group[],\n    props: z\n      .object({\n        availableToUserId: z.string().optional(),\n        beforeTime: z.coerce.number().int().optional(),\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n      })\n      .strict(),\n  },\n  'market/:id': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as LiteMarket | FullMarket,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z.object({ id: z.string(), lite: coerceBoolean.optional() }),\n  },\n  'market/:id/prob': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as {\n      prob?: number\n      answerProbs?: { [answerId: string]: number }\n    },\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'market-probs': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as {\n      [contractId: string]: {\n        prob?: number\n        answerProbs?: { [answerId: string]: number }\n      }\n    },\n    props: z\n      .object({\n        ids: z.array(z.string()).max(100),\n      })\n      .strict(),\n  },\n  'markets-by-ids': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: [] as Contract[],\n    props: z\n      .object({\n        ids: z.array(z.string()).max(100),\n      })\n      .strict(),\n  },\n  // deprecated. use /market/:id?lite=true instead\n  'market/:id/lite': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as LiteMarket,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z.object({ id: z.string() }),\n  },\n  'slug/:slug': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as LiteMarket | FullMarket,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z.object({ slug: z.string(), lite: coerceBoolean.optional() }),\n  },\n  market: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as LiteMarket,\n    props: createMarketProps,\n  },\n  'market/:contractId/update': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: updateMarketProps,\n    returns: {} as { success: true },\n  },\n  'market/:contractId/close': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    // returns: {} as LiteMarket,\n    props: z\n      .object({\n        contractId: z.string(),\n        closeTime: z.number().int().nonnegative().optional(),\n      })\n      .strict(),\n  },\n  'market/:contractId/resolve': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { message: string },\n    props: resolveMarketProps,\n  },\n  'market/:contractId/add-liquidity': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as LiquidityProvision,\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gt(0).finite(),\n      })\n      .strict(),\n  },\n  'market/:contractId/remove-liquidity': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as LiquidityProvision,\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gt(0).finite(),\n      })\n      .strict(),\n  },\n  'market/:contractId/add-bounty': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as Txn,\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gt(0).finite(),\n      })\n      .strict(),\n  },\n  'market/:contractId/award-bounty': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as Txn,\n    props: z\n      .object({\n        contractId: z.string(),\n        commentId: z.string(),\n        amount: z.number().gt(0).finite(),\n      })\n      .strict(),\n  },\n  'market/:contractId/group': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        contractId: z.string(),\n        groupId: z.string(),\n        remove: z.boolean().default(false),\n      })\n      .strict(),\n    returns: {} as { success: true },\n  },\n  'market/:contractId/groups': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({ contractId: z.string() }),\n    returns: [] as LiteGroup[],\n  },\n  'market/:contractId/answer': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { newAnswerId: string },\n    props: z\n      .object({\n        contractId: z.string().max(MAX_ANSWER_LENGTH),\n        text: z.string().min(1).max(MAX_ANSWER_LENGTH),\n      })\n      .strict(),\n  },\n  'market/:contractId/block': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ contractId: z.string() }).strict(),\n  },\n  'market/:contractId/unblock': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ contractId: z.string() }).strict(),\n  },\n  unresolve: {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { success: true },\n    props: z\n      .object({\n        contractId: z.string().max(MAX_ANSWER_LENGTH),\n        answerId: z.string().max(MAX_ANSWER_LENGTH).optional(),\n      })\n      .strict(),\n  },\n  leagues: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as League[],\n    props: z\n      .object({\n        userId: z.string().optional(),\n        cohort: z.string().optional(),\n        season: z.coerce.number().optional(),\n      })\n      .strict(),\n  },\n  markets: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as LiteMarket[],\n    props: z\n      .object({\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n        sort: z\n          .enum([\n            'created-time',\n            'updated-time',\n            'last-bet-time',\n            'last-comment-time',\n          ])\n          .optional(),\n        order: z.enum(['asc', 'desc']).optional(),\n        before: z.string().optional(),\n        userId: z.string().optional(),\n        groupId: z.string().optional(),\n      })\n      .strict(),\n  },\n  'search-markets': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as LiteMarket[],\n    props: searchProps,\n  },\n  'search-markets-full': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    preferAuth: true,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Contract[],\n    props: searchProps,\n  },\n  managram: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        amount: z.number().finite(),\n        toIds: z.array(z.string()),\n        message: z.string().max(MAX_COMMENT_LENGTH),\n        groupId: z.string().max(MAX_ID_LENGTH).optional(),\n        token: z.enum(['M$', 'CASH']).default('M$'),\n      })\n      .strict(),\n  },\n  manalink: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { slug: string },\n    props: z\n      .object({\n        amount: z.number().positive().finite().safe(),\n        expiresTime: z.number().lt(MAX_EXPIRES_AT).optional(),\n        maxUses: z.number().optional(),\n        message: z.string().optional(),\n      })\n      .strict(),\n  },\n  donate: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        amount: z.number().positive().finite().safe(),\n        to: z.string(),\n      })\n      .strict(),\n  },\n  'convert-sp-to-mana': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ amount: z.number().positive().finite().safe() }).strict(),\n  },\n  'convert-cash-to-mana': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ amount: z.number().positive().finite().safe() }).strict(),\n  },\n  'request-loan': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({}),\n    returns: {} as { payout: number },\n  },\n  // deprecated. use /txns instead\n  managrams: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: [] as ManaPayTxn[],\n    props: z\n      .object({\n        toId: z.string().optional(),\n        fromId: z.string().optional(),\n        limit: z.coerce.number().gte(0).lte(100).default(100),\n        before: z.coerce.number().optional(),\n        after: z.coerce.number().optional(),\n      })\n      .strict(),\n  },\n  'market/:id/positions': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as ContractMetric[],\n    props: z\n      .object({\n        id: z.string(),\n        userId: z.string().optional(),\n        answerId: z.string().optional(),\n        summaryOnly: z.boolean().optional(),\n        top: z.undefined().or(z.coerce.number()),\n        bottom: z.undefined().or(z.coerce.number()),\n        order: z.enum(['shares', 'profit']).optional(),\n      })\n      .strict(),\n  },\n  me: {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z.object({}),\n    returns: {} as FullUser,\n  },\n  'me/update': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({\n      name: z.string().trim().min(1).optional(),\n      username: z.string().trim().min(1).optional(),\n      avatarUrl: z.string().optional(),\n      bio: z.string().optional(),\n      website: z.string().optional(),\n      twitterHandle: z.string().optional(),\n      discordHandle: z.string().optional(),\n      // settings\n      optOutBetWarnings: z.boolean().optional(),\n      isAdvancedTrader: z.boolean().optional(),\n      //internal\n      seenStreakModal: z.boolean().optional(),\n      shouldShowWelcome: z.boolean().optional(),\n      hasSeenContractFollowModal: z.boolean().optional(),\n      hasSeenLoanModal: z.boolean().optional(),\n    }),\n    returns: {} as FullUser,\n  },\n  'me/delete': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({\n      username: z.string(), // just so you're sure\n    }),\n  },\n  'me/private': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z.object({}),\n    returns: {} as PrivateUser,\n  },\n  'me/private/update': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    props: z\n      .object({\n        email: z.string().email().optional(),\n        apiKey: z.string().optional(),\n        pushToken: z.string().optional(),\n        rejectedPushNotificationsOn: z.number().optional(),\n        lastPromptedToEnablePushNotifications: z.number().optional(),\n        interestedInPushNotifications: z.boolean().optional(),\n        hasSeenAppBannerInNotificationsOn: z.number().optional(),\n        installedAppPlatforms: z.array(z.string()).optional(),\n        paymentInfo: z.string().optional(),\n        lastAppReviewTime: z.number().optional(),\n      })\n      .strict(),\n  },\n  'user/:username': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as FullUser,\n    props: z.object({ username: z.string() }).strict(),\n  },\n  'user/:username/lite': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as DisplayUser,\n    props: z.object({ username: z.string() }).strict(),\n  },\n  'user/by-id/:id': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    // Do not add a caching strategy here. New users need up-to-date data.\n    returns: {} as FullUser,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'user/by-id/:id/lite': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as DisplayUser,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'users/by-id': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as DisplayUser[],\n    props: z.object({ ids: z.array(z.string()) }).strict(),\n  },\n  'users/by-id/balance': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as { id: string; balance: number }[],\n    props: z.object({ ids: z.array(z.string()) }).strict(),\n  },\n  'user/by-id/:id/block': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'user/by-id/:id/unblock': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  users: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as FullUser[],\n    props: z\n      .object({\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n        before: z.string().optional(),\n      })\n      .strict(),\n  },\n  'search-users': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as FullUser[],\n    props: z\n      .object({\n        term: z.string(),\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n        page: z.coerce.number().gte(0).default(0),\n      })\n      .strict(),\n  },\n  'search-contract-positions': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as DisplayUser[],\n    props: z\n      .object({\n        term: z.string(),\n        contractId: z.string(),\n        limit: z.coerce.number().gte(0).lte(100).default(10),\n      })\n      .strict(),\n  },\n  'save-twitch': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        twitchInfo: z.object({\n          twitchName: z.string().optional(),\n          controlToken: z.string().optional(),\n          botEnabled: z.boolean().optional(),\n          needsRelinking: z.boolean().optional(),\n        }),\n      })\n      .strict(),\n  },\n  'set-push-token': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({ pushToken: z.string() }).strict(),\n  },\n  'update-notif-settings': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      type: z.string() as z.ZodType<notification_preference>,\n      medium: z.enum(['email', 'browser', 'mobile']),\n      enabled: z.boolean(),\n    }),\n  },\n  headlines: {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: [] as Headline[],\n    props: z.object({\n      slug: z.enum(['politics', 'ai', 'news']).optional(),\n    }),\n  },\n  'politics-headlines': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: [] as Headline[],\n    props: z.object({}),\n  },\n  'set-news': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { success: true },\n    props: z\n      .object({\n        dashboardIds: z.array(z.string()),\n        endpoint: z.enum(['politics', 'ai', 'news']),\n      })\n      .strict(),\n  },\n  react: {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        contentId: z.string(),\n        contentType: z.enum(['comment', 'contract', 'post']),\n        commentParentType: z.enum(['post']).optional(),\n        remove: z.boolean().optional(),\n        reactionType: z.enum(['like', 'dislike']).optional().default('like'),\n      })\n      .strict(),\n    returns: { success: true },\n  },\n  'compatible-lovers': {\n    method: 'GET',\n    visibility: 'private',\n    authed: false,\n    props: z.object({ userId: z.string() }),\n    returns: {} as {\n      lover: Lover\n      compatibleLovers: Lover[]\n      loverCompatibilityScores: {\n        [userId: string]: CompatibilityScore\n      }\n    },\n  },\n  post: {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    returns: {} as ContractComment,\n    props: z\n      .object({\n        contractId: z.string(),\n        betId: z.string().optional(),\n        commentId: z.string().optional(),\n        content: contentSchema.optional(),\n      })\n      .strict(),\n  },\n  'fetch-link-preview': {\n    method: 'GET',\n    visibility: 'private',\n    authed: false,\n    props: z.object({ url: z.string() }).strict(),\n    cache: 'max-age=86400, stale-while-revalidate=86400',\n    returns: {} as LinkPreview,\n  },\n  'remove-pinned-photo': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    returns: { success: true },\n    props: z\n      .object({\n        userId: z.string(),\n      })\n      .strict(),\n  },\n  'get-related-markets': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    props: z\n      .object({\n        contractId: z.string(),\n        limit: z.coerce.number().gte(0).lte(100),\n        userId: z.string().optional(),\n        question: z.string().optional(),\n        uniqueBettorCount: z.coerce.number().gte(0).optional(),\n      })\n      .strict(),\n    returns: {} as {\n      marketsFromEmbeddings: Contract[]\n    },\n    cache: 'public, max-age=3600, stale-while-revalidate=10',\n  },\n  'get-related-markets-by-group': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: 'public, max-age=3600, stale-while-revalidate=10',\n    returns: {} as {\n      groupContracts: Contract[]\n    },\n    props: z\n      .object({\n        contractId: z.string(),\n        limit: z.coerce.number().gte(0).lte(100),\n        offset: z.coerce.number().gte(0),\n      })\n      .strict(),\n  },\n  'unlist-and-cancel-user-contracts': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        userId: z.string(),\n      })\n      .strict(),\n  },\n  'get-boost-analytics': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: false,\n    props: z\n      .object({\n        contractId: z.string(),\n      })\n      .strict(),\n    returns: {} as {\n      uniqueViewers: number\n      totalViews: number\n      uniquePromotedViewers: number\n      totalPromotedViews: number\n      boostPeriods: {\n        startTime: string\n        endTime: string\n      }[]\n    },\n  },\n  'get-seen-market-ids': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      contractIds: z.array(z.string()),\n      types: z.array(z.enum(['page', 'card', 'promoted'])).optional(),\n      since: z.number(),\n    }),\n    returns: [] as string[],\n  },\n  'get-compatibility-questions': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({}),\n    returns: {} as {\n      status: 'success'\n      questions: (Row<'love_questions'> & {\n        answer_count: number\n        score: number\n      })[]\n    },\n  },\n  'like-lover': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    props: z.object({\n      targetUserId: z.string(),\n      remove: z.boolean().optional(),\n    }),\n    returns: {} as {\n      status: 'success'\n    },\n  },\n  'ship-lovers': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    props: z.object({\n      targetUserId1: z.string(),\n      targetUserId2: z.string(),\n      remove: z.boolean().optional(),\n    }),\n    returns: {} as {\n      status: 'success'\n    },\n  },\n\n  'get-likes-and-ships': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z\n      .object({\n        userId: z.string(),\n      })\n      .strict(),\n    returns: {} as {\n      status: 'success'\n      likesReceived: LikeData[]\n      likesGiven: LikeData[]\n      ships: ShipData[]\n    },\n  },\n  'has-free-like': {\n    method: 'GET',\n    visibility: 'private',\n    authed: true,\n    props: z.object({}).strict(),\n    returns: {} as {\n      status: 'success'\n      hasFreeLike: boolean\n    },\n  },\n  'star-lover': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    props: z.object({\n      targetUserId: z.string(),\n      remove: z.boolean().optional(),\n    }),\n    returns: {} as {\n      status: 'success'\n    },\n  },\n  'get-lovers': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({}).strict(),\n    returns: {} as {\n      status: 'success'\n      lovers: Lover[]\n    },\n  },\n  'get-lover-answers': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({ userId: z.string() }).strict(),\n    returns: {} as {\n      status: 'success'\n      answers: Row<'love_compatibility_answers'>[]\n    },\n  },\n  'search-groups': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    // Is there a way to infer return { lite:[] as LiteGroup[] } if type is 'lite'?\n    returns: {\n      full: [] as Group[],\n      lite: [] as LiteGroup[],\n    },\n    props: SearchGroupParams(SearchGroupShape),\n  },\n  'search-my-groups': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {\n      full: [] as Group[],\n      lite: [] as LiteGroup[],\n    },\n    props: SearchGroupParams(MySearchGroupShape),\n  },\n  'get-groups-with-top-contracts': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as { topic: Topic; contracts: Contract[] }[],\n    props: z.object({}),\n  },\n  'get-balance-changes': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: [] as AnyBalanceChangeType[],\n    props: z\n      .object({\n        before: z.coerce.number().optional(),\n        after: z.coerce.number().default(0),\n        userId: z.string(),\n      })\n      .strict(),\n  },\n  'get-partner-stats': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z\n      .object({\n        userId: z.string(),\n      })\n      .strict(),\n    returns: {} as {\n      status: 'success' | 'error'\n      username: string\n      numContractsCreated: number\n      numUniqueBettors: number\n      numReferrals: number\n      numReferralsWhoRetained: number\n      totalTraderIncome: number\n      totalReferralIncome: number\n      dollarsEarned: number\n    },\n  },\n  'record-contract-view': {\n    method: 'POST',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      userId: z.string().optional(),\n      contractId: z.string(),\n      kind: z.enum(['page', 'card', 'promoted']),\n    }),\n    returns: {} as { status: 'success' },\n  },\n  'record-comment-view': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({\n      contractId: z.string(),\n      commentId: z.string(),\n    }),\n    returns: {} as { status: 'success' },\n  },\n  'record-contract-interaction': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({\n      contractId: z.string(),\n      kind: z.enum([\n        'page bet',\n        'page comment',\n        'page repost',\n        'page like',\n        'card bet',\n        'card click',\n        'promoted click',\n        'card like',\n        'page share',\n        'browse click',\n      ]),\n      commentId: z.string().optional(),\n      feedReasons: z.array(z.string()).optional(),\n      feedType: z.string().optional(),\n      betGroupId: z.string().optional(),\n      betId: z.string().optional(),\n    }),\n    returns: {} as { status: 'success' },\n  },\n  'get-dashboard-from-slug': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      dashboardSlug: z.string(),\n    }),\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as Dashboard,\n  },\n  'get-posts': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    preferAuth: true,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z\n      .object({\n        sortBy: z\n          .enum(['created_time', 'importance_score'])\n          .optional()\n          .default('created_time'),\n        term: z.string().optional(),\n        limit: z.coerce.number().gte(0).lte(200).default(100),\n        userId: z.string().optional(),\n        offset: z.coerce.number().gte(0).default(0),\n      })\n      .strict(),\n    returns: [] as TopLevelPost[],\n  },\n  'create-public-chat-message': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as ChatMessage,\n    props: z.object({\n      content: contentSchema,\n      channelId: z.string(),\n    }),\n  },\n  'get-followed-groups': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      userId: z.string(),\n    }),\n    returns: {} as {\n      groups: Group[]\n    },\n  },\n  'get-user-portfolio': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      userId: z.string(),\n    }),\n    returns: {} as LivePortfolioMetrics,\n  },\n  'get-user-portfolio-history': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      userId: z.string(),\n      period: z.enum(PERIODS),\n    }),\n    returns: {} as PortfolioMetrics[],\n  },\n  'get-channel-memberships': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      channelId: z.coerce.number().optional(),\n      createdTime: z.string().optional(),\n      lastUpdatedTime: z.string().optional(),\n      limit: z.coerce.number(),\n    }),\n    returns: {\n      channels: [] as PrivateMessageChannel[],\n      memberIdsByChannelId: {} as { [channelId: string]: string[] },\n    },\n  },\n  'get-channel-messages': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      channelId: z.coerce.number(),\n      limit: z.coerce.number(),\n      id: z.coerce.number().optional(),\n    }),\n    returns: [] as PrivateChatMessage[],\n  },\n  'get-channel-seen-time': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      channelIds: z.array(z.coerce.number()),\n    }),\n    returns: [] as [number, string][],\n  },\n  'set-channel-seen-time': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      channelId: z.coerce.number(),\n    }),\n  },\n  'get-feed': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as {\n      contracts: Contract[]\n      comments: ContractComment[]\n      bets: Bet[]\n      reposts: Repost[]\n      idsToReason: { [id: string]: string }\n    },\n    props: z\n      .object({\n        userId: z.string(),\n        limit: z.coerce.number().gt(0).lte(100).default(100),\n        offset: z.coerce.number().gte(0).default(0),\n        ignoreContractIds: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'get-mana-supply': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as ManaSupply,\n    props: z.object({}).strict(),\n  },\n  'get-notifications': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as Notification[],\n    props: z\n      .object({\n        after: z.coerce.number().optional(),\n        limit: z.coerce.number().gte(0).lte(1000).default(100),\n      })\n      .strict(),\n  },\n  'update-mod-report': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        reportId: z.number(),\n        updates: z\n          .object({\n            status: z\n              .enum(['new', 'under review', 'resolved', 'needs admin'])\n              .optional(),\n            mod_note: z.string().optional(),\n          })\n          .partial(),\n      })\n      .strict(),\n    returns: {} as { status: string; report: ModReport },\n  },\n  'get-mod-reports': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        statuses: z.array(\n          z.enum(['new', 'under review', 'resolved', 'needs admin'])\n        ),\n        limit: z.coerce.number().gte(0).lte(100).default(25),\n        offset: z.coerce.number().gte(0).default(0),\n        count: coerceBoolean.optional(),\n      })\n      .strict(),\n    returns: {} as {\n      status: string\n      count?: number\n      reports: ModReport[]\n    },\n  },\n  'get-txn-summary-stats': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as Row<'txn_summary_stats'>[],\n    props: z\n      .object({\n        ignoreCategories: z.array(z.string()).optional(),\n        fromType: z.string().optional(),\n        toType: z.string().optional(),\n        limitDays: z.coerce.number(),\n      })\n      .strict(),\n  },\n  'get-mana-summary-stats': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as Row<'mana_supply_stats'>[],\n    props: z\n      .object({\n        limitDays: z.coerce.number(),\n      })\n      .strict(),\n  },\n  'register-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: verificationParams,\n    returns: {} as RegistrationReturnType,\n  },\n  'get-verification-status-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      documents?: GIDXDocument[]\n      message?: string\n      documentStatus?: string\n    },\n    props: z.object({}),\n  },\n  'get-monitor-status-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n    },\n    props: z.object({\n      DeviceGPS: GPSProps,\n    }),\n  },\n  'get-checkout-session-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n      session?: CheckoutSession\n    },\n    props: z.object({\n      PayActionCode: z.enum(['PAY', 'PAYOUT']).default('PAY'),\n      DeviceGPS: GPSProps,\n      userId: z.string().optional(),\n      ip: z.string().optional(),\n    }),\n  },\n  'complete-checkout-session-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n      gidxMessage?: string | null\n      details?: PaymentDetail[]\n    },\n    props: z.object(checkoutParams),\n  },\n  'complete-cashout-session-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n      gidxMessage?: string | null\n      details?: PaymentDetail[]\n    },\n    props: z.object(cashoutParams),\n  },\n  'complete-cashout-request': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n      gidxMessage?: string | null\n      details?: PaymentDetail[]\n    },\n    props: z.object(cashoutRequestParams),\n  },\n  'get-verification-documents-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      documents: GIDXDocument[]\n      utilityDocuments: GIDXDocument[]\n      idDocuments: GIDXDocument[]\n      rejectedDocuments: GIDXDocument[]\n    },\n    props: z.object({}),\n  },\n  'upload-document-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { status: string },\n    props: z.object({\n      CategoryType: z.number().gte(1).lte(7),\n      fileName: z.string(),\n      fileUrl: z.string(),\n    }),\n  },\n  'identity-callback-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as { Accepted: boolean },\n    props: z.object({\n      MerchantCustomerID: z.string(),\n      NotificationType: z.string(),\n    }),\n  },\n  'payment-callback-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as { MerchantTransactionID: string },\n    props: z\n      .object({\n        MerchantTransactionID: z.string(),\n        TransactionStatusCode: z.coerce.number(),\n        TransactionStatusMessage: z.string(),\n        StatusCode: z.coerce.number(),\n        SessionID: z.string(),\n        MerchantSessionID: z.string(),\n        SessionScore: z.coerce.number(),\n        ReasonCodes: z.array(z.string()).optional(),\n        ServiceType: z.string(),\n        StatusMessage: z.string(),\n      })\n      .strict(),\n  },\n  'get-best-comments': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { comments: ContractComment[]; contracts: Contract[] },\n    props: z.object({\n      limit: z.coerce.number().gte(0).lte(100).default(20),\n      offset: z.coerce.number().gte(0).default(0),\n      ignoreContractIds: z.array(z.string()).optional(),\n      justLikes: z.coerce.number().optional(),\n    }),\n  },\n  'get-redeemable-prize-cash': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { redeemablePrizeCash: number },\n    props: z.object({}),\n  },\n  'get-total-redeemable-prize-cash': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as { total: number },\n    props: z.object({}),\n  },\n  'get-cashouts': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as PendingCashoutStatusData[],\n    props: z\n      .object({\n        limit: z.coerce.number().gte(0).lte(100).default(10),\n        offset: z.coerce.number().gte(0).default(0),\n        userId: z.string().optional(),\n      })\n      .strict(),\n  },\n  'get-kyc-stats': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({}),\n    returns: {} as {\n      initialVerifications: {\n        count: number\n        day: string\n      }[]\n      phoneVerifications: {\n        count: number\n        day: string\n      }[]\n    },\n  },\n  txns: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z\n      .object({\n        token: z.string().optional(),\n        offset: z.coerce.number().default(0),\n        limit: z.coerce.number().gte(0).lte(100).default(100),\n        before: z.coerce.number().optional(),\n        after: z.coerce.number().optional(),\n        toId: z.string().optional(),\n        fromId: z.string().optional(),\n        category: z.string().optional(),\n        ignoreCategories: z.array(z.string()).optional(),\n      })\n      .strict(),\n    returns: [] as Txn[],\n  },\n  'generate-ai-market-suggestions': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: [] as AIGeneratedMarket[],\n    props: z\n      .object({\n        prompt: z.string(),\n        existingTitles: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'generate-ai-description': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { description: JSONContent | undefined },\n    props: z\n      .object({\n        question: z.string(),\n        description: z.string().optional(),\n        answers: z.array(z.string()).optional(),\n        outcomeType: z.string().optional(),\n        shouldAnswersSumToOne: coerceBoolean.optional(),\n        addAnswersMode: z\n          .enum(['DISABLED', 'ONLY_CREATOR', 'ANYONE'])\n          .optional(),\n      })\n      .strict(),\n  },\n  'generate-ai-answers': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as {\n      answers: string[]\n      addAnswersMode: 'DISABLED' | 'ONLY_CREATOR' | 'ANYONE'\n    },\n    props: z\n      .object({\n        question: z.string(),\n        answers: z.array(z.string()),\n        shouldAnswersSumToOne: coerceBoolean,\n        description: z.string().optional(),\n      })\n      .strict(),\n  },\n  'get-monthly-bets-2024': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ userId: z.string() }),\n    returns: [] as { month: string; bet_count: number; total_amount: number }[],\n  },\n  'get-max-min-profit-2024': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ userId: z.string() }),\n    returns: [] as {\n      profit: number\n      data: Contract\n      answer_id: string | null\n      has_no_shares: boolean\n      has_yes_shares: boolean\n    }[],\n  },\n  'get-next-loan-amount': {\n    method: 'GET',\n    visibility: 'undocumented',\n    cache: DEFAULT_CACHE_STRATEGY,\n    authed: false,\n    returns: {} as { amount: number },\n    props: z.object({\n      userId: z.string(),\n    }),\n  },\n  'create-task': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as Task,\n    props: z\n      .object({\n        text: z.string(),\n        category_id: z.number().optional(),\n        priority: z.number().default(0),\n        assignee_id: z.string().optional(),\n      })\n      .strict(),\n  },\n  'update-task': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z\n      .object({\n        id: z.number(),\n        text: z.string().optional(),\n        completed: z.boolean().optional(),\n        priority: z.number().optional(),\n        category_id: z.number().optional(),\n        archived: z.boolean().optional(),\n        assignee_id: z.string().optional(),\n      })\n      .strict(),\n  },\n  'create-category': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { id: number },\n    props: z\n      .object({\n        name: z.string(),\n        color: z.string().optional(),\n        displayOrder: z.number().optional(),\n      })\n      .strict(),\n  },\n  'get-categories': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { categories: TaskCategory[] },\n    props: z.object({}).strict(),\n  },\n  'update-category': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z\n      .object({\n        categoryId: z.number(),\n        name: z.string().optional(),\n        color: z.string().optional(),\n        displayOrder: z.number().optional(),\n        archived: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  'get-tasks': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { tasks: Task[] },\n    props: z.object({}).strict(),\n  },\n  'is-sports-interested': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { isSportsInterested: boolean },\n    props: z.object({}).strict(),\n  },\n  'get-site-activity': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as {\n      bets: Bet[]\n      comments: CommentWithTotalReplies[]\n      newContracts: Contract[]\n      relatedContracts: Contract[]\n    },\n    props: z\n      .object({\n        limit: z.coerce.number().default(10),\n        offset: z.coerce.number().default(0),\n        blockedUserIds: z.array(z.string()).optional(),\n        blockedGroupSlugs: z.array(z.string()).optional(),\n        blockedContractIds: z.array(z.string()).optional(),\n        topicIds: z.array(z.string()).optional(),\n        types: z\n          .array(z.enum(['bets', 'comments', 'markets', 'limit-orders']))\n          .optional(),\n        minBetAmount: z.coerce.number().optional(),\n        onlyFollowedTopics: coerceBoolean.optional(),\n        onlyFollowedContracts: coerceBoolean.optional(),\n        onlyFollowedUsers: coerceBoolean.optional(),\n        userId: z.string().optional(),\n      })\n      .strict(),\n  },\n  'get-sports-games': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { schedule: any[] },\n    props: z.object({}).strict(),\n  },\n  'get-market-props': {\n    method: 'GET',\n    visibility: 'public',\n    cache: DEFAULT_CACHE_STRATEGY,\n    // Could set authed false and preferAuth with an api secret if we want it to replace static props\n    authed: true,\n    returns: {} as {\n      manaContract: MarketContract\n      chartAnnotations: ChartAnnotation[]\n      topics: Topic[]\n      comments: ContractComment[]\n      pinnedComments: ContractComment[]\n      userPositionsByOutcome: {\n        YES: ContractMetric[]\n        NO: ContractMetric[]\n      }\n      topContractMetrics: ContractMetric[]\n      totalPositions: number\n      dashboards: Dashboard[]\n      cashContract: MarketContract\n      totalManaBets: number\n      totalCashBets: number\n    },\n    props: z.object({\n      slug: z.string().optional(),\n      id: z.string().optional(),\n    }),\n  },\n  'get-user-contract-metrics-with-contracts': {\n    method: 'GET',\n    visibility: 'public',\n    preferAuth: true,\n    authed: false,\n    returns: {} as {\n      metricsByContract: Dictionary<ContractMetric[]>\n      contracts: MarketContract[]\n    },\n    props: z.object({\n      userId: z.string(),\n      limit: z.coerce.number(),\n      offset: z.coerce.number().gte(0).optional(),\n      perAnswer: coerceBoolean.optional(),\n      inMani: coerceBoolean.optional(),\n    }),\n  },\n  validateIap: {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z.object({\n      receipt: z.string(),\n    }),\n  },\n  'check-sports-event': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as { exists: boolean; existingMarket?: LiteMarket },\n    props: z\n      .object({\n        sportsEventId: z.string(),\n      })\n      .strict(),\n  },\n  'comment-reactions': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Reaction[],\n    props: z\n      .object({\n        contentIds: z.array(z.string()),\n        contentType: z.enum(['comment', 'contract']),\n      })\n      .strict(),\n  },\n  'mark-all-notifications-new': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({}).strict(),\n    returns: {} as { success: boolean },\n  },\n  'get-contract-voters': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        contractId: z.string(),\n      })\n      .strict(),\n    returns: [] as DisplayUser[],\n  },\n  'get-contract-option-voters': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ contractId: z.string(), optionId: z.string() }),\n    returns: [] as DisplayUser[],\n  },\n  'purchase-contract-boost': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        contractId: z.string(),\n        startTime: z.number().positive().finite().safe(),\n        method: z.enum(['mana', 'cash']),\n      })\n      .strict(),\n    returns: {} as { success: boolean; checkoutUrl?: string },\n  },\n  'generate-ai-numeric-ranges': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as {\n      thresholds: { answers: string[]; midpoints: number[] }\n      buckets: { answers: string[]; midpoints: number[] }\n    },\n    props: z\n      .object({\n        question: z.string(),\n        min: z.number(),\n        max: z.number(),\n        description: z.string().optional(),\n        unit: z.string(),\n      })\n      .strict(),\n  },\n  'infer-numeric-unit': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as {\n      unit: string\n    },\n    props: z\n      .object({\n        question: z.string(),\n        description: z.string().optional(),\n      })\n      .strict(),\n  },\n  'generate-ai-date-ranges': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as {\n      buckets: { answers: string[]; midpoints: number[] }\n      thresholds: { answers: string[]; midpoints: number[] }\n    },\n    props: z\n      .object({\n        question: z.string(),\n        min: z.string(),\n        max: z.string(),\n        description: z.string().optional(),\n      })\n      .strict(),\n  },\n  'regenerate-numeric-midpoints': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { midpoints: number[] },\n    props: z\n      .object({\n        description: z.string().optional(),\n        question: z.string(),\n        answers: z.array(z.string()),\n        min: z.number(),\n        max: z.number(),\n        unit: z.string(),\n        tab: z.enum(['thresholds', 'buckets']),\n      })\n      .strict(),\n  },\n  'regenerate-date-midpoints': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { midpoints: number[] },\n    props: z\n      .object({\n        description: z.string().optional(),\n        question: z.string(),\n        answers: z.array(z.string()),\n        min: z.string(),\n        max: z.string(),\n        tab: z.enum(['thresholds', 'buckets']),\n      })\n      .strict(),\n  },\n\n  'generate-concise-title': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        question: z.string(),\n      })\n      .strict(),\n    returns: {} as { title: string },\n  },\n  'get-close-date': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        question: z.string(),\n        utcOffset: z.number().optional(),\n      })\n      .strict(),\n    returns: {} as { closeTime: number },\n  },\n  'refer-user': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        referredByUsername: z.string(),\n        contractId: z.string().optional(),\n      })\n      .strict(),\n    returns: {} as { success: boolean },\n  },\n\n  'save-market-draft': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { id: number },\n    props: z\n      .object({\n        data: z.object({\n          question: z.string(),\n          description: z.any().optional(),\n          outcomeType: z.string(),\n          answers: z.array(z.string()).optional(),\n          closeDate: z.string().optional(),\n          closeHoursMinutes: z.string().optional(),\n          visibility: z.string(),\n          selectedGroups: z.array(z.any()),\n          savedAt: z.number(),\n        }),\n      })\n      .strict(),\n  },\n\n  'get-market-drafts': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: [] as MarketDraft[],\n    props: z.object({}).strict(),\n  },\n\n  'delete-market-draft': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z\n      .object({\n        id: z.coerce.number(),\n      })\n      .strict(),\n  },\n  'get-season-info': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      season: z.coerce.number().int().positive().optional(),\n    }),\n    returns: {} as {\n      season: number\n      startTime: number // epoch ms\n      endTime: number | null // epoch ms, null if a *mystery* for clients\n      status: 'active' | 'processing' | 'complete'\n    },\n  },\n  'mark-notification-read': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z\n      .object({\n        notificationId: z.string(),\n      })\n      .strict(),\n  },\n  'dismiss-user-report': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        reportId: z.string(),\n      })\n      .strict(),\n    returns: {} as { success: boolean },\n  },\n  'create-post': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { post: TopLevelPost },\n    props: z\n      .object({\n        title: z.string().min(1).max(120),\n        content: contentSchema,\n        isAnnouncement: z.boolean().optional(),\n        visibility: z.enum(['public', 'unlisted']).optional(),\n      })\n      .strict(),\n  },\n  'update-post': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { post: TopLevelPost },\n    props: z\n      .object({\n        id: z.string(),\n        title: z.string().min(1).max(480).optional(),\n        content: contentSchema.optional(),\n        visibility: z.enum(['public', 'unlisted']).optional(),\n      })\n      .strict(),\n  },\n  'create-post-comment': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { comment: PostComment },\n    props: z\n      .object({\n        postId: z.string(),\n        content: contentSchema,\n        replyToCommentId: z.string().optional(),\n      })\n      .strict(),\n  },\n  'update-post-comment': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { comment: PostComment },\n    props: z\n      .object({\n        commentId: z.string(),\n        postId: z.string(),\n        hidden: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  'follow-post': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: true },\n    props: z\n      .object({\n        postId: z.string(),\n        follow: z.boolean(),\n      })\n      .strict(),\n  },\n  'edit-post-comment': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        commentId: z.string(),\n        postId: z.string(),\n        content: contentSchema,\n      })\n      .strict(),\n    returns: {} as { success: boolean },\n  },\n} as const)\n\nexport type APIPath = keyof typeof API\nexport type APISchema<N extends APIPath> = (typeof API)[N]\n\nexport type APIParams<N extends APIPath> = z.input<APISchema<N>['props']>\nexport type ValidatedAPIParams<N extends APIPath> = z.output<\n  APISchema<N>['props']\n>\n\nexport type APIResponse<N extends APIPath> = APISchema<N> extends {\n  returns: Record<string, any>\n}\n  ? APISchema<N>['returns']\n  : void\n\nexport type APIResponseOptionalContinue<N extends APIPath> =\n  | { continue: () => Promise<void>; result: APIResponse<N> }\n  | APIResponse<N>\n"
        },
        {
          "path": "common/src/comment.ts",
          "preContent": "import { type JSONContent } from '@tiptap/core'\nimport { type OnLover } from 'common/love/love-comment'\nimport { type ContractToken, type Visibility } from './contract'\n\nexport const MAX_COMMENT_LENGTH = 10000\n\nexport type AnyCommentType = OnContract | OnPost | OnLover\n\n// Currently, comments are created after the bet, not atomically with the bet.\n// They're uniquely identified by the pair contractId/betId.\nexport type Comment<T extends AnyCommentType = AnyCommentType> = {\n  id: string\n  replyToCommentId?: string\n  userId: string\n\n  /** @deprecated - content now stored as JSON in content*/\n  text?: string\n  content: JSONContent\n  createdTime: number\n\n  // Denormalized, for rendering comments\n  userName: string\n  userUsername: string\n  userAvatarUrl?: string\n  /** @deprecated Not actually deprecated, only in supabase column, and not in data column */\n  likes?: number\n  dislikes?: number\n  hidden?: boolean\n  hiddenTime?: number\n  hiderId?: string\n  pinned?: boolean\n  pinnedTime?: number\n  pinnerId?: string\n  visibility: Visibility\n  editedTime?: number\n  isApi?: boolean\n} & T\n\nexport type OnContract = {\n  commentType: 'contract'\n  contractId: string\n  answerOutcome?: string // reply to answer.id\n  betId?: string\n\n  // denormalized from main contract\n  contractSlug: string\n  contractQuestion: string\n\n  // denormalized from bet\n  betAmount?: number\n  betOutcome?: string\n  betAnswerId?: string\n  // denormalized from the contract you are betting on (may be cash)\n  betToken?: ContractToken\n\n  // Used to respond to another user's bet\n  bettorUsername?: string\n  bettorName?: string\n  betLimitProb?: number\n  betOrderAmount?: number\n  bettorId?: string\n\n  // denormalized based on betting history\n  commenterPositionProb?: number // binary only\n  commenterPositionShares?: number\n  commenterPositionOutcome?: string\n  commenterPositionAnswerId?: string\n\n  bountyAwarded?: number\n  betReplyAmountsByOutcome?: { [outcome: string]: number }\n\n  isRepost?: boolean\n}\n\nexport type ContractComment = Comment<OnContract>\n\nexport type CommentWithTotalReplies = ContractComment & {\n  totalReplies?: number\n}\nexport type OnPost = {\n  commentType: 'post'\n  postId: string\n}\nexport type PostComment = Comment<OnPost>\n",
          "postContent": "import { type JSONContent } from '@tiptap/core'\nimport { type OnLover } from 'common/love/love-comment'\nimport { type ContractToken, type Visibility } from './contract'\n\nexport const MAX_COMMENT_LENGTH = 10000\n\nexport type AnyCommentType = OnContract | OnPost | OnLover\n\n// Currently, comments are created after the bet, not atomically with the bet.\n// They're uniquely identified by the pair contractId/betId.\nexport type Comment<T extends AnyCommentType = AnyCommentType> = {\n  id: string\n  replyToCommentId?: string\n  userId: string\n\n  /** @deprecated - content now stored as JSON in content*/\n  text?: string\n  content: JSONContent\n  createdTime: number\n\n  // Denormalized, for rendering comments\n  userName: string\n  userUsername: string\n  userAvatarUrl?: string\n  /** @deprecated Not actually deprecated, only in supabase column, and not in data column */\n  likes?: number\n  dislikes?: number\n  hidden?: boolean\n  hiddenTime?: number\n  hiderId?: string\n  pinned?: boolean\n  pinnedTime?: number\n  pinnerId?: string\n  visibility: Visibility\n  editedTime?: number\n  isApi?: boolean\n} & T\n\nexport type OnContract = {\n  commentType: 'contract'\n  contractId: string\n  answerOutcome?: string // reply to answer.id\n  betId?: string\n\n  // denormalized from main contract\n  contractSlug: string\n  contractQuestion: string\n\n  // denormalized from bet\n  betAmount?: number\n  betOutcome?: string\n  betAnswerId?: string\n  // denormalized from the contract you are betting on (may be cash)\n  betToken?: ContractToken\n\n  // Used to respond to another user's bet\n  bettorUsername?: string\n  bettorName?: string\n  betLimitProb?: number\n  betOrderAmount?: number\n  bettorId?: string\n\n  // denormalized based on betting history\n  commenterPositionProb?: number // binary only\n  commenterPositionShares?: number\n  commenterPositionOutcome?: string\n  commenterPositionAnswerId?: string\n\n  bountyAwarded?: number\n  betReplyAmountsByOutcome?: { [outcome: string]: number }\n\n  isRepost?: boolean\n}\n\nexport type ContractComment = Comment<OnContract>\n\nexport type CommentWithTotalReplies = ContractComment & {\n  totalReplies?: number\n}\nexport type OnPost = {\n  commentType: 'post'\n  postId: string\n  postSlug?: string // only available via get-comments api\n  postTitle?: string // only available via get-comments api\n}\nexport type PostComment = Comment<OnPost>\n"
        },
        {
          "path": "web/components/comments/profile-comments.tsx",
          "preContent": "import { useCallback } from 'react'\nimport { ContractComment } from 'common/comment'\nimport { User } from 'common/user'\nimport { groupConsecutive } from 'common/util/array'\nimport { UserLink } from 'web/components/widgets/user-link'\nimport { Col } from '../layout/col'\nimport { RelativeTimestamp } from '../relative-timestamp'\nimport { Avatar } from '../widgets/avatar'\nimport { Content } from '../widgets/editor'\nimport { PaginationNextPrev } from '../widgets/pagination'\nimport Link from 'next/link'\nimport { usePagination } from 'web/hooks/use-pagination'\nimport { api } from 'web/lib/api/api'\nimport { LoadingIndicator } from 'web/components/widgets/loading-indicator'\nimport { getCommentLink } from 'web/components/feed/copy-link-date-time'\nimport clsx from 'clsx'\nimport { linkClass } from 'web/components/widgets/site-link'\nimport { UserHovercard } from '../user/user-hovercard'\n\ntype ContractKey = {\n  contractId: string\n  contractSlug: string\n  contractQuestion: string\n}\n\nfunction contractPath(slug: string) {\n  // by convention this includes the contract creator username, but we don't\n  // have that handy, so we just put /market/\n  return `/market/${slug}`\n}\n\nexport function UserCommentsList(props: { user: User }) {\n  const { user } = props\n\n  const q = useCallback(\n    async (p: { limit: number; offset: number }) => {\n      const page = p.offset / p.limit\n      return await api('comments', {\n        userId: user.id,\n        limit: p.limit,\n        page,\n      })\n    },\n    [user.id]\n  )\n  const pagination = usePagination({ pageSize: 50, q })\n\n  const items = groupConsecutive(pagination.items, (c) => {\n    return {\n      contractId: c.contractId,\n      contractQuestion: c.contractQuestion,\n      contractSlug: c.contractSlug,\n    }\n  })\n\n  if (items.length === 0) {\n    if (pagination.isComplete) {\n      return <p className=\"text-ink-500 mt-4\">No comments yet</p>\n    } else {\n      return <LoadingIndicator className=\"mt-4\" />\n    }\n  }\n\n  return (\n    <Col className={'bg-canvas-50'}>\n      {items.map(({ key, items }, i) => {\n        return <ProfileCommentGroup key={i} groupKey={key} items={items} />\n      })}\n      <PaginationNextPrev\n        className=\"border-ink-200 border-t px-4 py-3 sm:px-6\"\n        {...pagination}\n      />\n    </Col>\n  )\n}\n\nfunction ProfileCommentGroup(props: {\n  groupKey: ContractKey\n  items: ContractComment[]\n}) {\n  const { groupKey, items } = props\n  const { contractSlug, contractQuestion } = groupKey\n  const path = contractPath(contractSlug)\n  return (\n    <div className=\"bg-canvas-0 border-ink-300 border-b p-2\">\n      <Link\n        className={clsx(\n          'text-primary-700 mb-2 block py-1 pl-2 font-medium',\n          linkClass\n        )}\n        href={path}\n      >\n        {contractQuestion}\n      </Link>\n      <Col className=\"gap-6\">\n        {items.map((c) => (\n          <ProfileComment key={c.id} comment={c} contractSlug={contractSlug} />\n        ))}\n      </Col>\n    </div>\n  )\n}\n\nfunction ProfileComment(props: {\n  comment: ContractComment\n  contractSlug: string\n}) {\n  const { comment, contractSlug } = props\n  const {\n    text,\n    content,\n    userId,\n    userUsername,\n    userName,\n    userAvatarUrl,\n    createdTime,\n    id,\n  } = comment\n\n  return (\n    <Link\n      href={getCommentLink('market', contractSlug, id)}\n      className={\n        'hover:bg-canvas-100 relative flex flex-row items-start space-x-3 rounded-lg p-2'\n      }\n    >\n      <UserHovercard userId={userId}>\n        <Avatar\n          noLink={true}\n          username={userUsername}\n          avatarUrl={userAvatarUrl}\n        />\n      </UserHovercard>\n      <div className=\"min-w-0 flex-1\">\n        <div className=\"text-ink-500 mt-0.5 text-sm\">\n          <UserHovercard userId={userId}>\n            <UserLink\n              className=\"text-ink-500\"\n              user={{\n                id: userId,\n                name: userName,\n                username: userUsername,\n              }}\n              noLink={true}\n            />\n          </UserHovercard>{' '}\n          <RelativeTimestamp time={createdTime} />\n        </div>\n        <Content content={content || text} size=\"sm\" />\n      </div>\n    </Link>\n  )\n}\n",
          "postContent": "import { useCallback } from 'react'\nimport { ContractComment, PostComment } from 'common/comment'\nimport { User } from 'common/user'\nimport { groupConsecutive } from 'common/util/array'\nimport { UserLink } from 'web/components/widgets/user-link'\nimport { Col } from '../layout/col'\nimport { RelativeTimestamp } from '../relative-timestamp'\nimport { Avatar } from '../widgets/avatar'\nimport { Content } from '../widgets/editor'\nimport { PaginationNextPrev } from '../widgets/pagination'\nimport Link from 'next/link'\nimport { usePagination } from 'web/hooks/use-pagination'\nimport { api } from 'web/lib/api/api'\nimport { LoadingIndicator } from 'web/components/widgets/loading-indicator'\nimport { getCommentLink } from 'web/components/feed/copy-link-date-time'\nimport clsx from 'clsx'\nimport { linkClass } from 'web/components/widgets/site-link'\nimport { UserHovercard } from '../user/user-hovercard'\n\ntype Key = {\n  slug: string\n  title: string\n}\n\nfunction contractPath(slug: string) {\n  // by convention this includes the contract creator username, but we don't\n  // have that handy, so we just put /market/\n  return `/market/${slug}`\n}\n\nexport function UserCommentsList(props: { user: User }) {\n  const { user } = props\n\n  const q = useCallback(\n    async (p: { limit: number; offset: number }) => {\n      const page = p.offset / p.limit\n      return (await api('user-comments', {\n        userId: user.id,\n        limit: p.limit,\n        page,\n      })) as (ContractComment | PostComment)[]\n    },\n    [user.id]\n  )\n  const pagination = usePagination({ pageSize: 50, q })\n\n  const items = groupConsecutive(pagination.items, (c) => {\n    if (c.commentType === 'contract') {\n      return {\n        slug: c.contractSlug,\n        title: c.contractQuestion,\n      }\n    } else {\n      return {\n        slug: c.postSlug ?? '',\n        title: c.postTitle ?? '',\n      }\n    }\n  })\n  if (items.length === 0) {\n    if (pagination.isComplete) {\n      return <p className=\"text-ink-500 mt-4\">No comments yet</p>\n    } else {\n      return <LoadingIndicator className=\"mt-4\" />\n    }\n  }\n\n  return (\n    <Col className={'bg-canvas-50'}>\n      {items.map(({ key, items }, i) => {\n        return <ProfileCommentGroup key={i} groupKey={key} items={items} />\n      })}\n      <PaginationNextPrev\n        className=\"border-ink-200 border-t px-4 py-3 sm:px-6\"\n        {...pagination}\n      />\n    </Col>\n  )\n}\n\nfunction ProfileCommentGroup(props: {\n  groupKey: Key\n  items: (ContractComment | PostComment)[]\n}) {\n  const { groupKey, items } = props\n  const { slug, title } = groupKey\n  const path =\n    items[0].commentType === 'contract' ? contractPath(slug) : `/post/${slug}`\n  return (\n    <div className=\"bg-canvas-0 border-ink-300 border-b p-2\">\n      <Link\n        className={clsx(\n          'text-primary-700 mb-2 block py-1 pl-2 font-medium',\n          linkClass\n        )}\n        href={path}\n      >\n        {title}\n      </Link>\n      <Col className=\"gap-6\">\n        {items.map((c) => (\n          <ProfileComment key={c.id} comment={c} slug={slug} />\n        ))}\n      </Col>\n    </div>\n  )\n}\n\nfunction ProfileComment(props: {\n  comment: ContractComment | PostComment\n  slug: string\n}) {\n  const { comment, slug } = props\n  const {\n    text,\n    content,\n    userId,\n    userUsername,\n    userName,\n    userAvatarUrl,\n    createdTime,\n    id,\n  } = comment\n\n  return (\n    <Link\n      href={\n        comment.commentType === 'contract'\n          ? getCommentLink('market', slug, id)\n          : `/post/${slug}#${id}`\n      }\n      className={\n        'hover:bg-canvas-100 relative flex flex-row items-start space-x-3 rounded-lg p-2'\n      }\n    >\n      <UserHovercard userId={userId}>\n        <Avatar\n          noLink={true}\n          username={userUsername}\n          avatarUrl={userAvatarUrl}\n        />\n      </UserHovercard>\n      <div className=\"min-w-0 flex-1\">\n        <div className=\"text-ink-500 mt-0.5 text-sm\">\n          <UserHovercard userId={userId}>\n            <UserLink\n              className=\"text-ink-500\"\n              user={{\n                id: userId,\n                name: userName,\n                username: userUsername,\n              }}\n              noLink={true}\n            />\n          </UserHovercard>{' '}\n          <RelativeTimestamp time={createdTime} />\n        </div>\n        <Content content={content || text} size=\"sm\" />\n      </div>\n    </Link>\n  )\n}\n"
        },
        {
          "path": "web/components/top-level-posts/post-comments.tsx",
          "preContent": "import { Editor } from '@tiptap/core'\nimport clsx from 'clsx'\nimport { track } from 'web/lib/service/analytics'\nimport { PostComment } from 'common/comment'\nimport { getPostCommentShareUrl, TopLevelPost } from 'common/top-level-post'\nimport { Dictionary, groupBy, sortBy } from 'lodash'\nimport { useRouter } from 'next/router'\nimport { useEffect, useRef, useState } from 'react'\nimport { Avatar } from 'web/components/widgets/avatar'\nimport { CommentInput } from 'web/components/comments/comment-input'\nimport { Content } from 'web/components/widgets/editor'\nimport { CopyLinkDateTimeComponent } from 'web/components/feed/copy-link-date-time'\nimport { Col } from 'web/components/layout/col'\nimport { Row } from 'web/components/layout/row'\nimport { UserLink } from 'web/components/widgets/user-link'\nimport { isBlocked, usePrivateUser, useUser } from 'web/hooks/use-user'\nimport { firebaseLogin } from 'web/lib/firebase/users'\nimport { scrollIntoViewCentered } from 'web/lib/util/scroll'\nimport { toast } from 'react-hot-toast'\nimport { APIError } from 'common/api/utils'\nimport { api } from 'web/lib/api/api'\nimport { useApiSubscription } from 'client-common/hooks/use-api-subscription'\nimport { getCommentsOnPost } from 'web/lib/supabase/comments'\nimport { UserHovercard } from 'web/components/user/user-hovercard'\nimport {\n  ReplyIcon,\n  DotsHorizontalIcon,\n  EyeOffIcon,\n  LinkIcon,\n  EyeIcon,\n} from '@heroicons/react/solid'\nimport DropdownMenu, {\n  DropdownItem,\n} from 'web/components/widgets/dropdown-menu'\nimport { IconButton } from 'web/components/buttons/button'\nimport { Tooltip } from 'web/components/widgets/tooltip'\nimport { copyToClipboard } from 'web/lib/util/copy'\nimport { buildArray } from 'common/util/array'\nimport { useAdminOrMod } from 'web/hooks/use-admin'\nimport { ReactButton } from 'web/components/contract/react-button'\n\nconst roundThreadColor = 'border-ink-100 dark:border-ink-200'\n\nexport function PostCommentsActivity(props: {\n  post: TopLevelPost\n  comments: PostComment[]\n}) {\n  const { post, comments } = props\n  const commentsByUserId = groupBy(comments, (c) => c.userId)\n  const commentsByParentId = groupBy(comments, (c) => c.replyToCommentId ?? '_')\n  const topLevelComments = sortBy(\n    commentsByParentId['_'] ?? [],\n    (c) => -c.createdTime\n  )\n\n  return (\n    <Col>\n      <PostCommentInput post={post} />\n      {topLevelComments.map((parent) => (\n        <PostCommentThread\n          key={parent.id}\n          post={post}\n          parentComment={parent}\n          threadComments={sortBy(\n            commentsByParentId[parent.id] ?? [],\n            (c) => c.createdTime\n          )}\n          commentsByUserId={commentsByUserId}\n        />\n      ))}\n    </Col>\n  )\n}\n\nexport function PostCommentThread(props: {\n  post: TopLevelPost\n  threadComments: PostComment[]\n  parentComment: PostComment\n  commentsByUserId: Dictionary<PostComment[]>\n}) {\n  const { post, threadComments, parentComment } = props\n  const [showReply, setShowReply] = useState(false)\n  const [replyTo, setReplyTo] = useState<{ id: string; username: string }>()\n\n  function scrollAndOpenReplyInput(comment: PostComment) {\n    setReplyTo({ id: comment.userId, username: comment.userUsername })\n    setShowReply(true)\n  }\n\n  return (\n    <Col className=\"relative w-full items-stretch gap-3 pb-4\">\n      <span\n        className=\"bg-ink-200 absolute left-4 top-5 -ml-px h-[calc(100%-2rem)] w-0.5\"\n        aria-hidden=\"true\"\n      />\n      {[parentComment].concat(threadComments).map((comment, commentIdx) => (\n        <PostCommentItem\n          key={comment.id}\n          indent={commentIdx != 0}\n          post={post}\n          comment={comment}\n          onReplyClick={scrollAndOpenReplyInput}\n        />\n      ))}\n      {showReply && (\n        <Col className=\"-pb-2 relative ml-6\">\n          <span\n            className=\"bg-ink-200 absolute -left-1 -ml-[1px] mt-[0.8rem] h-2 w-0.5 rotate-90\"\n            aria-hidden=\"true\"\n          />\n          <PostCommentInput\n            post={post}\n            parentCommentId={parentComment.id}\n            replyToUser={replyTo}\n            onSubmitComment={() => setShowReply(false)}\n          />\n        </Col>\n      )}\n    </Col>\n  )\n}\n\nexport function PostCommentInput(props: {\n  post: TopLevelPost\n  parentCommentId?: string\n  replyToUser?: { id: string; username: string }\n  onSubmitComment?: () => void\n}) {\n  const user = useUser()\n  const privateUser = usePrivateUser()\n\n  const { post, parentCommentId, replyToUser } = props\n\n  async function onSubmitComment(editor: Editor) {\n    if (!user) {\n      track('sign in to comment')\n      await firebaseLogin()\n      return\n    }\n\n    try {\n      await api('create-post-comment', {\n        postId: post.id,\n        content: editor.getJSON(),\n        replyToCommentId: parentCommentId,\n      })\n\n      track('post message', {\n        user,\n        surfaceId: post.id,\n        replyToCommentId: parentCommentId,\n      })\n\n      props.onSubmitComment?.()\n    } catch (e) {\n      console.error(e)\n      if (e instanceof APIError) {\n        toast.error(e.message)\n      } else {\n        toast.error('Error submitting comment. Try again?')\n      }\n    }\n  }\n\n  return (\n    <CommentInput\n      autoFocus={false}\n      replyToUserInfo={replyToUser}\n      parentCommentId={parentCommentId}\n      onSubmitComment={onSubmitComment}\n      pageId={post.id}\n      blocked={isBlocked(privateUser, post.creatorId)}\n      commentTypes={['top-level-post']}\n    />\n  )\n}\n\nexport function PostCommentItem(props: {\n  post: TopLevelPost\n  comment: PostComment\n  indent?: boolean\n  probAtCreatedTime?: number\n  onReplyClick?: (comment: PostComment) => void\n}) {\n  const { post, comment, indent, onReplyClick } = props\n  const { userId, userUsername, userName, userAvatarUrl, createdTime } = comment\n  const user = useUser()\n  const isAdminOrMod = useAdminOrMod()\n  const commentRef = useRef<HTMLDivElement>(null)\n  const [highlighted, setHighlighted] = useState(false)\n  const router = useRouter()\n  const [optimisticallyHidden, setOptimisticallyHidden] = useState(\n    comment.hidden ?? false\n  )\n  useEffect(() => {\n    if (router.asPath.endsWith(`#${comment.id}`)) {\n      setHighlighted(true)\n    }\n  }, [comment.id, router.asPath])\n\n  useEffect(() => {\n    if (highlighted && commentRef.current) {\n      scrollIntoViewCentered(commentRef.current)\n    }\n  }, [highlighted, commentRef.current?.id])\n\n  const isParent = !indent\n\n  const menuItems: DropdownItem[] = buildArray(\n    {\n      name: 'Copy Link',\n      icon: <LinkIcon className=\"h-5 w-5\" />,\n      onClick: () => {\n        copyToClipboard(\n          getPostCommentShareUrl(post, comment.id, user?.username)\n        )\n        toast.success('Link copied to clipboard')\n      },\n    },\n    isAdminOrMod && {\n      name: optimisticallyHidden ? 'Unhide comment' : 'Hide comment',\n      icon: optimisticallyHidden ? (\n        <EyeIcon className=\"h-5 w-5\" />\n      ) : (\n        <EyeOffIcon className=\"h-5 w-5\" />\n      ),\n      onClick: async () => {\n        const currentlyHidden = optimisticallyHidden\n        setOptimisticallyHidden(!currentlyHidden)\n        try {\n          await api('update-post-comment', {\n            commentId: comment.id,\n            postId: post.id,\n            hidden: !currentlyHidden,\n          })\n          toast.success(\n            !currentlyHidden ? 'Comment hidden' : 'Comment unhidden'\n          )\n        } catch (e) {\n          setOptimisticallyHidden(currentlyHidden)\n          toast.error('Error hiding/unhiding comment')\n          console.error(e)\n        }\n      },\n    }\n  )\n\n  return (\n    <Col id={comment.id} ref={commentRef} className=\"group\">\n      <Row className={clsx(isParent ? 'gap-2' : 'gap-1')}>\n        <Row className=\"relative\">\n          {!isParent && (\n            <div\n              className={clsx(\n                roundThreadColor,\n                '-mt-4 ml-4 h-6 w-4 rounded-bl-xl border-b-2 border-l'\n              )}\n            />\n          )}\n          <UserHovercard userId={userId} className=\"z-10 self-start\">\n            <Avatar\n              username={userUsername}\n              size={isParent ? 'sm' : '2xs'}\n              avatarUrl={userAvatarUrl}\n            />\n          </UserHovercard>\n        </Row>\n        <Col\n          className={clsx(\n            'grow rounded-lg rounded-tl-none px-3 pb-0.5 pt-1 transition-colors',\n            highlighted\n              ? 'bg-primary-100 border-primary-300 border-2'\n              : 'bg-canvas-50'\n          )}\n        >\n          <div className=\"text-ink-500 mt-0.5 flex items-center justify-between text-xs sm:text-sm\">\n            <Row className=\"gap-1\">\n              <UserLink\n                user={{\n                  id: userId,\n                  name: userName,\n                  username: userUsername,\n                }}\n              />\n            </Row>\n            <CopyLinkDateTimeComponent\n              prefix={'post'}\n              slug={post.slug}\n              createdTime={createdTime}\n              elementId={comment.id}\n            />\n            <DropdownMenu\n              items={menuItems}\n              buttonContent={<DotsHorizontalIcon className=\"h-5 w-5\" />}\n              menuWidth=\"w-40\"\n              buttonClass=\"px-1 py-0\"\n              className=\"ml-auto self-start\"\n            />\n          </div>\n          <HideableContent\n            comment={comment}\n            optimisticallyHidden={optimisticallyHidden}\n          />\n          <Row className=\"text-ink-500 mt-2 w-full items-center justify-end gap-1 text-xs\">\n            <ReactButton\n              contentId={comment.id}\n              contentCreatorId={comment.userId}\n              user={user}\n              contentType={'comment'}\n              reactionType={'like'}\n              contentText={`comment by ${comment.userName}`}\n              trackingLocation={'post comment item'}\n              size={'xs'}\n              className={'text-gray-500'}\n              postId={post.id}\n            />\n            {onReplyClick && (\n              <Tooltip text=\"Reply\" placement=\"bottom\">\n                <IconButton\n                  size=\"xs\"\n                  onClick={() => onReplyClick(comment)}\n                  className=\"hover:text-primary-700\"\n                >\n                  <ReplyIcon className=\"h-5 w-5\" />\n                </IconButton>\n              </Tooltip>\n            )}\n          </Row>\n        </Col>\n      </Row>\n    </Col>\n  )\n}\n\nfunction HideableContent(props: {\n  comment: PostComment\n  optimisticallyHidden?: boolean\n}) {\n  const { comment, optimisticallyHidden } = props\n  const { text, content } = comment\n  //hides if enough dislikes\n  const dislikes = comment.dislikes ?? 0\n  const likes = comment.likes ?? 0\n  const majorityDislikes = dislikes > 10 && dislikes / (likes + dislikes) >= 0.8\n\n  const hidden = optimisticallyHidden ?? comment.hidden\n  const initiallyHidden = majorityDislikes || hidden\n  const [showHidden, setShowHidden] = useState(false)\n\n  return initiallyHidden && !showHidden ? (\n    <div\n      className=\"hover text-ink-600 text-sm font-thin italic hover:cursor-pointer\"\n      onClick={() => {\n        setShowHidden(!showHidden)\n      }}\n    >\n      Comment hidden\n    </div>\n  ) : (\n    <Content size=\"sm\" className=\"mt-1 grow\" content={content || text} />\n  )\n}\n\nexport const useNewPostComments = (postId: string) => {\n  const [comments, setComments] = useState<PostComment[]>([])\n\n  useApiSubscription({\n    topics: [`post/${postId}/new-comment`],\n    onBroadcast: (data) =>\n      setComments((c) => [...c, data.data.comment as PostComment]),\n  })\n\n  return { comments }\n}\n\nexport const usePostComments = (postId: string, afterTime?: string) => {\n  const [comments, setComments] = useState<PostComment[]>([])\n\n  useEffect(() => {\n    getCommentsOnPost(postId, afterTime).then((comments) => {\n      setComments(comments)\n    })\n  }, [postId, afterTime])\n\n  return { comments }\n}\n",
          "postContent": "import { Editor } from '@tiptap/core'\nimport clsx from 'clsx'\nimport { track } from 'web/lib/service/analytics'\nimport { PostComment } from 'common/comment'\nimport { getPostCommentShareUrl, TopLevelPost } from 'common/top-level-post'\nimport { Dictionary, groupBy, sortBy } from 'lodash'\nimport { useRouter } from 'next/router'\nimport { useEffect, useRef, useState } from 'react'\nimport { Avatar } from 'web/components/widgets/avatar'\nimport {\n  CommentInput,\n  CommentInputTextArea,\n} from 'web/components/comments/comment-input'\nimport { Content } from 'web/components/widgets/editor'\nimport { CopyLinkDateTimeComponent } from 'web/components/feed/copy-link-date-time'\nimport { Col } from 'web/components/layout/col'\nimport { Row } from 'web/components/layout/row'\nimport { UserLink } from 'web/components/widgets/user-link'\nimport { isBlocked, usePrivateUser, useUser } from 'web/hooks/use-user'\nimport { firebaseLogin } from 'web/lib/firebase/users'\nimport { scrollIntoViewCentered } from 'web/lib/util/scroll'\nimport { toast } from 'react-hot-toast'\nimport { APIError } from 'common/api/utils'\nimport { api } from 'web/lib/api/api'\nimport { useApiSubscription } from 'client-common/hooks/use-api-subscription'\nimport { getCommentsOnPost } from 'web/lib/supabase/comments'\nimport { UserHovercard } from 'web/components/user/user-hovercard'\nimport {\n  ReplyIcon,\n  DotsHorizontalIcon,\n  EyeOffIcon,\n  LinkIcon,\n  EyeIcon,\n  PencilIcon,\n} from '@heroicons/react/outline'\nimport DropdownMenu, {\n  DropdownItem,\n} from 'web/components/widgets/dropdown-menu'\nimport { IconButton } from 'web/components/buttons/button'\nimport { Tooltip } from 'web/components/widgets/tooltip'\nimport { copyToClipboard } from 'web/lib/util/copy'\nimport { buildArray } from 'common/util/array'\nimport { useAdminOrMod } from 'web/hooks/use-admin'\nimport { ReactButton } from 'web/components/contract/react-button'\nimport { JSONContent } from '@tiptap/core'\nimport { Modal } from 'web/components/layout/modal'\nimport { Title } from 'web/components/widgets/title'\nimport { useTextEditor } from 'web/components/widgets/editor'\nimport { MAX_COMMENT_LENGTH } from 'common/comment'\nimport { safeLocalStorage } from 'web/lib/util/local'\nimport { User } from 'common/user'\n\nconst roundThreadColor = 'border-ink-100 dark:border-ink-200'\n\nexport function PostCommentsActivity(props: {\n  post: TopLevelPost\n  comments: PostComment[]\n}) {\n  const { post, comments } = props\n  const commentsByUserId = groupBy(comments, (c) => c.userId)\n  const commentsByParentId = groupBy(comments, (c) => c.replyToCommentId ?? '_')\n  const topLevelComments = sortBy(\n    commentsByParentId['_'] ?? [],\n    (c) => -c.createdTime\n  )\n\n  return (\n    <Col>\n      <PostCommentInput post={post} />\n      {topLevelComments.map((parent) => (\n        <PostCommentThread\n          key={parent.id}\n          post={post}\n          parentComment={parent}\n          threadComments={sortBy(\n            commentsByParentId[parent.id] ?? [],\n            (c) => c.createdTime\n          )}\n          commentsByUserId={commentsByUserId}\n        />\n      ))}\n    </Col>\n  )\n}\n\nexport function PostCommentThread(props: {\n  post: TopLevelPost\n  threadComments: PostComment[]\n  parentComment: PostComment\n  commentsByUserId: Dictionary<PostComment[]>\n}) {\n  const { post, threadComments, parentComment } = props\n  const [showReply, setShowReply] = useState(false)\n  const [replyTo, setReplyTo] = useState<{ id: string; username: string }>()\n\n  function scrollAndOpenReplyInput(comment: PostComment) {\n    setReplyTo({ id: comment.userId, username: comment.userUsername })\n    setShowReply(true)\n  }\n\n  return (\n    <Col className=\"relative w-full items-stretch gap-3 pb-4\">\n      <span\n        className=\"bg-ink-200 absolute left-4 top-5 -ml-px h-[calc(100%-2rem)] w-0.5\"\n        aria-hidden=\"true\"\n      />\n      {[parentComment].concat(threadComments).map((comment, commentIdx) => (\n        <PostCommentItem\n          key={comment.id}\n          indent={commentIdx != 0}\n          post={post}\n          comment={comment}\n          onReplyClick={scrollAndOpenReplyInput}\n        />\n      ))}\n      {showReply && (\n        <Col className=\"-pb-2 relative ml-6\">\n          <span\n            className=\"bg-ink-200 absolute -left-1 -ml-[1px] mt-[0.8rem] h-2 w-0.5 rotate-90\"\n            aria-hidden=\"true\"\n          />\n          <PostCommentInput\n            post={post}\n            parentCommentId={parentComment.id}\n            replyToUser={replyTo}\n            onSubmitComment={() => setShowReply(false)}\n          />\n        </Col>\n      )}\n    </Col>\n  )\n}\n\nexport function PostCommentInput(props: {\n  post: TopLevelPost\n  parentCommentId?: string\n  replyToUser?: { id: string; username: string }\n  onSubmitComment?: () => void\n}) {\n  const user = useUser()\n  const privateUser = usePrivateUser()\n\n  const { post, parentCommentId, replyToUser } = props\n\n  async function onSubmitComment(editor: Editor) {\n    if (!user) {\n      track('sign in to comment')\n      await firebaseLogin()\n      return\n    }\n\n    try {\n      await api('create-post-comment', {\n        postId: post.id,\n        content: editor.getJSON(),\n        replyToCommentId: parentCommentId,\n      })\n\n      track('post message', {\n        user,\n        surfaceId: post.id,\n        replyToCommentId: parentCommentId,\n      })\n\n      props.onSubmitComment?.()\n    } catch (e) {\n      console.error(e)\n      if (e instanceof APIError) {\n        toast.error(e.message)\n      } else {\n        toast.error('Error submitting comment. Try again?')\n      }\n    }\n  }\n\n  return (\n    <CommentInput\n      autoFocus={false}\n      replyToUserInfo={replyToUser}\n      parentCommentId={parentCommentId}\n      onSubmitComment={onSubmitComment}\n      pageId={post.id}\n      blocked={isBlocked(privateUser, post.creatorId)}\n      commentTypes={['top-level-post']}\n    />\n  )\n}\n\nexport function PostCommentItem(props: {\n  post: TopLevelPost\n  comment: PostComment\n  indent?: boolean\n  probAtCreatedTime?: number\n  onReplyClick?: (comment: PostComment) => void\n}) {\n  const { post, comment, indent, onReplyClick } = props\n  const { userId, userUsername, userName, userAvatarUrl, createdTime } = comment\n  const user = useUser()\n  const isAdminOrMod = useAdminOrMod()\n  const commentRef = useRef<HTMLDivElement>(null)\n  const [highlighted, setHighlighted] = useState(false)\n  const router = useRouter()\n  const [optimisticallyHidden, setOptimisticallyHidden] = useState(\n    comment.hidden ?? false\n  )\n  const [isEditing, setIsEditing] = useState(false)\n  const [commentState, setCommentState] = useState(comment)\n\n  useEffect(() => {\n    if (router.asPath.endsWith(`#${comment.id}`)) {\n      setHighlighted(true)\n    }\n  }, [comment.id, router.asPath])\n\n  useEffect(() => {\n    if (highlighted && commentRef.current) {\n      scrollIntoViewCentered(commentRef.current)\n    }\n  }, [highlighted, commentRef.current?.id])\n\n  const isParent = !indent\n\n  const setContent = (content: JSONContent) => {\n    setCommentState((prevState) => ({ ...prevState, content }))\n  }\n\n  const isCreator = user?.id === userId\n  const canEdit = isCreator || isAdminOrMod\n\n  const menuItems: DropdownItem[] = buildArray(\n    canEdit && {\n      name: 'Edit',\n      icon: <PencilIcon className=\"h-5 w-5\" />,\n      onClick: () => setIsEditing(true),\n    },\n    {\n      name: 'Copy Link',\n      icon: <LinkIcon className=\"h-5 w-5\" />,\n      onClick: () => {\n        copyToClipboard(\n          getPostCommentShareUrl(post, comment.id, user?.username)\n        )\n        toast.success('Link copied to clipboard')\n      },\n    },\n    isAdminOrMod && {\n      name: optimisticallyHidden ? 'Unhide comment' : 'Hide comment',\n      icon: optimisticallyHidden ? (\n        <EyeIcon className=\"h-5 w-5\" />\n      ) : (\n        <EyeOffIcon className=\"h-5 w-5\" />\n      ),\n      onClick: async () => {\n        const currentlyHidden = optimisticallyHidden\n        setOptimisticallyHidden(!currentlyHidden)\n        try {\n          await api('update-post-comment', {\n            commentId: comment.id,\n            postId: post.id,\n            hidden: !currentlyHidden,\n          })\n          toast.success(\n            !currentlyHidden ? 'Comment hidden' : 'Comment unhidden'\n          )\n        } catch (e) {\n          setOptimisticallyHidden(currentlyHidden)\n          toast.error('Error hiding/unhiding comment')\n          console.error(e)\n        }\n      },\n    }\n  )\n\n  return (\n    <Col id={comment.id} ref={commentRef} className=\"group\">\n      <Row className={clsx(isParent ? 'gap-2' : 'gap-1')}>\n        <Row className=\"relative\">\n          {!isParent && (\n            <div\n              className={clsx(\n                roundThreadColor,\n                '-mt-4 ml-4 h-6 w-4 rounded-bl-xl border-b-2 border-l'\n              )}\n            />\n          )}\n          <UserHovercard userId={userId} className=\"z-10 self-start\">\n            <Avatar\n              username={userUsername}\n              size={isParent ? 'sm' : '2xs'}\n              avatarUrl={userAvatarUrl}\n            />\n          </UserHovercard>\n        </Row>\n        <Col\n          className={clsx(\n            'grow rounded-lg rounded-tl-none px-3 pb-0.5 pt-1 transition-colors',\n            highlighted\n              ? 'bg-primary-100 border-primary-300 border-2'\n              : 'bg-canvas-50'\n          )}\n        >\n          <div className=\"text-ink-500 mt-0.5 flex items-center justify-between text-xs sm:text-sm\">\n            <Row className=\"gap-1\">\n              <UserLink\n                user={{\n                  id: userId,\n                  name: userName,\n                  username: userUsername,\n                }}\n              />\n            </Row>\n            {comment.editedTime && (\n              <span className=\"ml-1 pt-0.5 text-xs\"> (edited)</span>\n            )}\n            <CopyLinkDateTimeComponent\n              prefix={'post'}\n              slug={post.slug}\n              createdTime={comment.editedTime ?? createdTime}\n              elementId={comment.id}\n            />\n\n            <DropdownMenu\n              items={menuItems}\n              buttonContent={<DotsHorizontalIcon className=\"h-5 w-5\" />}\n              menuWidth=\"w-40\"\n              buttonClass=\"px-1 py-0\"\n              className=\"ml-auto self-start\"\n            />\n          </div>\n          <HideableContent\n            comment={commentState}\n            optimisticallyHidden={optimisticallyHidden}\n          />\n          <Row className=\"text-ink-500 mt-2 w-full items-center justify-end gap-1 text-xs\">\n            <ReactButton\n              contentId={comment.id}\n              contentCreatorId={comment.userId}\n              user={user}\n              contentType={'comment'}\n              reactionType={'like'}\n              contentText={`comment by ${comment.userName}`}\n              trackingLocation={'post comment item'}\n              size={'xs'}\n              className={'text-gray-500'}\n              postId={post.id}\n            />\n            {onReplyClick && (\n              <Tooltip text=\"Reply\" placement=\"bottom\">\n                <IconButton\n                  size=\"xs\"\n                  onClick={() => onReplyClick(comment)}\n                  className=\"hover:text-primary-700\"\n                >\n                  <ReplyIcon className=\"h-5 w-5\" />\n                </IconButton>\n              </Tooltip>\n            )}\n          </Row>\n        </Col>\n      </Row>\n      {isEditing && (\n        <EditPostCommentModal\n          comment={commentState}\n          setContent={setContent}\n          post={post}\n          open={isEditing}\n          setOpen={setIsEditing}\n          user={user}\n        />\n      )}\n    </Col>\n  )\n}\n\nfunction HideableContent(props: {\n  comment: PostComment\n  optimisticallyHidden?: boolean\n}) {\n  const { comment, optimisticallyHidden } = props\n  const { content } = comment\n  const dislikes = comment.dislikes ?? 0\n  const likes = comment.likes ?? 0\n  const majorityDislikes = dislikes > 10 && dislikes / (likes + dislikes) >= 0.8\n\n  const hidden = optimisticallyHidden ?? comment.hidden\n  const initiallyHidden = majorityDislikes || hidden\n  const [showHidden, setShowHidden] = useState(false)\n\n  return initiallyHidden && !showHidden ? (\n    <div\n      className=\"hover text-ink-600 text-sm font-thin italic hover:cursor-pointer\"\n      onClick={() => {\n        setShowHidden(!showHidden)\n      }}\n    >\n      Comment hidden\n    </div>\n  ) : (\n    <Content size=\"sm\" className=\"mt-1 grow\" content={content} />\n  )\n}\n\nexport const useNewPostComments = (postId: string) => {\n  const [comments, setComments] = useState<PostComment[]>([])\n\n  useApiSubscription({\n    topics: [`post/${postId}/new-comment`],\n    onBroadcast: (data) =>\n      setComments((c) => [...c, data.data.comment as PostComment]),\n  })\n\n  return { comments }\n}\n\nexport const usePostComments = (postId: string, afterTime?: string) => {\n  const [comments, setComments] = useState<PostComment[]>([])\n\n  useEffect(() => {\n    getCommentsOnPost(postId, afterTime).then((comments) => {\n      setComments(comments)\n    })\n  }, [postId, afterTime])\n\n  return { comments }\n}\n\nfunction EditPostCommentModal(props: {\n  comment: PostComment\n  setContent: (content: JSONContent) => void\n  post: TopLevelPost\n  open: boolean\n  setOpen: (open: boolean) => void\n  user: User | null | undefined\n}) {\n  const key = `edit post comment ${props.comment.id}`\n  const { comment, user, post, setContent, open, setOpen } = props\n  const [isSubmitting, setIsSubmitting] = useState(false)\n\n  const editor = useTextEditor({\n    key,\n    size: 'sm',\n    max: MAX_COMMENT_LENGTH,\n    defaultValue: comment.content,\n    placeholder: 'Edit your comment',\n  })\n\n  useEffect(() => {\n    if (open) {\n      editor?.commands.focus('end')\n    }\n  }, [editor, open])\n\n  const submitComment = async () => {\n    if (!editor || editor.isEmpty || isSubmitting || !user) return\n    setIsSubmitting(true)\n    editor.commands.focus('end')\n    if (editor.state.selection.empty) {\n      editor.commands.insertContent(' ')\n      const endPos = editor.state.selection.from\n      editor.commands.deleteRange({ from: endPos - 1, to: endPos })\n    }\n\n    const newContent = editor.getJSON()\n\n    try {\n      await api('edit-post-comment', {\n        commentId: comment.id,\n        postId: post.id,\n        content: newContent,\n      })\n      setContent(newContent)\n      setIsSubmitting(false)\n      editor.commands.clearContent(true)\n      safeLocalStorage?.removeItem(`text ${key}`)\n      setOpen(false)\n      toast.success('Comment updated!')\n    } catch (e) {\n      console.error('Error editing comment', e)\n      toast.error('Failed to edit comment. Please try again.')\n      setIsSubmitting(false)\n    }\n  }\n\n  return (\n    <Modal open={open} setOpen={setOpen}>\n      <Col className={'bg-canvas-50 rounded-md p-4'}>\n        <Title>Edit Comment</Title>\n        <CommentInputTextArea\n          autoFocus={true}\n          editor={editor}\n          user={user}\n          submit={submitComment}\n          isSubmitting={isSubmitting}\n          submitOnEnter={true}\n        />\n      </Col>\n    </Modal>\n  )\n}\n"
        }
      ]
    },
    {
      "sha": "ebabf7796a92ce8ece8e2452b0f3f896a513ba0e",
      "author": "Ian Philips",
      "date": "2025-05-12 16:26:28 -0700",
      "message": "Add follow post button",
      "stats": {
        "filesChanged": 12,
        "insertions": 319,
        "deletions": 58
      },
      "selectionReason": "Implements post following functionality - adds a complete feature with UI, backend logic, and user engagement tracking",
      "spec": "Implement an API endpoint to enable users to follow or unfollow specific posts, accepting a post identifier and a follow state. Establish a backend mechanism to store and manage these user-post follow relationships. Introduce a notification system where users following a post are alerted to new comments, including a new user-configurable notification preference for \"comments on posts you follow.\" Integrate a \"Follow Post\" button (and an icon button variant) on post display pages, with its state reflecting the current user's follow status and triggering the API on interaction. Modify the existing 'Like' button component to support custom color schemes and child content, applying these changes to the 'Like' button on post pages. Finally, relocate the internal function for generating notifications when a user follows a market to be within the same module as the market-following API handler.",
      "fileStates": [
        {
          "path": "backend/api/src/follow-contract.ts",
          "preContent": "import {\n  createSupabaseDirectClient,\n  SupabaseDirectClient,\n} from 'shared/supabase/init'\nimport { APIHandler } from './helpers/endpoint'\nimport { broadcast } from 'shared/websockets/server'\nimport { createFollowsOnYourMarketNotification } from 'shared/create-notification'\nimport { getUser, log } from 'shared/utils'\n\nexport const followContract: APIHandler<'follow-contract'> = async (\n  { contractId, follow },\n  auth\n) => {\n  const pg = createSupabaseDirectClient()\n  await followContractInternal(pg, contractId, follow, auth.uid)\n  broadcast(`contract-follow/${contractId}`, {\n    follow,\n    followerId: auth.uid,\n  })\n\n  return {\n    result: { success: true },\n    continue: async () => {\n      if (!follow) return\n      try {\n        const follower = await getUser(auth.uid)\n        if (follower) {\n          await createFollowsOnYourMarketNotification(contractId, follower, pg)\n        }\n      } catch (error) {\n        log.error('Failed to create follow notification:', { error })\n      }\n    },\n  }\n}\nexport const followContractInternal = async (\n  pg: SupabaseDirectClient,\n  contractId: string,\n  follow: boolean,\n  followerId: string\n) => {\n  if (follow) {\n    await pg.none(\n      `insert into contract_follows (contract_id, follow_id)\n       values ($1, $2)\n       on conflict (contract_id, follow_id) do nothing`,\n      [contractId, followerId]\n    )\n  } else {\n    await pg.none(\n      `delete from contract_follows\n       where contract_id = $1 and follow_id = $2`,\n      [contractId, followerId]\n    )\n  }\n}\n",
          "postContent": "import {\n  createSupabaseDirectClient,\n  SupabaseDirectClient,\n} from 'shared/supabase/init'\nimport { APIHandler } from './helpers/endpoint'\nimport { broadcast } from 'shared/websockets/server'\nimport { getContract, getPrivateUser, getUser, log } from 'shared/utils'\nimport { getNotificationDestinationsForUser } from 'common/user-notification-preferences'\nimport { userIsBlocked } from 'common/user-notification-preferences'\nimport { User } from 'common/user'\nimport { insertNotificationToSupabase } from 'shared/supabase/notifications'\nimport { Notification } from 'common/notification'\n\nexport const followContract: APIHandler<'follow-contract'> = async (\n  { contractId, follow },\n  auth\n) => {\n  const pg = createSupabaseDirectClient()\n  await followContractInternal(pg, contractId, follow, auth.uid)\n  broadcast(`contract-follow/${contractId}`, {\n    follow,\n    followerId: auth.uid,\n  })\n\n  return {\n    result: { success: true },\n    continue: async () => {\n      if (!follow) return\n      try {\n        const follower = await getUser(auth.uid)\n        if (follower) {\n          await createFollowsOnYourMarketNotification(contractId, follower, pg)\n        }\n      } catch (error) {\n        log.error('Failed to create follow notification:', { error })\n      }\n    },\n  }\n}\nexport const followContractInternal = async (\n  pg: SupabaseDirectClient,\n  contractId: string,\n  follow: boolean,\n  followerId: string\n) => {\n  if (follow) {\n    await pg.none(\n      `insert into contract_follows (contract_id, follow_id)\n       values ($1, $2)\n       on conflict (contract_id, follow_id) do nothing`,\n      [contractId, followerId]\n    )\n  } else {\n    await pg.none(\n      `delete from contract_follows\n       where contract_id = $1 and follow_id = $2`,\n      [contractId, followerId]\n    )\n  }\n}\n\nconst createFollowsOnYourMarketNotification = async (\n  contractId: string,\n  followerUser: User,\n  pg: SupabaseDirectClient\n) => {\n  const contract = await getContract(pg, contractId)\n  if (!contract) return\n\n  // Don't notify if follower is the creator\n  if (followerUser.id === contract.creatorId) return\n\n  const creatorId = contract.creatorId\n  const privateUser = await getPrivateUser(creatorId)\n  if (!privateUser) return\n  if (userIsBlocked(privateUser, followerUser.id)) return\n\n  const { sendToBrowser } = getNotificationDestinationsForUser(\n    privateUser,\n    'market_follows'\n  )\n\n  if (sendToBrowser) {\n    const notification: Notification = {\n      id: `${followerUser.id}-follows-${contractId}}`,\n      userId: creatorId,\n      reason: 'market_follows',\n      createdTime: Date.now(),\n      isSeen: false,\n      sourceId: followerUser.id,\n      sourceType: 'follow',\n      sourceUpdateType: 'created',\n      sourceContractId: contractId,\n      sourceUserName: followerUser.name,\n      sourceUserUsername: followerUser.username,\n      sourceUserAvatarUrl: followerUser.avatarUrl,\n      sourceText: '',\n      sourceContractCreatorUsername: contract.creatorUsername,\n      sourceContractTitle: contract.question,\n      sourceContractSlug: contract.slug,\n      sourceSlug: contract.slug,\n      sourceTitle: contract.question,\n    }\n\n    await insertNotificationToSupabase(notification, pg)\n  }\n}\n"
        },
        {
          "path": "backend/api/src/follow-post.ts",
          "preContent": "[NEW FILE]",
          "postContent": "import { APIError, APIHandler } from './helpers/endpoint'\nimport { createSupabaseDirectClient } from 'shared/supabase/init'\nimport { log } from 'shared/monitoring/log'\n\nexport const followPost: APIHandler<'follow-post'> = async (props, auth) => {\n  const { postId, follow } = props\n  const userId = auth.uid\n\n  const pg = createSupabaseDirectClient()\n\n  try {\n    if (follow) {\n      // Add a new follow relationship\n      await pg.none(\n        'INSERT INTO post_follows (post_id, user_id) VALUES ($1, $2) ON CONFLICT (post_id, user_id) DO NOTHING',\n        [postId, userId]\n      )\n    } else {\n      // Remove the follow relationship\n      await pg.none(\n        'DELETE FROM post_follows WHERE post_id = $1 AND user_id = $2',\n        [postId, userId]\n      )\n    }\n\n    // We could potentially broadcast this change via websockets if live updates on the button are needed immediately for other users viewing the same post.\n    // For now, the button's local state handles the immediate feedback for the acting user.\n\n    return { success: true }\n  } catch (error) {\n    log.error('Failed to update post follow status', {\n      error,\n      postId,\n      userId,\n      follow,\n    })\n    throw new APIError(500, 'Failed to update post follow status')\n  }\n}\n"
        },
        {
          "path": "backend/api/src/routes.ts",
          "preContent": "import { updateMe } from './update-me'\nimport { placeBet } from './place-bet'\nimport { cancelBet } from './cancel-bet'\nimport { sellShares } from './sell-shares'\nimport { createMarket } from './create-market'\nimport { createComment } from './create-comment'\nimport { resolveMarket } from './resolve-market'\nimport { closeMarket } from './close-market'\nimport { getMe } from './get-me'\nimport { saveTwitchCredentials } from './save-twitch-credentials'\nimport { addLiquidity } from './add-liquidity'\nimport { removeLiquidity } from './remove-liquidity'\nimport { searchGroups, searchMyGroups } from './search-groups'\nimport { awardBounty } from './award-bounty'\nimport { addBounty } from './add-bounty'\nimport { createAnswerCPMM } from './create-answer-cpmm'\nimport { managram } from './managram'\nimport { setnews } from './set-news'\nimport { getDashboardFromSlug } from './get-dashboard-from-slug'\nimport { unresolve } from './unresolve'\nimport { updateMarket } from 'api/update-market'\nimport { getCompatibleLovers } from './love/compatible-lovers'\nimport { type APIPath } from 'common/api/schema'\nimport { getMarkets } from 'api/markets'\nimport { hideComment } from './hide-comment'\nimport { pinComment } from './pin-comment'\nimport { getManagrams } from './get-managrams'\nimport { getGroups } from './get-groups'\nimport { getComments } from './get-comments'\nimport { getBetPointsBetween, getBets } from './get-bets'\nimport { getLiteUser, getUser } from './get-user'\nimport { getUsers } from './get-users'\nimport { getUserBalancesByIds, getUsersByIds } from './get-users-by-ids'\nimport { getMarket } from './get-market'\nimport { getMarketProb } from './get-market-prob'\nimport { getMarketProbs } from './get-market-probs'\nimport { getGroup } from './get-group'\nimport { getPositions } from './get-positions'\nimport { getLeagues } from './get-leagues'\nimport { getContract } from './get-contract'\nimport { getSingleAnswer } from './get-answer'\nimport { getContractAnswers } from './get-contract-answers'\nimport { addOrRemoveTopicFromContract } from './add-topic-to-market'\nimport { addOrRemoveTopicFromTopic } from './add-topic-to-topic'\nimport { searchUsers } from './search-users'\nimport { searchMarketsLite, searchMarketsFull } from './search-contracts'\nimport { post } from 'api/post'\nimport { fetchLinkPreview } from './fetch-link-preview'\nimport { type APIHandler } from './helpers/endpoint'\nimport { requestLoan } from 'api/request-loan'\nimport { removePinnedPhoto } from './love/remove-pinned-photo'\nimport { getHeadlines, getPoliticsHeadlines } from './get-headlines'\nimport { getBoostAnalytics } from 'api/get-boost-analytics'\nimport { getCompatibilityQuestions } from './love/get-compatibililty-questions'\nimport { addOrRemoveReaction } from './reaction'\nimport { likeLover } from './love/like-lover'\nimport { shipLovers } from './love/ship-lovers'\nimport { createManalink } from './create-manalink'\nimport { getLikesAndShips } from './love/get-likes-and-ships'\nimport { hasFreeLike } from './love/has-free-like'\nimport { starLover } from './love/star-lover'\nimport { getLovers } from './love/get-lovers'\nimport { unlistAndCancelUserContracts } from './unlist-and-cancel-user-contracts'\nimport { getGroupsWithTopContracts } from 'api/get-topics-with-markets'\nimport { getBalanceChanges } from 'api/get-balance-changes'\nimport { getLoverAnswers } from './love/get-lover-answers'\nimport { placeMultiBet } from 'api/place-multi-bet'\nimport { getPartnerStats } from './get-partner-stats'\nimport { getSeenMarketIds } from 'api/get-seen-market-ids'\nimport { recordContractView } from 'api/record-contract-view'\nimport { createPublicChatMessage } from 'api/create-public-chat-message'\nimport { getFollowedGroups } from './get-followed-groups'\nimport { getUniqueBetGroupCount } from 'api/get-unique-bet-groups'\nimport { deleteGroup } from './delete-group'\nimport { recordContractInteraction } from 'api/record-contract-interaction'\nimport { getUserPortfolio } from './get-user-portfolio'\nimport { createuser } from 'api/create-user'\nimport { verifyPhoneNumber } from 'api/verify-phone-number'\nimport { requestOTP } from 'api/request-phone-otp'\nimport { multiSell } from 'api/multi-sell'\nimport { convertCashToMana } from './convert-cash-to-mana'\nimport { convertSpiceToMana } from './convert-sp-to-mana'\nimport { donate } from './donate'\nimport { getFeed } from 'api/get-feed'\nimport { getManaSupply } from './get-mana-supply'\nimport { getUserPortfolioHistory } from './get-user-portfolio-history'\nimport { deleteMe } from './delete-me'\nimport { updateModReport } from './update-mod-report'\nimport { getModReports } from './get-mod-reports'\nimport { searchContractPositions } from 'api/search-contract-positions'\nimport { blockUser, unblockUser } from './block-user'\nimport { blockGroup, unblockGroup } from './block-group'\nimport { blockMarket, unblockMarket } from './block-market'\nimport { getTxnSummaryStats } from 'api/get-txn-summary-stats'\nimport { getManaSummaryStats } from 'api/get-mana-summary-stats'\nimport { register } from 'api/gidx/register'\nimport { uploadDocument } from 'api/gidx/upload-document'\nimport { identityCallbackGIDX, paymentCallbackGIDX } from 'api/gidx/callback'\nimport { getVerificationStatus } from 'api/gidx/get-verification-status'\nimport { getCurrentPrivateUser } from './get-current-private-user'\nimport { updatePrivateUser } from './update-private-user'\nimport { setPushToken } from './push-token'\nimport { updateNotifSettings } from './update-notif-settings'\nimport { getVerificationDocuments } from 'api/gidx/get-verification-documents'\nimport { getRedeemablePrizeCash } from './get-redeemable-prize-cash'\nimport { getTotalRedeemablePrizeCash } from './get-total-redeemable-prize-cash'\nimport { getMonitorStatus } from 'api/gidx/get-monitor-status'\nimport { getBestComments } from 'api/get-best-comments'\nimport { recordCommentView } from 'api/record-comment-view'\nimport {\n  getChannelMemberships,\n  getChannelMessages,\n  getLastSeenChannelTime,\n  setChannelLastSeenTime,\n} from 'api/get-private-messages'\nimport { getNotifications } from 'api/get-notifications'\nimport { getCheckoutSession } from 'api/gidx/get-checkout-session'\nimport { completeCheckoutSession } from 'api/gidx/complete-checkout-session'\nimport { getContractTopics } from './get-contract-topics'\nimport { getRelatedMarkets } from './get-related-markets'\nimport { getRelatedMarketsByGroup } from './get-related-markets-by-group'\nimport { followContract } from './follow-contract'\nimport { getUserLimitOrdersWithContracts } from 'api/get-user-limit-orders-with-contracts'\nimport { getInterestingGroupsFromViews } from 'api/get-interesting-groups-from-views'\nimport { completeCashoutSession } from 'api/gidx/complete-cashout-session'\nimport { getCashouts } from './get-cashouts'\nimport { getKYCStats } from './get-kyc-stats'\nimport { getTxns } from './get-txns'\nimport { refreshAllClients } from './refresh-all-clients'\nimport { getLeaderboard } from './get-leaderboard'\nimport { toggleSystemTradingStatus } from './toggle-system-status'\nimport { completeCashoutRequest } from './gidx/complete-cashout-request'\nimport { getDailyChangedMetricsAndContracts } from './get-daily-changed-metrics-and-contracts'\nimport { getMarketsByIds } from './get-markets'\nimport { getTopicTopics } from './get-topic-topics'\nimport { getTopicDashboards } from './get-topic-dashboards'\nimport { generateAIMarketSuggestions } from './generate-ai-market-suggestions'\nimport { generateAIDescription } from './generate-ai-description'\nimport { generateAIAnswers } from './generate-ai-answers'\nimport { getmonthlybets2024 } from './get-monthly-bets-2024'\nimport { getmaxminprofit2024 } from './get-max-min-profit-2024'\nimport { getNextLoanAmount } from './get-next-loan-amount'\nimport { checkSportsEvent } from './check-sports-event'\n\nimport { createTask } from './create-task'\nimport { updateTask } from './update-task'\nimport { createCategory } from './create-category'\nimport { getCategories } from './get-categories'\nimport { updateCategory } from './update-category'\nimport { getTasks } from './get-tasks'\n\nimport { getSiteActivity } from './get-site-activity'\nimport { isSportsInterested } from './is-sports-bettor'\nimport { getSportsGames } from './get-sports-games'\nimport { getMarketProps } from './get-market-props'\nimport { getUserContractMetricsWithContracts } from './get-user-contract-metrics-with-contracts'\nimport { validateiap } from './validate-iap'\nimport { getReactions } from './get-reactions'\nimport { markallnotificationsnew } from './mark-all-notifications-new'\nimport {\n  getContractOptionVoters,\n  getContractVoters,\n} from './get-contract-voters'\nimport { purchaseContractBoost } from './purchase-contract-boost'\nimport {\n  generateAINumericRanges,\n  regenerateNumericMidpoints,\n} from './generate-ai-numeric-ranges'\nimport {\n  generateAIDateRanges,\n  regenerateDateMidpoints,\n} from './generate-ai-date-ranges'\nimport { inferNumericUnit } from './infer-numeric-unit'\nimport { generateConciseTitle } from './generate-concise-title'\nimport { getCloseDateEndpoint } from './get-close-date'\nimport { referUser } from './refer-user'\nimport {\n  saveMarketDraft,\n  getMarketDrafts,\n  deleteMarketDraft,\n} from './market-drafts'\nimport { getSeasonInfo } from './get-season-info'\nimport { markNotificationRead } from './mark-all-notifications'\nimport { createPostComment, updatePostComment } from './create-post-comment'\nimport { createPost, updatePost } from './create-post'\nimport { getPosts } from './get-posts'\nimport { dismissUserReport } from './dismiss-user-report'\n\nexport const handlers: { [k in APIPath]: APIHandler<k> } = {\n  'refresh-all-clients': refreshAllClients,\n  bet: placeBet,\n  'multi-bet': placeMultiBet,\n  'follow-contract': followContract,\n  'bet/cancel/:betId': cancelBet,\n  'market/:contractId/sell': sellShares,\n  bets: getBets,\n  'bet-points': getBetPointsBetween,\n  'get-notifications': getNotifications,\n  'get-channel-memberships': getChannelMemberships,\n  'get-channel-messages': getChannelMessages,\n  'get-channel-seen-time': getLastSeenChannelTime,\n  'set-channel-seen-time': setChannelLastSeenTime,\n  'get-contract': getContract,\n  comment: createComment,\n  'hide-comment': hideComment,\n  'pin-comment': pinComment,\n  comments: getComments,\n  market: createMarket,\n  'market/:contractId/group': addOrRemoveTopicFromContract,\n  'market/:contractId/groups': getContractTopics,\n  'group/:slug': getGroup,\n  'group/by-id/:id': getGroup,\n  'group/by-id/:id/markets': ({ id, limit }, ...rest) =>\n    getMarkets({ groupId: id, limit }, ...rest),\n  'group/:slug/delete': deleteGroup,\n  'group/by-id/:id/delete': deleteGroup,\n  'group/:slug/block': blockGroup,\n  'group/:slug/unblock': unblockGroup,\n  'group/by-id/:topId/group/:bottomId': addOrRemoveTopicFromTopic,\n  'group/:slug/groups': getTopicTopics,\n  'group/:slug/dashboards': getTopicDashboards,\n  'group/by-id/:id/groups': getTopicTopics,\n  groups: getGroups,\n  'market/:id': getMarket,\n  'market/:id/lite': ({ id }) => getMarket({ id, lite: true }),\n  'market/:id/prob': getMarketProb,\n  'market-probs': getMarketProbs,\n  'answer/:answerId': getSingleAnswer,\n  'market/:contractId/answers': getContractAnswers,\n  'markets-by-ids': getMarketsByIds,\n  'slug/:slug': getMarket,\n  'market/:contractId/update': updateMarket,\n  'market/:contractId/close': closeMarket,\n  'market/:contractId/resolve': resolveMarket,\n  'market/:contractId/add-liquidity': addLiquidity,\n  'market/:contractId/remove-liquidity': removeLiquidity,\n  'market/:contractId/add-bounty': addBounty,\n  'market/:contractId/award-bounty': awardBounty,\n  'market/:contractId/answer': createAnswerCPMM,\n  'market/:contractId/block': blockMarket,\n  'market/:contractId/unblock': unblockMarket,\n  'get-user-limit-orders-with-contracts': getUserLimitOrdersWithContracts,\n  'get-interesting-groups-from-views': getInterestingGroupsFromViews,\n  leagues: getLeagues,\n  markets: getMarkets,\n  'search-markets': searchMarketsLite,\n  'search-markets-full': searchMarketsFull,\n  managram: managram,\n  managrams: getManagrams,\n  manalink: createManalink,\n  donate: donate,\n  'convert-cash-to-mana': convertCashToMana,\n  'convert-sp-to-mana': convertSpiceToMana,\n  'market/:id/positions': getPositions,\n  me: getMe,\n  'me/update': updateMe,\n  'me/delete': deleteMe,\n  'me/private': getCurrentPrivateUser,\n  'me/private/update': updatePrivateUser,\n  'user/by-id/:id': getUser,\n  'user/by-id/:id/lite': getLiteUser,\n  'user/:username': getUser,\n  'user/:username/lite': getLiteUser,\n  'user/:username/bets': (...props) => getBets(...props),\n  'user/by-id/:id/block': blockUser,\n  'user/by-id/:id/unblock': unblockUser,\n  users: getUsers,\n  'users/by-id': getUsersByIds,\n  'users/by-id/balance': getUserBalancesByIds,\n  'search-users': searchUsers,\n  react: addOrRemoveReaction,\n  'save-twitch': saveTwitchCredentials,\n  'set-push-token': setPushToken,\n  'update-notif-settings': updateNotifSettings,\n  headlines: getHeadlines,\n  'politics-headlines': getPoliticsHeadlines,\n  'compatible-lovers': getCompatibleLovers,\n  post: post,\n  'fetch-link-preview': fetchLinkPreview,\n  'request-loan': requestLoan,\n  'remove-pinned-photo': removePinnedPhoto,\n  'get-related-markets': getRelatedMarkets,\n  'get-related-markets-by-group': getRelatedMarketsByGroup,\n  'unlist-and-cancel-user-contracts': unlistAndCancelUserContracts,\n  'get-boost-analytics': getBoostAnalytics,\n  'get-compatibility-questions': getCompatibilityQuestions,\n  'like-lover': likeLover,\n  'ship-lovers': shipLovers,\n  'get-likes-and-ships': getLikesAndShips,\n  'has-free-like': hasFreeLike,\n  'star-lover': starLover,\n  'get-lovers': getLovers,\n  'get-lover-answers': getLoverAnswers,\n  'set-news': setnews,\n  'search-groups': searchGroups,\n  'search-my-groups': searchMyGroups,\n  'get-groups-with-top-contracts': getGroupsWithTopContracts,\n  'get-balance-changes': getBalanceChanges,\n  'get-partner-stats': getPartnerStats,\n  'get-posts': getPosts,\n  'get-seen-market-ids': getSeenMarketIds,\n  'record-contract-view': recordContractView,\n  'get-dashboard-from-slug': getDashboardFromSlug,\n  'create-public-chat-message': createPublicChatMessage,\n  unresolve: unresolve,\n  'get-followed-groups': getFollowedGroups,\n  'unique-bet-group-count': getUniqueBetGroupCount,\n  'record-contract-interaction': recordContractInteraction,\n  'get-user-portfolio': getUserPortfolio,\n  'get-user-portfolio-history': getUserPortfolioHistory,\n  createuser: createuser,\n  'verify-phone-number': verifyPhoneNumber,\n  'request-otp': requestOTP,\n  'multi-sell': multiSell,\n  'get-feed': getFeed,\n  'get-mana-supply': getManaSupply,\n  'update-mod-report': updateModReport,\n  'get-mod-reports': getModReports,\n  'search-contract-positions': searchContractPositions,\n  'get-txn-summary-stats': getTxnSummaryStats,\n  'get-mana-summary-stats': getManaSummaryStats,\n  'register-gidx': register,\n  'get-checkout-session-gidx': getCheckoutSession,\n  'complete-checkout-session-gidx': completeCheckoutSession,\n  'complete-cashout-session-gidx': completeCashoutSession,\n  'complete-cashout-request': completeCashoutRequest,\n  'get-verification-status-gidx': getVerificationStatus,\n  'upload-document-gidx': uploadDocument,\n  'identity-callback-gidx': identityCallbackGIDX,\n  'payment-callback-gidx': paymentCallbackGIDX,\n  'get-verification-documents-gidx': getVerificationDocuments,\n  'get-redeemable-prize-cash': getRedeemablePrizeCash,\n  'get-total-redeemable-prize-cash': getTotalRedeemablePrizeCash,\n  'get-monitor-status-gidx': getMonitorStatus,\n  'get-best-comments': getBestComments,\n  'record-comment-view': recordCommentView,\n  'get-cashouts': getCashouts,\n  'get-kyc-stats': getKYCStats,\n  txns: getTxns,\n  'toggle-system-trading-status': toggleSystemTradingStatus,\n  leaderboard: getLeaderboard,\n  'get-daily-changed-metrics-and-contracts': getDailyChangedMetricsAndContracts,\n  'generate-ai-market-suggestions': generateAIMarketSuggestions,\n  'generate-ai-description': generateAIDescription,\n  'generate-ai-answers': generateAIAnswers,\n  'get-monthly-bets-2024': getmonthlybets2024,\n  'get-max-min-profit-2024': getmaxminprofit2024,\n  'get-next-loan-amount': getNextLoanAmount,\n  'check-sports-event': checkSportsEvent,\n  'create-task': createTask,\n  'update-task': updateTask,\n  'create-category': createCategory,\n  'get-categories': getCategories,\n  'update-category': updateCategory,\n  'get-tasks': getTasks,\n  'get-site-activity': getSiteActivity,\n  'is-sports-interested': isSportsInterested,\n  'get-sports-games': getSportsGames,\n  'get-market-props': getMarketProps,\n  'get-user-contract-metrics-with-contracts':\n    getUserContractMetricsWithContracts,\n  validateIap: validateiap,\n  'comment-reactions': getReactions,\n  'mark-all-notifications-new': markallnotificationsnew,\n  'get-contract-voters': getContractVoters,\n  'get-contract-option-voters': getContractOptionVoters,\n  'purchase-contract-boost': purchaseContractBoost,\n  'generate-ai-numeric-ranges': generateAINumericRanges,\n  'regenerate-numeric-midpoints': regenerateNumericMidpoints,\n  'infer-numeric-unit': inferNumericUnit,\n  'generate-ai-date-ranges': generateAIDateRanges,\n  'regenerate-date-midpoints': regenerateDateMidpoints,\n  'generate-concise-title': generateConciseTitle,\n  'get-close-date': getCloseDateEndpoint,\n  'refer-user': referUser,\n  'create-post-comment': createPostComment,\n  'create-post': createPost,\n  'update-post': updatePost,\n  'update-post-comment': updatePostComment,\n  'save-market-draft': saveMarketDraft,\n  'get-market-drafts': getMarketDrafts,\n  'delete-market-draft': deleteMarketDraft,\n  'get-season-info': getSeasonInfo,\n  'mark-notification-read': markNotificationRead,\n  'dismiss-user-report': dismissUserReport,\n} as const\n",
          "postContent": "import { updateMe } from './update-me'\nimport { placeBet } from './place-bet'\nimport { cancelBet } from './cancel-bet'\nimport { sellShares } from './sell-shares'\nimport { createMarket } from './create-market'\nimport { createComment } from './create-comment'\nimport { resolveMarket } from './resolve-market'\nimport { closeMarket } from './close-market'\nimport { getMe } from './get-me'\nimport { saveTwitchCredentials } from './save-twitch-credentials'\nimport { addLiquidity } from './add-liquidity'\nimport { removeLiquidity } from './remove-liquidity'\nimport { searchGroups, searchMyGroups } from './search-groups'\nimport { awardBounty } from './award-bounty'\nimport { addBounty } from './add-bounty'\nimport { createAnswerCPMM } from './create-answer-cpmm'\nimport { managram } from './managram'\nimport { setnews } from './set-news'\nimport { getDashboardFromSlug } from './get-dashboard-from-slug'\nimport { unresolve } from './unresolve'\nimport { updateMarket } from 'api/update-market'\nimport { getCompatibleLovers } from './love/compatible-lovers'\nimport { type APIPath } from 'common/api/schema'\nimport { getMarkets } from 'api/markets'\nimport { hideComment } from './hide-comment'\nimport { pinComment } from './pin-comment'\nimport { getManagrams } from './get-managrams'\nimport { getGroups } from './get-groups'\nimport { getComments } from './get-comments'\nimport { getBetPointsBetween, getBets } from './get-bets'\nimport { getLiteUser, getUser } from './get-user'\nimport { getUsers } from './get-users'\nimport { getUserBalancesByIds, getUsersByIds } from './get-users-by-ids'\nimport { getMarket } from './get-market'\nimport { getMarketProb } from './get-market-prob'\nimport { getMarketProbs } from './get-market-probs'\nimport { getGroup } from './get-group'\nimport { getPositions } from './get-positions'\nimport { getLeagues } from './get-leagues'\nimport { getContract } from './get-contract'\nimport { getSingleAnswer } from './get-answer'\nimport { getContractAnswers } from './get-contract-answers'\nimport { addOrRemoveTopicFromContract } from './add-topic-to-market'\nimport { addOrRemoveTopicFromTopic } from './add-topic-to-topic'\nimport { searchUsers } from './search-users'\nimport { searchMarketsLite, searchMarketsFull } from './search-contracts'\nimport { post } from 'api/post'\nimport { fetchLinkPreview } from './fetch-link-preview'\nimport { type APIHandler } from './helpers/endpoint'\nimport { requestLoan } from 'api/request-loan'\nimport { removePinnedPhoto } from './love/remove-pinned-photo'\nimport { getHeadlines, getPoliticsHeadlines } from './get-headlines'\nimport { getBoostAnalytics } from 'api/get-boost-analytics'\nimport { getCompatibilityQuestions } from './love/get-compatibililty-questions'\nimport { addOrRemoveReaction } from './reaction'\nimport { likeLover } from './love/like-lover'\nimport { shipLovers } from './love/ship-lovers'\nimport { createManalink } from './create-manalink'\nimport { getLikesAndShips } from './love/get-likes-and-ships'\nimport { hasFreeLike } from './love/has-free-like'\nimport { starLover } from './love/star-lover'\nimport { getLovers } from './love/get-lovers'\nimport { unlistAndCancelUserContracts } from './unlist-and-cancel-user-contracts'\nimport { getGroupsWithTopContracts } from 'api/get-topics-with-markets'\nimport { getBalanceChanges } from 'api/get-balance-changes'\nimport { getLoverAnswers } from './love/get-lover-answers'\nimport { placeMultiBet } from 'api/place-multi-bet'\nimport { getPartnerStats } from './get-partner-stats'\nimport { getSeenMarketIds } from 'api/get-seen-market-ids'\nimport { recordContractView } from 'api/record-contract-view'\nimport { createPublicChatMessage } from 'api/create-public-chat-message'\nimport { getFollowedGroups } from './get-followed-groups'\nimport { getUniqueBetGroupCount } from 'api/get-unique-bet-groups'\nimport { deleteGroup } from './delete-group'\nimport { recordContractInteraction } from 'api/record-contract-interaction'\nimport { getUserPortfolio } from './get-user-portfolio'\nimport { createuser } from 'api/create-user'\nimport { verifyPhoneNumber } from 'api/verify-phone-number'\nimport { requestOTP } from 'api/request-phone-otp'\nimport { multiSell } from 'api/multi-sell'\nimport { convertCashToMana } from './convert-cash-to-mana'\nimport { convertSpiceToMana } from './convert-sp-to-mana'\nimport { donate } from './donate'\nimport { getFeed } from 'api/get-feed'\nimport { getManaSupply } from './get-mana-supply'\nimport { getUserPortfolioHistory } from './get-user-portfolio-history'\nimport { deleteMe } from './delete-me'\nimport { updateModReport } from './update-mod-report'\nimport { getModReports } from './get-mod-reports'\nimport { searchContractPositions } from 'api/search-contract-positions'\nimport { blockUser, unblockUser } from './block-user'\nimport { blockGroup, unblockGroup } from './block-group'\nimport { blockMarket, unblockMarket } from './block-market'\nimport { getTxnSummaryStats } from 'api/get-txn-summary-stats'\nimport { getManaSummaryStats } from 'api/get-mana-summary-stats'\nimport { register } from 'api/gidx/register'\nimport { uploadDocument } from 'api/gidx/upload-document'\nimport { identityCallbackGIDX, paymentCallbackGIDX } from 'api/gidx/callback'\nimport { getVerificationStatus } from 'api/gidx/get-verification-status'\nimport { getCurrentPrivateUser } from './get-current-private-user'\nimport { updatePrivateUser } from './update-private-user'\nimport { setPushToken } from './push-token'\nimport { updateNotifSettings } from './update-notif-settings'\nimport { getVerificationDocuments } from 'api/gidx/get-verification-documents'\nimport { getRedeemablePrizeCash } from './get-redeemable-prize-cash'\nimport { getTotalRedeemablePrizeCash } from './get-total-redeemable-prize-cash'\nimport { getMonitorStatus } from 'api/gidx/get-monitor-status'\nimport { getBestComments } from 'api/get-best-comments'\nimport { recordCommentView } from 'api/record-comment-view'\nimport {\n  getChannelMemberships,\n  getChannelMessages,\n  getLastSeenChannelTime,\n  setChannelLastSeenTime,\n} from 'api/get-private-messages'\nimport { getNotifications } from 'api/get-notifications'\nimport { getCheckoutSession } from 'api/gidx/get-checkout-session'\nimport { completeCheckoutSession } from 'api/gidx/complete-checkout-session'\nimport { getContractTopics } from './get-contract-topics'\nimport { getRelatedMarkets } from './get-related-markets'\nimport { getRelatedMarketsByGroup } from './get-related-markets-by-group'\nimport { followContract } from './follow-contract'\nimport { getUserLimitOrdersWithContracts } from 'api/get-user-limit-orders-with-contracts'\nimport { getInterestingGroupsFromViews } from 'api/get-interesting-groups-from-views'\nimport { completeCashoutSession } from 'api/gidx/complete-cashout-session'\nimport { getCashouts } from './get-cashouts'\nimport { getKYCStats } from './get-kyc-stats'\nimport { getTxns } from './get-txns'\nimport { refreshAllClients } from './refresh-all-clients'\nimport { getLeaderboard } from './get-leaderboard'\nimport { toggleSystemTradingStatus } from './toggle-system-status'\nimport { completeCashoutRequest } from './gidx/complete-cashout-request'\nimport { getDailyChangedMetricsAndContracts } from './get-daily-changed-metrics-and-contracts'\nimport { getMarketsByIds } from './get-markets'\nimport { getTopicTopics } from './get-topic-topics'\nimport { getTopicDashboards } from './get-topic-dashboards'\nimport { generateAIMarketSuggestions } from './generate-ai-market-suggestions'\nimport { generateAIDescription } from './generate-ai-description'\nimport { generateAIAnswers } from './generate-ai-answers'\nimport { getmonthlybets2024 } from './get-monthly-bets-2024'\nimport { getmaxminprofit2024 } from './get-max-min-profit-2024'\nimport { getNextLoanAmount } from './get-next-loan-amount'\nimport { checkSportsEvent } from './check-sports-event'\n\nimport { createTask } from './create-task'\nimport { updateTask } from './update-task'\nimport { createCategory } from './create-category'\nimport { getCategories } from './get-categories'\nimport { updateCategory } from './update-category'\nimport { getTasks } from './get-tasks'\n\nimport { getSiteActivity } from './get-site-activity'\nimport { isSportsInterested } from './is-sports-bettor'\nimport { getSportsGames } from './get-sports-games'\nimport { getMarketProps } from './get-market-props'\nimport { getUserContractMetricsWithContracts } from './get-user-contract-metrics-with-contracts'\nimport { validateiap } from './validate-iap'\nimport { getReactions } from './get-reactions'\nimport { markallnotificationsnew } from './mark-all-notifications-new'\nimport {\n  getContractOptionVoters,\n  getContractVoters,\n} from './get-contract-voters'\nimport { purchaseContractBoost } from './purchase-contract-boost'\nimport {\n  generateAINumericRanges,\n  regenerateNumericMidpoints,\n} from './generate-ai-numeric-ranges'\nimport {\n  generateAIDateRanges,\n  regenerateDateMidpoints,\n} from './generate-ai-date-ranges'\nimport { inferNumericUnit } from './infer-numeric-unit'\nimport { generateConciseTitle } from './generate-concise-title'\nimport { getCloseDateEndpoint } from './get-close-date'\nimport { referUser } from './refer-user'\nimport {\n  saveMarketDraft,\n  getMarketDrafts,\n  deleteMarketDraft,\n} from './market-drafts'\nimport { getSeasonInfo } from './get-season-info'\nimport { markNotificationRead } from './mark-all-notifications'\nimport { createPostComment, updatePostComment } from './create-post-comment'\nimport { createPost, updatePost } from './create-post'\nimport { getPosts } from './get-posts'\nimport { dismissUserReport } from './dismiss-user-report'\nimport { followPost } from './follow-post'\n\nexport const handlers: { [k in APIPath]: APIHandler<k> } = {\n  'refresh-all-clients': refreshAllClients,\n  bet: placeBet,\n  'multi-bet': placeMultiBet,\n  'follow-contract': followContract,\n  'bet/cancel/:betId': cancelBet,\n  'market/:contractId/sell': sellShares,\n  bets: getBets,\n  'bet-points': getBetPointsBetween,\n  'get-notifications': getNotifications,\n  'get-channel-memberships': getChannelMemberships,\n  'get-channel-messages': getChannelMessages,\n  'get-channel-seen-time': getLastSeenChannelTime,\n  'set-channel-seen-time': setChannelLastSeenTime,\n  'get-contract': getContract,\n  comment: createComment,\n  'hide-comment': hideComment,\n  'pin-comment': pinComment,\n  comments: getComments,\n  market: createMarket,\n  'market/:contractId/group': addOrRemoveTopicFromContract,\n  'market/:contractId/groups': getContractTopics,\n  'group/:slug': getGroup,\n  'group/by-id/:id': getGroup,\n  'group/by-id/:id/markets': ({ id, limit }, ...rest) =>\n    getMarkets({ groupId: id, limit }, ...rest),\n  'group/:slug/delete': deleteGroup,\n  'group/by-id/:id/delete': deleteGroup,\n  'group/:slug/block': blockGroup,\n  'group/:slug/unblock': unblockGroup,\n  'group/by-id/:topId/group/:bottomId': addOrRemoveTopicFromTopic,\n  'group/:slug/groups': getTopicTopics,\n  'group/:slug/dashboards': getTopicDashboards,\n  'group/by-id/:id/groups': getTopicTopics,\n  groups: getGroups,\n  'market/:id': getMarket,\n  'market/:id/lite': ({ id }) => getMarket({ id, lite: true }),\n  'market/:id/prob': getMarketProb,\n  'market-probs': getMarketProbs,\n  'answer/:answerId': getSingleAnswer,\n  'market/:contractId/answers': getContractAnswers,\n  'markets-by-ids': getMarketsByIds,\n  'slug/:slug': getMarket,\n  'market/:contractId/update': updateMarket,\n  'market/:contractId/close': closeMarket,\n  'market/:contractId/resolve': resolveMarket,\n  'market/:contractId/add-liquidity': addLiquidity,\n  'market/:contractId/remove-liquidity': removeLiquidity,\n  'market/:contractId/add-bounty': addBounty,\n  'market/:contractId/award-bounty': awardBounty,\n  'market/:contractId/answer': createAnswerCPMM,\n  'market/:contractId/block': blockMarket,\n  'market/:contractId/unblock': unblockMarket,\n  'get-user-limit-orders-with-contracts': getUserLimitOrdersWithContracts,\n  'get-interesting-groups-from-views': getInterestingGroupsFromViews,\n  leagues: getLeagues,\n  markets: getMarkets,\n  'search-markets': searchMarketsLite,\n  'search-markets-full': searchMarketsFull,\n  managram: managram,\n  managrams: getManagrams,\n  manalink: createManalink,\n  donate: donate,\n  'convert-cash-to-mana': convertCashToMana,\n  'convert-sp-to-mana': convertSpiceToMana,\n  'market/:id/positions': getPositions,\n  me: getMe,\n  'me/update': updateMe,\n  'me/delete': deleteMe,\n  'me/private': getCurrentPrivateUser,\n  'me/private/update': updatePrivateUser,\n  'user/by-id/:id': getUser,\n  'user/by-id/:id/lite': getLiteUser,\n  'user/:username': getUser,\n  'user/:username/lite': getLiteUser,\n  'user/:username/bets': (...props) => getBets(...props),\n  'user/by-id/:id/block': blockUser,\n  'user/by-id/:id/unblock': unblockUser,\n  users: getUsers,\n  'users/by-id': getUsersByIds,\n  'users/by-id/balance': getUserBalancesByIds,\n  'search-users': searchUsers,\n  react: addOrRemoveReaction,\n  'save-twitch': saveTwitchCredentials,\n  'set-push-token': setPushToken,\n  'update-notif-settings': updateNotifSettings,\n  headlines: getHeadlines,\n  'politics-headlines': getPoliticsHeadlines,\n  'compatible-lovers': getCompatibleLovers,\n  post: post,\n  'fetch-link-preview': fetchLinkPreview,\n  'request-loan': requestLoan,\n  'remove-pinned-photo': removePinnedPhoto,\n  'get-related-markets': getRelatedMarkets,\n  'get-related-markets-by-group': getRelatedMarketsByGroup,\n  'unlist-and-cancel-user-contracts': unlistAndCancelUserContracts,\n  'get-boost-analytics': getBoostAnalytics,\n  'get-compatibility-questions': getCompatibilityQuestions,\n  'like-lover': likeLover,\n  'ship-lovers': shipLovers,\n  'get-likes-and-ships': getLikesAndShips,\n  'has-free-like': hasFreeLike,\n  'star-lover': starLover,\n  'get-lovers': getLovers,\n  'get-lover-answers': getLoverAnswers,\n  'set-news': setnews,\n  'search-groups': searchGroups,\n  'search-my-groups': searchMyGroups,\n  'get-groups-with-top-contracts': getGroupsWithTopContracts,\n  'get-balance-changes': getBalanceChanges,\n  'get-partner-stats': getPartnerStats,\n  'get-posts': getPosts,\n  'get-seen-market-ids': getSeenMarketIds,\n  'record-contract-view': recordContractView,\n  'get-dashboard-from-slug': getDashboardFromSlug,\n  'create-public-chat-message': createPublicChatMessage,\n  unresolve: unresolve,\n  'get-followed-groups': getFollowedGroups,\n  'unique-bet-group-count': getUniqueBetGroupCount,\n  'record-contract-interaction': recordContractInteraction,\n  'get-user-portfolio': getUserPortfolio,\n  'get-user-portfolio-history': getUserPortfolioHistory,\n  createuser: createuser,\n  'verify-phone-number': verifyPhoneNumber,\n  'request-otp': requestOTP,\n  'multi-sell': multiSell,\n  'get-feed': getFeed,\n  'get-mana-supply': getManaSupply,\n  'update-mod-report': updateModReport,\n  'get-mod-reports': getModReports,\n  'search-contract-positions': searchContractPositions,\n  'get-txn-summary-stats': getTxnSummaryStats,\n  'get-mana-summary-stats': getManaSummaryStats,\n  'register-gidx': register,\n  'get-checkout-session-gidx': getCheckoutSession,\n  'complete-checkout-session-gidx': completeCheckoutSession,\n  'complete-cashout-session-gidx': completeCashoutSession,\n  'complete-cashout-request': completeCashoutRequest,\n  'get-verification-status-gidx': getVerificationStatus,\n  'upload-document-gidx': uploadDocument,\n  'identity-callback-gidx': identityCallbackGIDX,\n  'payment-callback-gidx': paymentCallbackGIDX,\n  'get-verification-documents-gidx': getVerificationDocuments,\n  'get-redeemable-prize-cash': getRedeemablePrizeCash,\n  'get-total-redeemable-prize-cash': getTotalRedeemablePrizeCash,\n  'get-monitor-status-gidx': getMonitorStatus,\n  'get-best-comments': getBestComments,\n  'record-comment-view': recordCommentView,\n  'get-cashouts': getCashouts,\n  'get-kyc-stats': getKYCStats,\n  txns: getTxns,\n  'toggle-system-trading-status': toggleSystemTradingStatus,\n  leaderboard: getLeaderboard,\n  'get-daily-changed-metrics-and-contracts': getDailyChangedMetricsAndContracts,\n  'generate-ai-market-suggestions': generateAIMarketSuggestions,\n  'generate-ai-description': generateAIDescription,\n  'generate-ai-answers': generateAIAnswers,\n  'get-monthly-bets-2024': getmonthlybets2024,\n  'get-max-min-profit-2024': getmaxminprofit2024,\n  'get-next-loan-amount': getNextLoanAmount,\n  'check-sports-event': checkSportsEvent,\n  'create-task': createTask,\n  'update-task': updateTask,\n  'create-category': createCategory,\n  'get-categories': getCategories,\n  'update-category': updateCategory,\n  'get-tasks': getTasks,\n  'get-site-activity': getSiteActivity,\n  'is-sports-interested': isSportsInterested,\n  'get-sports-games': getSportsGames,\n  'get-market-props': getMarketProps,\n  'get-user-contract-metrics-with-contracts':\n    getUserContractMetricsWithContracts,\n  validateIap: validateiap,\n  'comment-reactions': getReactions,\n  'mark-all-notifications-new': markallnotificationsnew,\n  'get-contract-voters': getContractVoters,\n  'get-contract-option-voters': getContractOptionVoters,\n  'purchase-contract-boost': purchaseContractBoost,\n  'generate-ai-numeric-ranges': generateAINumericRanges,\n  'regenerate-numeric-midpoints': regenerateNumericMidpoints,\n  'infer-numeric-unit': inferNumericUnit,\n  'generate-ai-date-ranges': generateAIDateRanges,\n  'regenerate-date-midpoints': regenerateDateMidpoints,\n  'generate-concise-title': generateConciseTitle,\n  'get-close-date': getCloseDateEndpoint,\n  'refer-user': referUser,\n  'create-post-comment': createPostComment,\n  'create-post': createPost,\n  'update-post': updatePost,\n  'update-post-comment': updatePostComment,\n  'save-market-draft': saveMarketDraft,\n  'get-market-drafts': getMarketDrafts,\n  'delete-market-draft': deleteMarketDraft,\n  'get-season-info': getSeasonInfo,\n  'mark-notification-read': markNotificationRead,\n  'dismiss-user-report': dismissUserReport,\n  'follow-post': followPost,\n} as const\n"
        },
        {
          "path": "backend/shared/src/create-notification.ts",
          "preContent": "import {\n  BetFillData,\n  BetReplyNotificationData,\n  BettingStreakData,\n  ContractResolutionData,\n  LeagueChangeData,\n  MarketMovementData,\n  Notification,\n  notification_reason_types,\n  NotificationReason,\n  PaymentCompletedData,\n  ReviewNotificationData,\n  UniqueBettorData,\n} from 'common/notification'\nimport {\n  MANIFOLD_AVATAR_URL,\n  MANIFOLD_USER_NAME,\n  MANIFOLD_USER_USERNAME,\n  PrivateUser,\n  User,\n} from 'common/user'\nimport { Contract, MarketContract } from 'common/contract'\nimport { getContract, getPrivateUser, getUser, log } from 'shared/utils'\nimport { ContractComment } from 'common/comment'\nimport {\n  forEach,\n  groupBy,\n  keyBy,\n  last,\n  mapValues,\n  minBy,\n  orderBy,\n  sum,\n  sumBy,\n  uniq,\n} from 'lodash'\nimport { Bet, LimitBet } from 'common/bet'\nimport { Answer } from 'common/answer'\nimport { removeUndefinedProps } from 'common/util/object'\nimport { mapAsync } from 'common/util/promise'\nimport {\n  sendBulkEmails,\n  sendMarketCloseEmail,\n  getMarketResolutionEmail,\n  sendNewUniqueBettorsEmail,\n  EmailAndTemplateEntry,\n  toDisplayResolution,\n  formatMoneyEmail,\n} from './emails'\nimport {\n  getNotificationDestinationsForUser,\n  notification_preference,\n  userIsBlocked,\n  userOptedOutOfBrowserNotifications,\n} from 'common/user-notification-preferences'\nimport { createPushNotifications } from './create-push-notifications'\nimport { QuestType } from 'common/quest'\nimport { QuestRewardTxn, UniqueBettorBonusTxn } from 'common/txn'\nimport { formatMoney } from 'common/util/format'\nimport {\n  createSupabaseDirectClient,\n  SupabaseDirectClient,\n} from 'shared/supabase/init'\nimport {\n  getUniqueBettorIds,\n  getUniqueBettorIdsForAnswer,\n} from 'shared/supabase/contracts'\nimport { richTextToString } from 'common/util/parse'\nimport { LeagueChangeNotificationData } from 'common/leagues'\nimport { hasUserSeenMarket } from 'shared/helpers/seen-markets'\nimport {\n  bulkInsertNotifications,\n  insertNotificationToSupabase,\n} from 'shared/supabase/notifications'\nimport { convertPrivateUser, convertUser } from 'common/supabase/users'\nimport { convertBet } from 'common/supabase/bets'\nimport { getRangeContainingValues, answerToMidpoint } from 'common/number'\nimport { floatingEqual } from 'common/util/math'\nimport { ContractMetric } from 'common/contract-metric'\nimport { nanoid } from 'common/util/random'\n\nexport * from './notifications/create-follow-or-market-subsidized-notification'\nexport * from './notifications/create-new-answer-on-contract-notification'\n\nexport type replied_users_info = {\n  [key: string]: {\n    repliedToType: 'comment' | 'answer'\n    repliedToAnswerText: string | undefined\n    repliedToAnswerId: string | undefined\n    bet: Bet | undefined\n  }\n}\n\nexport const createBetFillNotification = async (\n  toUser: User,\n  fromUser: User,\n  bet: Bet,\n  limitBet: LimitBet,\n  contract: Contract\n) => {\n  const privateUser = await getPrivateUser(toUser.id)\n  if (!privateUser) return\n  const { sendToBrowser, sendToMobile } = getNotificationDestinationsForUser(\n    privateUser,\n    'bet_fill'\n  )\n  if (!sendToBrowser && !sendToMobile) return\n\n  // The limit order fills array has a matchedBetId that does not match this bet id\n  // (even though this bet has a fills array that is matched to the limit order)\n  // This is likely bc this bet is an arbitrage bet. This should be fixed.\n  // This matches based on timestamp because of the above bug.\n  const fill =\n    limitBet.fills.find((fill) => fill.timestamp === bet.createdTime) ??\n    last(orderBy(limitBet.fills, 'timestamp', 'asc'))\n  // const fill = limitBet.fills.find((f) => f.matchedBetId === bet.id)\n\n  const fillAmount = fill?.amount ?? 0\n  const remainingAmount =\n    limitBet.orderAmount - sum(limitBet.fills.map((f) => f.amount))\n  const limitAt =\n    contract.outcomeType === 'PSEUDO_NUMERIC'\n      ? limitBet.limitProb * (contract.max - contract.min) + contract.min\n      : Math.round(limitBet.limitProb * 100) + '%'\n  const betAnswer =\n    'answers' in contract\n      ? (contract.answers as Answer[]).find((a) => a.id === bet.answerId)?.text\n      : undefined\n\n  if (fillAmount < 1) {\n    return\n  }\n\n  const notification: Notification = {\n    id: nanoid(6),\n    userId: toUser.id,\n    reason: 'bet_fill',\n    createdTime: Date.now(),\n    isSeen: false,\n    sourceId: limitBet.id,\n    sourceType: 'bet',\n    sourceUpdateType: 'updated',\n    sourceUserName: fromUser.name,\n    sourceUserUsername: fromUser.username,\n    sourceUserAvatarUrl: fromUser.avatarUrl,\n    sourceText: fillAmount.toString(),\n    sourceContractCreatorUsername: contract.creatorUsername,\n    sourceContractTitle: contract.question,\n    sourceContractSlug: contract.slug,\n    sourceContractId: contract.id,\n    data: {\n      betAnswer,\n      creatorOutcome: limitBet.outcome,\n      probability: limitBet.limitProb,\n      limitOrderTotal: limitBet.orderAmount,\n      limitOrderRemaining: remainingAmount,\n      limitAt: limitAt.toString(),\n      outcomeType: contract.outcomeType,\n      mechanism: contract.mechanism,\n    } as BetFillData,\n  }\n  if (sendToBrowser) {\n    const pg = createSupabaseDirectClient()\n    await insertNotificationToSupabase(notification, pg)\n  }\n  if (sendToMobile) {\n    await createPushNotifications([\n      [\n        privateUser,\n        notification,\n        `Fill on ${limitBet.outcome} order at ${limitAt}: ${contract.question}`,\n        `${formatMoneyEmail(fillAmount)} filled by ${fromUser.name}: ${\n          floatingEqual(remainingAmount, 0)\n            ? 'Order complete.'\n            : `${formatMoneyEmail(remainingAmount)} remaining.`\n        }`,\n      ],\n    ])\n  }\n}\n\nexport const createLimitBetCanceledNotification = async (\n  fromUser: User,\n  toUserId: string,\n  limitBet: LimitBet,\n  fillAmount: number,\n  contract: Contract\n) => {\n  const privateUser = await getPrivateUser(toUserId)\n  if (!privateUser) return\n  const { sendToBrowser } = getNotificationDestinationsForUser(\n    privateUser,\n    'bet_fill'\n  )\n  if (!sendToBrowser) return\n\n  const remainingAmount =\n    limitBet.orderAmount -\n    (sum(limitBet.fills.map((f) => f.amount)) + fillAmount)\n  const limitAt =\n    contract.outcomeType === 'PSEUDO_NUMERIC'\n      ? limitBet.limitProb * (contract.max - contract.min) + contract.min\n      : Math.round(limitBet.limitProb * 100) + '%'\n\n  const betAnswer =\n    'answers' in contract\n      ? (contract.answers as Answer[]).find((a) => a.id === limitBet.answerId)\n      : undefined\n\n  const notification: Notification = {\n    id: nanoid(6),\n    userId: toUserId,\n    reason: 'limit_order_cancelled',\n    createdTime: Date.now(),\n    isSeen: false,\n    sourceId: limitBet.id,\n    sourceType: 'bet',\n    sourceUpdateType: 'updated',\n    sourceUserName: fromUser.name,\n    sourceUserUsername: fromUser.username,\n    sourceUserAvatarUrl: fromUser.avatarUrl,\n    sourceText: remainingAmount.toString(),\n    sourceContractCreatorUsername: contract.creatorUsername,\n    sourceContractTitle: contract.question,\n    sourceContractSlug: contract.slug,\n    sourceContractId: contract.id,\n    data: {\n      creatorOutcome: limitBet.outcome,\n      probability: limitBet.limitProb,\n      limitOrderTotal: limitBet.orderAmount,\n      limitOrderRemaining: remainingAmount,\n      limitAt: limitAt.toString(),\n      outcomeType: contract.outcomeType,\n      mechanism: contract.mechanism,\n      betAnswer: betAnswer?.text,\n      betAnswerId: limitBet.answerId,\n      expiresAt: limitBet.expiresAt,\n      createdTime: limitBet.createdTime,\n    } as BetFillData,\n  }\n  const pg = createSupabaseDirectClient()\n  await insertNotificationToSupabase(notification, pg)\n}\n\nexport const createLimitBetExpiredNotification = async (\n  limitBet: LimitBet,\n  contract: Contract\n) => {\n  const toUserId = limitBet.userId\n  const privateUser = await getPrivateUser(toUserId)\n  if (!privateUser) return\n  const { sendToBrowser } = getNotificationDestinationsForUser(\n    privateUser,\n    'bet_fill'\n  )\n  if (!sendToBrowser) return\n\n  const remainingAmount =\n    limitBet.orderAmount - sum(limitBet.fills.map((f) => f.amount))\n  const limitAt =\n    contract.outcomeType === 'PSEUDO_NUMERIC'\n      ? limitBet.limitProb * (contract.max - contract.min) + contract.min\n      : Math.round(limitBet.limitProb * 100) + '%'\n  const betAnswer =\n    'answers' in contract\n      ? (contract.answers as Answer[]).find((a) => a.id === limitBet.answerId)\n      : undefined\n\n  const notification: Notification = {\n    id: nanoid(6),\n    userId: toUserId,\n    reason: 'limit_order_cancelled',\n    createdTime: Date.now(),\n    isSeen: false,\n    sourceId: limitBet.id,\n    sourceType: 'bet',\n    sourceUpdateType: 'expired',\n    sourceUserName: '',\n    sourceUserUsername: '',\n    sourceUserAvatarUrl: '',\n    sourceText: remainingAmount.toString(),\n    sourceContractCreatorUsername: contract.creatorUsername,\n    sourceContractTitle: contract.question,\n    sourceContractSlug: contract.slug,\n    sourceContractId: contract.id,\n    data: {\n      creatorOutcome: limitBet.outcome,\n      probability: limitBet.limitProb,\n      limitOrderTotal: limitBet.orderAmount,\n      limitOrderRemaining: remainingAmount,\n      limitAt: limitAt.toString(),\n      outcomeType: contract.outcomeType,\n      betAnswer: betAnswer?.text,\n      betAnswerId: limitBet.answerId,\n      expiresAt: limitBet.expiresAt,\n      createdTime: limitBet.createdTime,\n      mechanism: contract.mechanism,\n    } as BetFillData,\n  }\n  const pg = createSupabaseDirectClient()\n  await insertNotificationToSupabase(notification, pg)\n}\n\nexport const createReferralNotification = async (\n  toUserId: string,\n  referredUser: User,\n  bonusAmount: string,\n  referredByContract?: Contract\n) => {\n  const privateUser = await getPrivateUser(toUserId)\n  if (!privateUser) return\n  const { sendToBrowser } = getNotificationDestinationsForUser(\n    privateUser,\n    'you_referred_user'\n  )\n  if (!sendToBrowser) return\n\n  const notification: Notification = {\n    id: referredUser.id + '-signup-referral-bonus',\n    userId: toUserId,\n    reason:\n      referredByContract?.creatorId === toUserId\n        ? 'user_joined_to_bet_on_your_market'\n        : 'you_referred_user',\n    createdTime: Date.now(),\n    isSeen: false,\n    sourceId: referredUser.id,\n    sourceType: 'user',\n    sourceContractId: referredByContract?.id,\n\n    sourceUpdateType: 'updated',\n    sourceUserName: referredUser.name,\n    sourceUserUsername: referredUser.username,\n    sourceUserAvatarUrl: referredUser.avatarUrl,\n    sourceText: bonusAmount,\n    // Only pass the contract referral details if they weren't referred to a group\n    sourceContractCreatorUsername: referredByContract?.creatorUsername,\n    sourceContractTitle: referredByContract?.question,\n    sourceContractSlug: referredByContract?.slug,\n    sourceSlug: referredByContract?.slug,\n    sourceTitle: referredByContract?.question,\n  }\n  const pg = createSupabaseDirectClient()\n  await insertNotificationToSupabase(notification, pg)\n  // TODO send email notification\n}\n\nexport const createLoanIncomeNotification = async (\n  toUser: User,\n  income: number\n) => {\n  const privateUser = await getPrivateUser(toUser.id)\n  if (!privateUser) return\n  const { sendToBrowser } = getNotificationDestinationsForUser(\n    privateUser,\n    'loan_income'\n  )\n  if (!sendToBrowser) return\n  const idempotencyKey = new Date().toDateString().replace(' ', '-')\n\n  const notification: Notification = {\n    id: idempotencyKey + '-loan-income-' + income,\n    userId: toUser.id,\n    reason: 'loan_income',\n    createdTime: Date.now(),\n    isSeen: true,\n    sourceId: idempotencyKey,\n    sourceType: 'loan',\n    sourceUpdateType: 'updated',\n    sourceUserName: toUser.name,\n    sourceUserUsername: toUser.username,\n    sourceUserAvatarUrl: toUser.avatarUrl,\n    sourceText: income.toString(),\n    sourceTitle: 'Loan',\n  }\n  const pg = createSupabaseDirectClient()\n  await insertNotificationToSupabase(notification, pg)\n}\n\nexport const createManaPaymentNotification = async (\n  fromUser: User,\n  toUserId: string,\n  amount: number,\n  message: string | undefined,\n  token: 'M$' | 'CASH'\n) => {\n  const privateUser = await getPrivateUser(toUserId)\n  if (!privateUser) return\n  const optedOut = userOptedOutOfBrowserNotifications(privateUser)\n  if (optedOut) return\n\n  const notification: Notification = {\n    id: nanoid(6),\n    userId: toUserId,\n    reason: 'mana_payment_received',\n    createdTime: Date.now(),\n    isSeen: false,\n    sourceId: fromUser.id,\n    sourceType: 'mana_payment',\n    sourceUpdateType: 'created',\n    sourceUserName: fromUser.name,\n    sourceUserUsername: fromUser.username,\n    sourceUserAvatarUrl: fromUser.avatarUrl,\n    sourceText: amount.toString(),\n    data: {\n      message: message ?? '',\n      token,\n    },\n    sourceTitle: 'User payments',\n  }\n  const pg = createSupabaseDirectClient()\n  await insertNotificationToSupabase(notification, pg)\n}\n\nexport const createBettingStreakBonusNotification = async (\n  user: User,\n  txnId: string,\n  bet: Bet,\n  contract: Contract,\n  amount: number,\n  streak: number\n) => {\n  const privateUser = await getPrivateUser(user.id)\n  if (!privateUser) return\n  const { sendToBrowser } = getNotificationDestinationsForUser(\n    privateUser,\n    'betting_streaks'\n  )\n  if (!sendToBrowser) return\n\n  const notification: Notification = {\n    id: nanoid(6),\n    userId: user.id,\n    reason: 'betting_streaks',\n    createdTime: Date.now(),\n    isSeen: false,\n    sourceId: txnId,\n    sourceType: 'betting_streak_bonus',\n    sourceUpdateType: 'created',\n    sourceUserName: user.name,\n    sourceUserUsername: user.username,\n    sourceUserAvatarUrl: user.avatarUrl,\n    sourceText: amount.toString(),\n    sourceSlug: `/${contract.creatorUsername}/${contract.slug}/bets/${bet.id}`,\n    sourceTitle: 'Betting Streak Bonus',\n    sourceContractSlug: contract.slug,\n    sourceContractId: contract.id,\n    sourceContractTitle: contract.question,\n    sourceContractCreatorUsername: contract.creatorUsername,\n    data: {\n      streak: streak,\n      bonusAmount: amount,\n      cashAmount: 0,\n    } as BettingStreakData,\n  }\n  const pg = createSupabaseDirectClient()\n  await insertNotificationToSupabase(notification, pg)\n}\n\nexport const createBettingStreakExpiringNotification = async (\n  idsAndStreaks: [string, number][],\n  pg: SupabaseDirectClient\n) => {\n  const privateUsers = await pg.map(\n    `select * from private_users where id = any($1)`,\n    [idsAndStreaks.map(([id]) => id)],\n    convertPrivateUser\n  )\n  const bulkPushNotifications: [PrivateUser, Notification, string, string][] =\n    []\n  const bulkNotifications: Notification[] = []\n  forEach(idsAndStreaks, async ([userId, streak]) => {\n    const privateUser = privateUsers.find((user) => user.id === userId)\n    if (!privateUser) return\n    const { sendToBrowser, sendToMobile } = getNotificationDestinationsForUser(\n      privateUser,\n      'betting_streaks'\n    )\n    const id = nanoid(6)\n    const notification: Notification = {\n      id,\n      userId,\n      reason: 'betting_streaks',\n      createdTime: Date.now(),\n      isSeen: false,\n      sourceId: id,\n      sourceText: streak.toString(),\n      sourceType: 'betting_streak_expiring',\n      sourceUpdateType: 'created',\n      sourceUserName: '',\n      sourceUserUsername: '',\n      sourceUserAvatarUrl: '',\n      sourceTitle: 'Betting Streak Expiring',\n      data: {\n        streak: streak,\n      } as BettingStreakData,\n    }\n    if (sendToMobile) {\n      bulkPushNotifications.push([\n        privateUser,\n        notification,\n        `${streak} day streak expiring!`,\n        'Place a prediction in the next 3 hours to keep it.',\n      ])\n    }\n    if (sendToBrowser) {\n      bulkNotifications.push(notification)\n    }\n  })\n  await createPushNotifications(bulkPushNotifications)\n  await bulkInsertNotifications(bulkNotifications, pg)\n}\n\nexport const createLeagueChangedNotifications = async (\n  pg: SupabaseDirectClient,\n  data: LeagueChangeNotificationData[]\n) => {\n  if (data.length === 0) return\n\n  log(`Creating ${data.length} league change notifications.`)\n\n  const userIds = data.map((d) => d.userId)\n\n  // Fetch all relevant private users in bulk\n  const privateUsers = await pg.map(\n    `select * from private_users where id = any($1)`,\n    [userIds],\n    convertPrivateUser\n  )\n  const privateUserMap = new Map(privateUsers.map((user) => [user.id, user]))\n\n  const bulkNotifications: Notification[] = []\n\n  for (const item of data) {\n    const privateUser = privateUserMap.get(item.userId)\n    if (!privateUser) {\n      log(`Could not find private user ${item.userId}`)\n      continue\n    }\n\n    // Check notification preferences\n    const { sendToBrowser } = getNotificationDestinationsForUser(\n      privateUser,\n      'league_changed'\n    )\n    if (!sendToBrowser) continue\n\n    // Construct notification data\n    const id = nanoid(6) // Still need a unique ID per notification\n    const notificationData: LeagueChangeData = {\n      previousLeague: item.previousLeague,\n      newLeague: item.newLeague,\n      bonusAmount: item.bonusAmount,\n    }\n\n    const notification: Notification = {\n      id,\n      userId: item.userId,\n      reason: 'league_changed',\n      createdTime: Date.now(),\n      isSeen: false,\n      sourceId: id, // Use the generated id as sourceId for uniqueness? Or maybe season identifier? Let's use id for now.\n      sourceText: item.bonusAmount.toString(),\n      sourceType: 'league_change',\n      sourceUpdateType: 'created',\n      sourceUserName: '', // Not relevant for this type\n      sourceUserUsername: '', // Not relevant for this type\n      sourceUserAvatarUrl: '', // Not relevant for this type\n      data: notificationData,\n    }\n    bulkNotifications.push(notification)\n  }\n\n  if (bulkNotifications.length > 0) {\n    await bulkInsertNotifications(bulkNotifications, pg)\n    log(`Inserted ${bulkNotifications.length} league change notifications.`)\n  } else {\n    log('No league change notifications met filter criteria.')\n  }\n}\n\nexport const createNewBettorNotification = async (\n  // Creator of contract or answer that was bet on.\n  creatorId: string,\n  bettor: User,\n  contract: Contract,\n  bet: Bet,\n  txn: UniqueBettorBonusTxn,\n  bets: Bet[] | undefined\n) => {\n  const privateUser = await getPrivateUser(creatorId)\n  if (!privateUser) return\n  const { sendToBrowser, sendToEmail } = getNotificationDestinationsForUser(\n    privateUser,\n    'unique_bettors_on_your_contract'\n  )\n  const pg = createSupabaseDirectClient()\n\n  if (sendToBrowser) {\n    const { outcomeType } = contract\n    const pseudoNumericData =\n      outcomeType === 'PSEUDO_NUMERIC'\n        ? {\n            min: contract.min,\n            max: contract.max,\n            isLogScale: contract.isLogScale,\n          }\n        : {}\n    const allBetOnAnswerIds = (bets ?? []).map((b) => b.answerId)\n    const range =\n      outcomeType === 'NUMBER'\n        ? getRangeContainingValues(\n            contract.answers\n              .filter((a) => allBetOnAnswerIds.includes(a.id))\n              .map(answerToMidpoint),\n            contract\n          )\n        : undefined\n\n    const notification: Notification = {\n      id: nanoid(6),\n      userId: creatorId,\n      reason: 'unique_bettors_on_your_contract',\n      createdTime: Date.now(),\n      isSeen: false,\n      sourceId: bet.id,\n      sourceType: 'bonus',\n      sourceUpdateType: 'created',\n      sourceUserName: bettor.name,\n      sourceUserUsername: bettor.username,\n      sourceUserAvatarUrl: bettor.avatarUrl,\n      sourceText: txn.amount.toString(),\n      sourceSlug: contract.slug,\n      sourceTitle: contract.question,\n      sourceContractSlug: contract.slug,\n      sourceContractId: contract.id,\n      sourceContractTitle: contract.question,\n      sourceContractCreatorUsername: contract.creatorUsername,\n      data: removeUndefinedProps({\n        bet,\n        answerText:\n          outcomeType === 'MULTIPLE_CHOICE'\n            ? contract.answers.find(\n                (a) => a.id === bet.outcome || a.id === bet.answerId\n              )?.text\n            : outcomeType === 'NUMBER' && range\n            ? `${range[0]}-${range[1]}`\n            : undefined,\n        outcomeType,\n        ...pseudoNumericData,\n        totalAmountBet: sumBy(bets, 'amount'),\n        token: contract.token,\n        bonusAmount: txn.amount,\n      } as UniqueBettorData),\n    }\n    await insertNotificationToSupabase(notification, pg)\n  }\n\n  if (!sendToEmail || contract.uniqueBettorCount > 6) return\n  const { answerId } = bet\n  // For bets with answerId (multiple choice), give a bonus for the first bet on each answer.\n  // NOTE: this may miscount unique bettors if they place multiple bets quickly b/c of replication delay.\n  const uniqueBettorIds = answerId\n    ? await getUniqueBettorIdsForAnswer(contract.id, answerId, pg)\n    : await getUniqueBettorIds(contract.id, pg)\n  if (!uniqueBettorIds.includes(bettor.id)) uniqueBettorIds.push(bettor.id)\n  const uniqueBettorsExcludingCreator = uniqueBettorIds.filter(\n    (id) => id !== contract.creatorId\n  )\n  const TOTAL_NEW_BETTORS_TO_REPORT = 5\n  // Only send on 5th bettor\n  if (uniqueBettorsExcludingCreator.length !== TOTAL_NEW_BETTORS_TO_REPORT)\n    return\n\n  const lastBettorIds = uniqueBettorsExcludingCreator.slice(\n    uniqueBettorsExcludingCreator.length - TOTAL_NEW_BETTORS_TO_REPORT,\n    uniqueBettorsExcludingCreator.length\n  )\n\n  const mostRecentUniqueBettors = await pg.map(\n    `select * from users where id in ($1:list)`,\n    [lastBettorIds],\n    convertUser\n  )\n\n  const unseenBets = await pg.map<Bet>(\n    `select * from contract_bets where contract_id = $1\n            and user_id in ($2:list)`,\n    [contract.id, lastBettorIds],\n    convertBet\n  )\n\n  const bettorsToTheirBets = groupBy(unseenBets, (bet) => bet.userId)\n\n  // Don't send if creator has seen their market since the 1st bet was placed\n  const creatorHasSeenMarketSinceBet = await hasUserSeenMarket(\n    contract.id,\n    privateUser.id,\n    minBy(unseenBets, 'createdTime')?.createdTime ?? contract.createdTime,\n    pg\n  )\n  if (creatorHasSeenMarketSinceBet) return\n\n  // TODO: add back bonus amount to email\n  await sendNewUniqueBettorsEmail(\n    'unique_bettors_on_your_contract',\n    privateUser,\n    contract,\n    uniqueBettorsExcludingCreator.length,\n    mostRecentUniqueBettors,\n    bettorsToTheirBets,\n    txn.amount * TOTAL_NEW_BETTORS_TO_REPORT\n  )\n}\n\nexport const createContractResolvedNotifications = async (\n  contract: MarketContract,\n  resolver: User,\n  creator: User,\n  outcome: string,\n  probabilityInt: number | undefined,\n  resolutionValue: number | undefined,\n  answerId: string | undefined,\n  resolutionData: {\n    userIdToContractMetric: {\n      [userId: string]: Omit<ContractMetric, 'id'>\n    }\n    userPayouts: { [userId: string]: number }\n    creatorPayout: number\n    resolutionProbability?: number\n    resolutions?: { [outcome: string]: number }\n  }\n) => {\n  const { token } = contract\n  const bulkNotifications: Notification[] = []\n  const bulkNoPayoutEmails: EmailAndTemplateEntry[] = []\n  const bulkEmails: EmailAndTemplateEntry[] = []\n  const bulkPushNotifications: [PrivateUser, Notification, string, string][] =\n    []\n  const {\n    userIdToContractMetric: userIdToContractMetrics,\n    userPayouts,\n    creatorPayout,\n    resolutionProbability,\n    resolutions,\n  } = resolutionData\n\n  const isMultiChoice =\n    contract.outcomeType === 'MULTIPLE_CHOICE' ||\n    contract.outcomeType === 'MULTI_NUMERIC' ||\n    contract.outcomeType === 'DATE'\n  const isIndependentMulti = isMultiChoice && !contract.shouldAnswersSumToOne\n  const resolutionText = toDisplayResolution(\n    contract,\n    outcome,\n    resolutionProbability,\n    resolutions,\n    answerId\n  )\n\n  const pg = createSupabaseDirectClient()\n  const privateUsers = await pg.map(\n    `select private_users.*, users.name from private_users\n          join users on private_users.id = users.id\n          where private_users.id in\n          (select follow_id from contract_follows where contract_id = $1)\n          or private_users.id = any($2)`,\n    [isIndependentMulti ? '_' : contract.id, Object.keys(userPayouts)],\n    (r) => ({ ...convertPrivateUser(r), name: r.name })\n  )\n  const usersToNotify = uniq(\n    privateUsers.map((u) => u.id).filter((id) => id !== resolver.id)\n  )\n\n  const sortedProfits = Object.entries(userIdToContractMetrics)\n    .map(([userId, metrics]) => {\n      const profit = metrics.profit ?? 0\n      return { userId, profit }\n    })\n    .sort((a, b) => b.profit - a.profit)\n  const constructNotification = (\n    userId: string,\n    reason: NotificationReason\n  ): Notification => {\n    return {\n      id: nanoid(6),\n      userId,\n      reason,\n      createdTime: Date.now(),\n      isSeen: false,\n      sourceId: contract.id,\n      sourceType: 'contract',\n      sourceUpdateType: 'resolved',\n      sourceContractId: contract.id,\n      sourceUserName: resolver.name,\n      sourceUserUsername: resolver.username,\n      sourceUserAvatarUrl: resolver.avatarUrl,\n      sourceText: resolutionText,\n      sourceContractCreatorUsername: contract.creatorUsername,\n      sourceContractTitle: contract.question,\n      sourceContractSlug: contract.slug,\n      sourceSlug: contract.slug,\n      sourceTitle: contract.question,\n      data: removeUndefinedProps({\n        outcome,\n        answerId,\n        userInvestment: userIdToContractMetrics?.[userId]?.invested ?? 0,\n        userPayout: userPayouts[userId] ?? 0,\n        profitRank: sortedProfits.findIndex((p) => p.userId === userId) + 1,\n        totalShareholders: sortedProfits.length,\n        profit: userIdToContractMetrics?.[userId]?.profit ?? 0,\n        token,\n      }) as ContractResolutionData,\n    }\n  }\n\n  const sendNotificationsIfSettingsPermit = async (\n    userId: string,\n    reason: NotificationReason\n  ) => {\n    const privateUser = privateUsers.find((u) => u.id === userId)\n    if (!privateUser) return\n    const { sendToBrowser, sendToEmail, sendToMobile } =\n      getNotificationDestinationsForUser(privateUser, reason)\n\n    // Browser notifications\n    if (sendToBrowser) {\n      bulkNotifications.push(constructNotification(userId, reason))\n    }\n\n    // Emails notifications\n    if (sendToEmail && !contract.isTwitchContract) {\n      const email = getMarketResolutionEmail(\n        reason,\n        privateUser,\n        privateUser.name,\n        userIdToContractMetrics?.[userId]?.invested ?? 0,\n        userPayouts[userId] ?? 0,\n        creator,\n        creatorPayout,\n        contract,\n        outcome,\n        resolutionProbability,\n        resolutions,\n        answerId\n      )\n      if (email && floatingEqual(email.correctedInvestment, 0)) {\n        bulkNoPayoutEmails.push(email.entry)\n      } else if (email && !floatingEqual(email?.correctedInvestment, 0)) {\n        bulkEmails.push(email.entry)\n      }\n    }\n    if (sendToMobile) {\n      const notification = constructNotification(userId, reason)\n      const { userPayout, profitRank, userInvestment, totalShareholders } =\n        notification.data as ContractResolutionData\n      const betterThan = (totalShareholders ?? 0) - (profitRank ?? 0)\n      const comparison =\n        profitRank && totalShareholders && betterThan > 0\n          ? `, outperforming ${betterThan} other${betterThan > 1 ? 's' : ''}!`\n          : '.'\n      const profit = userPayout - userInvestment\n      const profitPercent = Math.round((profit / userInvestment) * 100)\n      const profitString = ` You made ${formatMoneyEmail(\n        profit,\n        token\n      )} (+${profitPercent}%)`\n      const lossString = ` You lost ${formatMoneyEmail(-profit, token)}`\n      bulkPushNotifications.push([\n        privateUser,\n        notification,\n        contract.question.length > 50\n          ? contract.question.slice(0, 50) + '...'\n          : contract.question,\n        `Resolved: ${resolutionText}.` +\n          (userInvestment === 0 || outcome === 'CANCEL'\n            ? ''\n            : (profit > 0 ? profitString : lossString) + comparison),\n      ])\n    }\n  }\n\n  await mapAsync(\n    usersToNotify,\n    (id) =>\n      sendNotificationsIfSettingsPermit(\n        id,\n        userIdToContractMetrics?.[id]?.invested\n          ? 'resolutions_on_watched_markets_with_shares_in'\n          : 'resolutions_on_watched_markets'\n      ),\n    20\n  )\n  await createPushNotifications(bulkPushNotifications)\n  await bulkInsertNotifications(bulkNotifications, pg)\n  const subjectResolution = toDisplayResolution(\n    contract,\n    outcome,\n    resolutionProbability,\n    resolutions,\n    answerId\n  )\n  const subject = `Resolved ${subjectResolution}: ${contract.question}`\n  await sendBulkEmails(subject, 'market-resolved-bulk', bulkEmails)\n  await sendBulkEmails(\n    subject,\n    'market-resolved-no-bets-bulk',\n    bulkNoPayoutEmails\n  )\n}\n\nexport const createMarketClosedNotification = async (\n  contract: Contract,\n  creator: User,\n  privateUser: PrivateUser,\n  idempotencyKey: string\n) => {\n  const notification: Notification = {\n    id: idempotencyKey,\n    userId: creator.id,\n    reason: 'your_contract_closed',\n    createdTime: Date.now(),\n    isSeen: false,\n    sourceId: contract.id,\n    sourceType: 'contract',\n    sourceUpdateType: 'closed',\n    sourceContractId: contract?.id,\n    sourceUserName: creator.name,\n    sourceUserUsername: creator.username,\n    sourceUserAvatarUrl: creator.avatarUrl,\n    sourceText: contract.closeTime?.toString() ?? new Date().toString(),\n    sourceContractCreatorUsername: creator.username,\n    sourceContractTitle: contract.question,\n    sourceContractSlug: contract.slug,\n    sourceSlug: contract.slug,\n    sourceTitle: contract.question,\n  }\n  const pg = createSupabaseDirectClient()\n  await insertNotificationToSupabase(notification, pg)\n  await sendMarketCloseEmail(creator, privateUser, contract)\n}\nexport const createWeeklyPortfolioUpdateNotification = async (\n  privateUser: PrivateUser,\n  userUsername: string,\n  weeklyProfit: number,\n  rangeEndDateSlug: string\n) => {\n  const { sendToBrowser } = getNotificationDestinationsForUser(\n    privateUser,\n    'profit_loss_updates'\n  )\n  if (!sendToBrowser) return\n\n  const id = rangeEndDateSlug + 'weekly_portfolio_update'\n\n  const notification: Notification = {\n    id,\n    userId: privateUser.id,\n    reason: 'profit_loss_updates',\n    createdTime: Date.now(),\n    isSeen: false,\n    sourceId: id,\n    sourceType: 'weekly_portfolio_update',\n    sourceUpdateType: 'created',\n    sourceUserName: '',\n    sourceUserUsername: userUsername,\n    sourceUserAvatarUrl: '',\n    sourceText: '',\n    sourceSlug: rangeEndDateSlug,\n    sourceTitle: `Weekly Portfolio Update for ${rangeEndDateSlug}`,\n    data: {\n      weeklyProfit,\n      rangeEndDateSlug,\n    },\n  }\n  const pg = createSupabaseDirectClient()\n  await insertNotificationToSupabase(notification, pg)\n}\n\nexport const createQuestPayoutNotification = async (\n  user: User,\n  txnId: string,\n  payoutAmount: number,\n  questCount: number,\n  questType: QuestType\n) => {\n  const privateUser = await getPrivateUser(user.id)\n  if (!privateUser) return\n  const { sendToBrowser } = getNotificationDestinationsForUser(\n    privateUser,\n    'quest_payout'\n  )\n  if (!sendToBrowser) return\n\n  const notification: Notification = {\n    id: txnId,\n    userId: user.id,\n    reason: 'quest_payout',\n    createdTime: Date.now(),\n    isSeen: false,\n    sourceId: txnId,\n    sourceType: 'quest_reward',\n    sourceUpdateType: 'created',\n    sourceUserName: user.name,\n    sourceUserUsername: user.username,\n    sourceUserAvatarUrl: user.avatarUrl,\n    sourceText: payoutAmount.toString(),\n    sourceTitle: 'Quests',\n    data: {\n      questType,\n      questCount,\n    } as QuestRewardTxn['data'],\n  }\n  const pg = createSupabaseDirectClient()\n  await insertNotificationToSupabase(notification, pg)\n}\n\nexport const createBountyAwardedNotification = async (\n  userId: string,\n  bountyContract: Contract,\n  txnId: string,\n  bountyAmount: number\n) => {\n  const privateUser = await getPrivateUser(userId)\n  if (!privateUser) return\n  if (userOptedOutOfBrowserNotifications(privateUser)) return\n  const notification: Notification = {\n    id: nanoid(6),\n    userId: userId,\n    reason: 'bounty_awarded',\n    createdTime: Date.now(),\n    isSeen: false,\n    sourceId: txnId,\n    sourceType: 'contract',\n    sourceUserName: bountyContract.creatorName,\n    sourceUserUsername: bountyContract.creatorUsername,\n    sourceUserAvatarUrl: bountyContract.creatorAvatarUrl ?? '',\n    sourceContractCreatorUsername: bountyContract.creatorUsername,\n    sourceText: bountyAmount.toString(),\n    sourceContractTitle: bountyContract.question,\n    sourceContractSlug: bountyContract.slug,\n    sourceContractId: txnId,\n  }\n  const pg = createSupabaseDirectClient()\n  await insertNotificationToSupabase(notification, pg)\n}\n\nexport const createBountyAddedNotification = async (\n  userId: string,\n  bountyContract: Contract,\n  txnId: string,\n  bountyAmount: number\n) => {\n  const privateUser = await getPrivateUser(userId)\n  const sender = await getUser(txnId)\n  if (!privateUser || !sender) return\n  if (userOptedOutOfBrowserNotifications(privateUser)) return\n  const notification: Notification = {\n    id: nanoid(6),\n    userId: userId,\n    reason: 'bounty_added',\n    createdTime: Date.now(),\n    isSeen: false,\n    sourceId: txnId,\n    sourceType: 'user',\n    sourceUserName: sender.name,\n    sourceUserUsername: sender.username,\n    sourceUserAvatarUrl: sender.avatarUrl ?? '',\n    sourceContractCreatorUsername: bountyContract.creatorUsername,\n    sourceText: bountyAmount.toString(),\n    sourceContractTitle: bountyContract.question,\n    sourceContractSlug: bountyContract.slug,\n    sourceContractId: bountyContract.id,\n  }\n  const pg = createSupabaseDirectClient()\n  await insertNotificationToSupabase(notification, pg)\n}\n\nexport const createBountyCanceledNotification = async (\n  contract: Contract,\n  amountLeft: number\n) => {\n  const pg = createSupabaseDirectClient()\n\n  const followerIds = await pg.manyOrNone<{ follow_id: string }>(\n    `select follow_id from contract_follows where contract_id = $1`,\n    [contract.id]\n  )\n  const contractFollowersIds = mapValues(\n    keyBy(followerIds, 'follow_id'),\n    () => true\n  )\n  const constructNotification = (\n    userId: string,\n    reason: notification_preference\n  ): Notification => {\n    return {\n      id: nanoid(6),\n      userId,\n      reason,\n      createdTime: Date.now(),\n      isSeen: false,\n      sourceId: contract.id,\n      sourceType: 'contract',\n      sourceContractId: contract.id,\n      sourceUserName: contract.creatorName,\n      sourceUserUsername: contract.creatorUsername,\n      sourceUserAvatarUrl: contract.creatorAvatarUrl ?? '',\n      sourceText: formatMoney(amountLeft),\n      sourceContractCreatorUsername: contract.creatorUsername,\n      sourceContractTitle: contract.question,\n      sourceContractSlug: contract.slug,\n      sourceSlug: contract.slug,\n      sourceTitle: contract.question,\n    }\n  }\n\n  const sendNotificationsIfSettingsPermit = async (\n    userId: string,\n    reason: notification_reason_types\n  ) => {\n    const privateUser = await getPrivateUser(userId)\n    if (!privateUser) return\n    const { sendToBrowser } = getNotificationDestinationsForUser(\n      privateUser,\n      reason\n    )\n\n    // Browser notifications\n    if (sendToBrowser) {\n      await insertNotificationToSupabase(\n        constructNotification(userId, 'bounty_canceled'),\n        pg\n      )\n    }\n  }\n\n  const notifyContractFollowers = async () => {\n    await mapAsync(\n      Object.keys(contractFollowersIds),\n      async (userId) => {\n        if (userId !== contract.creatorId) {\n          return sendNotificationsIfSettingsPermit(userId, 'bounty_canceled')\n        }\n      },\n      20\n    )\n  }\n\n  log('notifying followers')\n  await notifyContractFollowers()\n}\n\nexport const createVotedOnPollNotification = async (\n  voter: User,\n  sourceText: string,\n  sourceContract: Contract\n) => {\n  const pg = createSupabaseDirectClient()\n\n  const privateUsers = await pg.map(\n    `select * from private_users where id in\n           (select follow_id from contract_follows where contract_id = $1)\n           and id != $2`,\n    [sourceContract.id, voter.id],\n    convertPrivateUser\n  )\n  const followerIds = privateUsers.map((user) => user.id)\n  const bulkNotifications: Notification[] = []\n  const constructNotification = (\n    userId: string,\n    reason: notification_preference\n  ) => {\n    const notification: Notification = {\n      id: nanoid(6),\n      userId,\n      reason,\n      createdTime: Date.now(),\n      isSeen: false,\n      sourceId: sourceContract.id,\n      sourceType: 'contract',\n      sourceContractId: sourceContract.id,\n      sourceUserName: voter.name,\n      sourceUserUsername: voter.username,\n      sourceUserAvatarUrl: voter.avatarUrl,\n      sourceText,\n      sourceContractCreatorUsername: sourceContract.creatorUsername,\n      sourceContractTitle: sourceContract.question,\n      sourceContractSlug: sourceContract.slug,\n      sourceSlug: sourceContract.slug,\n      sourceTitle: sourceContract.question,\n    }\n    return removeUndefinedProps(notification)\n  }\n\n  const sendNotificationsIfSettingsPermit = async (\n    userId: string,\n    reason: notification_preference\n  ) => {\n    const privateUser = privateUsers.find((user) => user.id === userId)\n    if (!privateUser || userIsBlocked(privateUser, voter.id)) return\n\n    const { sendToBrowser } = getNotificationDestinationsForUser(\n      privateUser,\n      reason\n    )\n    // Browser notifications\n    if (!sendToBrowser) return\n    const notification = constructNotification(userId, reason)\n    bulkNotifications.push(notification)\n  }\n\n  log('notifying followers')\n  forEach(followerIds, (userId) => {\n    sendNotificationsIfSettingsPermit(\n      userId,\n      userId === sourceContract.creatorId\n        ? 'vote_on_your_contract'\n        : 'all_votes_on_watched_markets'\n    )\n  })\n\n  await bulkInsertNotifications(bulkNotifications, pg)\n}\n\nexport const createPollClosedNotification = async (\n  sourceText: string,\n  sourceContract: Contract\n) => {\n  const pg = createSupabaseDirectClient()\n  const privateUsers = await pg.map(\n    `select * from private_users where id in\n           (select follow_id from contract_follows where contract_id = $1)`,\n    [sourceContract.id],\n    convertPrivateUser\n  )\n  const followerIds = privateUsers.map((user) => user.id)\n  const bulkNotifications: Notification[] = []\n\n  const constructNotification = (\n    userId: string,\n    reason: NotificationReason\n  ) => {\n    const notification: Notification = {\n      id: nanoid(6),\n      userId,\n      reason,\n      createdTime: Date.now(),\n      isSeen: false,\n      sourceId: sourceContract.id,\n      sourceType: 'contract',\n      sourceContractId: sourceContract.id,\n      sourceUserName: sourceContract.creatorName,\n      sourceUserUsername: sourceContract.creatorUsername,\n      sourceUserAvatarUrl: sourceContract.creatorAvatarUrl ?? '',\n      sourceText,\n      sourceContractCreatorUsername: sourceContract.creatorUsername,\n      sourceContractTitle: sourceContract.question,\n      sourceContractSlug: sourceContract.slug,\n      sourceSlug: sourceContract.slug,\n      sourceTitle: sourceContract.question,\n    }\n    return removeUndefinedProps(notification)\n  }\n\n  const sendNotificationsIfSettingsPermit = async (\n    userId: string,\n    reason: NotificationReason\n  ) => {\n    const privateUser = privateUsers.find((user) => user.id === userId)\n    if (!privateUser) return\n    if (userIsBlocked(privateUser, sourceContract.creatorId)) return\n\n    const { sendToBrowser } = getNotificationDestinationsForUser(\n      privateUser,\n      reason\n    )\n\n    if (sendToBrowser) {\n      const notification = constructNotification(userId, reason)\n      bulkNotifications.push(notification)\n    }\n  }\n\n  log('notifying followers')\n  forEach(followerIds, (userId) => {\n    sendNotificationsIfSettingsPermit(\n      userId,\n      userId === sourceContract.creatorId\n        ? 'your_poll_closed'\n        : 'poll_close_on_watched_markets'\n    )\n  })\n  await bulkInsertNotifications(bulkNotifications, pg)\n}\n\nexport const createReferralsProgramNotification = async (\n  userId: string,\n  pg: SupabaseDirectClient\n) => {\n  const privateUser = await getPrivateUser(userId)\n  if (!privateUser) return\n\n  if (!userOptedOutOfBrowserNotifications(privateUser)) {\n    const notification: Notification = {\n      id: userId + 'referrals-program',\n      userId: privateUser.id,\n      reason: 'onboarding_flow',\n      createdTime: Date.now(),\n      isSeen: false,\n      sourceId: nanoid(6),\n      sourceType: 'referral_program',\n      sourceUpdateType: 'created',\n      sourceUserName: '',\n      sourceUserUsername: '',\n      sourceUserAvatarUrl: '',\n      sourceText: '',\n    }\n    await insertNotificationToSupabase(notification, pg)\n  }\n}\nexport const createFollowAfterReferralNotification = async (\n  userId: string,\n  referredByUser: User,\n  pg: SupabaseDirectClient\n) => {\n  const privateUser = await getPrivateUser(userId)\n  if (!privateUser) return\n\n  if (!userOptedOutOfBrowserNotifications(privateUser)) {\n    const notification: Notification = {\n      id: referredByUser.id + 'follow-after-referral',\n      userId: privateUser.id,\n      reason: 'onboarding_flow',\n      createdTime: Date.now(),\n      isSeen: false,\n      sourceId: referredByUser.id,\n      sourceType: 'follow',\n      sourceUpdateType: 'created',\n      sourceUserName: referredByUser.name,\n      sourceUserUsername: referredByUser.username,\n      sourceUserAvatarUrl: referredByUser.avatarUrl,\n      sourceText: '',\n    }\n    await insertNotificationToSupabase(notification, pg)\n  }\n}\n\nexport const createFollowSuggestionNotification = async (\n  userId: string,\n  contract: Contract,\n  pg: SupabaseDirectClient\n) => {\n  const privateUser = await getPrivateUser(userId)\n  if (!privateUser) return\n  const id = nanoid(6)\n  const contractCreator = await getUser(contract.creatorId)\n  if (!contractCreator) return\n\n  if (!userOptedOutOfBrowserNotifications(privateUser)) {\n    const notification: Notification = {\n      id,\n      userId: privateUser.id,\n      reason: 'onboarding_flow',\n      createdTime: Date.now(),\n      isSeen: false,\n      sourceId: id,\n      sourceType: 'follow_suggestion',\n      sourceUpdateType: 'created',\n      sourceUserName: contractCreator.name,\n      sourceUserUsername: contractCreator.username,\n      sourceUserAvatarUrl: contractCreator.avatarUrl,\n      sourceText: '',\n    }\n    await insertNotificationToSupabase(notification, pg)\n  }\n}\nexport const createMarketReviewedNotification = async (\n  userId: string,\n  reviewer: User,\n  contract: Contract,\n  rating: number,\n  review: string,\n  pg: SupabaseDirectClient\n) => {\n  const privateUser = await getPrivateUser(userId)\n  if (!privateUser) return\n  const id = nanoid(6)\n  const reason = 'review_on_your_market'\n  const { sendToBrowser } = getNotificationDestinationsForUser(\n    privateUser,\n    reason\n  )\n  if (sendToBrowser) {\n    const notification: Notification = {\n      id,\n      userId: privateUser.id,\n      reason,\n      createdTime: Date.now(),\n      isSeen: false,\n      sourceId: id,\n      sourceType: 'market_review',\n      sourceUpdateType: 'created',\n      sourceUserName: reviewer.name,\n      sourceUserUsername: reviewer.username,\n      sourceUserAvatarUrl: reviewer.avatarUrl,\n      sourceContractId: contract.id,\n      sourceContractSlug: contract.slug,\n      sourceContractTitle: contract.question,\n      sourceContractCreatorUsername: contract.creatorUsername,\n      sourceTitle: contract.question,\n      sourceSlug: contract.slug,\n      sourceText: '',\n      data: {\n        rating,\n        review,\n      } as ReviewNotificationData,\n    }\n    await insertNotificationToSupabase(notification, pg)\n  }\n}\nexport const createBetReplyToCommentNotification = async (\n  userId: string,\n  contract: Contract,\n  bet: Bet,\n  fromUser: User,\n  comment: ContractComment,\n  pg: SupabaseDirectClient\n) => {\n  const privateUser = await getPrivateUser(userId)\n  if (!privateUser) return\n  const reason = 'reply_to_users_comment'\n  const { sendToBrowser } = getNotificationDestinationsForUser(\n    privateUser,\n    reason\n  )\n  if (sendToBrowser) {\n    const notification: Notification = {\n      id: bet.id + 'reply-to' + comment.id,\n      userId: privateUser.id,\n      reason,\n      createdTime: Date.now(),\n      isSeen: false,\n      sourceId: bet.id,\n      sourceType: 'bet_reply',\n      sourceUpdateType: 'created',\n      sourceUserName: fromUser.name,\n      sourceUserUsername: fromUser.username,\n      sourceUserAvatarUrl: fromUser.avatarUrl,\n      sourceContractId: contract.id,\n      sourceContractSlug: contract.slug,\n      sourceContractTitle: contract.question,\n      sourceContractCreatorUsername: contract.creatorUsername,\n      sourceTitle: contract.question,\n      sourceSlug: contract.slug,\n      sourceText: '',\n      data: {\n        betAmount: bet.amount,\n        betOutcome: bet.outcome,\n        commentText: richTextToString(comment.content).slice(0, 250),\n      } as BetReplyNotificationData,\n    }\n    await insertNotificationToSupabase(notification, pg)\n  }\n}\n\nexport const createPushNotificationBonusNotification = async (\n  privateUser: PrivateUser,\n  txnId: string,\n  amount: number,\n  idempotencyKey: string\n) => {\n  if (userOptedOutOfBrowserNotifications(privateUser)) return\n\n  const notification: Notification = {\n    id: idempotencyKey,\n    userId: privateUser.id,\n    reason: 'onboarding_flow',\n    createdTime: Date.now(),\n    isSeen: false,\n    sourceId: txnId,\n    sourceType: 'push_notification_bonus',\n    sourceUpdateType: 'created',\n    sourceUserName: MANIFOLD_USER_NAME,\n    sourceUserUsername: MANIFOLD_USER_USERNAME,\n    sourceUserAvatarUrl: MANIFOLD_AVATAR_URL,\n    sourceText: amount.toString(),\n    sourceTitle: 'Push Notification Bonus',\n  }\n  const pg = createSupabaseDirectClient()\n  await insertNotificationToSupabase(notification, pg)\n}\n\nexport const createAirdropNotification = async (\n  user: User,\n  idempotencyKey: string,\n  amount: number\n) => {\n  const notification: Notification = {\n    id: idempotencyKey,\n    userId: user.id,\n    reason: 'airdrop',\n    createdTime: Date.now(),\n    isSeen: false,\n    sourceId: 'airdrop',\n    sourceType: 'airdrop',\n    sourceUpdateType: 'created',\n    sourceUserName: user.name,\n    sourceUserUsername: user.username,\n    sourceUserAvatarUrl: user.avatarUrl,\n    sourceText: '',\n    data: {\n      amount,\n    },\n  }\n\n  const pg = createSupabaseDirectClient()\n  await insertNotificationToSupabase(notification, pg)\n}\n\nexport const createManifestAirdropNotification = async (\n  user: User,\n  idempotencyKey: string,\n  amount: number\n) => {\n  const notification: Notification = {\n    id: idempotencyKey,\n    userId: user.id,\n    reason: 'manifest_airdrop',\n    createdTime: Date.now(),\n    isSeen: false,\n    sourceId: 'manifest_airdrop',\n    sourceType: 'manifest_airdrop',\n    sourceUpdateType: 'created',\n    sourceUserName: user.name,\n    sourceUserUsername: user.username,\n    sourceUserAvatarUrl: user.avatarUrl,\n    sourceText: '',\n    data: {\n      amount,\n    },\n  }\n\n  const pg = createSupabaseDirectClient()\n  await insertNotificationToSupabase(notification, pg)\n}\n\nexport const createExtraPurchasedManaNotification = async (\n  user: User,\n  idempotencyKey: string,\n  amount: number\n) => {\n  const notification: Notification = {\n    id: idempotencyKey,\n    userId: user.id,\n    reason: 'extra_purchased_mana',\n    createdTime: Date.now(),\n    isSeen: false,\n    sourceId: 'extra_purchased_mana',\n    sourceType: 'extra_purchased_mana',\n    sourceUpdateType: 'created',\n    sourceUserName: user.name,\n    sourceUserUsername: user.username,\n    sourceUserAvatarUrl: user.avatarUrl,\n    sourceText: '',\n    data: {\n      amount,\n    },\n  }\n\n  const pg = createSupabaseDirectClient()\n  await insertNotificationToSupabase(notification, pg)\n}\n\nexport const createPaymentSuccessNotification = async (\n  paymentData: PaymentCompletedData,\n  transactionId: string\n) => {\n  const notification: Notification = {\n    id: nanoid(6),\n    userId: paymentData.userId,\n    reason: 'payment_status',\n    createdTime: Date.now(),\n    isSeen: false,\n    sourceId: transactionId,\n    sourceType: 'payment_status',\n    sourceUpdateType: 'created',\n    sourceUserName: '',\n    sourceUserUsername: '',\n    sourceUserAvatarUrl: '',\n    sourceText: '',\n    data: paymentData,\n  }\n\n  const pg = createSupabaseDirectClient()\n  await insertNotificationToSupabase(notification, pg)\n}\n\nexport const createMarketMovementNotification = async (\n  params: Array<{\n    contract: Contract\n    id: string\n    privateUser: PrivateUser\n    beforeProb: number\n    afterProb: number\n    beforeTime: Date\n    afterTime: Date\n    answer?: Answer\n  }>\n) => {\n  const pg = createSupabaseDirectClient()\n\n  // Arrays to collect bulk notifications\n  const bulkNotifications: Notification[] = []\n  // const bulkEmails: [PrivateUser, Notification, string, string][] = []\n  // const bulkPushNotifications: [PrivateUser, Notification, string, string][] =\n  //   []\n\n  // Process each notification parameter set\n  for (const {\n    contract,\n    privateUser,\n    beforeProb,\n    afterProb,\n    beforeTime,\n    afterTime,\n    answer,\n    id,\n  } of params) {\n    // Skip if user blocked the creator\n    if (userIsBlocked(privateUser, contract.creatorId)) continue\n\n    // Check notification preferences\n    const { sendToBrowser } = getNotificationDestinationsForUser(\n      privateUser,\n      'market_movements'\n    )\n\n    if (!sendToBrowser) continue\n\n    // Create the notification data\n    const notificationData: MarketMovementData = {\n      val_start: beforeProb,\n      val_end: afterProb,\n      val_start_time: beforeTime.toISOString(),\n      val_end_time: afterTime.toISOString(),\n      answerText: answer?.text,\n    }\n\n    // Create the notification\n    const notification: Notification = {\n      id,\n      userId: privateUser.id,\n      reason: 'market_movements',\n      createdTime: Date.now(),\n      isSeen: false,\n      sourceId: contract.id,\n      sourceType: 'contract',\n      sourceContractId: contract.id,\n      sourceUserName: contract.creatorName,\n      sourceUserUsername: contract.creatorUsername,\n      sourceUserAvatarUrl: contract.creatorAvatarUrl ?? '',\n      sourceText: answer?.text ?? contract.question,\n      sourceContractCreatorUsername: contract.creatorUsername,\n      sourceContractTitle: contract.question,\n      sourceContractSlug: contract.slug,\n      sourceSlug: contract.slug,\n      sourceTitle: contract.question,\n      data: notificationData,\n    }\n\n    if (sendToBrowser) {\n      bulkNotifications.push(notification)\n    }\n\n    // if (sendToEmail) {\n    //   const subject = `Market Update: ${contract.question}`\n    //   const probChange = Math.abs(afterProb - beforeProb) * 100\n    //   const direction = afterProb > beforeProb ? 'rose' : 'fell'\n    //   const body = answer?.text\n    //     ? `The answer \"${answer.text}\" ${direction} from ${Math.round(\n    //         beforeProb * 100\n    //       )}% to ${Math.round(afterProb * 100)}% (a ${Math.round(\n    //         probChange\n    //       )}% change)`\n    //     : `The probability ${direction} from ${Math.round(\n    //         beforeProb * 100\n    //       )}% to ${Math.round(afterProb * 100)}% (a ${Math.round(\n    //         probChange\n    //       )}% change)`\n\n    //   bulkEmails.push([privateUser, notification, subject, body])\n    // }\n\n    // if (sendToMobile) {\n    //   const title = `${contract.question.substring(0, 50)}${\n    //     contract.question.length > 50 ? '...' : ''\n    //   }`\n    //   const probChange = Math.abs(afterProb - beforeProb) * 100\n    //   const direction = afterProb > beforeProb ? 'rose' : 'fell'\n    //   const body = answer?.text\n    //     ? `The answer \"${answer.text}\" ${direction} to ${Math.round(\n    //         afterProb * 100\n    //       )}% (${Math.round(probChange)}% change)`\n    //     : `The probability ${direction} to ${Math.round(\n    //         afterProb * 100\n    //       )}% (${Math.round(probChange)}% change)`\n\n    //   bulkPushNotifications.push([privateUser, notification, title, body])\n    // }\n  }\n\n  // Send the notifications in bulk\n  if (bulkNotifications.length > 0) {\n    await bulkInsertNotifications(bulkNotifications, pg)\n  }\n\n  // Handle bulk emails (commented out in original code)\n  // if (bulkEmails.length > 0) {\n  //   // Would need to be updated to handle bulk emails\n  //   // await sendMarketMovementEmails(bulkEmails)\n  // }\n\n  // Handle bulk push notifications (commented out in original code)\n  // if (bulkPushNotifications.length > 0) {\n  //   await createPushNotifications(bulkPushNotifications)\n  // }\n\n  return bulkNotifications\n}\n\nexport const createFollowsOnYourMarketNotification = async (\n  contractId: string,\n  followerUser: User,\n  pg: SupabaseDirectClient\n) => {\n  const contract = await getContract(pg, contractId)\n  if (!contract) return\n\n  // Don't notify if follower is the creator\n  if (followerUser.id === contract.creatorId) return\n\n  const creatorId = contract.creatorId\n  const privateUser = await getPrivateUser(creatorId)\n  if (!privateUser) return\n  if (userIsBlocked(privateUser, followerUser.id)) return\n\n  const { sendToBrowser } = getNotificationDestinationsForUser(\n    privateUser,\n    'market_follows'\n  )\n\n  if (sendToBrowser) {\n    const notification: Notification = {\n      id: `${followerUser.id}-follows-${contractId}}`,\n      userId: creatorId,\n      reason: 'market_follows',\n      createdTime: Date.now(),\n      isSeen: false,\n      sourceId: followerUser.id,\n      sourceType: 'follow',\n      sourceUpdateType: 'created',\n      sourceContractId: contractId,\n      sourceUserName: followerUser.name,\n      sourceUserUsername: followerUser.username,\n      sourceUserAvatarUrl: followerUser.avatarUrl,\n      sourceText: '',\n      sourceContractCreatorUsername: contract.creatorUsername,\n      sourceContractTitle: contract.question,\n      sourceContractSlug: contract.slug,\n      sourceSlug: contract.slug,\n      sourceTitle: contract.question,\n    }\n\n    await insertNotificationToSupabase(notification, pg)\n  }\n}\n\nexport const createAIDescriptionUpdateNotification = async (\n  contract: Contract,\n  updateText: string\n) => {\n  const notification: Notification = {\n    id: nanoid(6),\n    userId: contract.creatorId,\n    reason: 'admin',\n    createdTime: Date.now(),\n    isSeen: false,\n    sourceId: contract.id,\n    sourceType: 'contract',\n    sourceUpdateType: 'updated',\n    sourceContractId: contract.id,\n    sourceUserName: 'Manifold AI',\n    sourceUserUsername: 'ManifoldAI',\n    sourceUserAvatarUrl: 'https://manifold.markets/logo.svg',\n    sourceText: updateText.slice(0, 150),\n    sourceContractTitle: contract.question,\n    sourceContractCreatorUsername: contract.creatorUsername,\n    sourceContractSlug: contract.slug,\n  }\n\n  const pg = createSupabaseDirectClient()\n  await insertNotificationToSupabase(notification, pg)\n}\n",
          "postContent": "import {\n  BetFillData,\n  BetReplyNotificationData,\n  BettingStreakData,\n  ContractResolutionData,\n  LeagueChangeData,\n  MarketMovementData,\n  Notification,\n  notification_reason_types,\n  NotificationReason,\n  PaymentCompletedData,\n  ReviewNotificationData,\n  UniqueBettorData,\n} from 'common/notification'\nimport {\n  MANIFOLD_AVATAR_URL,\n  MANIFOLD_USER_NAME,\n  MANIFOLD_USER_USERNAME,\n  PrivateUser,\n  User,\n} from 'common/user'\nimport { Contract, MarketContract } from 'common/contract'\nimport { getPrivateUser, getUser, log } from 'shared/utils'\nimport { ContractComment } from 'common/comment'\nimport {\n  forEach,\n  groupBy,\n  keyBy,\n  last,\n  mapValues,\n  minBy,\n  orderBy,\n  sum,\n  sumBy,\n  uniq,\n} from 'lodash'\nimport { Bet, LimitBet } from 'common/bet'\nimport { Answer } from 'common/answer'\nimport { removeUndefinedProps } from 'common/util/object'\nimport { mapAsync } from 'common/util/promise'\nimport {\n  sendBulkEmails,\n  sendMarketCloseEmail,\n  getMarketResolutionEmail,\n  sendNewUniqueBettorsEmail,\n  EmailAndTemplateEntry,\n  toDisplayResolution,\n  formatMoneyEmail,\n} from './emails'\nimport {\n  getNotificationDestinationsForUser,\n  notification_preference,\n  userIsBlocked,\n  userOptedOutOfBrowserNotifications,\n} from 'common/user-notification-preferences'\nimport { createPushNotifications } from './create-push-notifications'\nimport { QuestType } from 'common/quest'\nimport { QuestRewardTxn, UniqueBettorBonusTxn } from 'common/txn'\nimport { formatMoney } from 'common/util/format'\nimport {\n  createSupabaseDirectClient,\n  SupabaseDirectClient,\n} from 'shared/supabase/init'\nimport {\n  getUniqueBettorIds,\n  getUniqueBettorIdsForAnswer,\n} from 'shared/supabase/contracts'\nimport { richTextToString } from 'common/util/parse'\nimport { LeagueChangeNotificationData } from 'common/leagues'\nimport { hasUserSeenMarket } from 'shared/helpers/seen-markets'\nimport {\n  bulkInsertNotifications,\n  insertNotificationToSupabase,\n} from 'shared/supabase/notifications'\nimport { convertPrivateUser, convertUser } from 'common/supabase/users'\nimport { convertBet } from 'common/supabase/bets'\nimport { getRangeContainingValues, answerToMidpoint } from 'common/number'\nimport { floatingEqual } from 'common/util/math'\nimport { ContractMetric } from 'common/contract-metric'\nimport { nanoid } from 'common/util/random'\n\nexport * from './notifications/create-follow-or-market-subsidized-notification'\nexport * from './notifications/create-new-answer-on-contract-notification'\n\nexport type replied_users_info = {\n  [key: string]: {\n    repliedToType: 'comment' | 'answer'\n    repliedToAnswerText: string | undefined\n    repliedToAnswerId: string | undefined\n    bet: Bet | undefined\n  }\n}\n\nexport const createBetFillNotification = async (\n  toUser: User,\n  fromUser: User,\n  bet: Bet,\n  limitBet: LimitBet,\n  contract: Contract\n) => {\n  const privateUser = await getPrivateUser(toUser.id)\n  if (!privateUser) return\n  const { sendToBrowser, sendToMobile } = getNotificationDestinationsForUser(\n    privateUser,\n    'bet_fill'\n  )\n  if (!sendToBrowser && !sendToMobile) return\n\n  // The limit order fills array has a matchedBetId that does not match this bet id\n  // (even though this bet has a fills array that is matched to the limit order)\n  // This is likely bc this bet is an arbitrage bet. This should be fixed.\n  // This matches based on timestamp because of the above bug.\n  const fill =\n    limitBet.fills.find((fill) => fill.timestamp === bet.createdTime) ??\n    last(orderBy(limitBet.fills, 'timestamp', 'asc'))\n  // const fill = limitBet.fills.find((f) => f.matchedBetId === bet.id)\n\n  const fillAmount = fill?.amount ?? 0\n  const remainingAmount =\n    limitBet.orderAmount - sum(limitBet.fills.map((f) => f.amount))\n  const limitAt =\n    contract.outcomeType === 'PSEUDO_NUMERIC'\n      ? limitBet.limitProb * (contract.max - contract.min) + contract.min\n      : Math.round(limitBet.limitProb * 100) + '%'\n  const betAnswer =\n    'answers' in contract\n      ? (contract.answers as Answer[]).find((a) => a.id === bet.answerId)?.text\n      : undefined\n\n  if (fillAmount < 1) {\n    return\n  }\n\n  const notification: Notification = {\n    id: nanoid(6),\n    userId: toUser.id,\n    reason: 'bet_fill',\n    createdTime: Date.now(),\n    isSeen: false,\n    sourceId: limitBet.id,\n    sourceType: 'bet',\n    sourceUpdateType: 'updated',\n    sourceUserName: fromUser.name,\n    sourceUserUsername: fromUser.username,\n    sourceUserAvatarUrl: fromUser.avatarUrl,\n    sourceText: fillAmount.toString(),\n    sourceContractCreatorUsername: contract.creatorUsername,\n    sourceContractTitle: contract.question,\n    sourceContractSlug: contract.slug,\n    sourceContractId: contract.id,\n    data: {\n      betAnswer,\n      creatorOutcome: limitBet.outcome,\n      probability: limitBet.limitProb,\n      limitOrderTotal: limitBet.orderAmount,\n      limitOrderRemaining: remainingAmount,\n      limitAt: limitAt.toString(),\n      outcomeType: contract.outcomeType,\n      mechanism: contract.mechanism,\n    } as BetFillData,\n  }\n  if (sendToBrowser) {\n    const pg = createSupabaseDirectClient()\n    await insertNotificationToSupabase(notification, pg)\n  }\n  if (sendToMobile) {\n    await createPushNotifications([\n      [\n        privateUser,\n        notification,\n        `Fill on ${limitBet.outcome} order at ${limitAt}: ${contract.question}`,\n        `${formatMoneyEmail(fillAmount)} filled by ${fromUser.name}: ${\n          floatingEqual(remainingAmount, 0)\n            ? 'Order complete.'\n            : `${formatMoneyEmail(remainingAmount)} remaining.`\n        }`,\n      ],\n    ])\n  }\n}\n\nexport const createLimitBetCanceledNotification = async (\n  fromUser: User,\n  toUserId: string,\n  limitBet: LimitBet,\n  fillAmount: number,\n  contract: Contract\n) => {\n  const privateUser = await getPrivateUser(toUserId)\n  if (!privateUser) return\n  const { sendToBrowser } = getNotificationDestinationsForUser(\n    privateUser,\n    'bet_fill'\n  )\n  if (!sendToBrowser) return\n\n  const remainingAmount =\n    limitBet.orderAmount -\n    (sum(limitBet.fills.map((f) => f.amount)) + fillAmount)\n  const limitAt =\n    contract.outcomeType === 'PSEUDO_NUMERIC'\n      ? limitBet.limitProb * (contract.max - contract.min) + contract.min\n      : Math.round(limitBet.limitProb * 100) + '%'\n\n  const betAnswer =\n    'answers' in contract\n      ? (contract.answers as Answer[]).find((a) => a.id === limitBet.answerId)\n      : undefined\n\n  const notification: Notification = {\n    id: nanoid(6),\n    userId: toUserId,\n    reason: 'limit_order_cancelled',\n    createdTime: Date.now(),\n    isSeen: false,\n    sourceId: limitBet.id,\n    sourceType: 'bet',\n    sourceUpdateType: 'updated',\n    sourceUserName: fromUser.name,\n    sourceUserUsername: fromUser.username,\n    sourceUserAvatarUrl: fromUser.avatarUrl,\n    sourceText: remainingAmount.toString(),\n    sourceContractCreatorUsername: contract.creatorUsername,\n    sourceContractTitle: contract.question,\n    sourceContractSlug: contract.slug,\n    sourceContractId: contract.id,\n    data: {\n      creatorOutcome: limitBet.outcome,\n      probability: limitBet.limitProb,\n      limitOrderTotal: limitBet.orderAmount,\n      limitOrderRemaining: remainingAmount,\n      limitAt: limitAt.toString(),\n      outcomeType: contract.outcomeType,\n      mechanism: contract.mechanism,\n      betAnswer: betAnswer?.text,\n      betAnswerId: limitBet.answerId,\n      expiresAt: limitBet.expiresAt,\n      createdTime: limitBet.createdTime,\n    } as BetFillData,\n  }\n  const pg = createSupabaseDirectClient()\n  await insertNotificationToSupabase(notification, pg)\n}\n\nexport const createLimitBetExpiredNotification = async (\n  limitBet: LimitBet,\n  contract: Contract\n) => {\n  const toUserId = limitBet.userId\n  const privateUser = await getPrivateUser(toUserId)\n  if (!privateUser) return\n  const { sendToBrowser } = getNotificationDestinationsForUser(\n    privateUser,\n    'bet_fill'\n  )\n  if (!sendToBrowser) return\n\n  const remainingAmount =\n    limitBet.orderAmount - sum(limitBet.fills.map((f) => f.amount))\n  const limitAt =\n    contract.outcomeType === 'PSEUDO_NUMERIC'\n      ? limitBet.limitProb * (contract.max - contract.min) + contract.min\n      : Math.round(limitBet.limitProb * 100) + '%'\n  const betAnswer =\n    'answers' in contract\n      ? (contract.answers as Answer[]).find((a) => a.id === limitBet.answerId)\n      : undefined\n\n  const notification: Notification = {\n    id: nanoid(6),\n    userId: toUserId,\n    reason: 'limit_order_cancelled',\n    createdTime: Date.now(),\n    isSeen: false,\n    sourceId: limitBet.id,\n    sourceType: 'bet',\n    sourceUpdateType: 'expired',\n    sourceUserName: '',\n    sourceUserUsername: '',\n    sourceUserAvatarUrl: '',\n    sourceText: remainingAmount.toString(),\n    sourceContractCreatorUsername: contract.creatorUsername,\n    sourceContractTitle: contract.question,\n    sourceContractSlug: contract.slug,\n    sourceContractId: contract.id,\n    data: {\n      creatorOutcome: limitBet.outcome,\n      probability: limitBet.limitProb,\n      limitOrderTotal: limitBet.orderAmount,\n      limitOrderRemaining: remainingAmount,\n      limitAt: limitAt.toString(),\n      outcomeType: contract.outcomeType,\n      betAnswer: betAnswer?.text,\n      betAnswerId: limitBet.answerId,\n      expiresAt: limitBet.expiresAt,\n      createdTime: limitBet.createdTime,\n      mechanism: contract.mechanism,\n    } as BetFillData,\n  }\n  const pg = createSupabaseDirectClient()\n  await insertNotificationToSupabase(notification, pg)\n}\n\nexport const createReferralNotification = async (\n  toUserId: string,\n  referredUser: User,\n  bonusAmount: string,\n  referredByContract?: Contract\n) => {\n  const privateUser = await getPrivateUser(toUserId)\n  if (!privateUser) return\n  const { sendToBrowser } = getNotificationDestinationsForUser(\n    privateUser,\n    'you_referred_user'\n  )\n  if (!sendToBrowser) return\n\n  const notification: Notification = {\n    id: referredUser.id + '-signup-referral-bonus',\n    userId: toUserId,\n    reason:\n      referredByContract?.creatorId === toUserId\n        ? 'user_joined_to_bet_on_your_market'\n        : 'you_referred_user',\n    createdTime: Date.now(),\n    isSeen: false,\n    sourceId: referredUser.id,\n    sourceType: 'user',\n    sourceContractId: referredByContract?.id,\n\n    sourceUpdateType: 'updated',\n    sourceUserName: referredUser.name,\n    sourceUserUsername: referredUser.username,\n    sourceUserAvatarUrl: referredUser.avatarUrl,\n    sourceText: bonusAmount,\n    // Only pass the contract referral details if they weren't referred to a group\n    sourceContractCreatorUsername: referredByContract?.creatorUsername,\n    sourceContractTitle: referredByContract?.question,\n    sourceContractSlug: referredByContract?.slug,\n    sourceSlug: referredByContract?.slug,\n    sourceTitle: referredByContract?.question,\n  }\n  const pg = createSupabaseDirectClient()\n  await insertNotificationToSupabase(notification, pg)\n  // TODO send email notification\n}\n\nexport const createLoanIncomeNotification = async (\n  toUser: User,\n  income: number\n) => {\n  const privateUser = await getPrivateUser(toUser.id)\n  if (!privateUser) return\n  const { sendToBrowser } = getNotificationDestinationsForUser(\n    privateUser,\n    'loan_income'\n  )\n  if (!sendToBrowser) return\n  const idempotencyKey = new Date().toDateString().replace(' ', '-')\n\n  const notification: Notification = {\n    id: idempotencyKey + '-loan-income-' + income,\n    userId: toUser.id,\n    reason: 'loan_income',\n    createdTime: Date.now(),\n    isSeen: true,\n    sourceId: idempotencyKey,\n    sourceType: 'loan',\n    sourceUpdateType: 'updated',\n    sourceUserName: toUser.name,\n    sourceUserUsername: toUser.username,\n    sourceUserAvatarUrl: toUser.avatarUrl,\n    sourceText: income.toString(),\n    sourceTitle: 'Loan',\n  }\n  const pg = createSupabaseDirectClient()\n  await insertNotificationToSupabase(notification, pg)\n}\n\nexport const createManaPaymentNotification = async (\n  fromUser: User,\n  toUserId: string,\n  amount: number,\n  message: string | undefined,\n  token: 'M$' | 'CASH'\n) => {\n  const privateUser = await getPrivateUser(toUserId)\n  if (!privateUser) return\n  const optedOut = userOptedOutOfBrowserNotifications(privateUser)\n  if (optedOut) return\n\n  const notification: Notification = {\n    id: nanoid(6),\n    userId: toUserId,\n    reason: 'mana_payment_received',\n    createdTime: Date.now(),\n    isSeen: false,\n    sourceId: fromUser.id,\n    sourceType: 'mana_payment',\n    sourceUpdateType: 'created',\n    sourceUserName: fromUser.name,\n    sourceUserUsername: fromUser.username,\n    sourceUserAvatarUrl: fromUser.avatarUrl,\n    sourceText: amount.toString(),\n    data: {\n      message: message ?? '',\n      token,\n    },\n    sourceTitle: 'User payments',\n  }\n  const pg = createSupabaseDirectClient()\n  await insertNotificationToSupabase(notification, pg)\n}\n\nexport const createBettingStreakBonusNotification = async (\n  user: User,\n  txnId: string,\n  bet: Bet,\n  contract: Contract,\n  amount: number,\n  streak: number\n) => {\n  const privateUser = await getPrivateUser(user.id)\n  if (!privateUser) return\n  const { sendToBrowser } = getNotificationDestinationsForUser(\n    privateUser,\n    'betting_streaks'\n  )\n  if (!sendToBrowser) return\n\n  const notification: Notification = {\n    id: nanoid(6),\n    userId: user.id,\n    reason: 'betting_streaks',\n    createdTime: Date.now(),\n    isSeen: false,\n    sourceId: txnId,\n    sourceType: 'betting_streak_bonus',\n    sourceUpdateType: 'created',\n    sourceUserName: user.name,\n    sourceUserUsername: user.username,\n    sourceUserAvatarUrl: user.avatarUrl,\n    sourceText: amount.toString(),\n    sourceSlug: `/${contract.creatorUsername}/${contract.slug}/bets/${bet.id}`,\n    sourceTitle: 'Betting Streak Bonus',\n    sourceContractSlug: contract.slug,\n    sourceContractId: contract.id,\n    sourceContractTitle: contract.question,\n    sourceContractCreatorUsername: contract.creatorUsername,\n    data: {\n      streak: streak,\n      bonusAmount: amount,\n      cashAmount: 0,\n    } as BettingStreakData,\n  }\n  const pg = createSupabaseDirectClient()\n  await insertNotificationToSupabase(notification, pg)\n}\n\nexport const createBettingStreakExpiringNotification = async (\n  idsAndStreaks: [string, number][],\n  pg: SupabaseDirectClient\n) => {\n  const privateUsers = await pg.map(\n    `select * from private_users where id = any($1)`,\n    [idsAndStreaks.map(([id]) => id)],\n    convertPrivateUser\n  )\n  const bulkPushNotifications: [PrivateUser, Notification, string, string][] =\n    []\n  const bulkNotifications: Notification[] = []\n  forEach(idsAndStreaks, async ([userId, streak]) => {\n    const privateUser = privateUsers.find((user) => user.id === userId)\n    if (!privateUser) return\n    const { sendToBrowser, sendToMobile } = getNotificationDestinationsForUser(\n      privateUser,\n      'betting_streaks'\n    )\n    const id = nanoid(6)\n    const notification: Notification = {\n      id,\n      userId,\n      reason: 'betting_streaks',\n      createdTime: Date.now(),\n      isSeen: false,\n      sourceId: id,\n      sourceText: streak.toString(),\n      sourceType: 'betting_streak_expiring',\n      sourceUpdateType: 'created',\n      sourceUserName: '',\n      sourceUserUsername: '',\n      sourceUserAvatarUrl: '',\n      sourceTitle: 'Betting Streak Expiring',\n      data: {\n        streak: streak,\n      } as BettingStreakData,\n    }\n    if (sendToMobile) {\n      bulkPushNotifications.push([\n        privateUser,\n        notification,\n        `${streak} day streak expiring!`,\n        'Place a prediction in the next 3 hours to keep it.',\n      ])\n    }\n    if (sendToBrowser) {\n      bulkNotifications.push(notification)\n    }\n  })\n  await createPushNotifications(bulkPushNotifications)\n  await bulkInsertNotifications(bulkNotifications, pg)\n}\n\nexport const createLeagueChangedNotifications = async (\n  pg: SupabaseDirectClient,\n  data: LeagueChangeNotificationData[]\n) => {\n  if (data.length === 0) return\n\n  log(`Creating ${data.length} league change notifications.`)\n\n  const userIds = data.map((d) => d.userId)\n\n  // Fetch all relevant private users in bulk\n  const privateUsers = await pg.map(\n    `select * from private_users where id = any($1)`,\n    [userIds],\n    convertPrivateUser\n  )\n  const privateUserMap = new Map(privateUsers.map((user) => [user.id, user]))\n\n  const bulkNotifications: Notification[] = []\n\n  for (const item of data) {\n    const privateUser = privateUserMap.get(item.userId)\n    if (!privateUser) {\n      log(`Could not find private user ${item.userId}`)\n      continue\n    }\n\n    // Check notification preferences\n    const { sendToBrowser } = getNotificationDestinationsForUser(\n      privateUser,\n      'league_changed'\n    )\n    if (!sendToBrowser) continue\n\n    // Construct notification data\n    const id = nanoid(6) // Still need a unique ID per notification\n    const notificationData: LeagueChangeData = {\n      previousLeague: item.previousLeague,\n      newLeague: item.newLeague,\n      bonusAmount: item.bonusAmount,\n    }\n\n    const notification: Notification = {\n      id,\n      userId: item.userId,\n      reason: 'league_changed',\n      createdTime: Date.now(),\n      isSeen: false,\n      sourceId: id, // Use the generated id as sourceId for uniqueness? Or maybe season identifier? Let's use id for now.\n      sourceText: item.bonusAmount.toString(),\n      sourceType: 'league_change',\n      sourceUpdateType: 'created',\n      sourceUserName: '', // Not relevant for this type\n      sourceUserUsername: '', // Not relevant for this type\n      sourceUserAvatarUrl: '', // Not relevant for this type\n      data: notificationData,\n    }\n    bulkNotifications.push(notification)\n  }\n\n  if (bulkNotifications.length > 0) {\n    await bulkInsertNotifications(bulkNotifications, pg)\n    log(`Inserted ${bulkNotifications.length} league change notifications.`)\n  } else {\n    log('No league change notifications met filter criteria.')\n  }\n}\n\nexport const createNewBettorNotification = async (\n  // Creator of contract or answer that was bet on.\n  creatorId: string,\n  bettor: User,\n  contract: Contract,\n  bet: Bet,\n  txn: UniqueBettorBonusTxn,\n  bets: Bet[] | undefined\n) => {\n  const privateUser = await getPrivateUser(creatorId)\n  if (!privateUser) return\n  const { sendToBrowser, sendToEmail } = getNotificationDestinationsForUser(\n    privateUser,\n    'unique_bettors_on_your_contract'\n  )\n  const pg = createSupabaseDirectClient()\n\n  if (sendToBrowser) {\n    const { outcomeType } = contract\n    const pseudoNumericData =\n      outcomeType === 'PSEUDO_NUMERIC'\n        ? {\n            min: contract.min,\n            max: contract.max,\n            isLogScale: contract.isLogScale,\n          }\n        : {}\n    const allBetOnAnswerIds = (bets ?? []).map((b) => b.answerId)\n    const range =\n      outcomeType === 'NUMBER'\n        ? getRangeContainingValues(\n            contract.answers\n              .filter((a) => allBetOnAnswerIds.includes(a.id))\n              .map(answerToMidpoint),\n            contract\n          )\n        : undefined\n\n    const notification: Notification = {\n      id: nanoid(6),\n      userId: creatorId,\n      reason: 'unique_bettors_on_your_contract',\n      createdTime: Date.now(),\n      isSeen: false,\n      sourceId: bet.id,\n      sourceType: 'bonus',\n      sourceUpdateType: 'created',\n      sourceUserName: bettor.name,\n      sourceUserUsername: bettor.username,\n      sourceUserAvatarUrl: bettor.avatarUrl,\n      sourceText: txn.amount.toString(),\n      sourceSlug: contract.slug,\n      sourceTitle: contract.question,\n      sourceContractSlug: contract.slug,\n      sourceContractId: contract.id,\n      sourceContractTitle: contract.question,\n      sourceContractCreatorUsername: contract.creatorUsername,\n      data: removeUndefinedProps({\n        bet,\n        answerText:\n          outcomeType === 'MULTIPLE_CHOICE'\n            ? contract.answers.find(\n                (a) => a.id === bet.outcome || a.id === bet.answerId\n              )?.text\n            : outcomeType === 'NUMBER' && range\n            ? `${range[0]}-${range[1]}`\n            : undefined,\n        outcomeType,\n        ...pseudoNumericData,\n        totalAmountBet: sumBy(bets, 'amount'),\n        token: contract.token,\n        bonusAmount: txn.amount,\n      } as UniqueBettorData),\n    }\n    await insertNotificationToSupabase(notification, pg)\n  }\n\n  if (!sendToEmail || contract.uniqueBettorCount > 6) return\n  const { answerId } = bet\n  // For bets with answerId (multiple choice), give a bonus for the first bet on each answer.\n  // NOTE: this may miscount unique bettors if they place multiple bets quickly b/c of replication delay.\n  const uniqueBettorIds = answerId\n    ? await getUniqueBettorIdsForAnswer(contract.id, answerId, pg)\n    : await getUniqueBettorIds(contract.id, pg)\n  if (!uniqueBettorIds.includes(bettor.id)) uniqueBettorIds.push(bettor.id)\n  const uniqueBettorsExcludingCreator = uniqueBettorIds.filter(\n    (id) => id !== contract.creatorId\n  )\n  const TOTAL_NEW_BETTORS_TO_REPORT = 5\n  // Only send on 5th bettor\n  if (uniqueBettorsExcludingCreator.length !== TOTAL_NEW_BETTORS_TO_REPORT)\n    return\n\n  const lastBettorIds = uniqueBettorsExcludingCreator.slice(\n    uniqueBettorsExcludingCreator.length - TOTAL_NEW_BETTORS_TO_REPORT,\n    uniqueBettorsExcludingCreator.length\n  )\n\n  const mostRecentUniqueBettors = await pg.map(\n    `select * from users where id in ($1:list)`,\n    [lastBettorIds],\n    convertUser\n  )\n\n  const unseenBets = await pg.map<Bet>(\n    `select * from contract_bets where contract_id = $1\n            and user_id in ($2:list)`,\n    [contract.id, lastBettorIds],\n    convertBet\n  )\n\n  const bettorsToTheirBets = groupBy(unseenBets, (bet) => bet.userId)\n\n  // Don't send if creator has seen their market since the 1st bet was placed\n  const creatorHasSeenMarketSinceBet = await hasUserSeenMarket(\n    contract.id,\n    privateUser.id,\n    minBy(unseenBets, 'createdTime')?.createdTime ?? contract.createdTime,\n    pg\n  )\n  if (creatorHasSeenMarketSinceBet) return\n\n  // TODO: add back bonus amount to email\n  await sendNewUniqueBettorsEmail(\n    'unique_bettors_on_your_contract',\n    privateUser,\n    contract,\n    uniqueBettorsExcludingCreator.length,\n    mostRecentUniqueBettors,\n    bettorsToTheirBets,\n    txn.amount * TOTAL_NEW_BETTORS_TO_REPORT\n  )\n}\n\nexport const createContractResolvedNotifications = async (\n  contract: MarketContract,\n  resolver: User,\n  creator: User,\n  outcome: string,\n  probabilityInt: number | undefined,\n  resolutionValue: number | undefined,\n  answerId: string | undefined,\n  resolutionData: {\n    userIdToContractMetric: {\n      [userId: string]: Omit<ContractMetric, 'id'>\n    }\n    userPayouts: { [userId: string]: number }\n    creatorPayout: number\n    resolutionProbability?: number\n    resolutions?: { [outcome: string]: number }\n  }\n) => {\n  const { token } = contract\n  const bulkNotifications: Notification[] = []\n  const bulkNoPayoutEmails: EmailAndTemplateEntry[] = []\n  const bulkEmails: EmailAndTemplateEntry[] = []\n  const bulkPushNotifications: [PrivateUser, Notification, string, string][] =\n    []\n  const {\n    userIdToContractMetric: userIdToContractMetrics,\n    userPayouts,\n    creatorPayout,\n    resolutionProbability,\n    resolutions,\n  } = resolutionData\n\n  const isMultiChoice =\n    contract.outcomeType === 'MULTIPLE_CHOICE' ||\n    contract.outcomeType === 'MULTI_NUMERIC' ||\n    contract.outcomeType === 'DATE'\n  const isIndependentMulti = isMultiChoice && !contract.shouldAnswersSumToOne\n  const resolutionText = toDisplayResolution(\n    contract,\n    outcome,\n    resolutionProbability,\n    resolutions,\n    answerId\n  )\n\n  const pg = createSupabaseDirectClient()\n  const privateUsers = await pg.map(\n    `select private_users.*, users.name from private_users\n          join users on private_users.id = users.id\n          where private_users.id in\n          (select follow_id from contract_follows where contract_id = $1)\n          or private_users.id = any($2)`,\n    [isIndependentMulti ? '_' : contract.id, Object.keys(userPayouts)],\n    (r) => ({ ...convertPrivateUser(r), name: r.name })\n  )\n  const usersToNotify = uniq(\n    privateUsers.map((u) => u.id).filter((id) => id !== resolver.id)\n  )\n\n  const sortedProfits = Object.entries(userIdToContractMetrics)\n    .map(([userId, metrics]) => {\n      const profit = metrics.profit ?? 0\n      return { userId, profit }\n    })\n    .sort((a, b) => b.profit - a.profit)\n  const constructNotification = (\n    userId: string,\n    reason: NotificationReason\n  ): Notification => {\n    return {\n      id: nanoid(6),\n      userId,\n      reason,\n      createdTime: Date.now(),\n      isSeen: false,\n      sourceId: contract.id,\n      sourceType: 'contract',\n      sourceUpdateType: 'resolved',\n      sourceContractId: contract.id,\n      sourceUserName: resolver.name,\n      sourceUserUsername: resolver.username,\n      sourceUserAvatarUrl: resolver.avatarUrl,\n      sourceText: resolutionText,\n      sourceContractCreatorUsername: contract.creatorUsername,\n      sourceContractTitle: contract.question,\n      sourceContractSlug: contract.slug,\n      sourceSlug: contract.slug,\n      sourceTitle: contract.question,\n      data: removeUndefinedProps({\n        outcome,\n        answerId,\n        userInvestment: userIdToContractMetrics?.[userId]?.invested ?? 0,\n        userPayout: userPayouts[userId] ?? 0,\n        profitRank: sortedProfits.findIndex((p) => p.userId === userId) + 1,\n        totalShareholders: sortedProfits.length,\n        profit: userIdToContractMetrics?.[userId]?.profit ?? 0,\n        token,\n      }) as ContractResolutionData,\n    }\n  }\n\n  const sendNotificationsIfSettingsPermit = async (\n    userId: string,\n    reason: NotificationReason\n  ) => {\n    const privateUser = privateUsers.find((u) => u.id === userId)\n    if (!privateUser) return\n    const { sendToBrowser, sendToEmail, sendToMobile } =\n      getNotificationDestinationsForUser(privateUser, reason)\n\n    // Browser notifications\n    if (sendToBrowser) {\n      bulkNotifications.push(constructNotification(userId, reason))\n    }\n\n    // Emails notifications\n    if (sendToEmail && !contract.isTwitchContract) {\n      const email = getMarketResolutionEmail(\n        reason,\n        privateUser,\n        privateUser.name,\n        userIdToContractMetrics?.[userId]?.invested ?? 0,\n        userPayouts[userId] ?? 0,\n        creator,\n        creatorPayout,\n        contract,\n        outcome,\n        resolutionProbability,\n        resolutions,\n        answerId\n      )\n      if (email && floatingEqual(email.correctedInvestment, 0)) {\n        bulkNoPayoutEmails.push(email.entry)\n      } else if (email && !floatingEqual(email?.correctedInvestment, 0)) {\n        bulkEmails.push(email.entry)\n      }\n    }\n    if (sendToMobile) {\n      const notification = constructNotification(userId, reason)\n      const { userPayout, profitRank, userInvestment, totalShareholders } =\n        notification.data as ContractResolutionData\n      const betterThan = (totalShareholders ?? 0) - (profitRank ?? 0)\n      const comparison =\n        profitRank && totalShareholders && betterThan > 0\n          ? `, outperforming ${betterThan} other${betterThan > 1 ? 's' : ''}!`\n          : '.'\n      const profit = userPayout - userInvestment\n      const profitPercent = Math.round((profit / userInvestment) * 100)\n      const profitString = ` You made ${formatMoneyEmail(\n        profit,\n        token\n      )} (+${profitPercent}%)`\n      const lossString = ` You lost ${formatMoneyEmail(-profit, token)}`\n      bulkPushNotifications.push([\n        privateUser,\n        notification,\n        contract.question.length > 50\n          ? contract.question.slice(0, 50) + '...'\n          : contract.question,\n        `Resolved: ${resolutionText}.` +\n          (userInvestment === 0 || outcome === 'CANCEL'\n            ? ''\n            : (profit > 0 ? profitString : lossString) + comparison),\n      ])\n    }\n  }\n\n  await mapAsync(\n    usersToNotify,\n    (id) =>\n      sendNotificationsIfSettingsPermit(\n        id,\n        userIdToContractMetrics?.[id]?.invested\n          ? 'resolutions_on_watched_markets_with_shares_in'\n          : 'resolutions_on_watched_markets'\n      ),\n    20\n  )\n  await createPushNotifications(bulkPushNotifications)\n  await bulkInsertNotifications(bulkNotifications, pg)\n  const subjectResolution = toDisplayResolution(\n    contract,\n    outcome,\n    resolutionProbability,\n    resolutions,\n    answerId\n  )\n  const subject = `Resolved ${subjectResolution}: ${contract.question}`\n  await sendBulkEmails(subject, 'market-resolved-bulk', bulkEmails)\n  await sendBulkEmails(\n    subject,\n    'market-resolved-no-bets-bulk',\n    bulkNoPayoutEmails\n  )\n}\n\nexport const createMarketClosedNotification = async (\n  contract: Contract,\n  creator: User,\n  privateUser: PrivateUser,\n  idempotencyKey: string\n) => {\n  const notification: Notification = {\n    id: idempotencyKey,\n    userId: creator.id,\n    reason: 'your_contract_closed',\n    createdTime: Date.now(),\n    isSeen: false,\n    sourceId: contract.id,\n    sourceType: 'contract',\n    sourceUpdateType: 'closed',\n    sourceContractId: contract?.id,\n    sourceUserName: creator.name,\n    sourceUserUsername: creator.username,\n    sourceUserAvatarUrl: creator.avatarUrl,\n    sourceText: contract.closeTime?.toString() ?? new Date().toString(),\n    sourceContractCreatorUsername: creator.username,\n    sourceContractTitle: contract.question,\n    sourceContractSlug: contract.slug,\n    sourceSlug: contract.slug,\n    sourceTitle: contract.question,\n  }\n  const pg = createSupabaseDirectClient()\n  await insertNotificationToSupabase(notification, pg)\n  await sendMarketCloseEmail(creator, privateUser, contract)\n}\nexport const createWeeklyPortfolioUpdateNotification = async (\n  privateUser: PrivateUser,\n  userUsername: string,\n  weeklyProfit: number,\n  rangeEndDateSlug: string\n) => {\n  const { sendToBrowser } = getNotificationDestinationsForUser(\n    privateUser,\n    'profit_loss_updates'\n  )\n  if (!sendToBrowser) return\n\n  const id = rangeEndDateSlug + 'weekly_portfolio_update'\n\n  const notification: Notification = {\n    id,\n    userId: privateUser.id,\n    reason: 'profit_loss_updates',\n    createdTime: Date.now(),\n    isSeen: false,\n    sourceId: id,\n    sourceType: 'weekly_portfolio_update',\n    sourceUpdateType: 'created',\n    sourceUserName: '',\n    sourceUserUsername: userUsername,\n    sourceUserAvatarUrl: '',\n    sourceText: '',\n    sourceSlug: rangeEndDateSlug,\n    sourceTitle: `Weekly Portfolio Update for ${rangeEndDateSlug}`,\n    data: {\n      weeklyProfit,\n      rangeEndDateSlug,\n    },\n  }\n  const pg = createSupabaseDirectClient()\n  await insertNotificationToSupabase(notification, pg)\n}\n\nexport const createQuestPayoutNotification = async (\n  user: User,\n  txnId: string,\n  payoutAmount: number,\n  questCount: number,\n  questType: QuestType\n) => {\n  const privateUser = await getPrivateUser(user.id)\n  if (!privateUser) return\n  const { sendToBrowser } = getNotificationDestinationsForUser(\n    privateUser,\n    'quest_payout'\n  )\n  if (!sendToBrowser) return\n\n  const notification: Notification = {\n    id: txnId,\n    userId: user.id,\n    reason: 'quest_payout',\n    createdTime: Date.now(),\n    isSeen: false,\n    sourceId: txnId,\n    sourceType: 'quest_reward',\n    sourceUpdateType: 'created',\n    sourceUserName: user.name,\n    sourceUserUsername: user.username,\n    sourceUserAvatarUrl: user.avatarUrl,\n    sourceText: payoutAmount.toString(),\n    sourceTitle: 'Quests',\n    data: {\n      questType,\n      questCount,\n    } as QuestRewardTxn['data'],\n  }\n  const pg = createSupabaseDirectClient()\n  await insertNotificationToSupabase(notification, pg)\n}\n\nexport const createBountyAwardedNotification = async (\n  userId: string,\n  bountyContract: Contract,\n  txnId: string,\n  bountyAmount: number\n) => {\n  const privateUser = await getPrivateUser(userId)\n  if (!privateUser) return\n  if (userOptedOutOfBrowserNotifications(privateUser)) return\n  const notification: Notification = {\n    id: nanoid(6),\n    userId: userId,\n    reason: 'bounty_awarded',\n    createdTime: Date.now(),\n    isSeen: false,\n    sourceId: txnId,\n    sourceType: 'contract',\n    sourceUserName: bountyContract.creatorName,\n    sourceUserUsername: bountyContract.creatorUsername,\n    sourceUserAvatarUrl: bountyContract.creatorAvatarUrl ?? '',\n    sourceContractCreatorUsername: bountyContract.creatorUsername,\n    sourceText: bountyAmount.toString(),\n    sourceContractTitle: bountyContract.question,\n    sourceContractSlug: bountyContract.slug,\n    sourceContractId: txnId,\n  }\n  const pg = createSupabaseDirectClient()\n  await insertNotificationToSupabase(notification, pg)\n}\n\nexport const createBountyAddedNotification = async (\n  userId: string,\n  bountyContract: Contract,\n  txnId: string,\n  bountyAmount: number\n) => {\n  const privateUser = await getPrivateUser(userId)\n  const sender = await getUser(txnId)\n  if (!privateUser || !sender) return\n  if (userOptedOutOfBrowserNotifications(privateUser)) return\n  const notification: Notification = {\n    id: nanoid(6),\n    userId: userId,\n    reason: 'bounty_added',\n    createdTime: Date.now(),\n    isSeen: false,\n    sourceId: txnId,\n    sourceType: 'user',\n    sourceUserName: sender.name,\n    sourceUserUsername: sender.username,\n    sourceUserAvatarUrl: sender.avatarUrl ?? '',\n    sourceContractCreatorUsername: bountyContract.creatorUsername,\n    sourceText: bountyAmount.toString(),\n    sourceContractTitle: bountyContract.question,\n    sourceContractSlug: bountyContract.slug,\n    sourceContractId: bountyContract.id,\n  }\n  const pg = createSupabaseDirectClient()\n  await insertNotificationToSupabase(notification, pg)\n}\n\nexport const createBountyCanceledNotification = async (\n  contract: Contract,\n  amountLeft: number\n) => {\n  const pg = createSupabaseDirectClient()\n\n  const followerIds = await pg.manyOrNone<{ follow_id: string }>(\n    `select follow_id from contract_follows where contract_id = $1`,\n    [contract.id]\n  )\n  const contractFollowersIds = mapValues(\n    keyBy(followerIds, 'follow_id'),\n    () => true\n  )\n  const constructNotification = (\n    userId: string,\n    reason: notification_preference\n  ): Notification => {\n    return {\n      id: nanoid(6),\n      userId,\n      reason,\n      createdTime: Date.now(),\n      isSeen: false,\n      sourceId: contract.id,\n      sourceType: 'contract',\n      sourceContractId: contract.id,\n      sourceUserName: contract.creatorName,\n      sourceUserUsername: contract.creatorUsername,\n      sourceUserAvatarUrl: contract.creatorAvatarUrl ?? '',\n      sourceText: formatMoney(amountLeft),\n      sourceContractCreatorUsername: contract.creatorUsername,\n      sourceContractTitle: contract.question,\n      sourceContractSlug: contract.slug,\n      sourceSlug: contract.slug,\n      sourceTitle: contract.question,\n    }\n  }\n\n  const sendNotificationsIfSettingsPermit = async (\n    userId: string,\n    reason: notification_reason_types\n  ) => {\n    const privateUser = await getPrivateUser(userId)\n    if (!privateUser) return\n    const { sendToBrowser } = getNotificationDestinationsForUser(\n      privateUser,\n      reason\n    )\n\n    // Browser notifications\n    if (sendToBrowser) {\n      await insertNotificationToSupabase(\n        constructNotification(userId, 'bounty_canceled'),\n        pg\n      )\n    }\n  }\n\n  const notifyContractFollowers = async () => {\n    await mapAsync(\n      Object.keys(contractFollowersIds),\n      async (userId) => {\n        if (userId !== contract.creatorId) {\n          return sendNotificationsIfSettingsPermit(userId, 'bounty_canceled')\n        }\n      },\n      20\n    )\n  }\n\n  log('notifying followers')\n  await notifyContractFollowers()\n}\n\nexport const createVotedOnPollNotification = async (\n  voter: User,\n  sourceText: string,\n  sourceContract: Contract\n) => {\n  const pg = createSupabaseDirectClient()\n\n  const privateUsers = await pg.map(\n    `select * from private_users where id in\n           (select follow_id from contract_follows where contract_id = $1)\n           and id != $2`,\n    [sourceContract.id, voter.id],\n    convertPrivateUser\n  )\n  const followerIds = privateUsers.map((user) => user.id)\n  const bulkNotifications: Notification[] = []\n  const constructNotification = (\n    userId: string,\n    reason: notification_preference\n  ) => {\n    const notification: Notification = {\n      id: nanoid(6),\n      userId,\n      reason,\n      createdTime: Date.now(),\n      isSeen: false,\n      sourceId: sourceContract.id,\n      sourceType: 'contract',\n      sourceContractId: sourceContract.id,\n      sourceUserName: voter.name,\n      sourceUserUsername: voter.username,\n      sourceUserAvatarUrl: voter.avatarUrl,\n      sourceText,\n      sourceContractCreatorUsername: sourceContract.creatorUsername,\n      sourceContractTitle: sourceContract.question,\n      sourceContractSlug: sourceContract.slug,\n      sourceSlug: sourceContract.slug,\n      sourceTitle: sourceContract.question,\n    }\n    return removeUndefinedProps(notification)\n  }\n\n  const sendNotificationsIfSettingsPermit = async (\n    userId: string,\n    reason: notification_preference\n  ) => {\n    const privateUser = privateUsers.find((user) => user.id === userId)\n    if (!privateUser || userIsBlocked(privateUser, voter.id)) return\n\n    const { sendToBrowser } = getNotificationDestinationsForUser(\n      privateUser,\n      reason\n    )\n    // Browser notifications\n    if (!sendToBrowser) return\n    const notification = constructNotification(userId, reason)\n    bulkNotifications.push(notification)\n  }\n\n  log('notifying followers')\n  forEach(followerIds, (userId) => {\n    sendNotificationsIfSettingsPermit(\n      userId,\n      userId === sourceContract.creatorId\n        ? 'vote_on_your_contract'\n        : 'all_votes_on_watched_markets'\n    )\n  })\n\n  await bulkInsertNotifications(bulkNotifications, pg)\n}\n\nexport const createPollClosedNotification = async (\n  sourceText: string,\n  sourceContract: Contract\n) => {\n  const pg = createSupabaseDirectClient()\n  const privateUsers = await pg.map(\n    `select * from private_users where id in\n           (select follow_id from contract_follows where contract_id = $1)`,\n    [sourceContract.id],\n    convertPrivateUser\n  )\n  const followerIds = privateUsers.map((user) => user.id)\n  const bulkNotifications: Notification[] = []\n\n  const constructNotification = (\n    userId: string,\n    reason: NotificationReason\n  ) => {\n    const notification: Notification = {\n      id: nanoid(6),\n      userId,\n      reason,\n      createdTime: Date.now(),\n      isSeen: false,\n      sourceId: sourceContract.id,\n      sourceType: 'contract',\n      sourceContractId: sourceContract.id,\n      sourceUserName: sourceContract.creatorName,\n      sourceUserUsername: sourceContract.creatorUsername,\n      sourceUserAvatarUrl: sourceContract.creatorAvatarUrl ?? '',\n      sourceText,\n      sourceContractCreatorUsername: sourceContract.creatorUsername,\n      sourceContractTitle: sourceContract.question,\n      sourceContractSlug: sourceContract.slug,\n      sourceSlug: sourceContract.slug,\n      sourceTitle: sourceContract.question,\n    }\n    return removeUndefinedProps(notification)\n  }\n\n  const sendNotificationsIfSettingsPermit = async (\n    userId: string,\n    reason: NotificationReason\n  ) => {\n    const privateUser = privateUsers.find((user) => user.id === userId)\n    if (!privateUser) return\n    if (userIsBlocked(privateUser, sourceContract.creatorId)) return\n\n    const { sendToBrowser } = getNotificationDestinationsForUser(\n      privateUser,\n      reason\n    )\n\n    if (sendToBrowser) {\n      const notification = constructNotification(userId, reason)\n      bulkNotifications.push(notification)\n    }\n  }\n\n  log('notifying followers')\n  forEach(followerIds, (userId) => {\n    sendNotificationsIfSettingsPermit(\n      userId,\n      userId === sourceContract.creatorId\n        ? 'your_poll_closed'\n        : 'poll_close_on_watched_markets'\n    )\n  })\n  await bulkInsertNotifications(bulkNotifications, pg)\n}\n\nexport const createReferralsProgramNotification = async (\n  userId: string,\n  pg: SupabaseDirectClient\n) => {\n  const privateUser = await getPrivateUser(userId)\n  if (!privateUser) return\n\n  if (!userOptedOutOfBrowserNotifications(privateUser)) {\n    const notification: Notification = {\n      id: userId + 'referrals-program',\n      userId: privateUser.id,\n      reason: 'onboarding_flow',\n      createdTime: Date.now(),\n      isSeen: false,\n      sourceId: nanoid(6),\n      sourceType: 'referral_program',\n      sourceUpdateType: 'created',\n      sourceUserName: '',\n      sourceUserUsername: '',\n      sourceUserAvatarUrl: '',\n      sourceText: '',\n    }\n    await insertNotificationToSupabase(notification, pg)\n  }\n}\nexport const createFollowAfterReferralNotification = async (\n  userId: string,\n  referredByUser: User,\n  pg: SupabaseDirectClient\n) => {\n  const privateUser = await getPrivateUser(userId)\n  if (!privateUser) return\n\n  if (!userOptedOutOfBrowserNotifications(privateUser)) {\n    const notification: Notification = {\n      id: referredByUser.id + 'follow-after-referral',\n      userId: privateUser.id,\n      reason: 'onboarding_flow',\n      createdTime: Date.now(),\n      isSeen: false,\n      sourceId: referredByUser.id,\n      sourceType: 'follow',\n      sourceUpdateType: 'created',\n      sourceUserName: referredByUser.name,\n      sourceUserUsername: referredByUser.username,\n      sourceUserAvatarUrl: referredByUser.avatarUrl,\n      sourceText: '',\n    }\n    await insertNotificationToSupabase(notification, pg)\n  }\n}\n\nexport const createFollowSuggestionNotification = async (\n  userId: string,\n  contract: Contract,\n  pg: SupabaseDirectClient\n) => {\n  const privateUser = await getPrivateUser(userId)\n  if (!privateUser) return\n  const id = nanoid(6)\n  const contractCreator = await getUser(contract.creatorId)\n  if (!contractCreator) return\n\n  if (!userOptedOutOfBrowserNotifications(privateUser)) {\n    const notification: Notification = {\n      id,\n      userId: privateUser.id,\n      reason: 'onboarding_flow',\n      createdTime: Date.now(),\n      isSeen: false,\n      sourceId: id,\n      sourceType: 'follow_suggestion',\n      sourceUpdateType: 'created',\n      sourceUserName: contractCreator.name,\n      sourceUserUsername: contractCreator.username,\n      sourceUserAvatarUrl: contractCreator.avatarUrl,\n      sourceText: '',\n    }\n    await insertNotificationToSupabase(notification, pg)\n  }\n}\nexport const createMarketReviewedNotification = async (\n  userId: string,\n  reviewer: User,\n  contract: Contract,\n  rating: number,\n  review: string,\n  pg: SupabaseDirectClient\n) => {\n  const privateUser = await getPrivateUser(userId)\n  if (!privateUser) return\n  const id = nanoid(6)\n  const reason = 'review_on_your_market'\n  const { sendToBrowser } = getNotificationDestinationsForUser(\n    privateUser,\n    reason\n  )\n  if (sendToBrowser) {\n    const notification: Notification = {\n      id,\n      userId: privateUser.id,\n      reason,\n      createdTime: Date.now(),\n      isSeen: false,\n      sourceId: id,\n      sourceType: 'market_review',\n      sourceUpdateType: 'created',\n      sourceUserName: reviewer.name,\n      sourceUserUsername: reviewer.username,\n      sourceUserAvatarUrl: reviewer.avatarUrl,\n      sourceContractId: contract.id,\n      sourceContractSlug: contract.slug,\n      sourceContractTitle: contract.question,\n      sourceContractCreatorUsername: contract.creatorUsername,\n      sourceTitle: contract.question,\n      sourceSlug: contract.slug,\n      sourceText: '',\n      data: {\n        rating,\n        review,\n      } as ReviewNotificationData,\n    }\n    await insertNotificationToSupabase(notification, pg)\n  }\n}\nexport const createBetReplyToCommentNotification = async (\n  userId: string,\n  contract: Contract,\n  bet: Bet,\n  fromUser: User,\n  comment: ContractComment,\n  pg: SupabaseDirectClient\n) => {\n  const privateUser = await getPrivateUser(userId)\n  if (!privateUser) return\n  const reason = 'reply_to_users_comment'\n  const { sendToBrowser } = getNotificationDestinationsForUser(\n    privateUser,\n    reason\n  )\n  if (sendToBrowser) {\n    const notification: Notification = {\n      id: bet.id + 'reply-to' + comment.id,\n      userId: privateUser.id,\n      reason,\n      createdTime: Date.now(),\n      isSeen: false,\n      sourceId: bet.id,\n      sourceType: 'bet_reply',\n      sourceUpdateType: 'created',\n      sourceUserName: fromUser.name,\n      sourceUserUsername: fromUser.username,\n      sourceUserAvatarUrl: fromUser.avatarUrl,\n      sourceContractId: contract.id,\n      sourceContractSlug: contract.slug,\n      sourceContractTitle: contract.question,\n      sourceContractCreatorUsername: contract.creatorUsername,\n      sourceTitle: contract.question,\n      sourceSlug: contract.slug,\n      sourceText: '',\n      data: {\n        betAmount: bet.amount,\n        betOutcome: bet.outcome,\n        commentText: richTextToString(comment.content).slice(0, 250),\n      } as BetReplyNotificationData,\n    }\n    await insertNotificationToSupabase(notification, pg)\n  }\n}\n\nexport const createPushNotificationBonusNotification = async (\n  privateUser: PrivateUser,\n  txnId: string,\n  amount: number,\n  idempotencyKey: string\n) => {\n  if (userOptedOutOfBrowserNotifications(privateUser)) return\n\n  const notification: Notification = {\n    id: idempotencyKey,\n    userId: privateUser.id,\n    reason: 'onboarding_flow',\n    createdTime: Date.now(),\n    isSeen: false,\n    sourceId: txnId,\n    sourceType: 'push_notification_bonus',\n    sourceUpdateType: 'created',\n    sourceUserName: MANIFOLD_USER_NAME,\n    sourceUserUsername: MANIFOLD_USER_USERNAME,\n    sourceUserAvatarUrl: MANIFOLD_AVATAR_URL,\n    sourceText: amount.toString(),\n    sourceTitle: 'Push Notification Bonus',\n  }\n  const pg = createSupabaseDirectClient()\n  await insertNotificationToSupabase(notification, pg)\n}\n\nexport const createAirdropNotification = async (\n  user: User,\n  idempotencyKey: string,\n  amount: number\n) => {\n  const notification: Notification = {\n    id: idempotencyKey,\n    userId: user.id,\n    reason: 'airdrop',\n    createdTime: Date.now(),\n    isSeen: false,\n    sourceId: 'airdrop',\n    sourceType: 'airdrop',\n    sourceUpdateType: 'created',\n    sourceUserName: user.name,\n    sourceUserUsername: user.username,\n    sourceUserAvatarUrl: user.avatarUrl,\n    sourceText: '',\n    data: {\n      amount,\n    },\n  }\n\n  const pg = createSupabaseDirectClient()\n  await insertNotificationToSupabase(notification, pg)\n}\n\nexport const createManifestAirdropNotification = async (\n  user: User,\n  idempotencyKey: string,\n  amount: number\n) => {\n  const notification: Notification = {\n    id: idempotencyKey,\n    userId: user.id,\n    reason: 'manifest_airdrop',\n    createdTime: Date.now(),\n    isSeen: false,\n    sourceId: 'manifest_airdrop',\n    sourceType: 'manifest_airdrop',\n    sourceUpdateType: 'created',\n    sourceUserName: user.name,\n    sourceUserUsername: user.username,\n    sourceUserAvatarUrl: user.avatarUrl,\n    sourceText: '',\n    data: {\n      amount,\n    },\n  }\n\n  const pg = createSupabaseDirectClient()\n  await insertNotificationToSupabase(notification, pg)\n}\n\nexport const createExtraPurchasedManaNotification = async (\n  user: User,\n  idempotencyKey: string,\n  amount: number\n) => {\n  const notification: Notification = {\n    id: idempotencyKey,\n    userId: user.id,\n    reason: 'extra_purchased_mana',\n    createdTime: Date.now(),\n    isSeen: false,\n    sourceId: 'extra_purchased_mana',\n    sourceType: 'extra_purchased_mana',\n    sourceUpdateType: 'created',\n    sourceUserName: user.name,\n    sourceUserUsername: user.username,\n    sourceUserAvatarUrl: user.avatarUrl,\n    sourceText: '',\n    data: {\n      amount,\n    },\n  }\n\n  const pg = createSupabaseDirectClient()\n  await insertNotificationToSupabase(notification, pg)\n}\n\nexport const createPaymentSuccessNotification = async (\n  paymentData: PaymentCompletedData,\n  transactionId: string\n) => {\n  const notification: Notification = {\n    id: nanoid(6),\n    userId: paymentData.userId,\n    reason: 'payment_status',\n    createdTime: Date.now(),\n    isSeen: false,\n    sourceId: transactionId,\n    sourceType: 'payment_status',\n    sourceUpdateType: 'created',\n    sourceUserName: '',\n    sourceUserUsername: '',\n    sourceUserAvatarUrl: '',\n    sourceText: '',\n    data: paymentData,\n  }\n\n  const pg = createSupabaseDirectClient()\n  await insertNotificationToSupabase(notification, pg)\n}\n\nexport const createMarketMovementNotification = async (\n  params: Array<{\n    contract: Contract\n    id: string\n    privateUser: PrivateUser\n    beforeProb: number\n    afterProb: number\n    beforeTime: Date\n    afterTime: Date\n    answer?: Answer\n  }>\n) => {\n  const pg = createSupabaseDirectClient()\n\n  // Arrays to collect bulk notifications\n  const bulkNotifications: Notification[] = []\n  // const bulkEmails: [PrivateUser, Notification, string, string][] = []\n  // const bulkPushNotifications: [PrivateUser, Notification, string, string][] =\n  //   []\n\n  // Process each notification parameter set\n  for (const {\n    contract,\n    privateUser,\n    beforeProb,\n    afterProb,\n    beforeTime,\n    afterTime,\n    answer,\n    id,\n  } of params) {\n    // Skip if user blocked the creator\n    if (userIsBlocked(privateUser, contract.creatorId)) continue\n\n    // Check notification preferences\n    const { sendToBrowser } = getNotificationDestinationsForUser(\n      privateUser,\n      'market_movements'\n    )\n\n    if (!sendToBrowser) continue\n\n    // Create the notification data\n    const notificationData: MarketMovementData = {\n      val_start: beforeProb,\n      val_end: afterProb,\n      val_start_time: beforeTime.toISOString(),\n      val_end_time: afterTime.toISOString(),\n      answerText: answer?.text,\n    }\n\n    // Create the notification\n    const notification: Notification = {\n      id,\n      userId: privateUser.id,\n      reason: 'market_movements',\n      createdTime: Date.now(),\n      isSeen: false,\n      sourceId: contract.id,\n      sourceType: 'contract',\n      sourceContractId: contract.id,\n      sourceUserName: contract.creatorName,\n      sourceUserUsername: contract.creatorUsername,\n      sourceUserAvatarUrl: contract.creatorAvatarUrl ?? '',\n      sourceText: answer?.text ?? contract.question,\n      sourceContractCreatorUsername: contract.creatorUsername,\n      sourceContractTitle: contract.question,\n      sourceContractSlug: contract.slug,\n      sourceSlug: contract.slug,\n      sourceTitle: contract.question,\n      data: notificationData,\n    }\n\n    if (sendToBrowser) {\n      bulkNotifications.push(notification)\n    }\n\n    // if (sendToEmail) {\n    //   const subject = `Market Update: ${contract.question}`\n    //   const probChange = Math.abs(afterProb - beforeProb) * 100\n    //   const direction = afterProb > beforeProb ? 'rose' : 'fell'\n    //   const body = answer?.text\n    //     ? `The answer \"${answer.text}\" ${direction} from ${Math.round(\n    //         beforeProb * 100\n    //       )}% to ${Math.round(afterProb * 100)}% (a ${Math.round(\n    //         probChange\n    //       )}% change)`\n    //     : `The probability ${direction} from ${Math.round(\n    //         beforeProb * 100\n    //       )}% to ${Math.round(afterProb * 100)}% (a ${Math.round(\n    //         probChange\n    //       )}% change)`\n\n    //   bulkEmails.push([privateUser, notification, subject, body])\n    // }\n\n    // if (sendToMobile) {\n    //   const title = `${contract.question.substring(0, 50)}${\n    //     contract.question.length > 50 ? '...' : ''\n    //   }`\n    //   const probChange = Math.abs(afterProb - beforeProb) * 100\n    //   const direction = afterProb > beforeProb ? 'rose' : 'fell'\n    //   const body = answer?.text\n    //     ? `The answer \"${answer.text}\" ${direction} to ${Math.round(\n    //         afterProb * 100\n    //       )}% (${Math.round(probChange)}% change)`\n    //     : `The probability ${direction} to ${Math.round(\n    //         afterProb * 100\n    //       )}% (${Math.round(probChange)}% change)`\n\n    //   bulkPushNotifications.push([privateUser, notification, title, body])\n    // }\n  }\n\n  // Send the notifications in bulk\n  if (bulkNotifications.length > 0) {\n    await bulkInsertNotifications(bulkNotifications, pg)\n  }\n\n  // Handle bulk emails (commented out in original code)\n  // if (bulkEmails.length > 0) {\n  //   // Would need to be updated to handle bulk emails\n  //   // await sendMarketMovementEmails(bulkEmails)\n  // }\n\n  // Handle bulk push notifications (commented out in original code)\n  // if (bulkPushNotifications.length > 0) {\n  //   await createPushNotifications(bulkPushNotifications)\n  // }\n\n  return bulkNotifications\n}\n\nexport const createAIDescriptionUpdateNotification = async (\n  contract: Contract,\n  updateText: string\n) => {\n  const notification: Notification = {\n    id: nanoid(6),\n    userId: contract.creatorId,\n    reason: 'admin',\n    createdTime: Date.now(),\n    isSeen: false,\n    sourceId: contract.id,\n    sourceType: 'contract',\n    sourceUpdateType: 'updated',\n    sourceContractId: contract.id,\n    sourceUserName: 'Manifold AI',\n    sourceUserUsername: 'ManifoldAI',\n    sourceUserAvatarUrl: 'https://manifold.markets/logo.svg',\n    sourceText: updateText.slice(0, 150),\n    sourceContractTitle: contract.question,\n    sourceContractCreatorUsername: contract.creatorUsername,\n    sourceContractSlug: contract.slug,\n  }\n\n  const pg = createSupabaseDirectClient()\n  await insertNotificationToSupabase(notification, pg)\n}\n"
        },
        {
          "path": "backend/shared/src/notifications/create-new-contract-comment-notif.ts",
          "preContent": "import {\n  CommentNotificationData,\n  Notification,\n  NOTIFICATION_DESCRIPTIONS,\n  NotificationReason,\n} from 'common/notification'\nimport { PrivateUser, User } from 'common/user'\nimport { Contract } from 'common/contract'\nimport { isProd, log } from 'shared/utils'\nimport { uniq } from 'lodash'\nimport { removeUndefinedProps } from 'common/util/object'\nimport {\n  sendBulkEmails,\n  getNewCommentEmail,\n  EmailAndTemplateEntry,\n} from '../emails'\nimport {\n  getNotificationDestinationsForUser,\n  notification_destination_types,\n  userIsBlocked,\n} from 'common/user-notification-preferences'\nimport { createPushNotifications } from '../create-push-notifications'\nimport { createSupabaseDirectClient } from 'shared/supabase/init'\nimport {\n  getUniqueBettorIds,\n  getUniqueVoterIds,\n} from 'shared/supabase/contracts'\nimport { isAdminId, isModId } from 'common/envs/constants'\nimport { bulkInsertNotifications } from 'shared/supabase/notifications'\nimport { convertPrivateUser } from 'common/supabase/users'\nimport { nanoid } from 'common/util/random'\nimport { replied_users_info } from 'shared/create-notification'\nimport { TopLevelPost as Post } from 'common/top-level-post'\nimport { PostComment } from 'common/comment'\nimport { richTextToString } from 'common/util/parse'\nimport { uniqBy } from 'lodash'\nimport { SupabaseDirectClient } from 'shared/supabase/init'\n\nconst ALL_TRADERS_ID = isProd()\n  ? 'X3z4hxRXipWvGoFhxlDOVxmP5vL2'\n  : 'eMG8r3PEdRgtGArGGx1VUBGDwY53'\n\nexport const createCommentOnContractNotification = async (\n  sourceId: string,\n  sourceUser: User,\n  sourceText: string,\n  sourceContract: Contract,\n  repliedUsersInfo: replied_users_info,\n  taggedUserIds: string[],\n  requiresResponse: boolean\n) => {\n  const pg = createSupabaseDirectClient()\n\n  const usersToReceivedNotifications: Record<\n    string,\n    notification_destination_types[]\n  > = {}\n\n  const followerIds = await pg.map(\n    `select follow_id from contract_follows where contract_id = $1`,\n    [sourceContract.id],\n    (r) => r.follow_id\n  )\n  const isReply = Object.keys(repliedUsersInfo).length > 0\n  const buildNotification = (userId: string, reason: NotificationReason) => {\n    return removeUndefinedProps({\n      id: nanoid(6),\n      userId,\n      reason,\n      createdTime: Date.now(),\n      isSeen: false,\n      sourceId,\n      sourceType: 'comment',\n      sourceUpdateType: 'created',\n      sourceContractId: sourceContract.id,\n      sourceUserName: sourceUser.name,\n      sourceUserUsername: sourceUser.username,\n      sourceUserAvatarUrl: sourceUser.avatarUrl,\n      sourceText,\n      sourceContractCreatorUsername: sourceContract.creatorUsername,\n      sourceContractTitle: sourceContract.question,\n      sourceContractSlug: sourceContract.slug,\n      sourceSlug: sourceContract.slug,\n      sourceTitle: sourceContract.question,\n      data: {\n        isReply,\n      } as CommentNotificationData,\n      markedAsRead:\n        requiresResponse && sourceContract.creatorId === userId\n          ? false\n          : undefined,\n    }) as Notification\n  }\n\n  const needNotFollowContractReasons = ['tagged_user']\n\n  if (\n    taggedUserIds?.includes(ALL_TRADERS_ID) &&\n    (sourceUser.id === sourceContract.creatorId ||\n      isAdminId(sourceUser.id) ||\n      isModId(sourceUser.id))\n  ) {\n    const allBettors = await getUniqueBettorIds(sourceContract.id, pg)\n    const allVoters = await getUniqueVoterIds(sourceContract.id, pg)\n    const allUsers = uniq(allBettors.concat(allVoters))\n    taggedUserIds.push(...allUsers)\n  }\n  const bettorIds = await getUniqueBettorIds(sourceContract.id, pg)\n\n  const allRelevantUserIds = uniq([\n    ...followerIds,\n    sourceContract.creatorId,\n    ...(taggedUserIds ?? []),\n    ...(repliedUsersInfo ? Object.keys(repliedUsersInfo) : []),\n    ...bettorIds,\n  ])\n  const bulkNotifications: Notification[] = []\n  const bulkEmails: EmailAndTemplateEntry[] = []\n  const bulkPushNotifications: [PrivateUser, Notification, string, string][] =\n    []\n  const privateUsers = await pg.map(\n    `select private_users.*, users.name from private_users\n           join users on private_users.id = users.id\n           where private_users.id = any($1)`,\n    [allRelevantUserIds],\n    (r) => ({ ...convertPrivateUser(r), name: r.name })\n  )\n  const privateUserMap = new Map(privateUsers.map((user) => [user.id, user]))\n\n  const sendNotificationsIfSettingsPermit = async (\n    userId: string,\n    reason: NotificationReason\n  ) => {\n    const privateUser = privateUserMap.get(userId)\n    if (\n      !privateUser ||\n      sourceUser.id == userId ||\n      userIsBlocked(privateUser, sourceUser.id) ||\n      (!followerIds.some((id) => id === userId) &&\n        !needNotFollowContractReasons.includes(reason))\n    )\n      return\n\n    const { sendToBrowser, sendToEmail, sendToMobile, notificationPreference } =\n      getNotificationDestinationsForUser(privateUser, reason)\n\n    const receivedNotifications = usersToReceivedNotifications[userId] ?? []\n\n    // Browser notifications\n    if (sendToBrowser && !receivedNotifications.includes('browser')) {\n      bulkNotifications.push(buildNotification(userId, reason))\n      receivedNotifications.push('browser')\n    }\n\n    // Mobile push notifications\n    if (sendToMobile && !receivedNotifications.includes('mobile')) {\n      const reasonText =\n        (notificationPreference &&\n          NOTIFICATION_DESCRIPTIONS[notificationPreference].verb) ??\n        'commented'\n      const notification = buildNotification(userId, reason)\n      bulkPushNotifications.push([\n        privateUser,\n        notification,\n        `${sourceUser.name} ${reasonText} on ${sourceContract.question}`,\n        sourceText,\n      ])\n      receivedNotifications.push('mobile')\n    }\n\n    // Email notifications\n    if (sendToEmail && !receivedNotifications.includes('email')) {\n      const { bet } = repliedUsersInfo?.[userId] ?? {}\n      // TODO: change subject of email title to be more specific, i.e.: replied to you on/tagged you on/comment\n      const email = getNewCommentEmail(\n        reason,\n        privateUser,\n        privateUser.name,\n        sourceUser,\n        sourceContract,\n        sourceText,\n        sourceId,\n        bet\n      )\n      if (email) {\n        bulkEmails.push(email)\n      }\n      receivedNotifications.push('email')\n    }\n    usersToReceivedNotifications[userId] = receivedNotifications\n  }\n\n  log('notifying replies')\n  if (repliedUsersInfo) {\n    await Promise.all(\n      Object.keys(repliedUsersInfo).map(async (userId) =>\n        sendNotificationsIfSettingsPermit(\n          userId,\n          repliedUsersInfo[userId].repliedToType === 'answer'\n            ? 'reply_to_users_answer'\n            : 'reply_to_users_comment'\n        )\n      )\n    )\n  }\n  log('notifying tagged users')\n  if (taggedUserIds && taggedUserIds.length > 0) {\n    await Promise.all(\n      uniq(taggedUserIds).map(async (userId) =>\n        sendNotificationsIfSettingsPermit(userId, 'tagged_user')\n      )\n    )\n  }\n  log('notifying creator')\n  await sendNotificationsIfSettingsPermit(\n    sourceContract.creatorId,\n    'all_comments_on_my_markets'\n  )\n  log('notifying bettors')\n  await Promise.all(\n    bettorIds.map(async (userId) =>\n      sendNotificationsIfSettingsPermit(\n        userId,\n        'comment_on_contract_with_users_shares_in'\n      )\n    )\n  )\n  log('notifying followers')\n  await Promise.all(\n    followerIds.map(async (userId) =>\n      sendNotificationsIfSettingsPermit(\n        userId,\n        'comment_on_contract_you_follow'\n      )\n    )\n  )\n  await createPushNotifications(bulkPushNotifications)\n  await bulkInsertNotifications(bulkNotifications, pg)\n  await sendBulkEmails(\n    `Comment on ${sourceContract.question}`,\n    'market-comment-bulk',\n    bulkEmails,\n    `${sourceUser.name} on Manifold <no-reply@manifold.markets>`\n  )\n}\n\n// New function for post comment notifications\nexport const createCommentOnPostNotification = async (\n  pg: SupabaseDirectClient,\n  comment: PostComment,\n  post: Post,\n  commentCreator: User,\n  repliedUserId: string | undefined,\n  mentionedUserIds: string[]\n) => {\n  const usersToNotify: { userId: string; reason: NotificationReason }[] = []\n\n  // 1. Post Creator\n  if (post.creatorId !== commentCreator.id) {\n    usersToNotify.push({\n      userId: post.creatorId,\n      reason: 'comment_on_your_contract',\n    })\n  }\n\n  // 2. Replied User\n  if (repliedUserId && repliedUserId !== commentCreator.id) {\n    // Ensure replied user is not also the post creator already added\n    if (repliedUserId !== post.creatorId) {\n      usersToNotify.push({\n        userId: repliedUserId,\n        reason: 'reply_to_users_comment',\n      })\n    } else if (\n      repliedUserId === post.creatorId &&\n      post.creatorId !== commentCreator.id\n    ) {\n      // If replied user is the post creator, they'd get 'comment_on_your_post'\n      // If they also need 'reply_to_users_post_comment' for different email/push, handle here\n      // For now, 'comment_on_your_post' takes precedence if they are the creator.\n      // If they are the creator AND the commenter, they get nothing from this rule.\n      // If they are replied to AND the creator (and not the commenter), they get 'comment_on_your_post'.\n      // This specific case for 'reply_to_users_post_comment' might need more nuanced logic\n      // if the notification content/preference check differs significantly.\n      // Let's keep it simple: if they are the creator, 'comment_on_your_post' covers it.\n      // If they are replied to AND NOT the creator, they get 'reply_to_users_post_comment'.\n    }\n  }\n  // Refined logic for Replied User to avoid double notification if also creator,\n  // and ensure they get 'reply_to_users_post_comment' if not the creator.\n  if (\n    repliedUserId &&\n    repliedUserId !== commentCreator.id &&\n    repliedUserId !== post.creatorId\n  ) {\n    usersToNotify.push({\n      userId: repliedUserId,\n      reason: 'reply_to_users_comment',\n    })\n  }\n\n  // 3. Mentioned Users\n  mentionedUserIds.forEach((mentionedUserId) => {\n    // Ensure mentioned user is not the commenter, post creator, or replied user (if already processed)\n    if (\n      mentionedUserId !== commentCreator.id &&\n      mentionedUserId !== post.creatorId &&\n      mentionedUserId !== repliedUserId\n    ) {\n      usersToNotify.push({\n        userId: mentionedUserId,\n        reason: 'tagged_user',\n      })\n    }\n  })\n\n  const uniqueUsersToNotify = uniqBy(usersToNotify, (u) => u.userId + u.reason) // Unique by user and reason\n  if (uniqueUsersToNotify.length === 0) {\n    log(\n      `No unique users to notify for post comment ${comment.id} on post ${post.id}`\n    )\n    return\n  }\n\n  const postTitle = post.title\n  const commentText = richTextToString(comment.content)\n\n  const buildNotification = (\n    userId: string,\n    reason: NotificationReason\n  ): Notification => {\n    return removeUndefinedProps({\n      id: nanoid(6),\n      userId,\n      reason,\n      createdTime: Date.now(),\n      isSeen: false,\n      sourceId: comment.id,\n      sourceType: 'comment',\n      sourceUpdateType: 'created',\n      sourceUserName: commentCreator.name,\n      sourceUserUsername: commentCreator.username,\n      sourceUserAvatarUrl: commentCreator.avatarUrl,\n      sourceText: commentText,\n      sourceSlug: `post/${post.slug}#${comment.id}`,\n      sourceTitle: postTitle,\n      data: removeUndefinedProps({\n        isReply: !!repliedUserId,\n      }),\n    }) as Notification\n  }\n\n  const allRelevantUserIds = uniq(uniqueUsersToNotify.map((u) => u.userId))\n  if (allRelevantUserIds.length === 0) return\n\n  const privateUsers = await pg.map(\n    `select pu.*, u.name as user_name, u.username as user_username, u.data->>'avatarUrl' as user_avatar_url\n     from private_users pu join users u on pu.id = u.id where pu.id = any($1)`,\n    [allRelevantUserIds],\n    (r) => ({\n      ...convertPrivateUser(r),\n      name: r.user_name,\n      username: r.user_username,\n      avatarUrl: r.user_avatar_url,\n    })\n  )\n  const privateUserMap = new Map(privateUsers.map((user) => [user.id, user]))\n\n  const bulkNotifications: Notification[] = []\n  const bulkEmails: EmailAndTemplateEntry[] = []\n  const bulkPushNotifications: [PrivateUser, Notification, string, string][] =\n    []\n  const usersToReceivedNotifications: Record<\n    string,\n    notification_destination_types[]\n  > = {}\n\n  for (const { userId, reason } of uniqueUsersToNotify) {\n    const privateUser = privateUserMap.get(userId)\n    if (!privateUser || userIsBlocked(privateUser, commentCreator.id)) {\n      continue\n    }\n\n    const { sendToBrowser, sendToMobile, notificationPreference } =\n      getNotificationDestinationsForUser(privateUser, reason)\n\n    const receivedNotifications = usersToReceivedNotifications[userId] ?? []\n\n    if (sendToBrowser && !receivedNotifications.includes('browser')) {\n      bulkNotifications.push(buildNotification(userId, reason))\n      receivedNotifications.push('browser')\n    }\n\n    if (sendToMobile && !receivedNotifications.includes('mobile')) {\n      const reasonText =\n        (notificationPreference &&\n          NOTIFICATION_DESCRIPTIONS[notificationPreference].verb) ||\n        'interacted with a post'\n      const pushNotification = buildNotification(userId, reason)\n      bulkPushNotifications.push([\n        privateUser,\n        pushNotification,\n        `${commentCreator.name} ${reasonText} on ${postTitle}`,\n        commentText,\n      ])\n      receivedNotifications.push('mobile')\n    }\n\n    // if (sendToEmail && !receivedNotifications.includes('email')) {\n    //   const emailPostObject = {\n    //     question: postTitle,\n    //     slug: post.slug,\n    //     id: post.id,\n    //     creatorUsername: post.creatorUsername,\n    //   } as any\n\n    //   const email = getNewCommentEmail(\n    //     reason,\n    //     privateUser,\n    //     privateUser.name,\n    //     commentCreator,\n    //     emailPostObject,\n    //     commentText,\n    //     comment.id,\n    //     undefined\n    //   )\n    //   if (email) {\n    //     bulkEmails.push(email)\n    //   }\n    //   receivedNotifications.push('email')\n    // }\n    usersToReceivedNotifications[userId] = receivedNotifications\n  }\n\n  if (bulkNotifications.length > 0) {\n    await bulkInsertNotifications(bulkNotifications, pg)\n  }\n  if (bulkPushNotifications.length > 0) {\n    await createPushNotifications(bulkPushNotifications)\n  }\n  if (bulkEmails.length > 0) {\n    await sendBulkEmails(\n      `Comment on post: ${postTitle}`,\n      'market-comment-bulk',\n      bulkEmails,\n      `${commentCreator.name} on Manifold <no-reply@manifold.markets>`\n    )\n  }\n\n  log(\n    `Created ${bulkNotifications.length} browser notifications for post comment ${comment.id} on post ${post.id}`\n  )\n}\n",
          "postContent": "import {\n  CommentNotificationData,\n  Notification,\n  NOTIFICATION_DESCRIPTIONS,\n  NotificationReason,\n} from 'common/notification'\nimport { PrivateUser, User } from 'common/user'\nimport { Contract } from 'common/contract'\nimport { isProd, log } from 'shared/utils'\nimport { uniq } from 'lodash'\nimport { removeUndefinedProps } from 'common/util/object'\nimport {\n  sendBulkEmails,\n  getNewCommentEmail,\n  EmailAndTemplateEntry,\n} from '../emails'\nimport {\n  getNotificationDestinationsForUser,\n  notification_destination_types,\n  userIsBlocked,\n} from 'common/user-notification-preferences'\nimport { createPushNotifications } from '../create-push-notifications'\nimport { createSupabaseDirectClient } from 'shared/supabase/init'\nimport {\n  getUniqueBettorIds,\n  getUniqueVoterIds,\n} from 'shared/supabase/contracts'\nimport { isAdminId, isModId } from 'common/envs/constants'\nimport { bulkInsertNotifications } from 'shared/supabase/notifications'\nimport { convertPrivateUser } from 'common/supabase/users'\nimport { nanoid } from 'common/util/random'\nimport { replied_users_info } from 'shared/create-notification'\nimport { TopLevelPost as Post } from 'common/top-level-post'\nimport { PostComment } from 'common/comment'\nimport { richTextToString } from 'common/util/parse'\nimport { uniqBy } from 'lodash'\nimport { SupabaseDirectClient } from 'shared/supabase/init'\n\nconst ALL_TRADERS_ID = isProd()\n  ? 'X3z4hxRXipWvGoFhxlDOVxmP5vL2'\n  : 'eMG8r3PEdRgtGArGGx1VUBGDwY53'\n\nexport const createCommentOnContractNotification = async (\n  sourceId: string,\n  sourceUser: User,\n  sourceText: string,\n  sourceContract: Contract,\n  repliedUsersInfo: replied_users_info,\n  taggedUserIds: string[],\n  requiresResponse: boolean\n) => {\n  const pg = createSupabaseDirectClient()\n\n  const usersToReceivedNotifications: Record<\n    string,\n    notification_destination_types[]\n  > = {}\n\n  const followerIds = await pg.map(\n    `select follow_id from contract_follows where contract_id = $1`,\n    [sourceContract.id],\n    (r) => r.follow_id\n  )\n  const isReply = Object.keys(repliedUsersInfo).length > 0\n  const buildNotification = (userId: string, reason: NotificationReason) => {\n    return removeUndefinedProps({\n      id: nanoid(6),\n      userId,\n      reason,\n      createdTime: Date.now(),\n      isSeen: false,\n      sourceId,\n      sourceType: 'comment',\n      sourceUpdateType: 'created',\n      sourceContractId: sourceContract.id,\n      sourceUserName: sourceUser.name,\n      sourceUserUsername: sourceUser.username,\n      sourceUserAvatarUrl: sourceUser.avatarUrl,\n      sourceText,\n      sourceContractCreatorUsername: sourceContract.creatorUsername,\n      sourceContractTitle: sourceContract.question,\n      sourceContractSlug: sourceContract.slug,\n      sourceSlug: sourceContract.slug,\n      sourceTitle: sourceContract.question,\n      data: {\n        isReply,\n      } as CommentNotificationData,\n      markedAsRead:\n        requiresResponse && sourceContract.creatorId === userId\n          ? false\n          : undefined,\n    }) as Notification\n  }\n\n  const needNotFollowContractReasons = ['tagged_user']\n\n  if (\n    taggedUserIds?.includes(ALL_TRADERS_ID) &&\n    (sourceUser.id === sourceContract.creatorId ||\n      isAdminId(sourceUser.id) ||\n      isModId(sourceUser.id))\n  ) {\n    const allBettors = await getUniqueBettorIds(sourceContract.id, pg)\n    const allVoters = await getUniqueVoterIds(sourceContract.id, pg)\n    const allUsers = uniq(allBettors.concat(allVoters))\n    taggedUserIds.push(...allUsers)\n  }\n  const bettorIds = await getUniqueBettorIds(sourceContract.id, pg)\n\n  const allRelevantUserIds = uniq([\n    ...followerIds,\n    sourceContract.creatorId,\n    ...(taggedUserIds ?? []),\n    ...(repliedUsersInfo ? Object.keys(repliedUsersInfo) : []),\n    ...bettorIds,\n  ])\n  const bulkNotifications: Notification[] = []\n  const bulkEmails: EmailAndTemplateEntry[] = []\n  const bulkPushNotifications: [PrivateUser, Notification, string, string][] =\n    []\n  const privateUsers = await pg.map(\n    `select private_users.*, users.name from private_users\n           join users on private_users.id = users.id\n           where private_users.id = any($1)`,\n    [allRelevantUserIds],\n    (r) => ({ ...convertPrivateUser(r), name: r.name })\n  )\n  const privateUserMap = new Map(privateUsers.map((user) => [user.id, user]))\n\n  const sendNotificationsIfSettingsPermit = async (\n    userId: string,\n    reason: NotificationReason\n  ) => {\n    const privateUser = privateUserMap.get(userId)\n    if (\n      !privateUser ||\n      sourceUser.id == userId ||\n      userIsBlocked(privateUser, sourceUser.id) ||\n      (!followerIds.some((id) => id === userId) &&\n        !needNotFollowContractReasons.includes(reason))\n    )\n      return\n\n    const { sendToBrowser, sendToEmail, sendToMobile, notificationPreference } =\n      getNotificationDestinationsForUser(privateUser, reason)\n\n    const receivedNotifications = usersToReceivedNotifications[userId] ?? []\n\n    // Browser notifications\n    if (sendToBrowser && !receivedNotifications.includes('browser')) {\n      bulkNotifications.push(buildNotification(userId, reason))\n      receivedNotifications.push('browser')\n    }\n\n    // Mobile push notifications\n    if (sendToMobile && !receivedNotifications.includes('mobile')) {\n      const reasonText =\n        (notificationPreference &&\n          NOTIFICATION_DESCRIPTIONS[notificationPreference].verb) ??\n        'commented'\n      const notification = buildNotification(userId, reason)\n      bulkPushNotifications.push([\n        privateUser,\n        notification,\n        `${sourceUser.name} ${reasonText} on ${sourceContract.question}`,\n        sourceText,\n      ])\n      receivedNotifications.push('mobile')\n    }\n\n    // Email notifications\n    if (sendToEmail && !receivedNotifications.includes('email')) {\n      const { bet } = repliedUsersInfo?.[userId] ?? {}\n      // TODO: change subject of email title to be more specific, i.e.: replied to you on/tagged you on/comment\n      const email = getNewCommentEmail(\n        reason,\n        privateUser,\n        privateUser.name,\n        sourceUser,\n        sourceContract,\n        sourceText,\n        sourceId,\n        bet\n      )\n      if (email) {\n        bulkEmails.push(email)\n      }\n      receivedNotifications.push('email')\n    }\n    usersToReceivedNotifications[userId] = receivedNotifications\n  }\n\n  log('notifying replies')\n  if (repliedUsersInfo) {\n    await Promise.all(\n      Object.keys(repliedUsersInfo).map(async (userId) =>\n        sendNotificationsIfSettingsPermit(\n          userId,\n          repliedUsersInfo[userId].repliedToType === 'answer'\n            ? 'reply_to_users_answer'\n            : 'reply_to_users_comment'\n        )\n      )\n    )\n  }\n  log('notifying tagged users')\n  if (taggedUserIds && taggedUserIds.length > 0) {\n    await Promise.all(\n      uniq(taggedUserIds).map(async (userId) =>\n        sendNotificationsIfSettingsPermit(userId, 'tagged_user')\n      )\n    )\n  }\n  log('notifying creator')\n  await sendNotificationsIfSettingsPermit(\n    sourceContract.creatorId,\n    'all_comments_on_my_markets'\n  )\n  log('notifying bettors')\n  await Promise.all(\n    bettorIds.map(async (userId) =>\n      sendNotificationsIfSettingsPermit(\n        userId,\n        'comment_on_contract_with_users_shares_in'\n      )\n    )\n  )\n  log('notifying followers')\n  await Promise.all(\n    followerIds.map(async (userId) =>\n      sendNotificationsIfSettingsPermit(\n        userId,\n        'comment_on_contract_you_follow'\n      )\n    )\n  )\n  await createPushNotifications(bulkPushNotifications)\n  await bulkInsertNotifications(bulkNotifications, pg)\n  await sendBulkEmails(\n    `Comment on ${sourceContract.question}`,\n    'market-comment-bulk',\n    bulkEmails,\n    `${sourceUser.name} on Manifold <no-reply@manifold.markets>`\n  )\n}\n\n// New function for post comment notifications\nexport const createCommentOnPostNotification = async (\n  pg: SupabaseDirectClient,\n  comment: PostComment,\n  post: Post,\n  commentCreator: User,\n  repliedUserId: string | undefined,\n  mentionedUserIds: string[]\n) => {\n  const usersToNotify: { userId: string; reason: NotificationReason }[] = []\n\n  // Fetch post followers\n  const followerIds = await pg.map(\n    `select user_id from post_follows where post_id = $1`,\n    [post.id],\n    (r) => r.user_id\n  )\n\n  // 1. Post Creator\n  if (post.creatorId !== commentCreator.id) {\n    usersToNotify.push({\n      userId: post.creatorId,\n      reason: 'comment_on_your_contract',\n    })\n  }\n\n  // 2. Replied User\n  if (repliedUserId && repliedUserId !== commentCreator.id) {\n    // Ensure replied user is not also the post creator already added\n    if (repliedUserId !== post.creatorId) {\n      usersToNotify.push({\n        userId: repliedUserId,\n        reason: 'reply_to_users_comment',\n      })\n    } else if (\n      repliedUserId === post.creatorId &&\n      post.creatorId !== commentCreator.id\n    ) {\n      // If replied user is the post creator, they'd get 'comment_on_your_post'\n      // If they also need 'reply_to_users_post_comment' for different email/push, handle here\n      // For now, 'comment_on_your_post' takes precedence if they are the creator.\n      // If they are the creator AND the commenter, they get nothing from this rule.\n      // If they are replied to AND the creator (and not the commenter), they get 'comment_on_your_post'.\n      // This specific case for 'reply_to_users_post_comment' might need more nuanced logic\n      // if the notification content/preference check differs significantly.\n      // Let's keep it simple: if they are the creator, 'comment_on_your_post' covers it.\n      // If they are replied to AND NOT the creator, they get 'reply_to_users_post_comment'.\n    }\n  }\n  // Refined logic for Replied User to avoid double notification if also creator,\n  // and ensure they get 'reply_to_users_post_comment' if not the creator.\n  if (\n    repliedUserId &&\n    repliedUserId !== commentCreator.id &&\n    repliedUserId !== post.creatorId\n  ) {\n    usersToNotify.push({\n      userId: repliedUserId,\n      reason: 'reply_to_users_comment',\n    })\n  }\n\n  // 3. Mentioned Users\n  mentionedUserIds.forEach((mentionedUserId) => {\n    // Ensure mentioned user is not the commenter, post creator, or replied user (if already processed)\n    if (\n      mentionedUserId !== commentCreator.id &&\n      mentionedUserId !== post.creatorId &&\n      mentionedUserId !== repliedUserId\n    ) {\n      usersToNotify.push({\n        userId: mentionedUserId,\n        reason: 'tagged_user',\n      })\n    }\n  })\n\n  // 4. Post Followers\n  followerIds.forEach((followerId) => {\n    // Ensure follower is not the commenter, post creator, replied user, or a mentioned user (already processed)\n    if (\n      followerId !== commentCreator.id &&\n      followerId !== post.creatorId &&\n      followerId !== repliedUserId &&\n      !mentionedUserIds.includes(followerId)\n    ) {\n      usersToNotify.push({\n        userId: followerId,\n        reason: 'all_comments_on_followed_posts',\n      })\n    }\n  })\n\n  const uniqueUsersToNotify = uniqBy(usersToNotify, (u) => u.userId + u.reason) // Unique by user and reason\n  if (uniqueUsersToNotify.length === 0) {\n    log(\n      `No unique users to notify for post comment ${comment.id} on post ${post.id}`\n    )\n    return\n  }\n\n  const postTitle = post.title\n  const commentText = richTextToString(comment.content)\n\n  const buildNotification = (\n    userId: string,\n    reason: NotificationReason\n  ): Notification => {\n    return removeUndefinedProps({\n      id: nanoid(6),\n      userId,\n      reason,\n      createdTime: Date.now(),\n      isSeen: false,\n      sourceId: comment.id,\n      sourceType: 'comment',\n      sourceUpdateType: 'created',\n      sourceUserName: commentCreator.name,\n      sourceUserUsername: commentCreator.username,\n      sourceUserAvatarUrl: commentCreator.avatarUrl,\n      sourceText: commentText,\n      sourceSlug: `post/${post.slug}#${comment.id}`,\n      sourceTitle: postTitle,\n      data: removeUndefinedProps({\n        isReply: !!repliedUserId,\n      }),\n    }) as Notification\n  }\n\n  const allRelevantUserIds = uniq(uniqueUsersToNotify.map((u) => u.userId))\n  if (allRelevantUserIds.length === 0) return\n\n  const privateUsers = await pg.map(\n    `select pu.*, u.name as user_name, u.username as user_username, u.data->>'avatarUrl' as user_avatar_url\n     from private_users pu join users u on pu.id = u.id where pu.id = any($1)`,\n    [allRelevantUserIds],\n    (r) => ({\n      ...convertPrivateUser(r),\n      name: r.user_name,\n      username: r.user_username,\n      avatarUrl: r.user_avatar_url,\n    })\n  )\n  const privateUserMap = new Map(privateUsers.map((user) => [user.id, user]))\n\n  const bulkNotifications: Notification[] = []\n  const bulkEmails: EmailAndTemplateEntry[] = []\n  const bulkPushNotifications: [PrivateUser, Notification, string, string][] =\n    []\n  const usersToReceivedNotifications: Record<\n    string,\n    notification_destination_types[]\n  > = {}\n\n  for (const { userId, reason } of uniqueUsersToNotify) {\n    const privateUser = privateUserMap.get(userId)\n    if (!privateUser || userIsBlocked(privateUser, commentCreator.id)) {\n      continue\n    }\n\n    const { sendToBrowser, sendToMobile, notificationPreference } =\n      getNotificationDestinationsForUser(privateUser, reason)\n\n    const receivedNotifications = usersToReceivedNotifications[userId] ?? []\n\n    if (sendToBrowser && !receivedNotifications.includes('browser')) {\n      bulkNotifications.push(buildNotification(userId, reason))\n      receivedNotifications.push('browser')\n    }\n\n    if (sendToMobile && !receivedNotifications.includes('mobile')) {\n      const reasonText =\n        (notificationPreference &&\n          NOTIFICATION_DESCRIPTIONS[notificationPreference].verb) ||\n        'interacted with a post'\n      const pushNotification = buildNotification(userId, reason)\n      bulkPushNotifications.push([\n        privateUser,\n        pushNotification,\n        `${commentCreator.name} ${reasonText} on ${postTitle}`,\n        commentText,\n      ])\n      receivedNotifications.push('mobile')\n    }\n\n    // if (sendToEmail && !receivedNotifications.includes('email')) {\n    //   const emailPostObject = {\n    //     question: postTitle,\n    //     slug: post.slug,\n    //     id: post.id,\n    //     creatorUsername: post.creatorUsername,\n    //   } as any\n\n    //   const email = getNewCommentEmail(\n    //     reason,\n    //     privateUser,\n    //     privateUser.name,\n    //     commentCreator,\n    //     emailPostObject,\n    //     commentText,\n    //     comment.id,\n    //     undefined\n    //   )\n    //   if (email) {\n    //     bulkEmails.push(email)\n    //   }\n    //   receivedNotifications.push('email')\n    // }\n    usersToReceivedNotifications[userId] = receivedNotifications\n  }\n\n  if (bulkNotifications.length > 0) {\n    await bulkInsertNotifications(bulkNotifications, pg)\n  }\n  if (bulkPushNotifications.length > 0) {\n    await createPushNotifications(bulkPushNotifications)\n  }\n  if (bulkEmails.length > 0) {\n    await sendBulkEmails(\n      `Comment on post: ${postTitle}`,\n      'market-comment-bulk',\n      bulkEmails,\n      `${commentCreator.name} on Manifold <no-reply@manifold.markets>`\n    )\n  }\n\n  log(\n    `Created ${bulkNotifications.length} browser notifications for post comment ${comment.id} on post ${post.id}`\n  )\n}\n"
        },
        {
          "path": "backend/supabase/post_follows.sql",
          "preContent": "[NEW FILE]",
          "postContent": "-- This file is autogenerated from regen-schema.ts\ncreate table if not exists\n  post_follows (\n    post_id text not null,\n    created_time timestamp with time zone default now() not null,\n    user_id text not null,\n    primary key (post_id, user_id)\n  );\n\n-- Row Level Security\nalter table post_follows enable row level security;\n\n-- Policies\ndrop policy if exists \"public read\" on post_follows;\n\ncreate policy \"public read\" on post_follows for\nselect\n  using (true);\n\n-- Indexes\ndrop index if exists post_follows_idx;\n\ncreate index post_follows_idx on public.post_follows using btree (user_id);\n"
        },
        {
          "path": "common/src/api/schema.ts",
          "preContent": "import { z } from 'zod'\nimport {\n  Group,\n  MAX_ID_LENGTH,\n  MySearchGroupShape,\n  LiteGroup,\n  SearchGroupParams,\n  SearchGroupShape,\n  Topic,\n} from 'common/group'\nimport {\n  createMarketProps,\n  resolveMarketProps,\n  type LiteMarket,\n  FullMarket,\n  updateMarketProps,\n} from './market-types'\nimport { type Answer } from 'common/answer'\nimport {\n  CommentWithTotalReplies,\n  MAX_COMMENT_LENGTH,\n  PostComment,\n  type ContractComment,\n} from 'common/comment'\nimport { CandidateBet } from 'common/new-bet'\nimport type { Bet, LimitBet } from 'common/bet'\nimport { coerceBoolean, contentSchema } from 'common/api/zod-types'\nimport { Lover } from 'common/love/lover'\nimport { AIGeneratedMarket, Contract, MarketContract } from 'common/contract'\nimport { CompatibilityScore } from 'common/love/compatibility-score'\nimport type { Txn, ManaPayTxn } from 'common/txn'\nimport { LiquidityProvision } from 'common/liquidity-provision'\nimport { DisplayUser, FullUser } from './user-types'\nimport { League } from 'common/leagues'\nimport { searchProps } from './market-search-types'\nimport { MAX_ANSWER_LENGTH } from 'common/answer'\nimport { type LinkPreview } from 'common/link-preview'\nimport { Headline } from 'common/news'\nimport { Row } from 'common/supabase/utils'\nimport { LikeData, ShipData } from './love-types'\nimport { AnyBalanceChangeType } from 'common/balance-change'\nimport { Dashboard } from 'common/dashboard'\nimport { ChatMessage, PrivateChatMessage } from 'common/chat-message'\nimport { PrivateUser, User } from '../user'\nimport { ManaSupply } from 'common/stats'\nimport { Repost } from 'common/repost'\nimport { PERIODS } from 'common/period'\nimport { SWEEPS_MIN_BET } from 'common/economy'\nimport {\n  LivePortfolioMetrics,\n  PortfolioMetrics,\n} from 'common/portfolio-metrics'\nimport { ModReport } from '../mod-report'\n\nimport { RegistrationReturnType } from 'common/reason-codes'\nimport {\n  CheckoutSession,\n  GIDXDocument,\n  GPSProps,\n  PaymentDetail,\n  checkoutParams,\n  verificationParams,\n  cashoutRequestParams,\n  PendingCashoutStatusData,\n  cashoutParams,\n} from 'common/gidx/gidx'\nimport { notification_preference } from 'common/user-notification-preferences'\nimport { PrivateMessageChannel } from 'common/supabase/private-messages'\nimport { Notification } from 'common/notification'\nimport { NON_POINTS_BETS_LIMIT } from 'common/supabase/bets'\nimport { ContractMetric } from 'common/contract-metric'\n\nimport { JSONContent } from '@tiptap/core'\nimport { Task, TaskCategory } from 'common/todo'\nimport { ChartAnnotation } from 'common/supabase/chart-annotations'\nimport { Dictionary } from 'lodash'\nimport { Reaction } from 'common/reaction'\nimport { YEAR_MS } from 'common/util/time'\nimport { MarketDraft } from 'common/drafts'\nimport { TopLevelPost } from 'common/top-level-post'\n// mqp: very unscientific, just balancing our willingness to accept load\n// with user willingness to put up with stale data\nexport const DEFAULT_CACHE_STRATEGY =\n  'public, max-age=5, stale-while-revalidate=10'\nconst MAX_EXPIRES_AT = 1_000 * YEAR_MS\n\ntype APIGenericSchema = {\n  // GET is for retrieval, POST is to mutate something, PUT is idempotent mutation (can be repeated safely)\n  method: 'GET' | 'POST' | 'PUT'\n  //private APIs can only be called from manifold. undocumented endpoints can change or be deleted at any time!\n  visibility: 'public' | 'undocumented' | 'private'\n  // whether the endpoint requires authentication\n  authed: boolean\n  // zod schema for the request body (or for params for GET requests)\n  props: z.ZodType\n  // note this has to be JSON serializable\n  returns?: Record<string, any>\n  // Cache-Control header. like, 'max-age=60'\n  cache?: string\n  // whether the endpoint should prefer authentication even if not required\n  preferAuth?: boolean\n}\n\nlet _apiTypeCheck: { [x: string]: APIGenericSchema }\nexport const API = (_apiTypeCheck = {\n  'refresh-all-clients': {\n    method: 'POST',\n    visibility: 'public',\n    props: z.object({ message: z.string().optional() }),\n    authed: true,\n  },\n  'toggle-system-trading-status': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        token: z.enum(['MANA', 'CASH']),\n      })\n      .strict(),\n    returns: {} as { status: boolean },\n  },\n  comment: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as ContractComment,\n    props: z\n      .object({\n        contractId: z.string(),\n        content: contentSchema.optional(),\n        html: z.string().optional(),\n        markdown: z.string().optional(),\n        replyToCommentId: z.string().optional(),\n        replyToAnswerId: z.string().optional(),\n        replyToBetId: z.string().optional(),\n      })\n      .strict(),\n  },\n\n  'follow-contract': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: true },\n    props: z\n      .object({\n        contractId: z.string(),\n        follow: z.boolean(),\n      })\n      .strict(),\n  },\n  'get-contract': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as Contract,\n    props: z\n      .object({\n        contractId: z.string(),\n      })\n      .strict(),\n  },\n  'answer/:answerId': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as Answer,\n    props: z.object({ answerId: z.string() }).strict(),\n  },\n  'market/:contractId/answers': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: [] as Answer[],\n    props: z.object({ contractId: z.string() }).strict(),\n  },\n  'hide-comment': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ commentPath: z.string() }).strict(),\n  },\n  'pin-comment': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({ commentPath: z.string() }).strict(),\n  },\n  comments: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    // cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as ContractComment[],\n    props: z\n      .object({\n        contractId: z.string().optional(),\n        contractSlug: z.string().optional(),\n        afterTime: z.coerce.number().optional(),\n        limit: z.coerce.number().gte(0).lte(1000).default(1000),\n        page: z.coerce.number().gte(0).default(0),\n        userId: z.string().optional(),\n        isPolitics: coerceBoolean.optional(),\n      })\n      .strict(),\n  },\n  bet: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as CandidateBet & { betId: string },\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gte(SWEEPS_MIN_BET),\n        replyToCommentId: z.string().optional(),\n        limitProb: z.number().gte(0.01).lte(0.99).optional(),\n        expiresMillisAfter: z.number().lt(MAX_EXPIRES_AT).optional(),\n        silent: z.boolean().optional(),\n        expiresAt: z.number().lt(MAX_EXPIRES_AT).optional(),\n        // Used for binary and new multiple choice contracts (cpmm-multi-1).\n        outcome: z.enum(['YES', 'NO']).default('YES'),\n        //Multi\n        answerId: z.string().optional(),\n        dryRun: z.boolean().optional(),\n        deps: z.array(z.string()).optional(),\n        deterministic: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  createuser: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { user: User; privateUser: PrivateUser },\n    props: z\n      .object({\n        deviceToken: z.string().optional(),\n        adminToken: z.string().optional(),\n        visitedContractIds: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'multi-bet': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as (CandidateBet & { betId: string })[],\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gte(1),\n        limitProb: z.number().gte(0).lte(1).optional(),\n        expiresAt: z.number().lt(MAX_EXPIRES_AT).optional(),\n        answerIds: z.array(z.string()).min(1),\n        deterministic: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  'multi-sell': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as (CandidateBet & { betId: string })[],\n    props: z\n      .object({\n        contractId: z.string(),\n        answerIds: z.array(z.string()).min(1),\n        deterministic: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  leaderboard: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as { userId: string; score: number }[],\n    props: z\n      .object({\n        groupId: z.string().optional(),\n        limit: z.coerce.number().min(1).max(100).default(50),\n        token: z.enum(['MANA', 'CASH']).default('MANA'),\n        kind: z.enum(['creator', 'profit', 'loss', 'volume', 'referral']),\n      })\n      .strict(),\n  },\n  'verify-phone-number': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { status: string },\n    props: z\n      .object({\n        phoneNumber: z.string(),\n        code: z.string(),\n      })\n      .strict(),\n  },\n  'request-otp': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { status: string },\n    props: z\n      .object({\n        phoneNumber: z.string(),\n      })\n      .strict(),\n  },\n  'bet/cancel/:betId': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ betId: z.string() }).strict(),\n    returns: {} as LimitBet,\n  },\n  // sell shares\n  'market/:contractId/sell': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as CandidateBet & { betId: string },\n    props: z\n      .object({\n        contractId: z.string(),\n        shares: z.number().positive().optional(), // leave it out to sell all shares\n        outcome: z.enum(['YES', 'NO']),\n        answerId: z.string().optional(), // Required for multi binary markets\n        deterministic: z.boolean().optional(),\n        deps: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'get-user-limit-orders-with-contracts': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as {\n      bets: LimitBet[]\n      contracts: MarketContract[]\n    },\n    props: z\n      .object({\n        userId: z.string(),\n        count: z.coerce.number().lte(5000),\n        includeExpired: coerceBoolean.optional().default(false),\n        includeCancelled: coerceBoolean.optional().default(false),\n        includeFilled: coerceBoolean.optional().default(false),\n      })\n      .strict(),\n  },\n  'get-interesting-groups-from-views': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as (Group & { hasBet: boolean })[],\n    props: z\n      .object({\n        userId: z.string(),\n        contractIds: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  bets: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Bet[],\n    props: z\n      .object({\n        id: z.string().optional(),\n        userId: z.string().optional(),\n        username: z.string().optional(),\n        contractId: z.string().or(z.array(z.string())).optional(),\n        contractSlug: z.string().optional(),\n        answerId: z.string().optional(),\n        // market: z.string().optional(), // deprecated, synonym for `contractSlug`\n        limit: z.coerce\n          .number()\n          .gte(0)\n          .lte(50000)\n          .default(NON_POINTS_BETS_LIMIT),\n        before: z.string().optional(),\n        after: z.string().optional(),\n        beforeTime: z.coerce.number().optional(),\n        afterTime: z.coerce.number().optional(),\n        order: z.enum(['asc', 'desc']).optional(),\n        kinds: z.enum(['open-limit']).optional(),\n        // undocumented fields. idk what a good api interface would be\n        filterRedemptions: coerceBoolean.optional(),\n        includeZeroShareRedemptions: coerceBoolean.optional(),\n        commentRepliesOnly: coerceBoolean.optional(),\n        count: coerceBoolean.optional(),\n        points: coerceBoolean.optional(),\n      })\n      .strict(),\n  },\n  'bet-points': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: 'public, max-age=600, stale-while-revalidate=60',\n    returns: [] as Bet[],\n    props: z\n      .object({\n        contractId: z.string(),\n        answerId: z.string().optional(),\n        limit: z.coerce.number().gte(0).lte(50000).default(5000),\n        beforeTime: z.coerce.number(),\n        afterTime: z.coerce.number(),\n        filterRedemptions: coerceBoolean.optional(),\n        includeZeroShareRedemptions: coerceBoolean.optional(),\n      })\n      .strict(),\n  },\n  'unique-bet-group-count': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as { count: number },\n    props: z\n      .object({\n        contractId: z.string(),\n      })\n      .strict(),\n  },\n  'get-daily-changed-metrics-and-contracts': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    cache: 'public, max-age=900, stale-while-revalidate=90', // 15 minute cache\n    props: z\n      .object({\n        limit: z.coerce.number(),\n        userId: z.string(),\n        balance: z.coerce.number(),\n      })\n      .strict(),\n    returns: {} as {\n      manaMetrics: ContractMetric[]\n      contracts: MarketContract[]\n      manaProfit: number\n      manaInvestmentValue: number\n      balance: number\n    },\n  },\n  // deprecated. use /bets?username= instead\n  'user/:username/bets': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Bet[],\n    props: z\n      .object({\n        username: z.string(),\n        limit: z.coerce.number().gte(0).lte(1000).default(1000),\n      })\n      .strict(),\n  },\n  'group/:slug': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as Group,\n    props: z.object({ slug: z.string() }),\n  },\n  'group/:slug/groups': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as { above: LiteGroup[]; below: LiteGroup[] },\n    props: z.object({ slug: z.string() }).strict(),\n  },\n  'group/:slug/dashboards': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as {\n      id: string\n      title: string\n      slug: string\n      creatorId: string\n    }[],\n    props: z.object({ slug: z.string() }).strict(),\n  },\n  'group/by-id/:id/groups': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as { above: LiteGroup[]; below: LiteGroup[] },\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'group/by-id/:id': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as Group,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  // deprecated. use /markets?groupId= instead\n  'group/by-id/:id/markets': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as LiteMarket[],\n    props: z\n      .object({\n        id: z.string(),\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n      })\n      .strict(),\n  },\n  'group/:slug/delete': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ slug: z.string() }),\n  },\n  'group/by-id/:id/delete': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ id: z.string() }),\n  },\n  'group/:slug/block': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ slug: z.string() }),\n  },\n  'group/:slug/unblock': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ slug: z.string() }).strict(),\n  },\n  'group/by-id/:topId/group/:bottomId': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        topId: z.string(),\n        bottomId: z.string(),\n        remove: z.boolean().optional(),\n      })\n      .strict(),\n    returns: {} as { status: 'success' },\n  },\n  groups: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Group[],\n    props: z\n      .object({\n        availableToUserId: z.string().optional(),\n        beforeTime: z.coerce.number().int().optional(),\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n      })\n      .strict(),\n  },\n  'market/:id': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as LiteMarket | FullMarket,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z.object({ id: z.string(), lite: coerceBoolean.optional() }),\n  },\n  'market/:id/prob': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as {\n      prob?: number\n      answerProbs?: { [answerId: string]: number }\n    },\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'market-probs': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as {\n      [contractId: string]: {\n        prob?: number\n        answerProbs?: { [answerId: string]: number }\n      }\n    },\n    props: z\n      .object({\n        ids: z.array(z.string()).max(100),\n      })\n      .strict(),\n  },\n  'markets-by-ids': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: [] as Contract[],\n    props: z\n      .object({\n        ids: z.array(z.string()).max(100),\n      })\n      .strict(),\n  },\n  // deprecated. use /market/:id?lite=true instead\n  'market/:id/lite': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as LiteMarket,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z.object({ id: z.string() }),\n  },\n  'slug/:slug': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as LiteMarket | FullMarket,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z.object({ slug: z.string(), lite: coerceBoolean.optional() }),\n  },\n  market: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as LiteMarket,\n    props: createMarketProps,\n  },\n  'market/:contractId/update': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: updateMarketProps,\n    returns: {} as { success: true },\n  },\n  'market/:contractId/close': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    // returns: {} as LiteMarket,\n    props: z\n      .object({\n        contractId: z.string(),\n        closeTime: z.number().int().nonnegative().optional(),\n      })\n      .strict(),\n  },\n  'market/:contractId/resolve': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { message: string },\n    props: resolveMarketProps,\n  },\n  'market/:contractId/add-liquidity': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as LiquidityProvision,\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gt(0).finite(),\n      })\n      .strict(),\n  },\n  'market/:contractId/remove-liquidity': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as LiquidityProvision,\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gt(0).finite(),\n      })\n      .strict(),\n  },\n  'market/:contractId/add-bounty': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as Txn,\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gt(0).finite(),\n      })\n      .strict(),\n  },\n  'market/:contractId/award-bounty': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as Txn,\n    props: z\n      .object({\n        contractId: z.string(),\n        commentId: z.string(),\n        amount: z.number().gt(0).finite(),\n      })\n      .strict(),\n  },\n  'market/:contractId/group': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        contractId: z.string(),\n        groupId: z.string(),\n        remove: z.boolean().default(false),\n      })\n      .strict(),\n    returns: {} as { success: true },\n  },\n  'market/:contractId/groups': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({ contractId: z.string() }),\n    returns: [] as LiteGroup[],\n  },\n  'market/:contractId/answer': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { newAnswerId: string },\n    props: z\n      .object({\n        contractId: z.string().max(MAX_ANSWER_LENGTH),\n        text: z.string().min(1).max(MAX_ANSWER_LENGTH),\n      })\n      .strict(),\n  },\n  'market/:contractId/block': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ contractId: z.string() }).strict(),\n  },\n  'market/:contractId/unblock': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ contractId: z.string() }).strict(),\n  },\n  unresolve: {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { success: true },\n    props: z\n      .object({\n        contractId: z.string().max(MAX_ANSWER_LENGTH),\n        answerId: z.string().max(MAX_ANSWER_LENGTH).optional(),\n      })\n      .strict(),\n  },\n  leagues: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as League[],\n    props: z\n      .object({\n        userId: z.string().optional(),\n        cohort: z.string().optional(),\n        season: z.coerce.number().optional(),\n      })\n      .strict(),\n  },\n  markets: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as LiteMarket[],\n    props: z\n      .object({\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n        sort: z\n          .enum([\n            'created-time',\n            'updated-time',\n            'last-bet-time',\n            'last-comment-time',\n          ])\n          .optional(),\n        order: z.enum(['asc', 'desc']).optional(),\n        before: z.string().optional(),\n        userId: z.string().optional(),\n        groupId: z.string().optional(),\n      })\n      .strict(),\n  },\n  'search-markets': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as LiteMarket[],\n    props: searchProps,\n  },\n  'search-markets-full': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    preferAuth: true,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Contract[],\n    props: searchProps,\n  },\n  managram: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        amount: z.number().finite(),\n        toIds: z.array(z.string()),\n        message: z.string().max(MAX_COMMENT_LENGTH),\n        groupId: z.string().max(MAX_ID_LENGTH).optional(),\n        token: z.enum(['M$', 'CASH']).default('M$'),\n      })\n      .strict(),\n  },\n  manalink: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { slug: string },\n    props: z\n      .object({\n        amount: z.number().positive().finite().safe(),\n        expiresTime: z.number().lt(MAX_EXPIRES_AT).optional(),\n        maxUses: z.number().optional(),\n        message: z.string().optional(),\n      })\n      .strict(),\n  },\n  donate: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        amount: z.number().positive().finite().safe(),\n        to: z.string(),\n      })\n      .strict(),\n  },\n  'convert-sp-to-mana': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ amount: z.number().positive().finite().safe() }).strict(),\n  },\n  'convert-cash-to-mana': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ amount: z.number().positive().finite().safe() }).strict(),\n  },\n  'request-loan': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({}),\n    returns: {} as { payout: number },\n  },\n  // deprecated. use /txns instead\n  managrams: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: [] as ManaPayTxn[],\n    props: z\n      .object({\n        toId: z.string().optional(),\n        fromId: z.string().optional(),\n        limit: z.coerce.number().gte(0).lte(100).default(100),\n        before: z.coerce.number().optional(),\n        after: z.coerce.number().optional(),\n      })\n      .strict(),\n  },\n  'market/:id/positions': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as ContractMetric[],\n    props: z\n      .object({\n        id: z.string(),\n        userId: z.string().optional(),\n        answerId: z.string().optional(),\n        summaryOnly: z.boolean().optional(),\n        top: z.undefined().or(z.coerce.number()),\n        bottom: z.undefined().or(z.coerce.number()),\n        order: z.enum(['shares', 'profit']).optional(),\n      })\n      .strict(),\n  },\n  me: {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z.object({}),\n    returns: {} as FullUser,\n  },\n  'me/update': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({\n      name: z.string().trim().min(1).optional(),\n      username: z.string().trim().min(1).optional(),\n      avatarUrl: z.string().optional(),\n      bio: z.string().optional(),\n      website: z.string().optional(),\n      twitterHandle: z.string().optional(),\n      discordHandle: z.string().optional(),\n      // settings\n      optOutBetWarnings: z.boolean().optional(),\n      isAdvancedTrader: z.boolean().optional(),\n      //internal\n      seenStreakModal: z.boolean().optional(),\n      shouldShowWelcome: z.boolean().optional(),\n      hasSeenContractFollowModal: z.boolean().optional(),\n      hasSeenLoanModal: z.boolean().optional(),\n    }),\n    returns: {} as FullUser,\n  },\n  'me/delete': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({\n      username: z.string(), // just so you're sure\n    }),\n  },\n  'me/private': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z.object({}),\n    returns: {} as PrivateUser,\n  },\n  'me/private/update': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    props: z\n      .object({\n        email: z.string().email().optional(),\n        apiKey: z.string().optional(),\n        pushToken: z.string().optional(),\n        rejectedPushNotificationsOn: z.number().optional(),\n        lastPromptedToEnablePushNotifications: z.number().optional(),\n        interestedInPushNotifications: z.boolean().optional(),\n        hasSeenAppBannerInNotificationsOn: z.number().optional(),\n        installedAppPlatforms: z.array(z.string()).optional(),\n        paymentInfo: z.string().optional(),\n        lastAppReviewTime: z.number().optional(),\n      })\n      .strict(),\n  },\n  'user/:username': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as FullUser,\n    props: z.object({ username: z.string() }).strict(),\n  },\n  'user/:username/lite': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as DisplayUser,\n    props: z.object({ username: z.string() }).strict(),\n  },\n  'user/by-id/:id': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    // Do not add a caching strategy here. New users need up-to-date data.\n    returns: {} as FullUser,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'user/by-id/:id/lite': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as DisplayUser,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'users/by-id': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as DisplayUser[],\n    props: z.object({ ids: z.array(z.string()) }).strict(),\n  },\n  'users/by-id/balance': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as { id: string; balance: number }[],\n    props: z.object({ ids: z.array(z.string()) }).strict(),\n  },\n  'user/by-id/:id/block': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'user/by-id/:id/unblock': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  users: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as FullUser[],\n    props: z\n      .object({\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n        before: z.string().optional(),\n      })\n      .strict(),\n  },\n  'search-users': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as FullUser[],\n    props: z\n      .object({\n        term: z.string(),\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n        page: z.coerce.number().gte(0).default(0),\n      })\n      .strict(),\n  },\n  'search-contract-positions': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as DisplayUser[],\n    props: z\n      .object({\n        term: z.string(),\n        contractId: z.string(),\n        limit: z.coerce.number().gte(0).lte(100).default(10),\n      })\n      .strict(),\n  },\n  'save-twitch': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        twitchInfo: z.object({\n          twitchName: z.string().optional(),\n          controlToken: z.string().optional(),\n          botEnabled: z.boolean().optional(),\n          needsRelinking: z.boolean().optional(),\n        }),\n      })\n      .strict(),\n  },\n  'set-push-token': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({ pushToken: z.string() }).strict(),\n  },\n  'update-notif-settings': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      type: z.string() as z.ZodType<notification_preference>,\n      medium: z.enum(['email', 'browser', 'mobile']),\n      enabled: z.boolean(),\n    }),\n  },\n  headlines: {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: [] as Headline[],\n    props: z.object({\n      slug: z.enum(['politics', 'ai', 'news']).optional(),\n    }),\n  },\n  'politics-headlines': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: [] as Headline[],\n    props: z.object({}),\n  },\n  'set-news': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { success: true },\n    props: z\n      .object({\n        dashboardIds: z.array(z.string()),\n        endpoint: z.enum(['politics', 'ai', 'news']),\n      })\n      .strict(),\n  },\n  react: {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        contentId: z.string(),\n        contentType: z.enum(['comment', 'contract', 'post']),\n        commentParentType: z.enum(['post']).optional(),\n        remove: z.boolean().optional(),\n        reactionType: z.enum(['like', 'dislike']).optional().default('like'),\n      })\n      .strict(),\n    returns: { success: true },\n  },\n  'compatible-lovers': {\n    method: 'GET',\n    visibility: 'private',\n    authed: false,\n    props: z.object({ userId: z.string() }),\n    returns: {} as {\n      lover: Lover\n      compatibleLovers: Lover[]\n      loverCompatibilityScores: {\n        [userId: string]: CompatibilityScore\n      }\n    },\n  },\n  post: {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    returns: {} as ContractComment,\n    props: z\n      .object({\n        contractId: z.string(),\n        betId: z.string().optional(),\n        commentId: z.string().optional(),\n        content: contentSchema.optional(),\n      })\n      .strict(),\n  },\n  'fetch-link-preview': {\n    method: 'GET',\n    visibility: 'private',\n    authed: false,\n    props: z.object({ url: z.string() }).strict(),\n    cache: 'max-age=86400, stale-while-revalidate=86400',\n    returns: {} as LinkPreview,\n  },\n  'remove-pinned-photo': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    returns: { success: true },\n    props: z\n      .object({\n        userId: z.string(),\n      })\n      .strict(),\n  },\n  'get-related-markets': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    props: z\n      .object({\n        contractId: z.string(),\n        limit: z.coerce.number().gte(0).lte(100),\n        userId: z.string().optional(),\n        question: z.string().optional(),\n        uniqueBettorCount: z.coerce.number().gte(0).optional(),\n      })\n      .strict(),\n    returns: {} as {\n      marketsFromEmbeddings: Contract[]\n    },\n    cache: 'public, max-age=3600, stale-while-revalidate=10',\n  },\n  'get-related-markets-by-group': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: 'public, max-age=3600, stale-while-revalidate=10',\n    returns: {} as {\n      groupContracts: Contract[]\n    },\n    props: z\n      .object({\n        contractId: z.string(),\n        limit: z.coerce.number().gte(0).lte(100),\n        offset: z.coerce.number().gte(0),\n      })\n      .strict(),\n  },\n  'unlist-and-cancel-user-contracts': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        userId: z.string(),\n      })\n      .strict(),\n  },\n  'get-boost-analytics': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: false,\n    props: z\n      .object({\n        contractId: z.string(),\n      })\n      .strict(),\n    returns: {} as {\n      uniqueViewers: number\n      totalViews: number\n      uniquePromotedViewers: number\n      totalPromotedViews: number\n      boostPeriods: {\n        startTime: string\n        endTime: string\n      }[]\n    },\n  },\n  'get-seen-market-ids': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      contractIds: z.array(z.string()),\n      types: z.array(z.enum(['page', 'card', 'promoted'])).optional(),\n      since: z.number(),\n    }),\n    returns: [] as string[],\n  },\n  'get-compatibility-questions': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({}),\n    returns: {} as {\n      status: 'success'\n      questions: (Row<'love_questions'> & {\n        answer_count: number\n        score: number\n      })[]\n    },\n  },\n  'like-lover': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    props: z.object({\n      targetUserId: z.string(),\n      remove: z.boolean().optional(),\n    }),\n    returns: {} as {\n      status: 'success'\n    },\n  },\n  'ship-lovers': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    props: z.object({\n      targetUserId1: z.string(),\n      targetUserId2: z.string(),\n      remove: z.boolean().optional(),\n    }),\n    returns: {} as {\n      status: 'success'\n    },\n  },\n\n  'get-likes-and-ships': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z\n      .object({\n        userId: z.string(),\n      })\n      .strict(),\n    returns: {} as {\n      status: 'success'\n      likesReceived: LikeData[]\n      likesGiven: LikeData[]\n      ships: ShipData[]\n    },\n  },\n  'has-free-like': {\n    method: 'GET',\n    visibility: 'private',\n    authed: true,\n    props: z.object({}).strict(),\n    returns: {} as {\n      status: 'success'\n      hasFreeLike: boolean\n    },\n  },\n  'star-lover': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    props: z.object({\n      targetUserId: z.string(),\n      remove: z.boolean().optional(),\n    }),\n    returns: {} as {\n      status: 'success'\n    },\n  },\n  'get-lovers': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({}).strict(),\n    returns: {} as {\n      status: 'success'\n      lovers: Lover[]\n    },\n  },\n  'get-lover-answers': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({ userId: z.string() }).strict(),\n    returns: {} as {\n      status: 'success'\n      answers: Row<'love_compatibility_answers'>[]\n    },\n  },\n  'search-groups': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    // Is there a way to infer return { lite:[] as LiteGroup[] } if type is 'lite'?\n    returns: {\n      full: [] as Group[],\n      lite: [] as LiteGroup[],\n    },\n    props: SearchGroupParams(SearchGroupShape),\n  },\n  'search-my-groups': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {\n      full: [] as Group[],\n      lite: [] as LiteGroup[],\n    },\n    props: SearchGroupParams(MySearchGroupShape),\n  },\n  'get-groups-with-top-contracts': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as { topic: Topic; contracts: Contract[] }[],\n    props: z.object({}),\n  },\n  'get-balance-changes': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: [] as AnyBalanceChangeType[],\n    props: z\n      .object({\n        before: z.coerce.number().optional(),\n        after: z.coerce.number().default(0),\n        userId: z.string(),\n      })\n      .strict(),\n  },\n  'get-partner-stats': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z\n      .object({\n        userId: z.string(),\n      })\n      .strict(),\n    returns: {} as {\n      status: 'success' | 'error'\n      username: string\n      numContractsCreated: number\n      numUniqueBettors: number\n      numReferrals: number\n      numReferralsWhoRetained: number\n      totalTraderIncome: number\n      totalReferralIncome: number\n      dollarsEarned: number\n    },\n  },\n  'record-contract-view': {\n    method: 'POST',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      userId: z.string().optional(),\n      contractId: z.string(),\n      kind: z.enum(['page', 'card', 'promoted']),\n    }),\n    returns: {} as { status: 'success' },\n  },\n  'record-comment-view': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({\n      contractId: z.string(),\n      commentId: z.string(),\n    }),\n    returns: {} as { status: 'success' },\n  },\n  'record-contract-interaction': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({\n      contractId: z.string(),\n      kind: z.enum([\n        'page bet',\n        'page comment',\n        'page repost',\n        'page like',\n        'card bet',\n        'card click',\n        'promoted click',\n        'card like',\n        'page share',\n        'browse click',\n      ]),\n      commentId: z.string().optional(),\n      feedReasons: z.array(z.string()).optional(),\n      feedType: z.string().optional(),\n      betGroupId: z.string().optional(),\n      betId: z.string().optional(),\n    }),\n    returns: {} as { status: 'success' },\n  },\n  'get-dashboard-from-slug': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      dashboardSlug: z.string(),\n    }),\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as Dashboard,\n  },\n  'get-posts': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    preferAuth: true,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z\n      .object({\n        sortBy: z\n          .enum(['created_time', 'importance_score'])\n          .optional()\n          .default('created_time'),\n        term: z.string().optional(),\n        limit: z.coerce.number().gte(0).lte(200).default(100),\n        userId: z.string().optional(),\n        offset: z.coerce.number().gte(0).default(0),\n      })\n      .strict(),\n    returns: [] as TopLevelPost[],\n  },\n  'create-public-chat-message': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as ChatMessage,\n    props: z.object({\n      content: contentSchema,\n      channelId: z.string(),\n    }),\n  },\n  'get-followed-groups': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      userId: z.string(),\n    }),\n    returns: {} as {\n      groups: Group[]\n    },\n  },\n  'get-user-portfolio': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      userId: z.string(),\n    }),\n    returns: {} as LivePortfolioMetrics,\n  },\n  'get-user-portfolio-history': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      userId: z.string(),\n      period: z.enum(PERIODS),\n    }),\n    returns: {} as PortfolioMetrics[],\n  },\n  'get-channel-memberships': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      channelId: z.coerce.number().optional(),\n      createdTime: z.string().optional(),\n      lastUpdatedTime: z.string().optional(),\n      limit: z.coerce.number(),\n    }),\n    returns: {\n      channels: [] as PrivateMessageChannel[],\n      memberIdsByChannelId: {} as { [channelId: string]: string[] },\n    },\n  },\n  'get-channel-messages': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      channelId: z.coerce.number(),\n      limit: z.coerce.number(),\n      id: z.coerce.number().optional(),\n    }),\n    returns: [] as PrivateChatMessage[],\n  },\n  'get-channel-seen-time': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      channelIds: z.array(z.coerce.number()),\n    }),\n    returns: [] as [number, string][],\n  },\n  'set-channel-seen-time': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      channelId: z.coerce.number(),\n    }),\n  },\n  'get-feed': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as {\n      contracts: Contract[]\n      comments: ContractComment[]\n      bets: Bet[]\n      reposts: Repost[]\n      idsToReason: { [id: string]: string }\n    },\n    props: z\n      .object({\n        userId: z.string(),\n        limit: z.coerce.number().gt(0).lte(100).default(100),\n        offset: z.coerce.number().gte(0).default(0),\n        ignoreContractIds: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'get-mana-supply': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as ManaSupply,\n    props: z.object({}).strict(),\n  },\n  'get-notifications': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as Notification[],\n    props: z\n      .object({\n        after: z.coerce.number().optional(),\n        limit: z.coerce.number().gte(0).lte(1000).default(100),\n      })\n      .strict(),\n  },\n  'update-mod-report': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        reportId: z.number(),\n        updates: z\n          .object({\n            status: z\n              .enum(['new', 'under review', 'resolved', 'needs admin'])\n              .optional(),\n            mod_note: z.string().optional(),\n          })\n          .partial(),\n      })\n      .strict(),\n    returns: {} as { status: string; report: ModReport },\n  },\n  'get-mod-reports': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        statuses: z.array(\n          z.enum(['new', 'under review', 'resolved', 'needs admin'])\n        ),\n        limit: z.coerce.number().gte(0).lte(100).default(25),\n        offset: z.coerce.number().gte(0).default(0),\n        count: coerceBoolean.optional(),\n      })\n      .strict(),\n    returns: {} as {\n      status: string\n      count?: number\n      reports: ModReport[]\n    },\n  },\n  'get-txn-summary-stats': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as Row<'txn_summary_stats'>[],\n    props: z\n      .object({\n        ignoreCategories: z.array(z.string()).optional(),\n        fromType: z.string().optional(),\n        toType: z.string().optional(),\n        limitDays: z.coerce.number(),\n      })\n      .strict(),\n  },\n  'get-mana-summary-stats': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as Row<'mana_supply_stats'>[],\n    props: z\n      .object({\n        limitDays: z.coerce.number(),\n      })\n      .strict(),\n  },\n  'register-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: verificationParams,\n    returns: {} as RegistrationReturnType,\n  },\n  'get-verification-status-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      documents?: GIDXDocument[]\n      message?: string\n      documentStatus?: string\n    },\n    props: z.object({}),\n  },\n  'get-monitor-status-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n    },\n    props: z.object({\n      DeviceGPS: GPSProps,\n    }),\n  },\n  'get-checkout-session-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n      session?: CheckoutSession\n    },\n    props: z.object({\n      PayActionCode: z.enum(['PAY', 'PAYOUT']).default('PAY'),\n      DeviceGPS: GPSProps,\n      userId: z.string().optional(),\n      ip: z.string().optional(),\n    }),\n  },\n  'complete-checkout-session-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n      gidxMessage?: string | null\n      details?: PaymentDetail[]\n    },\n    props: z.object(checkoutParams),\n  },\n  'complete-cashout-session-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n      gidxMessage?: string | null\n      details?: PaymentDetail[]\n    },\n    props: z.object(cashoutParams),\n  },\n  'complete-cashout-request': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n      gidxMessage?: string | null\n      details?: PaymentDetail[]\n    },\n    props: z.object(cashoutRequestParams),\n  },\n  'get-verification-documents-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      documents: GIDXDocument[]\n      utilityDocuments: GIDXDocument[]\n      idDocuments: GIDXDocument[]\n      rejectedDocuments: GIDXDocument[]\n    },\n    props: z.object({}),\n  },\n  'upload-document-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { status: string },\n    props: z.object({\n      CategoryType: z.number().gte(1).lte(7),\n      fileName: z.string(),\n      fileUrl: z.string(),\n    }),\n  },\n  'identity-callback-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as { Accepted: boolean },\n    props: z.object({\n      MerchantCustomerID: z.string(),\n      NotificationType: z.string(),\n    }),\n  },\n  'payment-callback-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as { MerchantTransactionID: string },\n    props: z\n      .object({\n        MerchantTransactionID: z.string(),\n        TransactionStatusCode: z.coerce.number(),\n        TransactionStatusMessage: z.string(),\n        StatusCode: z.coerce.number(),\n        SessionID: z.string(),\n        MerchantSessionID: z.string(),\n        SessionScore: z.coerce.number(),\n        ReasonCodes: z.array(z.string()).optional(),\n        ServiceType: z.string(),\n        StatusMessage: z.string(),\n      })\n      .strict(),\n  },\n  'get-best-comments': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { comments: ContractComment[]; contracts: Contract[] },\n    props: z.object({\n      limit: z.coerce.number().gte(0).lte(100).default(20),\n      offset: z.coerce.number().gte(0).default(0),\n      ignoreContractIds: z.array(z.string()).optional(),\n      justLikes: z.coerce.number().optional(),\n    }),\n  },\n  'get-redeemable-prize-cash': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { redeemablePrizeCash: number },\n    props: z.object({}),\n  },\n  'get-total-redeemable-prize-cash': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as { total: number },\n    props: z.object({}),\n  },\n  'get-cashouts': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as PendingCashoutStatusData[],\n    props: z\n      .object({\n        limit: z.coerce.number().gte(0).lte(100).default(10),\n        offset: z.coerce.number().gte(0).default(0),\n        userId: z.string().optional(),\n      })\n      .strict(),\n  },\n  'get-kyc-stats': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({}),\n    returns: {} as {\n      initialVerifications: {\n        count: number\n        day: string\n      }[]\n      phoneVerifications: {\n        count: number\n        day: string\n      }[]\n    },\n  },\n  txns: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z\n      .object({\n        token: z.string().optional(),\n        offset: z.coerce.number().default(0),\n        limit: z.coerce.number().gte(0).lte(100).default(100),\n        before: z.coerce.number().optional(),\n        after: z.coerce.number().optional(),\n        toId: z.string().optional(),\n        fromId: z.string().optional(),\n        category: z.string().optional(),\n        ignoreCategories: z.array(z.string()).optional(),\n      })\n      .strict(),\n    returns: [] as Txn[],\n  },\n  'generate-ai-market-suggestions': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: [] as AIGeneratedMarket[],\n    props: z\n      .object({\n        prompt: z.string(),\n        existingTitles: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'generate-ai-description': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { description: JSONContent | undefined },\n    props: z\n      .object({\n        question: z.string(),\n        description: z.string().optional(),\n        answers: z.array(z.string()).optional(),\n        outcomeType: z.string().optional(),\n        shouldAnswersSumToOne: coerceBoolean.optional(),\n        addAnswersMode: z\n          .enum(['DISABLED', 'ONLY_CREATOR', 'ANYONE'])\n          .optional(),\n      })\n      .strict(),\n  },\n  'generate-ai-answers': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as {\n      answers: string[]\n      addAnswersMode: 'DISABLED' | 'ONLY_CREATOR' | 'ANYONE'\n    },\n    props: z\n      .object({\n        question: z.string(),\n        answers: z.array(z.string()),\n        shouldAnswersSumToOne: coerceBoolean,\n        description: z.string().optional(),\n      })\n      .strict(),\n  },\n  'get-monthly-bets-2024': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ userId: z.string() }),\n    returns: [] as { month: string; bet_count: number; total_amount: number }[],\n  },\n  'get-max-min-profit-2024': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ userId: z.string() }),\n    returns: [] as {\n      profit: number\n      data: Contract\n      answer_id: string | null\n      has_no_shares: boolean\n      has_yes_shares: boolean\n    }[],\n  },\n  'get-next-loan-amount': {\n    method: 'GET',\n    visibility: 'undocumented',\n    cache: DEFAULT_CACHE_STRATEGY,\n    authed: false,\n    returns: {} as { amount: number },\n    props: z.object({\n      userId: z.string(),\n    }),\n  },\n  'create-task': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as Task,\n    props: z\n      .object({\n        text: z.string(),\n        category_id: z.number().optional(),\n        priority: z.number().default(0),\n        assignee_id: z.string().optional(),\n      })\n      .strict(),\n  },\n  'update-task': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z\n      .object({\n        id: z.number(),\n        text: z.string().optional(),\n        completed: z.boolean().optional(),\n        priority: z.number().optional(),\n        category_id: z.number().optional(),\n        archived: z.boolean().optional(),\n        assignee_id: z.string().optional(),\n      })\n      .strict(),\n  },\n  'create-category': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { id: number },\n    props: z\n      .object({\n        name: z.string(),\n        color: z.string().optional(),\n        displayOrder: z.number().optional(),\n      })\n      .strict(),\n  },\n  'get-categories': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { categories: TaskCategory[] },\n    props: z.object({}).strict(),\n  },\n  'update-category': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z\n      .object({\n        categoryId: z.number(),\n        name: z.string().optional(),\n        color: z.string().optional(),\n        displayOrder: z.number().optional(),\n        archived: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  'get-tasks': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { tasks: Task[] },\n    props: z.object({}).strict(),\n  },\n  'is-sports-interested': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { isSportsInterested: boolean },\n    props: z.object({}).strict(),\n  },\n  'get-site-activity': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as {\n      bets: Bet[]\n      comments: CommentWithTotalReplies[]\n      newContracts: Contract[]\n      relatedContracts: Contract[]\n    },\n    props: z\n      .object({\n        limit: z.coerce.number().default(10),\n        offset: z.coerce.number().default(0),\n        blockedUserIds: z.array(z.string()).optional(),\n        blockedGroupSlugs: z.array(z.string()).optional(),\n        blockedContractIds: z.array(z.string()).optional(),\n        topicIds: z.array(z.string()).optional(),\n        types: z\n          .array(z.enum(['bets', 'comments', 'markets', 'limit-orders']))\n          .optional(),\n        minBetAmount: z.coerce.number().optional(),\n        onlyFollowedTopics: coerceBoolean.optional(),\n        onlyFollowedContracts: coerceBoolean.optional(),\n        onlyFollowedUsers: coerceBoolean.optional(),\n        userId: z.string().optional(),\n      })\n      .strict(),\n  },\n  'get-sports-games': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { schedule: any[] },\n    props: z.object({}).strict(),\n  },\n  'get-market-props': {\n    method: 'GET',\n    visibility: 'public',\n    cache: DEFAULT_CACHE_STRATEGY,\n    // Could set authed false and preferAuth with an api secret if we want it to replace static props\n    authed: true,\n    returns: {} as {\n      manaContract: MarketContract\n      chartAnnotations: ChartAnnotation[]\n      topics: Topic[]\n      comments: ContractComment[]\n      pinnedComments: ContractComment[]\n      userPositionsByOutcome: {\n        YES: ContractMetric[]\n        NO: ContractMetric[]\n      }\n      topContractMetrics: ContractMetric[]\n      totalPositions: number\n      dashboards: Dashboard[]\n      cashContract: MarketContract\n      totalManaBets: number\n      totalCashBets: number\n    },\n    props: z.object({\n      slug: z.string().optional(),\n      id: z.string().optional(),\n    }),\n  },\n  'get-user-contract-metrics-with-contracts': {\n    method: 'GET',\n    visibility: 'public',\n    preferAuth: true,\n    authed: false,\n    returns: {} as {\n      metricsByContract: Dictionary<ContractMetric[]>\n      contracts: MarketContract[]\n    },\n    props: z.object({\n      userId: z.string(),\n      limit: z.coerce.number(),\n      offset: z.coerce.number().gte(0).optional(),\n      perAnswer: coerceBoolean.optional(),\n      inMani: coerceBoolean.optional(),\n    }),\n  },\n  validateIap: {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z.object({\n      receipt: z.string(),\n    }),\n  },\n  'check-sports-event': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as { exists: boolean; existingMarket?: LiteMarket },\n    props: z\n      .object({\n        sportsEventId: z.string(),\n      })\n      .strict(),\n  },\n  'comment-reactions': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Reaction[],\n    props: z\n      .object({\n        contentIds: z.array(z.string()),\n        contentType: z.enum(['comment', 'contract']),\n      })\n      .strict(),\n  },\n  'mark-all-notifications-new': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({}).strict(),\n    returns: {} as { success: boolean },\n  },\n  'get-contract-voters': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        contractId: z.string(),\n      })\n      .strict(),\n    returns: [] as DisplayUser[],\n  },\n  'get-contract-option-voters': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ contractId: z.string(), optionId: z.string() }),\n    returns: [] as DisplayUser[],\n  },\n  'purchase-contract-boost': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        contractId: z.string(),\n        startTime: z.number().positive().finite().safe(),\n        method: z.enum(['mana', 'cash']),\n      })\n      .strict(),\n    returns: {} as { success: boolean; checkoutUrl?: string },\n  },\n  'generate-ai-numeric-ranges': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as {\n      thresholds: { answers: string[]; midpoints: number[] }\n      buckets: { answers: string[]; midpoints: number[] }\n    },\n    props: z\n      .object({\n        question: z.string(),\n        min: z.number(),\n        max: z.number(),\n        description: z.string().optional(),\n        unit: z.string(),\n      })\n      .strict(),\n  },\n  'infer-numeric-unit': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as {\n      unit: string\n    },\n    props: z\n      .object({\n        question: z.string(),\n        description: z.string().optional(),\n      })\n      .strict(),\n  },\n  'generate-ai-date-ranges': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as {\n      buckets: { answers: string[]; midpoints: number[] }\n      thresholds: { answers: string[]; midpoints: number[] }\n    },\n    props: z\n      .object({\n        question: z.string(),\n        min: z.string(),\n        max: z.string(),\n        description: z.string().optional(),\n      })\n      .strict(),\n  },\n  'regenerate-numeric-midpoints': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { midpoints: number[] },\n    props: z\n      .object({\n        description: z.string().optional(),\n        question: z.string(),\n        answers: z.array(z.string()),\n        min: z.number(),\n        max: z.number(),\n        unit: z.string(),\n        tab: z.enum(['thresholds', 'buckets']),\n      })\n      .strict(),\n  },\n  'regenerate-date-midpoints': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { midpoints: number[] },\n    props: z\n      .object({\n        description: z.string().optional(),\n        question: z.string(),\n        answers: z.array(z.string()),\n        min: z.string(),\n        max: z.string(),\n        tab: z.enum(['thresholds', 'buckets']),\n      })\n      .strict(),\n  },\n\n  'generate-concise-title': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        question: z.string(),\n      })\n      .strict(),\n    returns: {} as { title: string },\n  },\n  'get-close-date': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        question: z.string(),\n        utcOffset: z.number().optional(),\n      })\n      .strict(),\n    returns: {} as { closeTime: number },\n  },\n  'refer-user': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        referredByUsername: z.string(),\n        contractId: z.string().optional(),\n      })\n      .strict(),\n    returns: {} as { success: boolean },\n  },\n\n  'save-market-draft': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { id: number },\n    props: z\n      .object({\n        data: z.object({\n          question: z.string(),\n          description: z.any().optional(),\n          outcomeType: z.string(),\n          answers: z.array(z.string()).optional(),\n          closeDate: z.string().optional(),\n          closeHoursMinutes: z.string().optional(),\n          visibility: z.string(),\n          selectedGroups: z.array(z.any()),\n          savedAt: z.number(),\n        }),\n      })\n      .strict(),\n  },\n\n  'get-market-drafts': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: [] as MarketDraft[],\n    props: z.object({}).strict(),\n  },\n\n  'delete-market-draft': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z\n      .object({\n        id: z.coerce.number(),\n      })\n      .strict(),\n  },\n  'get-season-info': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      season: z.coerce.number().int().positive().optional(),\n    }),\n    returns: {} as {\n      season: number\n      startTime: number // epoch ms\n      endTime: number | null // epoch ms, null if a *mystery* for clients\n      status: 'active' | 'processing' | 'complete'\n    },\n  },\n  'mark-notification-read': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z\n      .object({\n        notificationId: z.string(),\n      })\n      .strict(),\n  },\n  'dismiss-user-report': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        reportId: z.string(),\n      })\n      .strict(),\n    returns: {} as { success: boolean },\n  },\n  'create-post': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { post: TopLevelPost },\n    props: z\n      .object({\n        title: z.string().min(1).max(120),\n        content: contentSchema,\n        isAnnouncement: z.boolean().optional(),\n        visibility: z.enum(['public', 'unlisted']).optional(),\n      })\n      .strict(),\n  },\n  'update-post': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { post: TopLevelPost },\n    props: z\n      .object({\n        id: z.string(),\n        title: z.string().min(1).max(480).optional(),\n        content: contentSchema.optional(),\n        visibility: z.enum(['public', 'unlisted']).optional(),\n      })\n      .strict(),\n  },\n  'create-post-comment': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { comment: PostComment },\n    props: z\n      .object({\n        postId: z.string(),\n        content: contentSchema,\n        replyToCommentId: z.string().optional(),\n      })\n      .strict(),\n  },\n  'update-post-comment': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { comment: PostComment },\n    props: z\n      .object({\n        commentId: z.string(),\n        postId: z.string(),\n        hidden: z.boolean().optional(),\n      })\n      .strict(),\n  },\n} as const)\n\nexport type APIPath = keyof typeof API\nexport type APISchema<N extends APIPath> = (typeof API)[N]\n\nexport type APIParams<N extends APIPath> = z.input<APISchema<N>['props']>\nexport type ValidatedAPIParams<N extends APIPath> = z.output<\n  APISchema<N>['props']\n>\n\nexport type APIResponse<N extends APIPath> = APISchema<N> extends {\n  returns: Record<string, any>\n}\n  ? APISchema<N>['returns']\n  : void\n\nexport type APIResponseOptionalContinue<N extends APIPath> =\n  | { continue: () => Promise<void>; result: APIResponse<N> }\n  | APIResponse<N>\n",
          "postContent": "import { z } from 'zod'\nimport {\n  Group,\n  MAX_ID_LENGTH,\n  MySearchGroupShape,\n  LiteGroup,\n  SearchGroupParams,\n  SearchGroupShape,\n  Topic,\n} from 'common/group'\nimport {\n  createMarketProps,\n  resolveMarketProps,\n  type LiteMarket,\n  FullMarket,\n  updateMarketProps,\n} from './market-types'\nimport { type Answer } from 'common/answer'\nimport {\n  CommentWithTotalReplies,\n  MAX_COMMENT_LENGTH,\n  PostComment,\n  type ContractComment,\n} from 'common/comment'\nimport { CandidateBet } from 'common/new-bet'\nimport type { Bet, LimitBet } from 'common/bet'\nimport { coerceBoolean, contentSchema } from 'common/api/zod-types'\nimport { Lover } from 'common/love/lover'\nimport { AIGeneratedMarket, Contract, MarketContract } from 'common/contract'\nimport { CompatibilityScore } from 'common/love/compatibility-score'\nimport type { Txn, ManaPayTxn } from 'common/txn'\nimport { LiquidityProvision } from 'common/liquidity-provision'\nimport { DisplayUser, FullUser } from './user-types'\nimport { League } from 'common/leagues'\nimport { searchProps } from './market-search-types'\nimport { MAX_ANSWER_LENGTH } from 'common/answer'\nimport { type LinkPreview } from 'common/link-preview'\nimport { Headline } from 'common/news'\nimport { Row } from 'common/supabase/utils'\nimport { LikeData, ShipData } from './love-types'\nimport { AnyBalanceChangeType } from 'common/balance-change'\nimport { Dashboard } from 'common/dashboard'\nimport { ChatMessage, PrivateChatMessage } from 'common/chat-message'\nimport { PrivateUser, User } from '../user'\nimport { ManaSupply } from 'common/stats'\nimport { Repost } from 'common/repost'\nimport { PERIODS } from 'common/period'\nimport { SWEEPS_MIN_BET } from 'common/economy'\nimport {\n  LivePortfolioMetrics,\n  PortfolioMetrics,\n} from 'common/portfolio-metrics'\nimport { ModReport } from '../mod-report'\n\nimport { RegistrationReturnType } from 'common/reason-codes'\nimport {\n  CheckoutSession,\n  GIDXDocument,\n  GPSProps,\n  PaymentDetail,\n  checkoutParams,\n  verificationParams,\n  cashoutRequestParams,\n  PendingCashoutStatusData,\n  cashoutParams,\n} from 'common/gidx/gidx'\nimport { notification_preference } from 'common/user-notification-preferences'\nimport { PrivateMessageChannel } from 'common/supabase/private-messages'\nimport { Notification } from 'common/notification'\nimport { NON_POINTS_BETS_LIMIT } from 'common/supabase/bets'\nimport { ContractMetric } from 'common/contract-metric'\n\nimport { JSONContent } from '@tiptap/core'\nimport { Task, TaskCategory } from 'common/todo'\nimport { ChartAnnotation } from 'common/supabase/chart-annotations'\nimport { Dictionary } from 'lodash'\nimport { Reaction } from 'common/reaction'\nimport { YEAR_MS } from 'common/util/time'\nimport { MarketDraft } from 'common/drafts'\nimport { TopLevelPost } from 'common/top-level-post'\n// mqp: very unscientific, just balancing our willingness to accept load\n// with user willingness to put up with stale data\nexport const DEFAULT_CACHE_STRATEGY =\n  'public, max-age=5, stale-while-revalidate=10'\nconst MAX_EXPIRES_AT = 1_000 * YEAR_MS\n\ntype APIGenericSchema = {\n  // GET is for retrieval, POST is to mutate something, PUT is idempotent mutation (can be repeated safely)\n  method: 'GET' | 'POST' | 'PUT'\n  //private APIs can only be called from manifold. undocumented endpoints can change or be deleted at any time!\n  visibility: 'public' | 'undocumented' | 'private'\n  // whether the endpoint requires authentication\n  authed: boolean\n  // zod schema for the request body (or for params for GET requests)\n  props: z.ZodType\n  // note this has to be JSON serializable\n  returns?: Record<string, any>\n  // Cache-Control header. like, 'max-age=60'\n  cache?: string\n  // whether the endpoint should prefer authentication even if not required\n  preferAuth?: boolean\n}\n\nlet _apiTypeCheck: { [x: string]: APIGenericSchema }\nexport const API = (_apiTypeCheck = {\n  'refresh-all-clients': {\n    method: 'POST',\n    visibility: 'public',\n    props: z.object({ message: z.string().optional() }),\n    authed: true,\n  },\n  'toggle-system-trading-status': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        token: z.enum(['MANA', 'CASH']),\n      })\n      .strict(),\n    returns: {} as { status: boolean },\n  },\n  comment: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as ContractComment,\n    props: z\n      .object({\n        contractId: z.string(),\n        content: contentSchema.optional(),\n        html: z.string().optional(),\n        markdown: z.string().optional(),\n        replyToCommentId: z.string().optional(),\n        replyToAnswerId: z.string().optional(),\n        replyToBetId: z.string().optional(),\n      })\n      .strict(),\n  },\n\n  'follow-contract': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: true },\n    props: z\n      .object({\n        contractId: z.string(),\n        follow: z.boolean(),\n      })\n      .strict(),\n  },\n  'get-contract': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as Contract,\n    props: z\n      .object({\n        contractId: z.string(),\n      })\n      .strict(),\n  },\n  'answer/:answerId': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as Answer,\n    props: z.object({ answerId: z.string() }).strict(),\n  },\n  'market/:contractId/answers': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: [] as Answer[],\n    props: z.object({ contractId: z.string() }).strict(),\n  },\n  'hide-comment': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ commentPath: z.string() }).strict(),\n  },\n  'pin-comment': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({ commentPath: z.string() }).strict(),\n  },\n  comments: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    // cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as ContractComment[],\n    props: z\n      .object({\n        contractId: z.string().optional(),\n        contractSlug: z.string().optional(),\n        afterTime: z.coerce.number().optional(),\n        limit: z.coerce.number().gte(0).lte(1000).default(1000),\n        page: z.coerce.number().gte(0).default(0),\n        userId: z.string().optional(),\n        isPolitics: coerceBoolean.optional(),\n      })\n      .strict(),\n  },\n  bet: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as CandidateBet & { betId: string },\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gte(SWEEPS_MIN_BET),\n        replyToCommentId: z.string().optional(),\n        limitProb: z.number().gte(0.01).lte(0.99).optional(),\n        expiresMillisAfter: z.number().lt(MAX_EXPIRES_AT).optional(),\n        silent: z.boolean().optional(),\n        expiresAt: z.number().lt(MAX_EXPIRES_AT).optional(),\n        // Used for binary and new multiple choice contracts (cpmm-multi-1).\n        outcome: z.enum(['YES', 'NO']).default('YES'),\n        //Multi\n        answerId: z.string().optional(),\n        dryRun: z.boolean().optional(),\n        deps: z.array(z.string()).optional(),\n        deterministic: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  createuser: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { user: User; privateUser: PrivateUser },\n    props: z\n      .object({\n        deviceToken: z.string().optional(),\n        adminToken: z.string().optional(),\n        visitedContractIds: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'multi-bet': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as (CandidateBet & { betId: string })[],\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gte(1),\n        limitProb: z.number().gte(0).lte(1).optional(),\n        expiresAt: z.number().lt(MAX_EXPIRES_AT).optional(),\n        answerIds: z.array(z.string()).min(1),\n        deterministic: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  'multi-sell': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as (CandidateBet & { betId: string })[],\n    props: z\n      .object({\n        contractId: z.string(),\n        answerIds: z.array(z.string()).min(1),\n        deterministic: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  leaderboard: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as { userId: string; score: number }[],\n    props: z\n      .object({\n        groupId: z.string().optional(),\n        limit: z.coerce.number().min(1).max(100).default(50),\n        token: z.enum(['MANA', 'CASH']).default('MANA'),\n        kind: z.enum(['creator', 'profit', 'loss', 'volume', 'referral']),\n      })\n      .strict(),\n  },\n  'verify-phone-number': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { status: string },\n    props: z\n      .object({\n        phoneNumber: z.string(),\n        code: z.string(),\n      })\n      .strict(),\n  },\n  'request-otp': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { status: string },\n    props: z\n      .object({\n        phoneNumber: z.string(),\n      })\n      .strict(),\n  },\n  'bet/cancel/:betId': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ betId: z.string() }).strict(),\n    returns: {} as LimitBet,\n  },\n  // sell shares\n  'market/:contractId/sell': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as CandidateBet & { betId: string },\n    props: z\n      .object({\n        contractId: z.string(),\n        shares: z.number().positive().optional(), // leave it out to sell all shares\n        outcome: z.enum(['YES', 'NO']),\n        answerId: z.string().optional(), // Required for multi binary markets\n        deterministic: z.boolean().optional(),\n        deps: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'get-user-limit-orders-with-contracts': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as {\n      bets: LimitBet[]\n      contracts: MarketContract[]\n    },\n    props: z\n      .object({\n        userId: z.string(),\n        count: z.coerce.number().lte(5000),\n        includeExpired: coerceBoolean.optional().default(false),\n        includeCancelled: coerceBoolean.optional().default(false),\n        includeFilled: coerceBoolean.optional().default(false),\n      })\n      .strict(),\n  },\n  'get-interesting-groups-from-views': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as (Group & { hasBet: boolean })[],\n    props: z\n      .object({\n        userId: z.string(),\n        contractIds: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  bets: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Bet[],\n    props: z\n      .object({\n        id: z.string().optional(),\n        userId: z.string().optional(),\n        username: z.string().optional(),\n        contractId: z.string().or(z.array(z.string())).optional(),\n        contractSlug: z.string().optional(),\n        answerId: z.string().optional(),\n        // market: z.string().optional(), // deprecated, synonym for `contractSlug`\n        limit: z.coerce\n          .number()\n          .gte(0)\n          .lte(50000)\n          .default(NON_POINTS_BETS_LIMIT),\n        before: z.string().optional(),\n        after: z.string().optional(),\n        beforeTime: z.coerce.number().optional(),\n        afterTime: z.coerce.number().optional(),\n        order: z.enum(['asc', 'desc']).optional(),\n        kinds: z.enum(['open-limit']).optional(),\n        // undocumented fields. idk what a good api interface would be\n        filterRedemptions: coerceBoolean.optional(),\n        includeZeroShareRedemptions: coerceBoolean.optional(),\n        commentRepliesOnly: coerceBoolean.optional(),\n        count: coerceBoolean.optional(),\n        points: coerceBoolean.optional(),\n      })\n      .strict(),\n  },\n  'bet-points': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: 'public, max-age=600, stale-while-revalidate=60',\n    returns: [] as Bet[],\n    props: z\n      .object({\n        contractId: z.string(),\n        answerId: z.string().optional(),\n        limit: z.coerce.number().gte(0).lte(50000).default(5000),\n        beforeTime: z.coerce.number(),\n        afterTime: z.coerce.number(),\n        filterRedemptions: coerceBoolean.optional(),\n        includeZeroShareRedemptions: coerceBoolean.optional(),\n      })\n      .strict(),\n  },\n  'unique-bet-group-count': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as { count: number },\n    props: z\n      .object({\n        contractId: z.string(),\n      })\n      .strict(),\n  },\n  'get-daily-changed-metrics-and-contracts': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    cache: 'public, max-age=900, stale-while-revalidate=90', // 15 minute cache\n    props: z\n      .object({\n        limit: z.coerce.number(),\n        userId: z.string(),\n        balance: z.coerce.number(),\n      })\n      .strict(),\n    returns: {} as {\n      manaMetrics: ContractMetric[]\n      contracts: MarketContract[]\n      manaProfit: number\n      manaInvestmentValue: number\n      balance: number\n    },\n  },\n  // deprecated. use /bets?username= instead\n  'user/:username/bets': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Bet[],\n    props: z\n      .object({\n        username: z.string(),\n        limit: z.coerce.number().gte(0).lte(1000).default(1000),\n      })\n      .strict(),\n  },\n  'group/:slug': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as Group,\n    props: z.object({ slug: z.string() }),\n  },\n  'group/:slug/groups': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as { above: LiteGroup[]; below: LiteGroup[] },\n    props: z.object({ slug: z.string() }).strict(),\n  },\n  'group/:slug/dashboards': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as {\n      id: string\n      title: string\n      slug: string\n      creatorId: string\n    }[],\n    props: z.object({ slug: z.string() }).strict(),\n  },\n  'group/by-id/:id/groups': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as { above: LiteGroup[]; below: LiteGroup[] },\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'group/by-id/:id': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as Group,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  // deprecated. use /markets?groupId= instead\n  'group/by-id/:id/markets': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as LiteMarket[],\n    props: z\n      .object({\n        id: z.string(),\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n      })\n      .strict(),\n  },\n  'group/:slug/delete': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ slug: z.string() }),\n  },\n  'group/by-id/:id/delete': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ id: z.string() }),\n  },\n  'group/:slug/block': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ slug: z.string() }),\n  },\n  'group/:slug/unblock': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ slug: z.string() }).strict(),\n  },\n  'group/by-id/:topId/group/:bottomId': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        topId: z.string(),\n        bottomId: z.string(),\n        remove: z.boolean().optional(),\n      })\n      .strict(),\n    returns: {} as { status: 'success' },\n  },\n  groups: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Group[],\n    props: z\n      .object({\n        availableToUserId: z.string().optional(),\n        beforeTime: z.coerce.number().int().optional(),\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n      })\n      .strict(),\n  },\n  'market/:id': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as LiteMarket | FullMarket,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z.object({ id: z.string(), lite: coerceBoolean.optional() }),\n  },\n  'market/:id/prob': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as {\n      prob?: number\n      answerProbs?: { [answerId: string]: number }\n    },\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'market-probs': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as {\n      [contractId: string]: {\n        prob?: number\n        answerProbs?: { [answerId: string]: number }\n      }\n    },\n    props: z\n      .object({\n        ids: z.array(z.string()).max(100),\n      })\n      .strict(),\n  },\n  'markets-by-ids': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: [] as Contract[],\n    props: z\n      .object({\n        ids: z.array(z.string()).max(100),\n      })\n      .strict(),\n  },\n  // deprecated. use /market/:id?lite=true instead\n  'market/:id/lite': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as LiteMarket,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z.object({ id: z.string() }),\n  },\n  'slug/:slug': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as LiteMarket | FullMarket,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z.object({ slug: z.string(), lite: coerceBoolean.optional() }),\n  },\n  market: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as LiteMarket,\n    props: createMarketProps,\n  },\n  'market/:contractId/update': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: updateMarketProps,\n    returns: {} as { success: true },\n  },\n  'market/:contractId/close': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    // returns: {} as LiteMarket,\n    props: z\n      .object({\n        contractId: z.string(),\n        closeTime: z.number().int().nonnegative().optional(),\n      })\n      .strict(),\n  },\n  'market/:contractId/resolve': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { message: string },\n    props: resolveMarketProps,\n  },\n  'market/:contractId/add-liquidity': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as LiquidityProvision,\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gt(0).finite(),\n      })\n      .strict(),\n  },\n  'market/:contractId/remove-liquidity': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as LiquidityProvision,\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gt(0).finite(),\n      })\n      .strict(),\n  },\n  'market/:contractId/add-bounty': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as Txn,\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gt(0).finite(),\n      })\n      .strict(),\n  },\n  'market/:contractId/award-bounty': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as Txn,\n    props: z\n      .object({\n        contractId: z.string(),\n        commentId: z.string(),\n        amount: z.number().gt(0).finite(),\n      })\n      .strict(),\n  },\n  'market/:contractId/group': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        contractId: z.string(),\n        groupId: z.string(),\n        remove: z.boolean().default(false),\n      })\n      .strict(),\n    returns: {} as { success: true },\n  },\n  'market/:contractId/groups': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({ contractId: z.string() }),\n    returns: [] as LiteGroup[],\n  },\n  'market/:contractId/answer': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { newAnswerId: string },\n    props: z\n      .object({\n        contractId: z.string().max(MAX_ANSWER_LENGTH),\n        text: z.string().min(1).max(MAX_ANSWER_LENGTH),\n      })\n      .strict(),\n  },\n  'market/:contractId/block': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ contractId: z.string() }).strict(),\n  },\n  'market/:contractId/unblock': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ contractId: z.string() }).strict(),\n  },\n  unresolve: {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { success: true },\n    props: z\n      .object({\n        contractId: z.string().max(MAX_ANSWER_LENGTH),\n        answerId: z.string().max(MAX_ANSWER_LENGTH).optional(),\n      })\n      .strict(),\n  },\n  leagues: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as League[],\n    props: z\n      .object({\n        userId: z.string().optional(),\n        cohort: z.string().optional(),\n        season: z.coerce.number().optional(),\n      })\n      .strict(),\n  },\n  markets: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as LiteMarket[],\n    props: z\n      .object({\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n        sort: z\n          .enum([\n            'created-time',\n            'updated-time',\n            'last-bet-time',\n            'last-comment-time',\n          ])\n          .optional(),\n        order: z.enum(['asc', 'desc']).optional(),\n        before: z.string().optional(),\n        userId: z.string().optional(),\n        groupId: z.string().optional(),\n      })\n      .strict(),\n  },\n  'search-markets': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as LiteMarket[],\n    props: searchProps,\n  },\n  'search-markets-full': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    preferAuth: true,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Contract[],\n    props: searchProps,\n  },\n  managram: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        amount: z.number().finite(),\n        toIds: z.array(z.string()),\n        message: z.string().max(MAX_COMMENT_LENGTH),\n        groupId: z.string().max(MAX_ID_LENGTH).optional(),\n        token: z.enum(['M$', 'CASH']).default('M$'),\n      })\n      .strict(),\n  },\n  manalink: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { slug: string },\n    props: z\n      .object({\n        amount: z.number().positive().finite().safe(),\n        expiresTime: z.number().lt(MAX_EXPIRES_AT).optional(),\n        maxUses: z.number().optional(),\n        message: z.string().optional(),\n      })\n      .strict(),\n  },\n  donate: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        amount: z.number().positive().finite().safe(),\n        to: z.string(),\n      })\n      .strict(),\n  },\n  'convert-sp-to-mana': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ amount: z.number().positive().finite().safe() }).strict(),\n  },\n  'convert-cash-to-mana': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ amount: z.number().positive().finite().safe() }).strict(),\n  },\n  'request-loan': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({}),\n    returns: {} as { payout: number },\n  },\n  // deprecated. use /txns instead\n  managrams: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: [] as ManaPayTxn[],\n    props: z\n      .object({\n        toId: z.string().optional(),\n        fromId: z.string().optional(),\n        limit: z.coerce.number().gte(0).lte(100).default(100),\n        before: z.coerce.number().optional(),\n        after: z.coerce.number().optional(),\n      })\n      .strict(),\n  },\n  'market/:id/positions': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as ContractMetric[],\n    props: z\n      .object({\n        id: z.string(),\n        userId: z.string().optional(),\n        answerId: z.string().optional(),\n        summaryOnly: z.boolean().optional(),\n        top: z.undefined().or(z.coerce.number()),\n        bottom: z.undefined().or(z.coerce.number()),\n        order: z.enum(['shares', 'profit']).optional(),\n      })\n      .strict(),\n  },\n  me: {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z.object({}),\n    returns: {} as FullUser,\n  },\n  'me/update': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({\n      name: z.string().trim().min(1).optional(),\n      username: z.string().trim().min(1).optional(),\n      avatarUrl: z.string().optional(),\n      bio: z.string().optional(),\n      website: z.string().optional(),\n      twitterHandle: z.string().optional(),\n      discordHandle: z.string().optional(),\n      // settings\n      optOutBetWarnings: z.boolean().optional(),\n      isAdvancedTrader: z.boolean().optional(),\n      //internal\n      seenStreakModal: z.boolean().optional(),\n      shouldShowWelcome: z.boolean().optional(),\n      hasSeenContractFollowModal: z.boolean().optional(),\n      hasSeenLoanModal: z.boolean().optional(),\n    }),\n    returns: {} as FullUser,\n  },\n  'me/delete': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({\n      username: z.string(), // just so you're sure\n    }),\n  },\n  'me/private': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z.object({}),\n    returns: {} as PrivateUser,\n  },\n  'me/private/update': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    props: z\n      .object({\n        email: z.string().email().optional(),\n        apiKey: z.string().optional(),\n        pushToken: z.string().optional(),\n        rejectedPushNotificationsOn: z.number().optional(),\n        lastPromptedToEnablePushNotifications: z.number().optional(),\n        interestedInPushNotifications: z.boolean().optional(),\n        hasSeenAppBannerInNotificationsOn: z.number().optional(),\n        installedAppPlatforms: z.array(z.string()).optional(),\n        paymentInfo: z.string().optional(),\n        lastAppReviewTime: z.number().optional(),\n      })\n      .strict(),\n  },\n  'user/:username': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as FullUser,\n    props: z.object({ username: z.string() }).strict(),\n  },\n  'user/:username/lite': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as DisplayUser,\n    props: z.object({ username: z.string() }).strict(),\n  },\n  'user/by-id/:id': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    // Do not add a caching strategy here. New users need up-to-date data.\n    returns: {} as FullUser,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'user/by-id/:id/lite': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as DisplayUser,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'users/by-id': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as DisplayUser[],\n    props: z.object({ ids: z.array(z.string()) }).strict(),\n  },\n  'users/by-id/balance': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as { id: string; balance: number }[],\n    props: z.object({ ids: z.array(z.string()) }).strict(),\n  },\n  'user/by-id/:id/block': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'user/by-id/:id/unblock': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  users: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as FullUser[],\n    props: z\n      .object({\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n        before: z.string().optional(),\n      })\n      .strict(),\n  },\n  'search-users': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as FullUser[],\n    props: z\n      .object({\n        term: z.string(),\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n        page: z.coerce.number().gte(0).default(0),\n      })\n      .strict(),\n  },\n  'search-contract-positions': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as DisplayUser[],\n    props: z\n      .object({\n        term: z.string(),\n        contractId: z.string(),\n        limit: z.coerce.number().gte(0).lte(100).default(10),\n      })\n      .strict(),\n  },\n  'save-twitch': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        twitchInfo: z.object({\n          twitchName: z.string().optional(),\n          controlToken: z.string().optional(),\n          botEnabled: z.boolean().optional(),\n          needsRelinking: z.boolean().optional(),\n        }),\n      })\n      .strict(),\n  },\n  'set-push-token': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({ pushToken: z.string() }).strict(),\n  },\n  'update-notif-settings': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      type: z.string() as z.ZodType<notification_preference>,\n      medium: z.enum(['email', 'browser', 'mobile']),\n      enabled: z.boolean(),\n    }),\n  },\n  headlines: {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: [] as Headline[],\n    props: z.object({\n      slug: z.enum(['politics', 'ai', 'news']).optional(),\n    }),\n  },\n  'politics-headlines': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: [] as Headline[],\n    props: z.object({}),\n  },\n  'set-news': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { success: true },\n    props: z\n      .object({\n        dashboardIds: z.array(z.string()),\n        endpoint: z.enum(['politics', 'ai', 'news']),\n      })\n      .strict(),\n  },\n  react: {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        contentId: z.string(),\n        contentType: z.enum(['comment', 'contract', 'post']),\n        commentParentType: z.enum(['post']).optional(),\n        remove: z.boolean().optional(),\n        reactionType: z.enum(['like', 'dislike']).optional().default('like'),\n      })\n      .strict(),\n    returns: { success: true },\n  },\n  'compatible-lovers': {\n    method: 'GET',\n    visibility: 'private',\n    authed: false,\n    props: z.object({ userId: z.string() }),\n    returns: {} as {\n      lover: Lover\n      compatibleLovers: Lover[]\n      loverCompatibilityScores: {\n        [userId: string]: CompatibilityScore\n      }\n    },\n  },\n  post: {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    returns: {} as ContractComment,\n    props: z\n      .object({\n        contractId: z.string(),\n        betId: z.string().optional(),\n        commentId: z.string().optional(),\n        content: contentSchema.optional(),\n      })\n      .strict(),\n  },\n  'fetch-link-preview': {\n    method: 'GET',\n    visibility: 'private',\n    authed: false,\n    props: z.object({ url: z.string() }).strict(),\n    cache: 'max-age=86400, stale-while-revalidate=86400',\n    returns: {} as LinkPreview,\n  },\n  'remove-pinned-photo': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    returns: { success: true },\n    props: z\n      .object({\n        userId: z.string(),\n      })\n      .strict(),\n  },\n  'get-related-markets': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    props: z\n      .object({\n        contractId: z.string(),\n        limit: z.coerce.number().gte(0).lte(100),\n        userId: z.string().optional(),\n        question: z.string().optional(),\n        uniqueBettorCount: z.coerce.number().gte(0).optional(),\n      })\n      .strict(),\n    returns: {} as {\n      marketsFromEmbeddings: Contract[]\n    },\n    cache: 'public, max-age=3600, stale-while-revalidate=10',\n  },\n  'get-related-markets-by-group': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: 'public, max-age=3600, stale-while-revalidate=10',\n    returns: {} as {\n      groupContracts: Contract[]\n    },\n    props: z\n      .object({\n        contractId: z.string(),\n        limit: z.coerce.number().gte(0).lte(100),\n        offset: z.coerce.number().gte(0),\n      })\n      .strict(),\n  },\n  'unlist-and-cancel-user-contracts': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        userId: z.string(),\n      })\n      .strict(),\n  },\n  'get-boost-analytics': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: false,\n    props: z\n      .object({\n        contractId: z.string(),\n      })\n      .strict(),\n    returns: {} as {\n      uniqueViewers: number\n      totalViews: number\n      uniquePromotedViewers: number\n      totalPromotedViews: number\n      boostPeriods: {\n        startTime: string\n        endTime: string\n      }[]\n    },\n  },\n  'get-seen-market-ids': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      contractIds: z.array(z.string()),\n      types: z.array(z.enum(['page', 'card', 'promoted'])).optional(),\n      since: z.number(),\n    }),\n    returns: [] as string[],\n  },\n  'get-compatibility-questions': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({}),\n    returns: {} as {\n      status: 'success'\n      questions: (Row<'love_questions'> & {\n        answer_count: number\n        score: number\n      })[]\n    },\n  },\n  'like-lover': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    props: z.object({\n      targetUserId: z.string(),\n      remove: z.boolean().optional(),\n    }),\n    returns: {} as {\n      status: 'success'\n    },\n  },\n  'ship-lovers': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    props: z.object({\n      targetUserId1: z.string(),\n      targetUserId2: z.string(),\n      remove: z.boolean().optional(),\n    }),\n    returns: {} as {\n      status: 'success'\n    },\n  },\n\n  'get-likes-and-ships': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z\n      .object({\n        userId: z.string(),\n      })\n      .strict(),\n    returns: {} as {\n      status: 'success'\n      likesReceived: LikeData[]\n      likesGiven: LikeData[]\n      ships: ShipData[]\n    },\n  },\n  'has-free-like': {\n    method: 'GET',\n    visibility: 'private',\n    authed: true,\n    props: z.object({}).strict(),\n    returns: {} as {\n      status: 'success'\n      hasFreeLike: boolean\n    },\n  },\n  'star-lover': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    props: z.object({\n      targetUserId: z.string(),\n      remove: z.boolean().optional(),\n    }),\n    returns: {} as {\n      status: 'success'\n    },\n  },\n  'get-lovers': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({}).strict(),\n    returns: {} as {\n      status: 'success'\n      lovers: Lover[]\n    },\n  },\n  'get-lover-answers': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({ userId: z.string() }).strict(),\n    returns: {} as {\n      status: 'success'\n      answers: Row<'love_compatibility_answers'>[]\n    },\n  },\n  'search-groups': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    // Is there a way to infer return { lite:[] as LiteGroup[] } if type is 'lite'?\n    returns: {\n      full: [] as Group[],\n      lite: [] as LiteGroup[],\n    },\n    props: SearchGroupParams(SearchGroupShape),\n  },\n  'search-my-groups': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {\n      full: [] as Group[],\n      lite: [] as LiteGroup[],\n    },\n    props: SearchGroupParams(MySearchGroupShape),\n  },\n  'get-groups-with-top-contracts': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as { topic: Topic; contracts: Contract[] }[],\n    props: z.object({}),\n  },\n  'get-balance-changes': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: [] as AnyBalanceChangeType[],\n    props: z\n      .object({\n        before: z.coerce.number().optional(),\n        after: z.coerce.number().default(0),\n        userId: z.string(),\n      })\n      .strict(),\n  },\n  'get-partner-stats': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z\n      .object({\n        userId: z.string(),\n      })\n      .strict(),\n    returns: {} as {\n      status: 'success' | 'error'\n      username: string\n      numContractsCreated: number\n      numUniqueBettors: number\n      numReferrals: number\n      numReferralsWhoRetained: number\n      totalTraderIncome: number\n      totalReferralIncome: number\n      dollarsEarned: number\n    },\n  },\n  'record-contract-view': {\n    method: 'POST',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      userId: z.string().optional(),\n      contractId: z.string(),\n      kind: z.enum(['page', 'card', 'promoted']),\n    }),\n    returns: {} as { status: 'success' },\n  },\n  'record-comment-view': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({\n      contractId: z.string(),\n      commentId: z.string(),\n    }),\n    returns: {} as { status: 'success' },\n  },\n  'record-contract-interaction': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({\n      contractId: z.string(),\n      kind: z.enum([\n        'page bet',\n        'page comment',\n        'page repost',\n        'page like',\n        'card bet',\n        'card click',\n        'promoted click',\n        'card like',\n        'page share',\n        'browse click',\n      ]),\n      commentId: z.string().optional(),\n      feedReasons: z.array(z.string()).optional(),\n      feedType: z.string().optional(),\n      betGroupId: z.string().optional(),\n      betId: z.string().optional(),\n    }),\n    returns: {} as { status: 'success' },\n  },\n  'get-dashboard-from-slug': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      dashboardSlug: z.string(),\n    }),\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as Dashboard,\n  },\n  'get-posts': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    preferAuth: true,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z\n      .object({\n        sortBy: z\n          .enum(['created_time', 'importance_score'])\n          .optional()\n          .default('created_time'),\n        term: z.string().optional(),\n        limit: z.coerce.number().gte(0).lte(200).default(100),\n        userId: z.string().optional(),\n        offset: z.coerce.number().gte(0).default(0),\n      })\n      .strict(),\n    returns: [] as TopLevelPost[],\n  },\n  'create-public-chat-message': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as ChatMessage,\n    props: z.object({\n      content: contentSchema,\n      channelId: z.string(),\n    }),\n  },\n  'get-followed-groups': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      userId: z.string(),\n    }),\n    returns: {} as {\n      groups: Group[]\n    },\n  },\n  'get-user-portfolio': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      userId: z.string(),\n    }),\n    returns: {} as LivePortfolioMetrics,\n  },\n  'get-user-portfolio-history': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      userId: z.string(),\n      period: z.enum(PERIODS),\n    }),\n    returns: {} as PortfolioMetrics[],\n  },\n  'get-channel-memberships': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      channelId: z.coerce.number().optional(),\n      createdTime: z.string().optional(),\n      lastUpdatedTime: z.string().optional(),\n      limit: z.coerce.number(),\n    }),\n    returns: {\n      channels: [] as PrivateMessageChannel[],\n      memberIdsByChannelId: {} as { [channelId: string]: string[] },\n    },\n  },\n  'get-channel-messages': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      channelId: z.coerce.number(),\n      limit: z.coerce.number(),\n      id: z.coerce.number().optional(),\n    }),\n    returns: [] as PrivateChatMessage[],\n  },\n  'get-channel-seen-time': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      channelIds: z.array(z.coerce.number()),\n    }),\n    returns: [] as [number, string][],\n  },\n  'set-channel-seen-time': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      channelId: z.coerce.number(),\n    }),\n  },\n  'get-feed': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as {\n      contracts: Contract[]\n      comments: ContractComment[]\n      bets: Bet[]\n      reposts: Repost[]\n      idsToReason: { [id: string]: string }\n    },\n    props: z\n      .object({\n        userId: z.string(),\n        limit: z.coerce.number().gt(0).lte(100).default(100),\n        offset: z.coerce.number().gte(0).default(0),\n        ignoreContractIds: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'get-mana-supply': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as ManaSupply,\n    props: z.object({}).strict(),\n  },\n  'get-notifications': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as Notification[],\n    props: z\n      .object({\n        after: z.coerce.number().optional(),\n        limit: z.coerce.number().gte(0).lte(1000).default(100),\n      })\n      .strict(),\n  },\n  'update-mod-report': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        reportId: z.number(),\n        updates: z\n          .object({\n            status: z\n              .enum(['new', 'under review', 'resolved', 'needs admin'])\n              .optional(),\n            mod_note: z.string().optional(),\n          })\n          .partial(),\n      })\n      .strict(),\n    returns: {} as { status: string; report: ModReport },\n  },\n  'get-mod-reports': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        statuses: z.array(\n          z.enum(['new', 'under review', 'resolved', 'needs admin'])\n        ),\n        limit: z.coerce.number().gte(0).lte(100).default(25),\n        offset: z.coerce.number().gte(0).default(0),\n        count: coerceBoolean.optional(),\n      })\n      .strict(),\n    returns: {} as {\n      status: string\n      count?: number\n      reports: ModReport[]\n    },\n  },\n  'get-txn-summary-stats': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as Row<'txn_summary_stats'>[],\n    props: z\n      .object({\n        ignoreCategories: z.array(z.string()).optional(),\n        fromType: z.string().optional(),\n        toType: z.string().optional(),\n        limitDays: z.coerce.number(),\n      })\n      .strict(),\n  },\n  'get-mana-summary-stats': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as Row<'mana_supply_stats'>[],\n    props: z\n      .object({\n        limitDays: z.coerce.number(),\n      })\n      .strict(),\n  },\n  'register-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: verificationParams,\n    returns: {} as RegistrationReturnType,\n  },\n  'get-verification-status-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      documents?: GIDXDocument[]\n      message?: string\n      documentStatus?: string\n    },\n    props: z.object({}),\n  },\n  'get-monitor-status-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n    },\n    props: z.object({\n      DeviceGPS: GPSProps,\n    }),\n  },\n  'get-checkout-session-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n      session?: CheckoutSession\n    },\n    props: z.object({\n      PayActionCode: z.enum(['PAY', 'PAYOUT']).default('PAY'),\n      DeviceGPS: GPSProps,\n      userId: z.string().optional(),\n      ip: z.string().optional(),\n    }),\n  },\n  'complete-checkout-session-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n      gidxMessage?: string | null\n      details?: PaymentDetail[]\n    },\n    props: z.object(checkoutParams),\n  },\n  'complete-cashout-session-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n      gidxMessage?: string | null\n      details?: PaymentDetail[]\n    },\n    props: z.object(cashoutParams),\n  },\n  'complete-cashout-request': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n      gidxMessage?: string | null\n      details?: PaymentDetail[]\n    },\n    props: z.object(cashoutRequestParams),\n  },\n  'get-verification-documents-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      documents: GIDXDocument[]\n      utilityDocuments: GIDXDocument[]\n      idDocuments: GIDXDocument[]\n      rejectedDocuments: GIDXDocument[]\n    },\n    props: z.object({}),\n  },\n  'upload-document-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { status: string },\n    props: z.object({\n      CategoryType: z.number().gte(1).lte(7),\n      fileName: z.string(),\n      fileUrl: z.string(),\n    }),\n  },\n  'identity-callback-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as { Accepted: boolean },\n    props: z.object({\n      MerchantCustomerID: z.string(),\n      NotificationType: z.string(),\n    }),\n  },\n  'payment-callback-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as { MerchantTransactionID: string },\n    props: z\n      .object({\n        MerchantTransactionID: z.string(),\n        TransactionStatusCode: z.coerce.number(),\n        TransactionStatusMessage: z.string(),\n        StatusCode: z.coerce.number(),\n        SessionID: z.string(),\n        MerchantSessionID: z.string(),\n        SessionScore: z.coerce.number(),\n        ReasonCodes: z.array(z.string()).optional(),\n        ServiceType: z.string(),\n        StatusMessage: z.string(),\n      })\n      .strict(),\n  },\n  'get-best-comments': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { comments: ContractComment[]; contracts: Contract[] },\n    props: z.object({\n      limit: z.coerce.number().gte(0).lte(100).default(20),\n      offset: z.coerce.number().gte(0).default(0),\n      ignoreContractIds: z.array(z.string()).optional(),\n      justLikes: z.coerce.number().optional(),\n    }),\n  },\n  'get-redeemable-prize-cash': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { redeemablePrizeCash: number },\n    props: z.object({}),\n  },\n  'get-total-redeemable-prize-cash': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as { total: number },\n    props: z.object({}),\n  },\n  'get-cashouts': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as PendingCashoutStatusData[],\n    props: z\n      .object({\n        limit: z.coerce.number().gte(0).lte(100).default(10),\n        offset: z.coerce.number().gte(0).default(0),\n        userId: z.string().optional(),\n      })\n      .strict(),\n  },\n  'get-kyc-stats': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({}),\n    returns: {} as {\n      initialVerifications: {\n        count: number\n        day: string\n      }[]\n      phoneVerifications: {\n        count: number\n        day: string\n      }[]\n    },\n  },\n  txns: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z\n      .object({\n        token: z.string().optional(),\n        offset: z.coerce.number().default(0),\n        limit: z.coerce.number().gte(0).lte(100).default(100),\n        before: z.coerce.number().optional(),\n        after: z.coerce.number().optional(),\n        toId: z.string().optional(),\n        fromId: z.string().optional(),\n        category: z.string().optional(),\n        ignoreCategories: z.array(z.string()).optional(),\n      })\n      .strict(),\n    returns: [] as Txn[],\n  },\n  'generate-ai-market-suggestions': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: [] as AIGeneratedMarket[],\n    props: z\n      .object({\n        prompt: z.string(),\n        existingTitles: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'generate-ai-description': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { description: JSONContent | undefined },\n    props: z\n      .object({\n        question: z.string(),\n        description: z.string().optional(),\n        answers: z.array(z.string()).optional(),\n        outcomeType: z.string().optional(),\n        shouldAnswersSumToOne: coerceBoolean.optional(),\n        addAnswersMode: z\n          .enum(['DISABLED', 'ONLY_CREATOR', 'ANYONE'])\n          .optional(),\n      })\n      .strict(),\n  },\n  'generate-ai-answers': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as {\n      answers: string[]\n      addAnswersMode: 'DISABLED' | 'ONLY_CREATOR' | 'ANYONE'\n    },\n    props: z\n      .object({\n        question: z.string(),\n        answers: z.array(z.string()),\n        shouldAnswersSumToOne: coerceBoolean,\n        description: z.string().optional(),\n      })\n      .strict(),\n  },\n  'get-monthly-bets-2024': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ userId: z.string() }),\n    returns: [] as { month: string; bet_count: number; total_amount: number }[],\n  },\n  'get-max-min-profit-2024': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ userId: z.string() }),\n    returns: [] as {\n      profit: number\n      data: Contract\n      answer_id: string | null\n      has_no_shares: boolean\n      has_yes_shares: boolean\n    }[],\n  },\n  'get-next-loan-amount': {\n    method: 'GET',\n    visibility: 'undocumented',\n    cache: DEFAULT_CACHE_STRATEGY,\n    authed: false,\n    returns: {} as { amount: number },\n    props: z.object({\n      userId: z.string(),\n    }),\n  },\n  'create-task': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as Task,\n    props: z\n      .object({\n        text: z.string(),\n        category_id: z.number().optional(),\n        priority: z.number().default(0),\n        assignee_id: z.string().optional(),\n      })\n      .strict(),\n  },\n  'update-task': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z\n      .object({\n        id: z.number(),\n        text: z.string().optional(),\n        completed: z.boolean().optional(),\n        priority: z.number().optional(),\n        category_id: z.number().optional(),\n        archived: z.boolean().optional(),\n        assignee_id: z.string().optional(),\n      })\n      .strict(),\n  },\n  'create-category': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { id: number },\n    props: z\n      .object({\n        name: z.string(),\n        color: z.string().optional(),\n        displayOrder: z.number().optional(),\n      })\n      .strict(),\n  },\n  'get-categories': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { categories: TaskCategory[] },\n    props: z.object({}).strict(),\n  },\n  'update-category': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z\n      .object({\n        categoryId: z.number(),\n        name: z.string().optional(),\n        color: z.string().optional(),\n        displayOrder: z.number().optional(),\n        archived: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  'get-tasks': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { tasks: Task[] },\n    props: z.object({}).strict(),\n  },\n  'is-sports-interested': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { isSportsInterested: boolean },\n    props: z.object({}).strict(),\n  },\n  'get-site-activity': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as {\n      bets: Bet[]\n      comments: CommentWithTotalReplies[]\n      newContracts: Contract[]\n      relatedContracts: Contract[]\n    },\n    props: z\n      .object({\n        limit: z.coerce.number().default(10),\n        offset: z.coerce.number().default(0),\n        blockedUserIds: z.array(z.string()).optional(),\n        blockedGroupSlugs: z.array(z.string()).optional(),\n        blockedContractIds: z.array(z.string()).optional(),\n        topicIds: z.array(z.string()).optional(),\n        types: z\n          .array(z.enum(['bets', 'comments', 'markets', 'limit-orders']))\n          .optional(),\n        minBetAmount: z.coerce.number().optional(),\n        onlyFollowedTopics: coerceBoolean.optional(),\n        onlyFollowedContracts: coerceBoolean.optional(),\n        onlyFollowedUsers: coerceBoolean.optional(),\n        userId: z.string().optional(),\n      })\n      .strict(),\n  },\n  'get-sports-games': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { schedule: any[] },\n    props: z.object({}).strict(),\n  },\n  'get-market-props': {\n    method: 'GET',\n    visibility: 'public',\n    cache: DEFAULT_CACHE_STRATEGY,\n    // Could set authed false and preferAuth with an api secret if we want it to replace static props\n    authed: true,\n    returns: {} as {\n      manaContract: MarketContract\n      chartAnnotations: ChartAnnotation[]\n      topics: Topic[]\n      comments: ContractComment[]\n      pinnedComments: ContractComment[]\n      userPositionsByOutcome: {\n        YES: ContractMetric[]\n        NO: ContractMetric[]\n      }\n      topContractMetrics: ContractMetric[]\n      totalPositions: number\n      dashboards: Dashboard[]\n      cashContract: MarketContract\n      totalManaBets: number\n      totalCashBets: number\n    },\n    props: z.object({\n      slug: z.string().optional(),\n      id: z.string().optional(),\n    }),\n  },\n  'get-user-contract-metrics-with-contracts': {\n    method: 'GET',\n    visibility: 'public',\n    preferAuth: true,\n    authed: false,\n    returns: {} as {\n      metricsByContract: Dictionary<ContractMetric[]>\n      contracts: MarketContract[]\n    },\n    props: z.object({\n      userId: z.string(),\n      limit: z.coerce.number(),\n      offset: z.coerce.number().gte(0).optional(),\n      perAnswer: coerceBoolean.optional(),\n      inMani: coerceBoolean.optional(),\n    }),\n  },\n  validateIap: {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z.object({\n      receipt: z.string(),\n    }),\n  },\n  'check-sports-event': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as { exists: boolean; existingMarket?: LiteMarket },\n    props: z\n      .object({\n        sportsEventId: z.string(),\n      })\n      .strict(),\n  },\n  'comment-reactions': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Reaction[],\n    props: z\n      .object({\n        contentIds: z.array(z.string()),\n        contentType: z.enum(['comment', 'contract']),\n      })\n      .strict(),\n  },\n  'mark-all-notifications-new': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({}).strict(),\n    returns: {} as { success: boolean },\n  },\n  'get-contract-voters': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        contractId: z.string(),\n      })\n      .strict(),\n    returns: [] as DisplayUser[],\n  },\n  'get-contract-option-voters': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ contractId: z.string(), optionId: z.string() }),\n    returns: [] as DisplayUser[],\n  },\n  'purchase-contract-boost': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        contractId: z.string(),\n        startTime: z.number().positive().finite().safe(),\n        method: z.enum(['mana', 'cash']),\n      })\n      .strict(),\n    returns: {} as { success: boolean; checkoutUrl?: string },\n  },\n  'generate-ai-numeric-ranges': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as {\n      thresholds: { answers: string[]; midpoints: number[] }\n      buckets: { answers: string[]; midpoints: number[] }\n    },\n    props: z\n      .object({\n        question: z.string(),\n        min: z.number(),\n        max: z.number(),\n        description: z.string().optional(),\n        unit: z.string(),\n      })\n      .strict(),\n  },\n  'infer-numeric-unit': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as {\n      unit: string\n    },\n    props: z\n      .object({\n        question: z.string(),\n        description: z.string().optional(),\n      })\n      .strict(),\n  },\n  'generate-ai-date-ranges': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as {\n      buckets: { answers: string[]; midpoints: number[] }\n      thresholds: { answers: string[]; midpoints: number[] }\n    },\n    props: z\n      .object({\n        question: z.string(),\n        min: z.string(),\n        max: z.string(),\n        description: z.string().optional(),\n      })\n      .strict(),\n  },\n  'regenerate-numeric-midpoints': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { midpoints: number[] },\n    props: z\n      .object({\n        description: z.string().optional(),\n        question: z.string(),\n        answers: z.array(z.string()),\n        min: z.number(),\n        max: z.number(),\n        unit: z.string(),\n        tab: z.enum(['thresholds', 'buckets']),\n      })\n      .strict(),\n  },\n  'regenerate-date-midpoints': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { midpoints: number[] },\n    props: z\n      .object({\n        description: z.string().optional(),\n        question: z.string(),\n        answers: z.array(z.string()),\n        min: z.string(),\n        max: z.string(),\n        tab: z.enum(['thresholds', 'buckets']),\n      })\n      .strict(),\n  },\n\n  'generate-concise-title': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        question: z.string(),\n      })\n      .strict(),\n    returns: {} as { title: string },\n  },\n  'get-close-date': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        question: z.string(),\n        utcOffset: z.number().optional(),\n      })\n      .strict(),\n    returns: {} as { closeTime: number },\n  },\n  'refer-user': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        referredByUsername: z.string(),\n        contractId: z.string().optional(),\n      })\n      .strict(),\n    returns: {} as { success: boolean },\n  },\n\n  'save-market-draft': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { id: number },\n    props: z\n      .object({\n        data: z.object({\n          question: z.string(),\n          description: z.any().optional(),\n          outcomeType: z.string(),\n          answers: z.array(z.string()).optional(),\n          closeDate: z.string().optional(),\n          closeHoursMinutes: z.string().optional(),\n          visibility: z.string(),\n          selectedGroups: z.array(z.any()),\n          savedAt: z.number(),\n        }),\n      })\n      .strict(),\n  },\n\n  'get-market-drafts': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: [] as MarketDraft[],\n    props: z.object({}).strict(),\n  },\n\n  'delete-market-draft': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z\n      .object({\n        id: z.coerce.number(),\n      })\n      .strict(),\n  },\n  'get-season-info': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      season: z.coerce.number().int().positive().optional(),\n    }),\n    returns: {} as {\n      season: number\n      startTime: number // epoch ms\n      endTime: number | null // epoch ms, null if a *mystery* for clients\n      status: 'active' | 'processing' | 'complete'\n    },\n  },\n  'mark-notification-read': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z\n      .object({\n        notificationId: z.string(),\n      })\n      .strict(),\n  },\n  'dismiss-user-report': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        reportId: z.string(),\n      })\n      .strict(),\n    returns: {} as { success: boolean },\n  },\n  'create-post': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { post: TopLevelPost },\n    props: z\n      .object({\n        title: z.string().min(1).max(120),\n        content: contentSchema,\n        isAnnouncement: z.boolean().optional(),\n        visibility: z.enum(['public', 'unlisted']).optional(),\n      })\n      .strict(),\n  },\n  'update-post': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { post: TopLevelPost },\n    props: z\n      .object({\n        id: z.string(),\n        title: z.string().min(1).max(480).optional(),\n        content: contentSchema.optional(),\n        visibility: z.enum(['public', 'unlisted']).optional(),\n      })\n      .strict(),\n  },\n  'create-post-comment': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { comment: PostComment },\n    props: z\n      .object({\n        postId: z.string(),\n        content: contentSchema,\n        replyToCommentId: z.string().optional(),\n      })\n      .strict(),\n  },\n  'update-post-comment': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { comment: PostComment },\n    props: z\n      .object({\n        commentId: z.string(),\n        postId: z.string(),\n        hidden: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  'follow-post': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: true },\n    props: z\n      .object({\n        postId: z.string(),\n        follow: z.boolean(),\n      })\n      .strict(),\n  },\n} as const)\n\nexport type APIPath = keyof typeof API\nexport type APISchema<N extends APIPath> = (typeof API)[N]\n\nexport type APIParams<N extends APIPath> = z.input<APISchema<N>['props']>\nexport type ValidatedAPIParams<N extends APIPath> = z.output<\n  APISchema<N>['props']\n>\n\nexport type APIResponse<N extends APIPath> = APISchema<N> extends {\n  returns: Record<string, any>\n}\n  ? APISchema<N>['returns']\n  : void\n\nexport type APIResponseOptionalContinue<N extends APIPath> =\n  | { continue: () => Promise<void>; result: APIResponse<N> }\n  | APIResponse<N>\n"
        },
        {
          "path": "common/src/notification.ts",
          "preContent": "import { ContractToken, OutcomeType } from 'common/contract'\nimport { groupPath } from './group'\nimport { PAST_BET } from './user'\nimport { notification_preference } from './user-notification-preferences'\nimport { Bet } from 'common/bet'\nimport { league_user_info } from './leagues'\nimport { groupBy } from 'lodash'\n\nexport type NotificationGroup = {\n  notifications: Notification[]\n  groupedById: string\n  isSeen: boolean\n  latestCreatedTime: number\n}\n\nexport type Notification = {\n  id: string\n  userId: string\n  reasonText?: string\n  reason: NotificationReason\n  createdTime: number\n  viewTime?: number\n  isSeen: boolean\n\n  sourceId: string\n  sourceType: notification_source_types\n  sourceUpdateType?: notification_source_update_types\n\n  // sourceContractId is used to group notifications on the same contract together\n  sourceContractId?: string\n  sourceUserName: string\n  sourceUserUsername: string\n  sourceUserAvatarUrl: string\n  sourceText: string\n  data?: { [key: string]: any }\n\n  sourceContractTitle?: string\n  sourceContractCreatorUsername?: string\n  sourceContractSlug?: string\n\n  sourceSlug?: string\n  sourceTitle?: string\n\n  isSeenOnHref?: string\n  markedAsRead?: boolean\n}\n\nexport type NotificationReason =\n  | notification_reason_types\n  | notification_preference\n\nexport type notification_source_types =\n  | 'contract'\n  | 'comment'\n  | 'bet'\n  | 'answer'\n  | 'liquidity'\n  | 'follow'\n  | 'tip'\n  | 'admin_message'\n  | 'group'\n  | 'user'\n  | 'bonus' // strictly unique bettor bonuses atm\n  | 'challenge'\n  | 'betting_streak_bonus'\n  | 'betting_streak_expiring'\n  | 'loan'\n  | 'tip_and_like'\n  | 'badge'\n  | 'signup_bonus'\n  | 'comment_like'\n  | 'contract_like'\n  | 'weekly_portfolio_update'\n  | 'quest_reward'\n  | 'league_change'\n  | 'bounty_added'\n  | 'mana_payment'\n  | 'referral_program'\n  | 'follow_suggestion'\n  | 'market_review'\n  | 'comment_on_lover'\n  | 'new_match'\n  | 'bet_reply'\n  | 'new_message'\n  | 'post'\n  | 'post_like'\n  | 'post_comment_like'\n  | love_notification_source_types\n  | 'push_notification_bonus'\n  | 'airdrop'\n  | 'manifest_airdrop'\n  | 'extra_purchased_mana'\n  | 'payment_status'\n\nexport type love_notification_source_types =\n  | 'love_contract'\n  | 'love_comment'\n  | 'love_answer'\n  | 'love_like'\n  | 'love_ship'\n\nexport type notification_source_update_types =\n  | 'created'\n  | 'updated'\n  | 'resolved'\n  | 'deleted'\n  | 'closed'\n  | 'canceled'\n  | 'expired'\n\n/** @deprecated - use a notification_preference (in user-notification-preferences.ts) */\nexport type notification_reason_types =\n  | 'on_new_follow'\n  | 'contract_from_followed_user'\n  | 'you_referred_user'\n  | 'user_joined_to_bet_on_your_market'\n  | 'bet_fill'\n  | 'limit_order_cancelled'\n  | 'user_joined_from_your_group_invite'\n  | 'betting_streak_incremented'\n  | 'loan_income'\n  | 'comment_on_your_contract'\n  | 'answer_on_your_contract'\n  | 'comment_on_contract_you_follow'\n  | 'answer_on_contract_you_follow'\n  | 'update_on_contract_you_follow'\n  | 'resolution_on_contract_you_follow'\n  | 'comment_on_contract_with_users_shares_in'\n  | 'update_on_contract_with_users_shares_in'\n  | 'resolution_on_contract_with_users_shares_in'\n  | 'comment_on_contract_with_users_answer'\n  | 'update_on_contract_with_users_answer'\n  | 'resolution_on_contract_with_users_answer'\n  | 'answer_on_contract_with_users_answer'\n  | 'comment_on_contract_with_users_comment'\n  | 'answer_on_contract_with_users_comment'\n  | 'update_on_contract_with_users_comment'\n  | 'resolution_on_contract_with_users_comment'\n  | 'reply_to_users_answer'\n  | 'reply_to_users_comment'\n  | 'your_contract_closed'\n  | 'subsidized_your_market'\n  | 'bounty_awarded'\n  | 'bounty_added'\n  | 'bounty_canceled'\n  | 'mana_payment_received'\n\ntype notification_descriptions = {\n  [key in notification_preference]: {\n    simple: string\n    detailed: string\n    necessary?: boolean\n    verb?: string\n  }\n}\nexport const NOTIFICATION_DESCRIPTIONS: notification_descriptions = {\n  all_answers_on_my_markets: {\n    simple: 'Answers on your questions',\n    detailed: 'Answers on your own questions',\n    verb: 'answered your question',\n  },\n  all_comments_on_my_markets: {\n    simple: 'Comments on your questions',\n    detailed: 'Comments on your own questions',\n    verb: 'commented on your market',\n  },\n  betting_streaks: {\n    simple: `Prediction streak bonuses & expirations`,\n    detailed: `Bonuses and expiration notices for prediction streaks made over consecutive days`,\n  },\n  all_answers_on_watched_markets: {\n    simple: 'All new answers',\n    detailed: \"All new answers on questions you're watching\",\n  },\n  quest_payout: {\n    simple: `Quest completion rewards`,\n    detailed: `Bonuses paid out for completing quests`,\n  },\n  contract_from_followed_user: {\n    simple: 'New questions from users you follow',\n    detailed: 'New questions from users you follow',\n  },\n  limit_order_fills: {\n    simple: 'Limit order fills, expirations, and cancellations',\n    detailed: 'When your limit order fills, cancels, or expires',\n  },\n  loan_income: {\n    simple: 'Automatic loans from your predictions in unresolved questions',\n    detailed:\n      'Automatic loans from your predictions that are locked in unresolved questions',\n  },\n\n  on_new_follow: {\n    simple: 'A user followed you',\n    detailed: 'A user followed you',\n  },\n  onboarding_flow: {\n    simple: 'Emails to help you get started using Manifold',\n    detailed: 'Emails to help you learn how to use Manifold',\n  },\n  probability_updates_on_watched_markets: {\n    simple: 'Large changes in probability on questions that you watch',\n    detailed: 'Large changes in probability on questions that you watch',\n  },\n  profit_loss_updates: {\n    simple: 'Weekly portfolio updates',\n    detailed: 'Weekly portfolio updates',\n  },\n  referral_bonuses: {\n    simple: 'Referring new users',\n    detailed: 'Bonuses you receive from referring a new user',\n  },\n  resolutions_on_watched_markets: {\n    simple: 'All question resolutions',\n    detailed: \"All resolutions on questions that you're watching\",\n  },\n  resolutions_on_watched_markets_with_shares_in: {\n    simple: `Only question resolutions that you've ${PAST_BET}`,\n    detailed: `Only resolutions of questions you're watching and that you've ${PAST_BET}`,\n  },\n  subsidized_your_market: {\n    simple: 'Your question was subsidized',\n    detailed: 'When someone subsidizes your market',\n  },\n  tagged_user: {\n    simple: 'A user tagged you',\n    detailed: 'When another use tags you',\n    verb: 'tagged you',\n  },\n  league_changed: {\n    simple: 'Your league changed',\n    detailed: 'When you join, move up, or move down a league',\n  },\n  thank_you_for_purchases: {\n    simple: 'Thank you notes for your purchases',\n    detailed: 'Thank you notes for your purchases',\n  },\n  trending_markets: {\n    simple: 'Weekly interesting questions',\n    detailed: 'Weekly interesting questions',\n  },\n  unique_bettors_on_your_contract: {\n    simple: 'Unique predictors on your questions',\n    detailed: 'Bonuses for unique predictors on your questions',\n  },\n  your_contract_closed: {\n    simple: 'Your question has closed and you need to resolve it (necessary)',\n    detailed: 'Your question has closed and you need to resolve it (necessary)',\n    necessary: true,\n  },\n  all_comments_on_watched_markets: {\n    simple: 'All new comments',\n    detailed: 'All new comments on questions you follow',\n  },\n  all_comments_on_contracts_with_shares_in_on_watched_markets: {\n    simple: `Only on questions you've ${PAST_BET}`,\n    detailed: `Comments on questions that you're watching and you've ${PAST_BET}`,\n  },\n  all_replies_to_my_comments_on_watched_markets: {\n    simple: 'Only replies to your comments',\n    detailed: \"Only replies to your comments on questions you're watching\",\n    verb: 'replied to you',\n  },\n  all_replies_to_my_answers_on_watched_markets: {\n    simple: 'Only replies to your answers',\n    detailed: \"Only replies to your answers on questions you're watching\",\n    verb: 'replied to you',\n  },\n  opt_out_all: {\n    simple: 'Opt out of all notifications (excludes when your questions close)',\n    detailed:\n      'Opt out of all notifications excluding your own question closure notifications',\n  },\n  user_liked_your_content: {\n    simple: 'A user liked your content',\n    detailed: 'A user liked your comment, market, or other content',\n  },\n  bounty_awarded: {\n    simple: 'Bounties you receive',\n    detailed: 'When the creator awards you a bounty for your comment',\n  },\n  bounty_added: {\n    simple: 'Bounties added to your question',\n    detailed: 'When another user adds a bounty to your question',\n  },\n  bounty_canceled: {\n    simple: 'A bounty you follow is canceled',\n    detailed: 'When the creator of a bounty cancels it',\n  },\n  all_votes_on_watched_markets: {\n    simple: 'Votes on polls you follow',\n    detailed: 'When a user votes on a poll you follow',\n  },\n  vote_on_your_contract: {\n    simple: 'Votes on your polls',\n    detailed: 'When a user votes on a poll you created',\n  },\n  poll_close_on_watched_markets: {\n    simple: 'Polls you follow close',\n    detailed: 'When a poll you follow closes',\n  },\n  your_poll_closed: {\n    simple: 'Your poll closes',\n    detailed: 'When a poll you created closes',\n  },\n  review_on_your_market: {\n    simple: 'Reviews on your questions',\n    detailed: 'When a user reviews your question after resolution',\n  },\n  new_match: {\n    simple: 'New matches',\n    detailed: 'When you match with another user',\n  },\n  new_message: {\n    simple: 'New messages',\n    detailed: 'When another user messages you',\n  },\n  new_endorsement: {\n    simple: 'New endorsements',\n    detailed: 'When another user endorses you',\n  },\n  new_love_like: {\n    simple: 'New likes',\n    detailed: 'When another user likes you',\n  },\n  new_love_ship: {\n    simple: 'New ships',\n    detailed:\n      'When another user supports a relationship between you and someone else',\n  },\n  airdrop: {\n    simple: 'You received a gift of mana',\n    detailed: 'Manifold has sent you a gift of mana',\n  },\n  manifest_airdrop: {\n    simple: 'You received a gift for attending Manifest',\n    detailed: 'Manifold has sent you a gift for attending Manifest',\n  },\n  extra_purchased_mana: {\n    simple: 'You just received 9x your purchased mana in 2024',\n    detailed: 'Manifold has sent you a gift of 9x your purchased mana in 2024.',\n  },\n  payment_status: {\n    simple: 'Payment updates',\n    detailed: 'Updates on your payment statuses',\n  },\n  market_movements: {\n    simple: 'Market movements',\n    detailed:\n      'When the probability of a market that you follow changes by a large amount',\n  },\n  market_follows: {\n    simple: 'Someone followed your market',\n    detailed: 'Get notified when someone follows one of your markets',\n    verb: 'followed your market',\n  },\n  admin: {\n    simple: 'Admin notifications',\n    detailed: 'Notifications from the Manifold team',\n  },\n}\n\nexport type BettingStreakData = {\n  streak: number\n  bonusAmount: number\n  cashAmount?: number\n}\nexport type LeagueChangeData = {\n  previousLeague: league_user_info | undefined\n  newLeague: { season: number; division: number; cohort: string }\n  bonusAmount: number\n}\n\nexport type BetFillData = {\n  betAnswer?: string\n  creatorOutcome: string\n  probability: number\n  limitOrderTotal?: number\n  limitOrderRemaining?: number\n  limitAt?: string\n  mechanism: 'cpmm-1' | 'cpmm-multi-1'\n  outcomeType: OutcomeType\n  betAnswerId?: string\n  expiresAt?: number\n  createdTime?: number\n}\n\nexport type ContractResolutionData = {\n  outcome: string\n  userPayout: number\n  userInvestment: number\n  profitRank?: number\n  totalShareholders?: number\n  profit?: number\n  answerId?: string\n  token?: ContractToken\n}\n\nexport type UniqueBettorData = {\n  bet: Bet\n  outcomeType: OutcomeType\n  answerText?: string\n  min?: number\n  max?: number\n  isLogScale?: boolean\n  isPartner?: boolean\n  totalUniqueBettors?: number\n  totalAmountBet?: number\n  token?: ContractToken\n  bonusAmount?: number\n}\n\nexport type ReviewNotificationData = {\n  rating: number\n  review: string\n}\n\nexport type CommentNotificationData = {\n  isReply: boolean\n}\n\nexport type BetReplyNotificationData = {\n  betAmount: number\n  betOutcome: string\n  commentText: string\n}\n\nexport type MarketMovementData = {\n  val_start: number\n  val_end: number\n  val_start_time: string\n  val_end_time: string\n  answerText?: string\n}\n\nexport type AirdropData = {\n  amount: number\n}\n\nexport type ManaPaymentData = {\n  message: string\n  token?: 'M$' | 'CASH'\n}\n\nexport type ExtraPurchasedManaData = {\n  amount: number\n}\n\nexport type PaymentCompletedData = {\n  userId: string\n  amount: number\n  currency: string\n  paymentMethodType: string\n  paymentAmountType: string\n}\n\nexport type ReferralData = {\n  manaAmount: number\n  cashAmount: number\n}\n\nexport function getSourceIdForLinkComponent(\n  sourceId: string,\n  sourceType?: notification_source_types\n) {\n  switch (sourceType) {\n    case 'answer':\n      return `answer-${sourceId}`\n    case 'comment':\n      return sourceId\n    case 'contract':\n      return ''\n    case 'bet':\n      return ''\n    default:\n      return sourceId\n  }\n}\n\nexport function getSourceUrl(notification: Notification) {\n  const {\n    sourceType,\n    sourceId,\n    sourceUserUsername,\n    sourceContractCreatorUsername,\n    sourceContractSlug,\n    sourceSlug,\n    reason,\n  } = notification\n\n  if (sourceType === 'weekly_portfolio_update')\n    return `/week/${sourceUserUsername}/${sourceSlug}`\n  if (reason === 'market_follows')\n    return `/${sourceContractCreatorUsername}/${sourceContractSlug}`\n  if (sourceType === 'follow') return `/${sourceUserUsername}`\n  if (sourceType === 'group' && sourceSlug) return `${groupPath(sourceSlug)}`\n  // User referral via contract:\n  if (\n    sourceContractCreatorUsername &&\n    sourceContractSlug &&\n    sourceType === 'user'\n  )\n    return `/${sourceContractCreatorUsername}/${sourceContractSlug}`\n  // User referral:\n  if (sourceType === 'user' && !sourceContractSlug)\n    return `/${sourceUserUsername}`\n  if (\n    sourceType === 'challenge' ||\n    ReactionNotificationTypes.includes(sourceType)\n  )\n    return `${sourceSlug}`\n  if (sourceContractCreatorUsername && sourceContractSlug) {\n    return `/${sourceContractCreatorUsername}/${sourceContractSlug}#${getSourceIdForLinkComponent(\n      sourceId ?? '',\n      sourceType\n    )}`\n  }\n  if (sourceSlug) {\n    return `${\n      sourceSlug.startsWith('/') ? sourceSlug : '/' + sourceSlug\n    }#${getSourceIdForLinkComponent(sourceId ?? '', sourceType)}`\n  }\n  return ''\n}\n\nexport const ReactionNotificationTypes: Partial<notification_source_types>[] = [\n  'comment_like',\n  'contract_like',\n  'post_like',\n  'post_comment_like',\n]\n\nexport const BalanceChangeNotificationTypes: NotificationReason[] = [\n  'loan_income',\n  // bonuses\n  'betting_streak_incremented',\n  'unique_bettors_on_your_contract',\n  // resolutions\n  'resolution_on_contract_with_users_shares_in',\n  'resolutions_on_watched_markets_with_shares_in',\n  // referrals\n  'you_referred_user',\n  'user_joined_to_bet_on_your_market',\n  'user_joined_from_your_group_invite',\n  'quest_payout',\n  'bet_fill',\n  'mana_payment_received',\n]\n\nexport const DELETE_PUSH_TOKEN = 'delete'\n\nexport function combineReactionNotifications(notifications: Notification[]) {\n  const groupedNotificationsBySourceType = groupBy(\n    notifications,\n    (n) =>\n      `${n.sourceType}-${\n        n.sourceTitle ?? n.sourceContractTitle ?? n.sourceContractId\n      }-${n.sourceText}`\n  )\n\n  const newNotifications = Object.values(groupedNotificationsBySourceType).map(\n    (notifications) => {\n      const mostRecentNotification = notifications[0]\n\n      return {\n        ...mostRecentNotification,\n        data: {\n          ...mostRecentNotification.data,\n          relatedNotifications: notifications,\n        },\n      }\n    }\n  )\n\n  return newNotifications as Notification[]\n}\n\n// Loop through the contracts and combine the notification items into one\nexport function combineAndSumIncomeNotifications(\n  notifications: Notification[]\n) {\n  const newNotifications: Notification[] = []\n  const groupedNotificationsBySourceType = groupBy(\n    notifications,\n    (n) => n.sourceType\n  )\n  const titleForNotification = (notification: Notification) => {\n    const outcomeType = notification.data?.outcomeType\n    return (\n      (notification.sourceTitle ?? notification.sourceContractTitle) +\n      (outcomeType !== 'NUMBER' ? notification.data?.answerText ?? '' : '') +\n      notification.data?.isPartner\n    )\n  }\n\n  for (const sourceType in groupedNotificationsBySourceType) {\n    // Source title splits by contracts, groups, betting streak bonus\n    const groupedNotificationsBySourceTitle = groupBy(\n      groupedNotificationsBySourceType[sourceType],\n      (notification) => titleForNotification(notification)\n    )\n    for (const sourceTitle in groupedNotificationsBySourceTitle) {\n      const notificationsForSourceTitle =\n        groupedNotificationsBySourceTitle[sourceTitle]\n\n      let sum = 0\n      notificationsForSourceTitle.forEach((notification) => {\n        sum += parseFloat(notification.sourceText ?? '0')\n      })\n\n      const { bet: _, ...otherData } =\n        notificationsForSourceTitle[0]?.data ?? {}\n\n      const newNotification = {\n        ...notificationsForSourceTitle[0],\n        sourceText: sum.toString(),\n        sourceUserUsername: notificationsForSourceTitle[0].sourceUserUsername,\n        data: {\n          relatedNotifications: notificationsForSourceTitle,\n          ...otherData,\n        },\n      }\n      newNotifications.push(newNotification)\n    }\n  }\n  return newNotifications\n}\n",
          "postContent": "import { ContractToken, OutcomeType } from 'common/contract'\nimport { groupPath } from './group'\nimport { PAST_BET } from './user'\nimport { notification_preference } from './user-notification-preferences'\nimport { Bet } from 'common/bet'\nimport { league_user_info } from './leagues'\nimport { groupBy } from 'lodash'\n\nexport type NotificationGroup = {\n  notifications: Notification[]\n  groupedById: string\n  isSeen: boolean\n  latestCreatedTime: number\n}\n\nexport type Notification = {\n  id: string\n  userId: string\n  reasonText?: string\n  reason: NotificationReason\n  createdTime: number\n  viewTime?: number\n  isSeen: boolean\n\n  sourceId: string\n  sourceType: notification_source_types\n  sourceUpdateType?: notification_source_update_types\n\n  // sourceContractId is used to group notifications on the same contract together\n  sourceContractId?: string\n  sourceUserName: string\n  sourceUserUsername: string\n  sourceUserAvatarUrl: string\n  sourceText: string\n  data?: { [key: string]: any }\n\n  sourceContractTitle?: string\n  sourceContractCreatorUsername?: string\n  sourceContractSlug?: string\n\n  sourceSlug?: string\n  sourceTitle?: string\n\n  isSeenOnHref?: string\n  markedAsRead?: boolean\n}\n\nexport type NotificationReason =\n  | notification_reason_types\n  | notification_preference\n\nexport type notification_source_types =\n  | 'contract'\n  | 'comment'\n  | 'bet'\n  | 'answer'\n  | 'liquidity'\n  | 'follow'\n  | 'tip'\n  | 'admin_message'\n  | 'group'\n  | 'user'\n  | 'bonus' // strictly unique bettor bonuses atm\n  | 'challenge'\n  | 'betting_streak_bonus'\n  | 'betting_streak_expiring'\n  | 'loan'\n  | 'tip_and_like'\n  | 'badge'\n  | 'signup_bonus'\n  | 'comment_like'\n  | 'contract_like'\n  | 'weekly_portfolio_update'\n  | 'quest_reward'\n  | 'league_change'\n  | 'bounty_added'\n  | 'mana_payment'\n  | 'referral_program'\n  | 'follow_suggestion'\n  | 'market_review'\n  | 'comment_on_lover'\n  | 'new_match'\n  | 'bet_reply'\n  | 'new_message'\n  | 'post'\n  | 'post_like'\n  | 'post_comment_like'\n  | love_notification_source_types\n  | 'push_notification_bonus'\n  | 'airdrop'\n  | 'manifest_airdrop'\n  | 'extra_purchased_mana'\n  | 'payment_status'\n\nexport type love_notification_source_types =\n  | 'love_contract'\n  | 'love_comment'\n  | 'love_answer'\n  | 'love_like'\n  | 'love_ship'\n\nexport type notification_source_update_types =\n  | 'created'\n  | 'updated'\n  | 'resolved'\n  | 'deleted'\n  | 'closed'\n  | 'canceled'\n  | 'expired'\n\n/** @deprecated - use a notification_preference (in user-notification-preferences.ts) */\nexport type notification_reason_types =\n  | 'on_new_follow'\n  | 'contract_from_followed_user'\n  | 'you_referred_user'\n  | 'user_joined_to_bet_on_your_market'\n  | 'bet_fill'\n  | 'limit_order_cancelled'\n  | 'user_joined_from_your_group_invite'\n  | 'betting_streak_incremented'\n  | 'loan_income'\n  | 'comment_on_your_contract'\n  | 'answer_on_your_contract'\n  | 'comment_on_contract_you_follow'\n  | 'answer_on_contract_you_follow'\n  | 'update_on_contract_you_follow'\n  | 'resolution_on_contract_you_follow'\n  | 'comment_on_contract_with_users_shares_in'\n  | 'update_on_contract_with_users_shares_in'\n  | 'resolution_on_contract_with_users_shares_in'\n  | 'comment_on_contract_with_users_answer'\n  | 'update_on_contract_with_users_answer'\n  | 'resolution_on_contract_with_users_answer'\n  | 'answer_on_contract_with_users_answer'\n  | 'comment_on_contract_with_users_comment'\n  | 'answer_on_contract_with_users_comment'\n  | 'update_on_contract_with_users_comment'\n  | 'resolution_on_contract_with_users_comment'\n  | 'reply_to_users_answer'\n  | 'reply_to_users_comment'\n  | 'your_contract_closed'\n  | 'subsidized_your_market'\n  | 'bounty_awarded'\n  | 'bounty_added'\n  | 'bounty_canceled'\n  | 'mana_payment_received'\n\ntype notification_descriptions = {\n  [key in notification_preference]: {\n    simple: string\n    detailed: string\n    necessary?: boolean\n    verb?: string\n  }\n}\nexport const NOTIFICATION_DESCRIPTIONS: notification_descriptions = {\n  all_answers_on_my_markets: {\n    simple: 'Answers on your questions',\n    detailed: 'Answers on your own questions',\n    verb: 'answered your question',\n  },\n  all_comments_on_my_markets: {\n    simple: 'Comments on your questions',\n    detailed: 'Comments on your own questions',\n    verb: 'commented on your market',\n  },\n  betting_streaks: {\n    simple: `Prediction streak bonuses & expirations`,\n    detailed: `Bonuses and expiration notices for prediction streaks made over consecutive days`,\n  },\n  all_answers_on_watched_markets: {\n    simple: 'All new answers',\n    detailed: \"All new answers on questions you're watching\",\n  },\n  quest_payout: {\n    simple: `Quest completion rewards`,\n    detailed: `Bonuses paid out for completing quests`,\n  },\n  contract_from_followed_user: {\n    simple: 'New questions from users you follow',\n    detailed: 'New questions from users you follow',\n  },\n  limit_order_fills: {\n    simple: 'Limit order fills, expirations, and cancellations',\n    detailed: 'When your limit order fills, cancels, or expires',\n  },\n  loan_income: {\n    simple: 'Automatic loans from your predictions in unresolved questions',\n    detailed:\n      'Automatic loans from your predictions that are locked in unresolved questions',\n  },\n\n  on_new_follow: {\n    simple: 'A user followed you',\n    detailed: 'A user followed you',\n  },\n  onboarding_flow: {\n    simple: 'Emails to help you get started using Manifold',\n    detailed: 'Emails to help you learn how to use Manifold',\n  },\n  probability_updates_on_watched_markets: {\n    simple: 'Large changes in probability on questions that you watch',\n    detailed: 'Large changes in probability on questions that you watch',\n  },\n  profit_loss_updates: {\n    simple: 'Weekly portfolio updates',\n    detailed: 'Weekly portfolio updates',\n  },\n  referral_bonuses: {\n    simple: 'Referring new users',\n    detailed: 'Bonuses you receive from referring a new user',\n  },\n  resolutions_on_watched_markets: {\n    simple: 'All question resolutions',\n    detailed: \"All resolutions on questions that you're watching\",\n  },\n  resolutions_on_watched_markets_with_shares_in: {\n    simple: `Only question resolutions that you've ${PAST_BET}`,\n    detailed: `Only resolutions of questions you're watching and that you've ${PAST_BET}`,\n  },\n  subsidized_your_market: {\n    simple: 'Your question was subsidized',\n    detailed: 'When someone subsidizes your market',\n  },\n  tagged_user: {\n    simple: 'A user tagged you',\n    detailed: 'When another use tags you',\n    verb: 'tagged you',\n  },\n  league_changed: {\n    simple: 'Your league changed',\n    detailed: 'When you join, move up, or move down a league',\n  },\n  thank_you_for_purchases: {\n    simple: 'Thank you notes for your purchases',\n    detailed: 'Thank you notes for your purchases',\n  },\n  trending_markets: {\n    simple: 'Weekly interesting questions',\n    detailed: 'Weekly interesting questions',\n  },\n  unique_bettors_on_your_contract: {\n    simple: 'Unique predictors on your questions',\n    detailed: 'Bonuses for unique predictors on your questions',\n  },\n  your_contract_closed: {\n    simple: 'Your question has closed and you need to resolve it (necessary)',\n    detailed: 'Your question has closed and you need to resolve it (necessary)',\n    necessary: true,\n  },\n  all_comments_on_watched_markets: {\n    simple: 'All new comments',\n    detailed: 'All new comments on questions you follow',\n  },\n  all_comments_on_contracts_with_shares_in_on_watched_markets: {\n    simple: `Only on questions you've ${PAST_BET}`,\n    detailed: `Comments on questions that you're watching and you've ${PAST_BET}`,\n  },\n  all_replies_to_my_comments_on_watched_markets: {\n    simple: 'Only replies to your comments',\n    detailed: \"Only replies to your comments on questions you're watching\",\n    verb: 'replied to you',\n  },\n  all_replies_to_my_answers_on_watched_markets: {\n    simple: 'Only replies to your answers',\n    detailed: \"Only replies to your answers on questions you're watching\",\n    verb: 'replied to you',\n  },\n  opt_out_all: {\n    simple: 'Opt out of all notifications (excludes when your questions close)',\n    detailed:\n      'Opt out of all notifications excluding your own question closure notifications',\n  },\n  user_liked_your_content: {\n    simple: 'A user liked your content',\n    detailed: 'A user liked your comment, market, or other content',\n  },\n  bounty_awarded: {\n    simple: 'Bounties you receive',\n    detailed: 'When the creator awards you a bounty for your comment',\n  },\n  bounty_added: {\n    simple: 'Bounties added to your question',\n    detailed: 'When another user adds a bounty to your question',\n  },\n  bounty_canceled: {\n    simple: 'A bounty you follow is canceled',\n    detailed: 'When the creator of a bounty cancels it',\n  },\n  all_votes_on_watched_markets: {\n    simple: 'Votes on polls you follow',\n    detailed: 'When a user votes on a poll you follow',\n  },\n  vote_on_your_contract: {\n    simple: 'Votes on your polls',\n    detailed: 'When a user votes on a poll you created',\n  },\n  poll_close_on_watched_markets: {\n    simple: 'Polls you follow close',\n    detailed: 'When a poll you follow closes',\n  },\n  your_poll_closed: {\n    simple: 'Your poll closes',\n    detailed: 'When a poll you created closes',\n  },\n  review_on_your_market: {\n    simple: 'Reviews on your questions',\n    detailed: 'When a user reviews your question after resolution',\n  },\n  new_match: {\n    simple: 'New matches',\n    detailed: 'When you match with another user',\n  },\n  new_message: {\n    simple: 'New messages',\n    detailed: 'When another user messages you',\n  },\n  new_endorsement: {\n    simple: 'New endorsements',\n    detailed: 'When another user endorses you',\n  },\n  new_love_like: {\n    simple: 'New likes',\n    detailed: 'When another user likes you',\n  },\n  new_love_ship: {\n    simple: 'New ships',\n    detailed:\n      'When another user supports a relationship between you and someone else',\n  },\n  airdrop: {\n    simple: 'You received a gift of mana',\n    detailed: 'Manifold has sent you a gift of mana',\n  },\n  manifest_airdrop: {\n    simple: 'You received a gift for attending Manifest',\n    detailed: 'Manifold has sent you a gift for attending Manifest',\n  },\n  extra_purchased_mana: {\n    simple: 'You just received 9x your purchased mana in 2024',\n    detailed: 'Manifold has sent you a gift of 9x your purchased mana in 2024.',\n  },\n  payment_status: {\n    simple: 'Payment updates',\n    detailed: 'Updates on your payment statuses',\n  },\n  market_movements: {\n    simple: 'Market movements',\n    detailed:\n      'When the probability of a market that you follow changes by a large amount',\n  },\n  market_follows: {\n    simple: 'Someone followed your market',\n    detailed: 'Get notified when someone follows one of your markets',\n    verb: 'followed your market',\n  },\n  admin: {\n    simple: 'Admin notifications',\n    detailed: 'Notifications from the Manifold team',\n  },\n  all_comments_on_followed_posts: {\n    simple: 'All new comments on posts you follow',\n    detailed: 'All new comments on posts you follow',\n  },\n}\n\nexport type BettingStreakData = {\n  streak: number\n  bonusAmount: number\n  cashAmount?: number\n}\nexport type LeagueChangeData = {\n  previousLeague: league_user_info | undefined\n  newLeague: { season: number; division: number; cohort: string }\n  bonusAmount: number\n}\n\nexport type BetFillData = {\n  betAnswer?: string\n  creatorOutcome: string\n  probability: number\n  limitOrderTotal?: number\n  limitOrderRemaining?: number\n  limitAt?: string\n  mechanism: 'cpmm-1' | 'cpmm-multi-1'\n  outcomeType: OutcomeType\n  betAnswerId?: string\n  expiresAt?: number\n  createdTime?: number\n}\n\nexport type ContractResolutionData = {\n  outcome: string\n  userPayout: number\n  userInvestment: number\n  profitRank?: number\n  totalShareholders?: number\n  profit?: number\n  answerId?: string\n  token?: ContractToken\n}\n\nexport type UniqueBettorData = {\n  bet: Bet\n  outcomeType: OutcomeType\n  answerText?: string\n  min?: number\n  max?: number\n  isLogScale?: boolean\n  isPartner?: boolean\n  totalUniqueBettors?: number\n  totalAmountBet?: number\n  token?: ContractToken\n  bonusAmount?: number\n}\n\nexport type ReviewNotificationData = {\n  rating: number\n  review: string\n}\n\nexport type CommentNotificationData = {\n  isReply: boolean\n}\n\nexport type BetReplyNotificationData = {\n  betAmount: number\n  betOutcome: string\n  commentText: string\n}\n\nexport type MarketMovementData = {\n  val_start: number\n  val_end: number\n  val_start_time: string\n  val_end_time: string\n  answerText?: string\n}\n\nexport type AirdropData = {\n  amount: number\n}\n\nexport type ManaPaymentData = {\n  message: string\n  token?: 'M$' | 'CASH'\n}\n\nexport type ExtraPurchasedManaData = {\n  amount: number\n}\n\nexport type PaymentCompletedData = {\n  userId: string\n  amount: number\n  currency: string\n  paymentMethodType: string\n  paymentAmountType: string\n}\n\nexport type ReferralData = {\n  manaAmount: number\n  cashAmount: number\n}\n\nexport function getSourceIdForLinkComponent(\n  sourceId: string,\n  sourceType?: notification_source_types\n) {\n  switch (sourceType) {\n    case 'answer':\n      return `answer-${sourceId}`\n    case 'comment':\n      return sourceId\n    case 'contract':\n      return ''\n    case 'bet':\n      return ''\n    default:\n      return sourceId\n  }\n}\n\nexport function getSourceUrl(notification: Notification) {\n  const {\n    sourceType,\n    sourceId,\n    sourceUserUsername,\n    sourceContractCreatorUsername,\n    sourceContractSlug,\n    sourceSlug,\n    reason,\n  } = notification\n\n  if (sourceType === 'weekly_portfolio_update')\n    return `/week/${sourceUserUsername}/${sourceSlug}`\n  if (reason === 'market_follows')\n    return `/${sourceContractCreatorUsername}/${sourceContractSlug}`\n  if (sourceType === 'follow') return `/${sourceUserUsername}`\n  if (sourceType === 'group' && sourceSlug) return `${groupPath(sourceSlug)}`\n  // User referral via contract:\n  if (\n    sourceContractCreatorUsername &&\n    sourceContractSlug &&\n    sourceType === 'user'\n  )\n    return `/${sourceContractCreatorUsername}/${sourceContractSlug}`\n  // User referral:\n  if (sourceType === 'user' && !sourceContractSlug)\n    return `/${sourceUserUsername}`\n  if (\n    sourceType === 'challenge' ||\n    ReactionNotificationTypes.includes(sourceType)\n  )\n    return `${sourceSlug}`\n  if (sourceContractCreatorUsername && sourceContractSlug) {\n    return `/${sourceContractCreatorUsername}/${sourceContractSlug}#${getSourceIdForLinkComponent(\n      sourceId ?? '',\n      sourceType\n    )}`\n  }\n  if (sourceSlug) {\n    return `${\n      sourceSlug.startsWith('/') ? sourceSlug : '/' + sourceSlug\n    }#${getSourceIdForLinkComponent(sourceId ?? '', sourceType)}`\n  }\n  return ''\n}\n\nexport const ReactionNotificationTypes: Partial<notification_source_types>[] = [\n  'comment_like',\n  'contract_like',\n  'post_like',\n  'post_comment_like',\n]\n\nexport const BalanceChangeNotificationTypes: NotificationReason[] = [\n  'loan_income',\n  // bonuses\n  'betting_streak_incremented',\n  'unique_bettors_on_your_contract',\n  // resolutions\n  'resolution_on_contract_with_users_shares_in',\n  'resolutions_on_watched_markets_with_shares_in',\n  // referrals\n  'you_referred_user',\n  'user_joined_to_bet_on_your_market',\n  'user_joined_from_your_group_invite',\n  'quest_payout',\n  'bet_fill',\n  'mana_payment_received',\n]\n\nexport const DELETE_PUSH_TOKEN = 'delete'\n\nexport function combineReactionNotifications(notifications: Notification[]) {\n  const groupedNotificationsBySourceType = groupBy(\n    notifications,\n    (n) =>\n      `${n.sourceType}-${\n        n.sourceTitle ?? n.sourceContractTitle ?? n.sourceContractId\n      }-${n.sourceText}`\n  )\n\n  const newNotifications = Object.values(groupedNotificationsBySourceType).map(\n    (notifications) => {\n      const mostRecentNotification = notifications[0]\n\n      return {\n        ...mostRecentNotification,\n        data: {\n          ...mostRecentNotification.data,\n          relatedNotifications: notifications,\n        },\n      }\n    }\n  )\n\n  return newNotifications as Notification[]\n}\n\n// Loop through the contracts and combine the notification items into one\nexport function combineAndSumIncomeNotifications(\n  notifications: Notification[]\n) {\n  const newNotifications: Notification[] = []\n  const groupedNotificationsBySourceType = groupBy(\n    notifications,\n    (n) => n.sourceType\n  )\n  const titleForNotification = (notification: Notification) => {\n    const outcomeType = notification.data?.outcomeType\n    return (\n      (notification.sourceTitle ?? notification.sourceContractTitle) +\n      (outcomeType !== 'NUMBER' ? notification.data?.answerText ?? '' : '') +\n      notification.data?.isPartner\n    )\n  }\n\n  for (const sourceType in groupedNotificationsBySourceType) {\n    // Source title splits by contracts, groups, betting streak bonus\n    const groupedNotificationsBySourceTitle = groupBy(\n      groupedNotificationsBySourceType[sourceType],\n      (notification) => titleForNotification(notification)\n    )\n    for (const sourceTitle in groupedNotificationsBySourceTitle) {\n      const notificationsForSourceTitle =\n        groupedNotificationsBySourceTitle[sourceTitle]\n\n      let sum = 0\n      notificationsForSourceTitle.forEach((notification) => {\n        sum += parseFloat(notification.sourceText ?? '0')\n      })\n\n      const { bet: _, ...otherData } =\n        notificationsForSourceTitle[0]?.data ?? {}\n\n      const newNotification = {\n        ...notificationsForSourceTitle[0],\n        sourceText: sum.toString(),\n        sourceUserUsername: notificationsForSourceTitle[0].sourceUserUsername,\n        data: {\n          relatedNotifications: notificationsForSourceTitle,\n          ...otherData,\n        },\n      }\n      newNotifications.push(newNotification)\n    }\n  }\n  return newNotifications\n}\n"
        },
        {
          "path": "common/src/user-notification-preferences.ts",
          "preContent": "import { filterDefined } from './util/array'\nimport { notification_reason_types, NotificationReason } from './notification'\nimport { getApiUrl } from './api/utils'\nimport { DOMAIN } from './envs/constants'\nimport { PrivateUser } from './user'\n\nexport type notification_destination_types = 'email' | 'browser' | 'mobile'\nexport type notification_preference = keyof notification_preferences\nexport type notification_preferences = {\n  // Watched Markets\n  all_comments_on_watched_markets: notification_destination_types[]\n  all_answers_on_watched_markets: notification_destination_types[]\n  poll_close_on_watched_markets: notification_destination_types[]\n\n  // Comments\n  all_replies_to_my_comments_on_watched_markets: notification_destination_types[]\n  all_replies_to_my_answers_on_watched_markets: notification_destination_types[]\n  all_comments_on_contracts_with_shares_in_on_watched_markets: notification_destination_types[]\n\n  // On users' markets\n  your_contract_closed: notification_destination_types[]\n  all_comments_on_my_markets: notification_destination_types[]\n  all_answers_on_my_markets: notification_destination_types[]\n  subsidized_your_market: notification_destination_types[]\n  vote_on_your_contract: notification_destination_types[]\n  your_poll_closed: notification_destination_types[]\n  review_on_your_market: notification_destination_types[]\n  market_follows: notification_destination_types[]\n\n  // Market updates\n  resolutions_on_watched_markets: notification_destination_types[]\n  resolutions_on_watched_markets_with_shares_in: notification_destination_types[]\n  all_votes_on_watched_markets: notification_destination_types[]\n  probability_updates_on_watched_markets: notification_destination_types[]\n  bounty_awarded: notification_destination_types[]\n  bounty_added: notification_destination_types[]\n  bounty_canceled: notification_destination_types[]\n  market_movements: notification_destination_types[]\n\n  // Balance Changes\n  loan_income: notification_destination_types[]\n  betting_streaks: notification_destination_types[]\n  referral_bonuses: notification_destination_types[]\n  unique_bettors_on_your_contract: notification_destination_types[]\n  limit_order_fills: notification_destination_types[]\n  quest_payout: notification_destination_types[]\n  airdrop: notification_destination_types[]\n  manifest_airdrop: notification_destination_types[]\n  extra_purchased_mana: notification_destination_types[]\n  payment_status: notification_destination_types[]\n\n  // Leagues\n  league_changed: notification_destination_types[]\n\n  // Manifold.love\n  new_match: notification_destination_types[]\n  new_endorsement: notification_destination_types[]\n  new_love_like: notification_destination_types[]\n  new_love_ship: notification_destination_types[]\n\n  // User-related\n  new_message: notification_destination_types[]\n  tagged_user: notification_destination_types[]\n  user_liked_your_content: notification_destination_types[]\n  on_new_follow: notification_destination_types[]\n  contract_from_followed_user: notification_destination_types[]\n\n  // General\n  trending_markets: notification_destination_types[]\n  profit_loss_updates: notification_destination_types[]\n  onboarding_flow: notification_destination_types[]\n  thank_you_for_purchases: notification_destination_types[]\n  opt_out_all: notification_destination_types[]\n  admin: notification_destination_types[] // Atm this preference isn't checked, it's always assumed true\n}\n\nexport const getDefaultNotificationPreferences = (isDev?: boolean) => {\n  const constructPref = (\n    browserIf: boolean,\n    emailIf: boolean,\n    mobileIf: boolean\n  ) => {\n    const browser = browserIf ? 'browser' : undefined\n    const email = isDev ? undefined : emailIf ? 'email' : undefined\n    const mobile = mobileIf ? 'mobile' : undefined\n    return filterDefined([\n      browser,\n      email,\n      mobile,\n    ]) as notification_destination_types[]\n  }\n  const defaults: notification_preferences = {\n    // Watched Markets\n    all_comments_on_watched_markets: constructPref(false, false, false),\n    // Answers\n    all_answers_on_watched_markets: constructPref(false, false, false),\n    // Comments\n    all_replies_to_my_comments_on_watched_markets: constructPref(\n      true,\n      true,\n      true\n    ),\n    all_replies_to_my_answers_on_watched_markets: constructPref(\n      true,\n      true,\n      true\n    ),\n    all_comments_on_contracts_with_shares_in_on_watched_markets: constructPref(\n      false,\n      false,\n      false\n    ),\n\n    // On users' markets\n    your_contract_closed: constructPref(true, true, false), // High priority\n    all_comments_on_my_markets: constructPref(true, true, false),\n    all_answers_on_my_markets: constructPref(true, true, false),\n    subsidized_your_market: constructPref(true, true, false),\n    vote_on_your_contract: constructPref(true, true, false),\n    your_poll_closed: constructPref(true, true, false),\n    review_on_your_market: constructPref(true, false, false),\n    market_follows: constructPref(true, false, false),\n    // Market updates\n    resolutions_on_watched_markets: constructPref(true, true, true),\n    all_votes_on_watched_markets: constructPref(false, false, false),\n    resolutions_on_watched_markets_with_shares_in: constructPref(\n      true,\n      true,\n      true\n    ),\n    bounty_awarded: constructPref(true, false, false),\n    bounty_added: constructPref(true, false, false),\n    bounty_canceled: constructPref(true, false, false),\n    poll_close_on_watched_markets: constructPref(true, false, false),\n    market_movements: constructPref(true, true, true),\n\n    // Balance Changes\n    loan_income: constructPref(true, false, false),\n    betting_streaks: constructPref(true, false, true),\n    referral_bonuses: constructPref(true, true, false),\n    unique_bettors_on_your_contract: constructPref(true, true, false),\n    limit_order_fills: constructPref(true, false, true),\n    quest_payout: constructPref(true, false, false),\n    airdrop: constructPref(true, false, false),\n    manifest_airdrop: constructPref(true, false, false),\n    extra_purchased_mana: constructPref(true, false, false),\n    payment_status: constructPref(true, false, false),\n\n    // Leagues\n    league_changed: constructPref(true, false, false),\n\n    // Manifold.love\n    new_match: constructPref(true, true, true),\n    new_endorsement: constructPref(true, true, true),\n    new_love_like: constructPref(true, false, false),\n    new_love_ship: constructPref(true, false, false),\n\n    // User-related\n    new_message: constructPref(true, true, true),\n    tagged_user: constructPref(true, true, true),\n    on_new_follow: constructPref(true, true, false),\n    contract_from_followed_user: constructPref(true, false, false),\n    user_liked_your_content: constructPref(true, false, false),\n\n    // General\n    trending_markets: constructPref(false, true, false),\n    profit_loss_updates: constructPref(true, true, false),\n    probability_updates_on_watched_markets: constructPref(true, false, true),\n    thank_you_for_purchases: constructPref(false, false, false),\n    onboarding_flow: constructPref(true, true, false),\n    admin: constructPref(true, true, true),\n    opt_out_all: [],\n  }\n  return defaults\n}\n\n// Adding a new key:value here is optional, you can just use a key of notification_subscription_types\n// You might want to add a key:value here if there will be multiple notification reasons that map to the same\n// subscription type, i.e. 'comment_on_contract_you_follow' and 'comment_on_contract_with_users_answer' both map to\n// 'all_comments_on_watched_markets' subscription type\n// TODO: perhaps better would be to map notification_subscription_types to arrays of notification_reason_types\nexport const notificationReasonToSubscriptionType: Partial<\n  Record<notification_reason_types, notification_preference>\n> = {\n  you_referred_user: 'referral_bonuses',\n  user_joined_to_bet_on_your_market: 'referral_bonuses',\n  bet_fill: 'limit_order_fills',\n  user_joined_from_your_group_invite: 'referral_bonuses',\n  betting_streak_incremented: 'betting_streaks',\n  comment_on_your_contract: 'all_comments_on_my_markets',\n  answer_on_your_contract: 'all_answers_on_my_markets',\n  comment_on_contract_you_follow: 'all_comments_on_watched_markets',\n  resolution_on_contract_you_follow: 'resolutions_on_watched_markets',\n  comment_on_contract_with_users_shares_in:\n    'all_comments_on_contracts_with_shares_in_on_watched_markets',\n  resolution_on_contract_with_users_shares_in:\n    'resolutions_on_watched_markets_with_shares_in',\n  comment_on_contract_with_users_answer: 'all_comments_on_watched_markets',\n  resolution_on_contract_with_users_answer: 'resolutions_on_watched_markets',\n  comment_on_contract_with_users_comment: 'all_comments_on_watched_markets',\n  resolution_on_contract_with_users_comment: 'resolutions_on_watched_markets',\n  reply_to_users_answer: 'all_replies_to_my_answers_on_watched_markets',\n  reply_to_users_comment: 'all_replies_to_my_comments_on_watched_markets',\n}\n\nexport function getNotificationPreference(reason: NotificationReason) {\n  return (notificationReasonToSubscriptionType[\n    reason as notification_reason_types\n  ] ?? reason) as notification_preference\n}\n\nexport const getNotificationDestinationsForUser = (\n  privateUser: PrivateUser,\n  // TODO: accept reasons array from most to least important and work backwards\n  reason: NotificationReason\n) => {\n  const notificationSettings = privateUser.notificationPreferences\n  const unsubscribeEndpoint = getApiUrl('unsubscribe')\n  try {\n    const notificationPreference = getNotificationPreference(reason)\n    // Get default destinations if user has no settings for this preference\n    // TODO: write the default notif preferences to the user's settings when missing\n    const destinations =\n      notificationSettings[notificationPreference] ??\n      getDefaultNotificationPreferences()[notificationPreference]\n    const optOutOfAllSettings = notificationSettings.opt_out_all\n    // Your market closure notifications are high priority, opt-out doesn't affect their delivery\n    const optedOutOfEmail =\n      optOutOfAllSettings.includes('email') &&\n      notificationPreference !== 'your_contract_closed'\n    const optedOutOfBrowser =\n      optOutOfAllSettings.includes('browser') &&\n      notificationPreference !== 'your_contract_closed'\n    const optedOutOfPush =\n      !privateUser.pushToken || optOutOfAllSettings.includes('mobile')\n    return {\n      sendToEmail: destinations.includes('email') && !optedOutOfEmail,\n      sendToBrowser: destinations.includes('browser') && !optedOutOfBrowser,\n      sendToMobile: destinations.includes('mobile') && !optedOutOfPush,\n      unsubscribeUrl: `${unsubscribeEndpoint}?id=${privateUser.id}&type=${notificationPreference}`,\n      urlToManageThisNotification: `${DOMAIN}/notifications?tab=settings&section=${notificationPreference}`,\n      notificationPreference,\n    }\n  } catch {\n    // Fail safely\n    console.log(\n      `couldn't get notification destinations for type ${reason} for user ${privateUser.id}`\n    )\n    return {\n      sendToEmail: false,\n      sendToBrowser: false,\n      sendToMobile: false,\n      unsubscribeUrl: '',\n      urlToManageThisNotification: '',\n    }\n  }\n}\n\nexport const userOptedOutOfBrowserNotifications = (\n  privateUser: PrivateUser\n) => {\n  const { notificationPreferences } = privateUser\n  const optOutOfAllSettings = notificationPreferences.opt_out_all\n  return optOutOfAllSettings.includes('browser')\n}\n\nexport const userIsBlocked = (\n  privateUserReceiver: PrivateUser,\n  userSenderId: string\n) => {\n  return (\n    privateUserReceiver.blockedUserIds.includes(userSenderId) ||\n    privateUserReceiver.blockedByUserIds.includes(userSenderId)\n  )\n}\n",
          "postContent": "import { filterDefined } from './util/array'\nimport { notification_reason_types, NotificationReason } from './notification'\nimport { getApiUrl } from './api/utils'\nimport { DOMAIN } from './envs/constants'\nimport { PrivateUser } from './user'\n\nexport type notification_destination_types = 'email' | 'browser' | 'mobile'\nexport type notification_preference = keyof notification_preferences\nexport type notification_preferences = {\n  // Watched Markets\n  all_comments_on_watched_markets: notification_destination_types[]\n  all_answers_on_watched_markets: notification_destination_types[]\n  poll_close_on_watched_markets: notification_destination_types[]\n  all_comments_on_followed_posts: notification_destination_types[]\n\n  // Comments\n  all_replies_to_my_comments_on_watched_markets: notification_destination_types[]\n  all_replies_to_my_answers_on_watched_markets: notification_destination_types[]\n  all_comments_on_contracts_with_shares_in_on_watched_markets: notification_destination_types[]\n\n  // On users' markets\n  your_contract_closed: notification_destination_types[]\n  all_comments_on_my_markets: notification_destination_types[]\n  all_answers_on_my_markets: notification_destination_types[]\n  subsidized_your_market: notification_destination_types[]\n  vote_on_your_contract: notification_destination_types[]\n  your_poll_closed: notification_destination_types[]\n  review_on_your_market: notification_destination_types[]\n  market_follows: notification_destination_types[]\n\n  // Market updates\n  resolutions_on_watched_markets: notification_destination_types[]\n  resolutions_on_watched_markets_with_shares_in: notification_destination_types[]\n  all_votes_on_watched_markets: notification_destination_types[]\n  probability_updates_on_watched_markets: notification_destination_types[]\n  bounty_awarded: notification_destination_types[]\n  bounty_added: notification_destination_types[]\n  bounty_canceled: notification_destination_types[]\n  market_movements: notification_destination_types[]\n\n  // Balance Changes\n  loan_income: notification_destination_types[]\n  betting_streaks: notification_destination_types[]\n  referral_bonuses: notification_destination_types[]\n  unique_bettors_on_your_contract: notification_destination_types[]\n  limit_order_fills: notification_destination_types[]\n  quest_payout: notification_destination_types[]\n  airdrop: notification_destination_types[]\n  manifest_airdrop: notification_destination_types[]\n  extra_purchased_mana: notification_destination_types[]\n  payment_status: notification_destination_types[]\n\n  // Leagues\n  league_changed: notification_destination_types[]\n\n  // Manifold.love\n  new_match: notification_destination_types[]\n  new_endorsement: notification_destination_types[]\n  new_love_like: notification_destination_types[]\n  new_love_ship: notification_destination_types[]\n\n  // User-related\n  new_message: notification_destination_types[]\n  tagged_user: notification_destination_types[]\n  user_liked_your_content: notification_destination_types[]\n  on_new_follow: notification_destination_types[]\n  contract_from_followed_user: notification_destination_types[]\n\n  // General\n  trending_markets: notification_destination_types[]\n  profit_loss_updates: notification_destination_types[]\n  onboarding_flow: notification_destination_types[]\n  thank_you_for_purchases: notification_destination_types[]\n  opt_out_all: notification_destination_types[]\n  admin: notification_destination_types[] // Atm this preference isn't checked, it's always assumed true\n}\n\nexport const getDefaultNotificationPreferences = (isDev?: boolean) => {\n  const constructPref = (\n    browserIf: boolean,\n    emailIf: boolean,\n    mobileIf: boolean\n  ) => {\n    const browser = browserIf ? 'browser' : undefined\n    const email = isDev ? undefined : emailIf ? 'email' : undefined\n    const mobile = mobileIf ? 'mobile' : undefined\n    return filterDefined([\n      browser,\n      email,\n      mobile,\n    ]) as notification_destination_types[]\n  }\n  const defaults: notification_preferences = {\n    // Watched Markets\n    all_comments_on_watched_markets: constructPref(false, false, false),\n    // Answers\n    all_answers_on_watched_markets: constructPref(false, false, false),\n    // Added for post follows\n    all_comments_on_followed_posts: constructPref(true, true, true),\n    // Comments\n    all_replies_to_my_comments_on_watched_markets: constructPref(\n      true,\n      true,\n      true\n    ),\n    all_replies_to_my_answers_on_watched_markets: constructPref(\n      true,\n      true,\n      true\n    ),\n    all_comments_on_contracts_with_shares_in_on_watched_markets: constructPref(\n      false,\n      false,\n      false\n    ),\n\n    // On users' markets\n    your_contract_closed: constructPref(true, true, false), // High priority\n    all_comments_on_my_markets: constructPref(true, true, false),\n    all_answers_on_my_markets: constructPref(true, true, false),\n    subsidized_your_market: constructPref(true, true, false),\n    vote_on_your_contract: constructPref(true, true, false),\n    your_poll_closed: constructPref(true, true, false),\n    review_on_your_market: constructPref(true, false, false),\n    market_follows: constructPref(true, false, false),\n    // Market updates\n    resolutions_on_watched_markets: constructPref(true, true, true),\n    all_votes_on_watched_markets: constructPref(false, false, false),\n    resolutions_on_watched_markets_with_shares_in: constructPref(\n      true,\n      true,\n      true\n    ),\n    bounty_awarded: constructPref(true, false, false),\n    bounty_added: constructPref(true, false, false),\n    bounty_canceled: constructPref(true, false, false),\n    poll_close_on_watched_markets: constructPref(true, false, false),\n    market_movements: constructPref(true, true, true),\n\n    // Balance Changes\n    loan_income: constructPref(true, false, false),\n    betting_streaks: constructPref(true, false, true),\n    referral_bonuses: constructPref(true, true, false),\n    unique_bettors_on_your_contract: constructPref(true, true, false),\n    limit_order_fills: constructPref(true, false, true),\n    quest_payout: constructPref(true, false, false),\n    airdrop: constructPref(true, false, false),\n    manifest_airdrop: constructPref(true, false, false),\n    extra_purchased_mana: constructPref(true, false, false),\n    payment_status: constructPref(true, false, false),\n\n    // Leagues\n    league_changed: constructPref(true, false, false),\n\n    // Manifold.love\n    new_match: constructPref(true, true, true),\n    new_endorsement: constructPref(true, true, true),\n    new_love_like: constructPref(true, false, false),\n    new_love_ship: constructPref(true, false, false),\n\n    // User-related\n    new_message: constructPref(true, true, true),\n    tagged_user: constructPref(true, true, true),\n    on_new_follow: constructPref(true, true, false),\n    contract_from_followed_user: constructPref(true, false, false),\n    user_liked_your_content: constructPref(true, false, false),\n\n    // General\n    trending_markets: constructPref(false, true, false),\n    profit_loss_updates: constructPref(true, true, false),\n    probability_updates_on_watched_markets: constructPref(true, false, true),\n    thank_you_for_purchases: constructPref(false, false, false),\n    onboarding_flow: constructPref(true, true, false),\n    admin: constructPref(true, true, true),\n    opt_out_all: [],\n  }\n  return defaults\n}\n\n// Adding a new key:value here is optional, you can just use a key of notification_subscription_types\n// You might want to add a key:value here if there will be multiple notification reasons that map to the same\n// subscription type, i.e. 'comment_on_contract_you_follow' and 'comment_on_contract_with_users_answer' both map to\n// 'all_comments_on_watched_markets' subscription type\n// TODO: perhaps better would be to map notification_subscription_types to arrays of notification_reason_types\nexport const notificationReasonToSubscriptionType: Partial<\n  Record<notification_reason_types, notification_preference>\n> = {\n  you_referred_user: 'referral_bonuses',\n  user_joined_to_bet_on_your_market: 'referral_bonuses',\n  bet_fill: 'limit_order_fills',\n  user_joined_from_your_group_invite: 'referral_bonuses',\n  betting_streak_incremented: 'betting_streaks',\n  comment_on_your_contract: 'all_comments_on_my_markets',\n  answer_on_your_contract: 'all_answers_on_my_markets',\n  comment_on_contract_you_follow: 'all_comments_on_watched_markets',\n  resolution_on_contract_you_follow: 'resolutions_on_watched_markets',\n  comment_on_contract_with_users_shares_in:\n    'all_comments_on_contracts_with_shares_in_on_watched_markets',\n  resolution_on_contract_with_users_shares_in:\n    'resolutions_on_watched_markets_with_shares_in',\n  comment_on_contract_with_users_answer: 'all_comments_on_watched_markets',\n  resolution_on_contract_with_users_answer: 'resolutions_on_watched_markets',\n  comment_on_contract_with_users_comment: 'all_comments_on_watched_markets',\n  resolution_on_contract_with_users_comment: 'resolutions_on_watched_markets',\n  reply_to_users_answer: 'all_replies_to_my_answers_on_watched_markets',\n  reply_to_users_comment: 'all_replies_to_my_comments_on_watched_markets',\n}\n\nexport function getNotificationPreference(reason: NotificationReason) {\n  return (notificationReasonToSubscriptionType[\n    reason as notification_reason_types\n  ] ?? reason) as notification_preference\n}\n\nexport const getNotificationDestinationsForUser = (\n  privateUser: PrivateUser,\n  // TODO: accept reasons array from most to least important and work backwards\n  reason: NotificationReason\n) => {\n  const notificationSettings = privateUser.notificationPreferences\n  const unsubscribeEndpoint = getApiUrl('unsubscribe')\n  try {\n    const notificationPreference = getNotificationPreference(reason)\n    // Get default destinations if user has no settings for this preference\n    // TODO: write the default notif preferences to the user's settings when missing\n    const destinations =\n      notificationSettings[notificationPreference] ??\n      getDefaultNotificationPreferences()[notificationPreference]\n    const optOutOfAllSettings = notificationSettings.opt_out_all\n    // Your market closure notifications are high priority, opt-out doesn't affect their delivery\n    const optedOutOfEmail =\n      optOutOfAllSettings.includes('email') &&\n      notificationPreference !== 'your_contract_closed'\n    const optedOutOfBrowser =\n      optOutOfAllSettings.includes('browser') &&\n      notificationPreference !== 'your_contract_closed'\n    const optedOutOfPush =\n      !privateUser.pushToken || optOutOfAllSettings.includes('mobile')\n    return {\n      sendToEmail: destinations.includes('email') && !optedOutOfEmail,\n      sendToBrowser: destinations.includes('browser') && !optedOutOfBrowser,\n      sendToMobile: destinations.includes('mobile') && !optedOutOfPush,\n      unsubscribeUrl: `${unsubscribeEndpoint}?id=${privateUser.id}&type=${notificationPreference}`,\n      urlToManageThisNotification: `${DOMAIN}/notifications?tab=settings&section=${notificationPreference}`,\n      notificationPreference,\n    }\n  } catch {\n    // Fail safely\n    console.log(\n      `couldn't get notification destinations for type ${reason} for user ${privateUser.id}`\n    )\n    return {\n      sendToEmail: false,\n      sendToBrowser: false,\n      sendToMobile: false,\n      unsubscribeUrl: '',\n      urlToManageThisNotification: '',\n    }\n  }\n}\n\nexport const userOptedOutOfBrowserNotifications = (\n  privateUser: PrivateUser\n) => {\n  const { notificationPreferences } = privateUser\n  const optOutOfAllSettings = notificationPreferences.opt_out_all\n  return optOutOfAllSettings.includes('browser')\n}\n\nexport const userIsBlocked = (\n  privateUserReceiver: PrivateUser,\n  userSenderId: string\n) => {\n  return (\n    privateUserReceiver.blockedUserIds.includes(userSenderId) ||\n    privateUserReceiver.blockedByUserIds.includes(userSenderId)\n  )\n}\n"
        },
        {
          "path": "web/components/buttons/follow-post-button.tsx",
          "preContent": "[NEW FILE]",
          "postContent": "import { BookmarkIcon } from '@heroicons/react/outline'\nimport clsx from 'clsx'\nimport { User } from 'common/user'\nimport { useEffect, useState } from 'react'\nimport toast from 'react-hot-toast'\nimport { Button, IconButton } from 'web/components/buttons/button'\nimport { Row } from 'web/components/layout/row'\nimport { TopLevelPost } from 'common/top-level-post'\nimport { firebaseLogin } from 'web/lib/firebase/users'\nimport { track } from 'web/lib/service/analytics'\nimport { db } from 'web/lib/supabase/db'\nimport { api } from 'web/lib/api/api'\nimport { BookmarkIcon as FilledBookmarkIcon } from '@heroicons/react/solid'\n\nexport const FollowPostButton = (props: {\n  post: TopLevelPost\n  user: User | undefined | null\n  className?: string\n}) => {\n  const { post, user, className } = props\n  const { following, setFollowing } = useIsFollowingPost(post, user)\n\n  return (\n    <Button\n      size=\"sm\"\n      color={'gray-outline'}\n      className={className}\n      onClick={async () => {\n        if (!user) return firebaseLogin()\n        if (following) {\n          unfollowPost(post.id, post.slug).then(() => setFollowing(false))\n        } else {\n          followPost(post.id, post.slug).then(() => setFollowing(true))\n        }\n      }}\n    >\n      {following ? (\n        <Row className={'items-center gap-x-2'}>\n          <FilledBookmarkIcon className={clsx('h-5 w-5')} aria-hidden=\"true\" />\n          Unfollow\n        </Row>\n      ) : (\n        <Row className={'items-center gap-x-2'}>\n          <BookmarkIcon className={clsx('h-5 w-5')} aria-hidden=\"true\" />\n          Follow\n        </Row>\n      )}\n    </Button>\n  )\n}\n\nexport const FollowPostIconButton = (props: {\n  post: TopLevelPost\n  user: User | undefined | null\n  className?: string\n}) => {\n  const { post, user, className } = props\n  const { following, setFollowing } = useIsFollowingPost(post, user)\n\n  return (\n    <IconButton\n      size=\"xs\"\n      className={className}\n      onClick={async () => {\n        if (!user) return firebaseLogin()\n        if (following) {\n          unfollowPost(post.id, post.slug).then(() => setFollowing(false))\n        } else {\n          followPost(post.id, post.slug).then(() => setFollowing(true))\n        }\n      }}\n    >\n      {following ? (\n        <FilledBookmarkIcon className={clsx('h-5 w-5')} aria-hidden=\"true\" />\n      ) : (\n        <BookmarkIcon\n          strokeWidth={2.5}\n          className={clsx('h-5 w-5')}\n          aria-hidden=\"true\"\n        />\n      )}\n    </IconButton>\n  )\n}\n\nconst useIsFollowingPost = (\n  post: TopLevelPost,\n  user: User | undefined | null\n) => {\n  const [following, setFollowing] = useState(false)\n\n  useEffect(() => {\n    if (!user) return\n    // Check initial follow status\n    db.from('post_follows')\n      .select('post_id')\n      .eq('user_id', user.id)\n      .eq('post_id', post.id)\n      .then((res) => {\n        setFollowing((res.data?.length ?? 0) > 0)\n      })\n  }, [user?.id, post.id]) // Add any other relevant dependencies if needed, e.g., a timestamp that updates when a follow action occurs\n\n  // Add useApiSubscription here if real-time updates are desired later\n  // Similar to how contract_follows works with `contract-follow/${contract.id}` topic\n\n  return { following, setFollowing }\n}\n\nexport async function unfollowPost(postId: string, postSlug: string) {\n  // Ensure the API endpoint name matches what we'll create\n  await toast.promise(api('follow-post', { postId, follow: false }), {\n    loading: 'Unfollowing post...',\n    success: `You'll no longer be notified of new comments!`,\n    error: 'Failed to unfollow post',\n  })\n  track('Unfollow Post', {\n    slug: postSlug,\n    postId,\n  })\n}\n\nexport async function followPost(postId: string, postSlug: string) {\n  // Ensure the API endpoint name matches what we'll create\n  await toast.promise(api('follow-post', { postId, follow: true }), {\n    loading: 'Following post...',\n    success: `You'll be notified of new comments!`,\n    error: 'Failed to follow post',\n  })\n  track('Follow Post', {\n    slug: postSlug,\n    postId,\n  })\n}\n"
        },
        {
          "path": "web/components/contract/react-button.tsx",
          "preContent": "import { HeartIcon } from '@heroicons/react/outline'\nimport clsx from 'clsx'\nimport { DisplayUser } from 'common/api/user-types'\nimport { Reaction, ReactionContentTypes, ReactionType } from 'common/reaction'\nimport { User } from 'common/user'\nimport { buildArray } from 'common/util/array'\nimport { removeUndefinedProps } from 'common/util/object'\nimport { capitalize } from 'lodash'\nimport { memo, useEffect, useState } from 'react'\nimport toast from 'react-hot-toast'\nimport { Button, SizeType } from 'web/components/buttons/button'\nimport useLongTouch from 'web/hooks/use-long-touch'\nimport { useReactionsOnContent } from 'web/hooks/use-reactions'\nimport { useUsers } from 'web/hooks/use-user-supabase'\nimport { track } from 'web/lib/service/analytics'\nimport { Col } from '../layout/col'\nimport { Row } from '../layout/row'\nimport {\n  MultiUserLinkInfo,\n  MultiUserTransactionModal,\n} from '../multi-user-transaction-link'\nimport { UserHovercard } from '../user/user-hovercard'\nimport { Avatar } from '../widgets/avatar'\nimport { LoadingIndicator } from '../widgets/loading-indicator'\nimport { Tooltip } from '../widgets/tooltip'\nimport { UserLink } from '../widgets/user-link'\nimport { api } from 'web/lib/api/api'\n\nconst LIKES_SHOWN = 3\n\nexport const ReactButton = memo(function ReactButton(props: {\n  contentId: string\n  contentCreatorId: string\n  user: User | null | undefined\n  contentType: ReactionContentTypes\n  contentText: string\n  trackingLocation: string\n  className?: string\n  placement?: 'top' | 'bottom'\n  reactionType?: ReactionType\n  size?: SizeType\n  disabled?: boolean\n  feedReason?: string\n  contractId?: string\n  commentId?: string\n  postId?: string\n  heartClassName?: string\n  userReactedWith?: 'like' | 'none'\n  onReact?: () => void\n  onUnreact?: () => void\n  hideReactList?: boolean\n}) {\n  const {\n    user,\n    contentType,\n    contentCreatorId,\n    contentId,\n    contentText,\n    className,\n    trackingLocation,\n    placement = 'bottom',\n    feedReason,\n    size,\n    contractId,\n    commentId,\n    postId,\n    heartClassName,\n    reactionType = 'like',\n    userReactedWith,\n    hideReactList,\n  } = props\n  const allReactions = useReactionsOnContent(contentType, contentId)\n  const reactions = allReactions?.filter(\n    (reaction: Reaction) => reaction.reaction_type == reactionType\n  )\n\n  const [reacted, setReacted] = useState(\n    userReactedWith ? userReactedWith == reactionType : false\n  )\n\n  useEffect(() => {\n    setReacted(userReactedWith == reactionType)\n  }, [userReactedWith])\n\n  useEffect(() => {\n    if (reactions)\n      setReacted(\n        reactions.some(\n          (l: Reaction) =>\n            l.user_id === user?.id && l.reaction_type == reactionType\n        )\n      )\n  }, [allReactions, user])\n\n  const totalReactions =\n    (reactions\n      ? reactions.filter((l: Reaction) => l.user_id != user?.id).length\n      : 0) + (reacted ? 1 : 0)\n\n  const disabled = props.disabled || !user\n  const isMe = contentCreatorId === user?.id\n  const [modalOpen, setModalOpen] = useState(false)\n\n  const onReact = async (shouldReact: boolean) => {\n    if (!user) return\n    setReacted(shouldReact)\n    if (shouldReact) {\n      if (props.onReact) props.onReact()\n      await api('react', {\n        remove: false,\n        contentId,\n        contentType,\n        reactionType,\n        commentParentType: postId ? 'post' : undefined,\n      })\n\n      track(\n        reactionType,\n        removeUndefinedProps({\n          itemId: contentId,\n          location: trackingLocation,\n          contractId:\n            contractId ?? (contentType === 'contract' ? contentId : undefined),\n          commentId:\n            commentId ?? (contentType === 'comment' ? contentId : undefined),\n          feedReason,\n          postId: postId ?? (contentType === 'post' ? contentId : undefined),\n        })\n      )\n    } else {\n      if (props.onUnreact) props.onUnreact()\n      await api('react', {\n        remove: true,\n        contentId,\n        contentType,\n        reactionType,\n        commentParentType: postId ? 'post' : undefined,\n      })\n    }\n  }\n\n  function handleReacted(liked: boolean) {\n    onReact(liked)\n  }\n\n  const likeLongPress = useLongTouch(\n    () => {\n      if (!hideReactList) {\n        setModalOpen(true)\n      }\n    },\n    () => {\n      if (!disabled) {\n        if (isMe && reactionType === 'like') {\n          toast(\"Of course you'd like yourself\", { icon: '🙄' })\n        } else {\n          handleReacted(!reacted)\n        }\n      }\n    }\n  )\n\n  const otherLikes = reacted ? totalReactions - 1 : totalReactions\n  const showList = otherLikes > 0 && !hideReactList\n\n  return (\n    <>\n      <Tooltip\n        text={\n          showList ? (\n            <UserReactedPopup\n              contentType={contentType}\n              contentId={contentId}\n              onRequestModal={() => setModalOpen(true)}\n              user={user}\n              userReacted={reacted}\n              reactionType={reactionType}\n            />\n          ) : (\n            capitalize(reactionType)\n          )\n        }\n        placement={placement}\n        noTap\n        hasSafePolygon={showList}\n        className=\"flex items-center\"\n        tooltipClassName=\"z-40\"\n      >\n        {size == '2xs' ? (\n          <button\n            disabled={disabled}\n            className={clsx(\n              'disabled:cursor-not-allowed',\n              'disabled:text-ink-500',\n              className\n            )}\n            {...likeLongPress}\n          >\n            <Row className={'text-ink-600 items-center gap-0.5'}>\n              <div className=\"relative\">\n                <HeartIcon\n                  className={clsx(\n                    'stroke-ink-500 h-4 w-4',\n                    reacted &&\n                      'fill-scarlet-200 stroke-scarlet-300 dark:stroke-scarlet-600'\n                  )}\n                />\n              </div>\n              {totalReactions > 0 && (\n                <div className=\" text-sm disabled:opacity-50\">\n                  {totalReactions}\n                </div>\n              )}\n            </Row>\n          </button>\n        ) : (\n          <Button\n            color={'gray-white'}\n            disabled={disabled}\n            size={size}\n            className={clsx(\n              'text-ink-500 disabled:cursor-not-allowed',\n              'disabled:text-ink-500',\n              className\n            )}\n            {...likeLongPress}\n          >\n            <Row className={'items-center gap-1.5'}>\n              <div className=\"relative\">\n                <HeartIcon\n                  className={clsx(\n                    'h-6 w-6',\n                    heartClassName,\n                    reacted &&\n                      'fill-scarlet-200 stroke-scarlet-300 dark:stroke-scarlet-600'\n                  )}\n                />\n              </div>\n              {totalReactions > 0 && (\n                <div className=\"my-auto h-5  text-sm disabled:opacity-50\">\n                  {totalReactions}\n                </div>\n              )}\n            </Row>\n          </Button>\n        )}\n      </Tooltip>\n      {modalOpen && (\n        <UserReactedFullList\n          contentType={contentType}\n          contentId={contentId}\n          user={user}\n          userReacted={reacted}\n          setOpen={setModalOpen}\n          titleName={contentText}\n          reactionType={reactionType}\n        />\n      )}\n    </>\n  )\n})\n\nfunction useReactedDisplayList(\n  reacts: Reaction[] = [],\n  self?: User | null,\n  prependSelf?: boolean\n) {\n  const users = useUsers(reacts.map((r) => r.user_id))\n\n  return buildArray([\n    prependSelf && self,\n    users?.filter((u): u is DisplayUser => !!u && u.id !== self?.id),\n  ])\n}\n\nfunction UserReactedFullList(props: {\n  contentType: ReactionContentTypes\n  contentId: string\n  user?: User | null\n  userReacted?: boolean\n  setOpen: (isOpen: boolean) => void\n  titleName?: string\n  reactionType: ReactionType\n}) {\n  const {\n    contentType,\n    contentId,\n    user,\n    userReacted,\n    setOpen,\n    titleName,\n    reactionType,\n  } = props\n  const reacts = useReactionsOnContent(contentType, contentId)?.filter(\n    (reaction: Reaction) => reaction.reaction_type == reactionType\n  )\n\n  const displayInfos = useReactedDisplayList(reacts, user, userReacted)\n\n  return (\n    <MultiUserTransactionModal\n      userInfos={displayInfos}\n      modalLabel={\n        <span>\n          {capitalize(reactionType + 'd ')}\n          <span className=\"font-bold\">\n            {titleName\n              ? titleName\n              : contentType === 'contract'\n              ? 'this question'\n              : `this ${contentType}`}\n          </span>\n        </span>\n      }\n      open={true}\n      setOpen={setOpen}\n      short={true}\n    />\n  )\n}\n\nfunction UserReactedPopup(props: {\n  contentType: ReactionContentTypes\n  contentId: string\n  onRequestModal: () => void\n  user?: User | null\n  userReacted?: boolean\n  reactionType: ReactionType\n}) {\n  const {\n    contentType,\n    contentId,\n    onRequestModal,\n    user,\n    userReacted,\n    reactionType,\n  } = props\n  const reacts = useReactionsOnContent(contentType, contentId)?.filter(\n    (reaction: Reaction) => reaction.reaction_type == reactionType\n  )\n\n  const displayInfos = useReactedDisplayList(reacts, user, userReacted)\n\n  if (displayInfos == null) {\n    return (\n      <Col className=\"min-w-[6rem] items-start\">\n        <div className=\"mb-1 font-bold\">{capitalize(reactionType)}</div>\n        <LoadingIndicator className=\"mx-auto my-2\" size=\"sm\" />\n      </Col>\n    )\n  }\n\n  // only show \"& n more\" for n > 1\n  const shown =\n    displayInfos.length <= LIKES_SHOWN + 1\n      ? displayInfos\n      : displayInfos.slice(0, LIKES_SHOWN)\n\n  return (\n    <Col className=\"min-w-[6rem] items-start\">\n      <div className=\"mb-1 font-bold\">{capitalize(reactionType)}</div>\n      {shown.map((u, i) => {\n        return <UserReactedItem key={i} userInfo={u} />\n      })}\n      {displayInfos.length > shown.length && (\n        <div\n          className=\"text-primary-300 hover:text-primary-200 w-full cursor-pointer text-left\"\n          onClick={onRequestModal}\n        >\n          & {displayInfos.length - shown.length} more\n        </div>\n      )}\n    </Col>\n  )\n}\n\nfunction UserReactedItem(props: { userInfo: MultiUserLinkInfo }) {\n  const { userInfo } = props\n  return (\n    <UserHovercard userId={userInfo.id}>\n      <Row className=\"items-center gap-1.5\">\n        <Avatar\n          username={userInfo.username}\n          avatarUrl={userInfo.avatarUrl}\n          size=\"2xs\"\n        />\n        <UserLink user={userInfo} short={true} />\n      </Row>\n    </UserHovercard>\n  )\n}\n",
          "postContent": "import { HeartIcon } from '@heroicons/react/outline'\nimport clsx from 'clsx'\nimport { DisplayUser } from 'common/api/user-types'\nimport { Reaction, ReactionContentTypes, ReactionType } from 'common/reaction'\nimport { User } from 'common/user'\nimport { buildArray } from 'common/util/array'\nimport { removeUndefinedProps } from 'common/util/object'\nimport { capitalize } from 'lodash'\nimport { memo, useEffect, useState } from 'react'\nimport toast from 'react-hot-toast'\nimport { Button, ColorType, SizeType } from 'web/components/buttons/button'\nimport useLongTouch from 'web/hooks/use-long-touch'\nimport { useReactionsOnContent } from 'web/hooks/use-reactions'\nimport { useUsers } from 'web/hooks/use-user-supabase'\nimport { track } from 'web/lib/service/analytics'\nimport { Col } from '../layout/col'\nimport { Row } from '../layout/row'\nimport {\n  MultiUserLinkInfo,\n  MultiUserTransactionModal,\n} from '../multi-user-transaction-link'\nimport { UserHovercard } from '../user/user-hovercard'\nimport { Avatar } from '../widgets/avatar'\nimport { LoadingIndicator } from '../widgets/loading-indicator'\nimport { Tooltip } from '../widgets/tooltip'\nimport { UserLink } from '../widgets/user-link'\nimport { api } from 'web/lib/api/api'\n\nconst LIKES_SHOWN = 3\n\nexport const ReactButton = memo(function ReactButton(props: {\n  contentId: string\n  contentCreatorId: string\n  user: User | null | undefined\n  contentType: ReactionContentTypes\n  contentText: string\n  trackingLocation: string\n  className?: string\n  placement?: 'top' | 'bottom'\n  reactionType?: ReactionType\n  size?: SizeType\n  disabled?: boolean\n  feedReason?: string\n  contractId?: string\n  commentId?: string\n  postId?: string\n  heartClassName?: string\n  userReactedWith?: 'like' | 'none'\n  onReact?: () => void\n  onUnreact?: () => void\n  hideReactList?: boolean\n  color?: ColorType\n  children?: React.ReactNode\n}) {\n  const {\n    user,\n    contentType,\n    contentCreatorId,\n    contentId,\n    contentText,\n    className,\n    trackingLocation,\n    placement = 'bottom',\n    feedReason,\n    size,\n    contractId,\n    commentId,\n    postId,\n    heartClassName,\n    reactionType = 'like',\n    userReactedWith,\n    hideReactList,\n    color = 'gray-white',\n    children,\n  } = props\n  const allReactions = useReactionsOnContent(contentType, contentId)\n  const reactions = allReactions?.filter(\n    (reaction: Reaction) => reaction.reaction_type == reactionType\n  )\n\n  const [reacted, setReacted] = useState(\n    userReactedWith ? userReactedWith == reactionType : false\n  )\n\n  useEffect(() => {\n    setReacted(userReactedWith == reactionType)\n  }, [userReactedWith])\n\n  useEffect(() => {\n    if (reactions)\n      setReacted(\n        reactions.some(\n          (l: Reaction) =>\n            l.user_id === user?.id && l.reaction_type == reactionType\n        )\n      )\n  }, [allReactions, user])\n\n  const totalReactions =\n    (reactions\n      ? reactions.filter((l: Reaction) => l.user_id != user?.id).length\n      : 0) + (reacted ? 1 : 0)\n\n  const disabled = props.disabled || !user\n  const isMe = contentCreatorId === user?.id\n  const [modalOpen, setModalOpen] = useState(false)\n\n  const onReact = async (shouldReact: boolean) => {\n    if (!user) return\n    setReacted(shouldReact)\n    if (shouldReact) {\n      if (props.onReact) props.onReact()\n      await api('react', {\n        remove: false,\n        contentId,\n        contentType,\n        reactionType,\n        commentParentType: postId ? 'post' : undefined,\n      })\n\n      track(\n        reactionType,\n        removeUndefinedProps({\n          itemId: contentId,\n          location: trackingLocation,\n          contractId:\n            contractId ?? (contentType === 'contract' ? contentId : undefined),\n          commentId:\n            commentId ?? (contentType === 'comment' ? contentId : undefined),\n          feedReason,\n          postId: postId ?? (contentType === 'post' ? contentId : undefined),\n        })\n      )\n    } else {\n      if (props.onUnreact) props.onUnreact()\n      await api('react', {\n        remove: true,\n        contentId,\n        contentType,\n        reactionType,\n        commentParentType: postId ? 'post' : undefined,\n      })\n    }\n  }\n\n  function handleReacted(liked: boolean) {\n    onReact(liked)\n  }\n\n  const likeLongPress = useLongTouch(\n    () => {\n      if (!hideReactList) {\n        setModalOpen(true)\n      }\n    },\n    () => {\n      if (!disabled) {\n        if (isMe && reactionType === 'like') {\n          toast(\"Of course you'd like yourself\", { icon: '🙄' })\n        } else {\n          handleReacted(!reacted)\n        }\n      }\n    }\n  )\n\n  const otherLikes = reacted ? totalReactions - 1 : totalReactions\n  const showList = otherLikes > 0 && !hideReactList\n\n  return (\n    <>\n      <Tooltip\n        text={\n          showList ? (\n            <UserReactedPopup\n              contentType={contentType}\n              contentId={contentId}\n              onRequestModal={() => setModalOpen(true)}\n              user={user}\n              userReacted={reacted}\n              reactionType={reactionType}\n            />\n          ) : (\n            capitalize(reactionType)\n          )\n        }\n        placement={placement}\n        noTap\n        hasSafePolygon={showList}\n        className=\"flex items-center\"\n        tooltipClassName=\"z-40\"\n      >\n        {size == '2xs' ? (\n          <button\n            disabled={disabled}\n            className={clsx(\n              'disabled:cursor-not-allowed',\n              'disabled:text-ink-500',\n              className\n            )}\n            {...likeLongPress}\n          >\n            <Row className={'text-ink-600 items-center gap-0.5'}>\n              <div className=\"relative\">\n                <HeartIcon\n                  className={clsx(\n                    'stroke-ink-500 h-4 w-4',\n                    reacted &&\n                      'fill-scarlet-200 stroke-scarlet-300 dark:stroke-scarlet-600'\n                  )}\n                />\n              </div>\n              {totalReactions > 0 && (\n                <div className=\" text-sm disabled:opacity-50\">\n                  {totalReactions}\n                </div>\n              )}\n              {children}\n            </Row>\n          </button>\n        ) : (\n          <Button\n            color={color}\n            disabled={disabled}\n            size={size}\n            className={clsx(\n              'text-ink-500 disabled:cursor-not-allowed',\n              'disabled:text-ink-500',\n              className\n            )}\n            {...likeLongPress}\n          >\n            <Row className={'items-center gap-1.5'}>\n              <div className=\"relative\">\n                <HeartIcon\n                  className={clsx(\n                    'h-6 w-6',\n                    heartClassName,\n                    reacted &&\n                      'fill-scarlet-200 stroke-scarlet-300 dark:stroke-scarlet-600'\n                  )}\n                />\n              </div>\n              {totalReactions > 0 && (\n                <div className=\"my-auto h-5  text-sm disabled:opacity-50\">\n                  {totalReactions}\n                </div>\n              )}\n              {children}\n            </Row>\n          </Button>\n        )}\n      </Tooltip>\n      {modalOpen && (\n        <UserReactedFullList\n          contentType={contentType}\n          contentId={contentId}\n          user={user}\n          userReacted={reacted}\n          setOpen={setModalOpen}\n          titleName={contentText}\n          reactionType={reactionType}\n        />\n      )}\n    </>\n  )\n})\n\nfunction useReactedDisplayList(\n  reacts: Reaction[] = [],\n  self?: User | null,\n  prependSelf?: boolean\n) {\n  const users = useUsers(reacts.map((r) => r.user_id))\n\n  return buildArray([\n    prependSelf && self,\n    users?.filter((u): u is DisplayUser => !!u && u.id !== self?.id),\n  ])\n}\n\nfunction UserReactedFullList(props: {\n  contentType: ReactionContentTypes\n  contentId: string\n  user?: User | null\n  userReacted?: boolean\n  setOpen: (isOpen: boolean) => void\n  titleName?: string\n  reactionType: ReactionType\n}) {\n  const {\n    contentType,\n    contentId,\n    user,\n    userReacted,\n    setOpen,\n    titleName,\n    reactionType,\n  } = props\n  const reacts = useReactionsOnContent(contentType, contentId)?.filter(\n    (reaction: Reaction) => reaction.reaction_type == reactionType\n  )\n\n  const displayInfos = useReactedDisplayList(reacts, user, userReacted)\n\n  return (\n    <MultiUserTransactionModal\n      userInfos={displayInfos}\n      modalLabel={\n        <span>\n          {capitalize(reactionType + 'd ')}\n          <span className=\"font-bold\">\n            {titleName\n              ? titleName\n              : contentType === 'contract'\n              ? 'this question'\n              : `this ${contentType}`}\n          </span>\n        </span>\n      }\n      open={true}\n      setOpen={setOpen}\n      short={true}\n    />\n  )\n}\n\nfunction UserReactedPopup(props: {\n  contentType: ReactionContentTypes\n  contentId: string\n  onRequestModal: () => void\n  user?: User | null\n  userReacted?: boolean\n  reactionType: ReactionType\n}) {\n  const {\n    contentType,\n    contentId,\n    onRequestModal,\n    user,\n    userReacted,\n    reactionType,\n  } = props\n  const reacts = useReactionsOnContent(contentType, contentId)?.filter(\n    (reaction: Reaction) => reaction.reaction_type == reactionType\n  )\n\n  const displayInfos = useReactedDisplayList(reacts, user, userReacted)\n\n  if (displayInfos == null) {\n    return (\n      <Col className=\"min-w-[6rem] items-start\">\n        <div className=\"mb-1 font-bold\">{capitalize(reactionType)}</div>\n        <LoadingIndicator className=\"mx-auto my-2\" size=\"sm\" />\n      </Col>\n    )\n  }\n\n  // only show \"& n more\" for n > 1\n  const shown =\n    displayInfos.length <= LIKES_SHOWN + 1\n      ? displayInfos\n      : displayInfos.slice(0, LIKES_SHOWN)\n\n  return (\n    <Col className=\"min-w-[6rem] items-start\">\n      <div className=\"mb-1 font-bold\">{capitalize(reactionType)}</div>\n      {shown.map((u, i) => {\n        return <UserReactedItem key={i} userInfo={u} />\n      })}\n      {displayInfos.length > shown.length && (\n        <div\n          className=\"text-primary-300 hover:text-primary-200 w-full cursor-pointer text-left\"\n          onClick={onRequestModal}\n        >\n          & {displayInfos.length - shown.length} more\n        </div>\n      )}\n    </Col>\n  )\n}\n\nfunction UserReactedItem(props: { userInfo: MultiUserLinkInfo }) {\n  const { userInfo } = props\n  return (\n    <UserHovercard userId={userInfo.id}>\n      <Row className=\"items-center gap-1.5\">\n        <Avatar\n          username={userInfo.username}\n          avatarUrl={userInfo.avatarUrl}\n          size=\"2xs\"\n        />\n        <UserLink user={userInfo} short={true} />\n      </Row>\n    </UserHovercard>\n  )\n}\n"
        },
        {
          "path": "web/pages/post/[slug]/index.tsx",
          "preContent": "import { Page } from 'web/components/layout/page'\nimport { Spacer } from 'web/components/layout/spacer'\nimport {\n  Content,\n  TextEditor,\n  useTextEditor,\n} from 'web/components/widgets/editor'\nimport {\n  EyeOffIcon,\n  PencilIcon,\n  DotsHorizontalIcon,\n} from '@heroicons/react/solid'\nimport { Button } from 'web/components/buttons/button'\nimport { useState, useEffect } from 'react'\nimport { Row } from 'web/components/layout/row'\nimport { Col } from 'web/components/layout/col'\nimport Custom404 from 'web/pages/404'\nimport { UserAvatarAndBadge } from 'web/components/widgets/user-link'\nimport { SEO } from 'web/components/SEO'\nimport { richTextToString } from 'common/util/parse'\nimport { CopyLinkOrShareButton } from 'web/components/buttons/copy-link-button'\nimport { DisplayUser, getUserById } from 'web/lib/supabase/users'\nimport { getPostShareUrl, TopLevelPost } from 'common/src/top-level-post'\nimport { useUser } from 'web/hooks/use-user'\nimport { api } from 'web/lib/api/api'\nimport { getCommentsOnPost } from 'web/lib/supabase/comments'\nimport { PostComment } from 'common/comment'\nimport {\n  PostCommentsActivity,\n  useNewPostComments,\n} from 'web/components/top-level-posts/post-comments'\nimport { ExpandingInput } from 'web/components/widgets/expanding-input'\nimport { useAdminOrMod } from 'web/hooks/use-admin'\nimport toast from 'react-hot-toast'\nimport { ReactButton } from 'web/components/contract/react-button'\nimport { getPostBySlug } from 'web/lib/supabase/posts'\nimport { useSaveReferral } from 'web/hooks/use-save-referral'\nimport DropdownMenu from 'web/components/widgets/dropdown-menu'\nimport { BackButton } from 'web/components/contract/back-button'\nimport { report as reportContent } from 'web/lib/api/api'\nimport { IoWarning } from 'react-icons/io5'\n\nexport async function getStaticProps(props: { params: { slug: string } }) {\n  const { slug } = props.params\n\n  const postData = await getPostBySlug(slug)\n  const creator = postData ? await getUserById(postData.creatorId) : null\n  const comments = postData ? await getCommentsOnPost(postData.id) : []\n  const watched: string[] = []\n  const skipped: string[] = []\n\n  return {\n    props: {\n      post: postData,\n      creator,\n      comments,\n      watched,\n      skipped,\n    },\n  }\n}\n\nexport async function getStaticPaths() {\n  return { paths: [], fallback: 'blocking' }\n}\n\nexport default function PostPage(props: {\n  post: TopLevelPost | null\n  creator: DisplayUser | null\n  comments: PostComment[]\n  watched?: string[] //user ids\n  skipped?: string[] //user ids\n}) {\n  const { creator } = props\n  const { comments: newComments } = useNewPostComments(props.post?.id ?? '_')\n  const comments = [...newComments, ...props.comments]\n  const [post, setPost] = useState(props.post)\n  const isAdminOrMod = useAdminOrMod()\n  const [editing, setEditing] = useState(false)\n  const currentUser = useUser()\n  useSaveReferral(currentUser, {\n    defaultReferrerUsername: post?.creatorUsername,\n  })\n\n  useEffect(() => {\n    setPost(props.post)\n  }, [props.post])\n\n  if (!post || !creator) {\n    return <Custom404 />\n  }\n  const shareUrl = getPostShareUrl(post, currentUser?.username)\n\n  const handleReact = () => {\n    if (!currentUser || !post) return\n    setPost((prevPost) => {\n      if (!prevPost) return null\n      const newLikedByUserIds = [\n        ...(prevPost.likedByUserIds ?? []),\n        currentUser.id,\n      ]\n      return {\n        ...prevPost,\n        likedByUserCount: (prevPost.likedByUserCount ?? 0) + 1,\n        likedByUserIds: newLikedByUserIds,\n      }\n    })\n  }\n\n  const handleUnreact = () => {\n    if (!currentUser || !post) return\n    setPost((prevPost) => {\n      if (!prevPost) return null\n      const newLikedByUserIds =\n        prevPost.likedByUserIds?.filter((id) => id !== currentUser.id) ?? []\n      return {\n        ...prevPost,\n        likedByUserCount: Math.max(0, (prevPost.likedByUserCount ?? 0) - 1),\n        likedByUserIds: newLikedByUserIds,\n      }\n    })\n  }\n\n  const togglePostVisibility = async () => {\n    if (!post) return\n    const newVisibility = post.visibility === 'unlisted' ? 'public' : 'unlisted'\n    try {\n      await api('update-post', {\n        id: post.id,\n        visibility: newVisibility,\n      })\n      setPost((prevPost) =>\n        prevPost ? { ...prevPost, visibility: newVisibility } : null\n      )\n      toast.success(\n        `Post successfully made ${\n          newVisibility === 'public' ? 'public' : 'unlisted'\n        }.`\n      )\n    } catch (error) {\n      console.error('Error updating post visibility:', error)\n      toast.error(\n        `Failed to update post visibility. ${\n          error instanceof Error ? error.message : ''\n        }`\n      )\n    } finally {\n    }\n  }\n\n  return (\n    <Page trackPageView={'post slug page'}>\n      <SEO\n        title={post.title}\n        description={richTextToString(post.content)}\n        url={'/post/' + post.slug}\n        shouldIgnore={post.visibility === 'unlisted'}\n      />\n      <Col className=\"mx-auto w-full max-w-2xl p-4\">\n        {!editing && (\n          <Col>\n            <Row>\n              <BackButton className=\"!p-0\" />\n            </Row>\n            <Col className=\"border-canvas-50 pt-4\">\n              <Row className=\" items-center justify-between gap-1 text-2xl font-bold\">\n                <span>\n                  {post.title}{' '}\n                  {post.visibility === 'unlisted' && (\n                    <EyeOffIcon className=\"inline-block h-4 w-4\" />\n                  )}\n                </span>\n              </Row>\n              <Row className=\"mt-3 items-center gap-2 \">\n                <CopyLinkOrShareButton\n                  tooltip=\"Copy link to post\"\n                  url={shareUrl}\n                  eventTrackingName={'copy post link'}\n                />\n                {post && (\n                  <ReactButton\n                    contentId={post.id}\n                    contentCreatorId={post.creatorId}\n                    user={currentUser}\n                    contentType={'post'}\n                    contentText={post.title}\n                    trackingLocation={'post page'}\n                    reactionType={'like'}\n                    size={'sm'}\n                    userReactedWith={\n                      currentUser &&\n                      post.likedByUserIds?.includes(currentUser.id)\n                        ? 'like'\n                        : 'none'\n                    }\n                    onReact={handleReact}\n                    onUnreact={handleUnreact}\n                  />\n                )}\n                {(isAdminOrMod || post.creatorId === currentUser?.id) &&\n                  post && (\n                    <DropdownMenu\n                      items={[\n                        {\n                          name:\n                            post.visibility === 'unlisted'\n                              ? 'Make Public'\n                              : 'Make Unlisted',\n                          icon:\n                            post.visibility === 'unlisted' ? (\n                              <EyeOffIcon className=\"h-5 w-5\" />\n                            ) : (\n                              <EyeOffIcon className=\"h-5 w-5\" />\n                            ),\n                          onClick: togglePostVisibility,\n                        },\n                        {\n                          name: 'Report',\n                          icon: <IoWarning className=\"h-5 w-5\" />,\n                          onClick: async () => {\n                            await toast.promise(\n                              reportContent({\n                                contentId: post.id,\n                                contentType: 'post',\n                                contentOwnerId: post.creatorId,\n                              }),\n                              {\n                                loading: 'Reporting...',\n                                success: `Post reported! Admins will take a look within 24 hours.`,\n                                error: `Error reporting post`,\n                              }\n                            )\n                          },\n                        },\n                      ]}\n                      buttonContent={<DotsHorizontalIcon className=\"h-5 w-5\" />}\n                      buttonClass=\"p-2\"\n                      menuWidth=\"w-40\"\n                    />\n                  )}\n              </Row>\n            </Col>\n\n            <Row className=\"border-canvas-50 items-center justify-between gap-4 border-b py-4\">\n              <UserAvatarAndBadge user={creator} />\n              <span className=\"text-ink-700\">\n                {new Date(post.createdTime).toLocaleDateString('en-US', {\n                  year: 'numeric',\n                  month: 'short',\n                  day: 'numeric',\n                })}\n              </span>\n            </Row>\n          </Col>\n        )}\n        <div className=\"bg-canvas-0 rounded-lg px-6 py-4 sm:py-0\">\n          <div className=\"flex w-full flex-col py-2\">\n            <RichEditPost\n              post={post}\n              onUpdate={setPost}\n              editing={editing}\n              setEditing={setEditing}\n            />\n          </div>\n        </div>\n        <Spacer h={4} />\n        <PostCommentsActivity post={post} comments={comments} />\n      </Col>\n    </Page>\n  )\n}\n\nfunction RichEditPost(props: {\n  post: TopLevelPost\n  children?: React.ReactNode\n  onUpdate?: (post: TopLevelPost) => void\n  editing: boolean\n  setEditing: (isEditing: boolean) => void\n}) {\n  const { post, children, onUpdate, editing, setEditing } = props\n  const user = useUser()\n  const canEdit = user?.id === post.creatorId\n  const [editableTitle, setEditableTitle] = useState(post.title)\n\n  const editor = useTextEditor({\n    defaultValue: post.content,\n    key: `post ${post?.id || ''}`,\n    size: 'lg',\n  })\n\n  return editing ? (\n    <>\n      <ExpandingInput\n        value={editableTitle}\n        onChange={(e) => setEditableTitle(e.target.value || '')}\n        placeholder=\"Post title\"\n        className=\"mb-2 text-2xl font-bold\"\n      />\n      <TextEditor editor={editor} />\n      <Spacer h={2} />\n      <Row className=\"gap-2\">\n        <Button\n          color=\"gray\"\n          onClick={() => {\n            setEditing(false)\n            setEditableTitle(post.title)\n            editor?.commands.focus('end')\n          }}\n        >\n          Cancel\n        </Button>\n        <Button\n          onClick={async () => {\n            if (!editor) return\n            const { post: updatedPost } = await api('update-post', {\n              id: post.id,\n              title: editableTitle,\n              content: editor.getJSON(),\n            })\n            onUpdate?.(updatedPost)\n            setEditing(false)\n          }}\n        >\n          Save\n        </Button>\n      </Row>\n    </>\n  ) : (\n    <Col className=\"gap-2\">\n      <Content size=\"lg\" content={post.content} />\n      {canEdit && (\n        <Row className=\"place-content-end\">\n          <Button\n            color=\"gray-white\"\n            size=\"xs\"\n            onClick={() => {\n              setEditableTitle(post.title)\n              setEditing(true)\n              editor?.commands.focus('end')\n            }}\n          >\n            <PencilIcon className=\"inline h-4 w-4\" />\n          </Button>\n          {children}\n        </Row>\n      )}\n    </Col>\n  )\n}\n",
          "postContent": "import { Page } from 'web/components/layout/page'\nimport { Spacer } from 'web/components/layout/spacer'\nimport {\n  Content,\n  TextEditor,\n  useTextEditor,\n} from 'web/components/widgets/editor'\nimport {\n  EyeOffIcon,\n  PencilIcon,\n  DotsHorizontalIcon,\n} from '@heroicons/react/solid'\nimport { Button } from 'web/components/buttons/button'\nimport { useState, useEffect } from 'react'\nimport { Row } from 'web/components/layout/row'\nimport { Col } from 'web/components/layout/col'\nimport Custom404 from 'web/pages/404'\nimport { UserAvatarAndBadge } from 'web/components/widgets/user-link'\nimport { SEO } from 'web/components/SEO'\nimport { richTextToString } from 'common/util/parse'\nimport { CopyLinkOrShareButton } from 'web/components/buttons/copy-link-button'\nimport { DisplayUser, getUserById } from 'web/lib/supabase/users'\nimport { getPostShareUrl, TopLevelPost } from 'common/src/top-level-post'\nimport { useUser } from 'web/hooks/use-user'\nimport { api } from 'web/lib/api/api'\nimport { getCommentsOnPost } from 'web/lib/supabase/comments'\nimport { PostComment } from 'common/comment'\nimport {\n  PostCommentsActivity,\n  useNewPostComments,\n} from 'web/components/top-level-posts/post-comments'\nimport { ExpandingInput } from 'web/components/widgets/expanding-input'\nimport { useAdminOrMod } from 'web/hooks/use-admin'\nimport toast from 'react-hot-toast'\nimport { ReactButton } from 'web/components/contract/react-button'\nimport { getPostBySlug } from 'web/lib/supabase/posts'\nimport { useSaveReferral } from 'web/hooks/use-save-referral'\nimport DropdownMenu from 'web/components/widgets/dropdown-menu'\nimport { BackButton } from 'web/components/contract/back-button'\nimport { report as reportContent } from 'web/lib/api/api'\nimport { IoWarning } from 'react-icons/io5'\nimport { FollowPostButton } from 'web/components/buttons/follow-post-button'\n\nexport async function getStaticProps(props: { params: { slug: string } }) {\n  const { slug } = props.params\n\n  const postData = await getPostBySlug(slug)\n  const creator = postData ? await getUserById(postData.creatorId) : null\n  const comments = postData ? await getCommentsOnPost(postData.id) : []\n  const watched: string[] = []\n  const skipped: string[] = []\n\n  return {\n    props: {\n      post: postData,\n      creator,\n      comments,\n      watched,\n      skipped,\n    },\n  }\n}\n\nexport async function getStaticPaths() {\n  return { paths: [], fallback: 'blocking' }\n}\n\nexport default function PostPage(props: {\n  post: TopLevelPost | null\n  creator: DisplayUser | null\n  comments: PostComment[]\n  watched?: string[] //user ids\n  skipped?: string[] //user ids\n}) {\n  const { creator } = props\n  const { comments: newComments } = useNewPostComments(props.post?.id ?? '_')\n  const comments = [...newComments, ...props.comments]\n  const [post, setPost] = useState(props.post)\n  const isAdminOrMod = useAdminOrMod()\n  const [editing, setEditing] = useState(false)\n  const currentUser = useUser()\n  useSaveReferral(currentUser, {\n    defaultReferrerUsername: post?.creatorUsername,\n  })\n\n  useEffect(() => {\n    setPost(props.post)\n  }, [props.post])\n\n  if (!post || !creator) {\n    return <Custom404 />\n  }\n  const shareUrl = getPostShareUrl(post, currentUser?.username)\n\n  const handleReact = () => {\n    if (!currentUser || !post) return\n    setPost((prevPost) => {\n      if (!prevPost) return null\n      const newLikedByUserIds = [\n        ...(prevPost.likedByUserIds ?? []),\n        currentUser.id,\n      ]\n      return {\n        ...prevPost,\n        likedByUserCount: (prevPost.likedByUserCount ?? 0) + 1,\n        likedByUserIds: newLikedByUserIds,\n      }\n    })\n  }\n\n  const handleUnreact = () => {\n    if (!currentUser || !post) return\n    setPost((prevPost) => {\n      if (!prevPost) return null\n      const newLikedByUserIds =\n        prevPost.likedByUserIds?.filter((id) => id !== currentUser.id) ?? []\n      return {\n        ...prevPost,\n        likedByUserCount: Math.max(0, (prevPost.likedByUserCount ?? 0) - 1),\n        likedByUserIds: newLikedByUserIds,\n      }\n    })\n  }\n\n  const togglePostVisibility = async () => {\n    if (!post) return\n    const newVisibility = post.visibility === 'unlisted' ? 'public' : 'unlisted'\n    try {\n      await api('update-post', {\n        id: post.id,\n        visibility: newVisibility,\n      })\n      setPost((prevPost) =>\n        prevPost ? { ...prevPost, visibility: newVisibility } : null\n      )\n      toast.success(\n        `Post successfully made ${\n          newVisibility === 'public' ? 'public' : 'unlisted'\n        }.`\n      )\n    } catch (error) {\n      console.error('Error updating post visibility:', error)\n      toast.error(\n        `Failed to update post visibility. ${\n          error instanceof Error ? error.message : ''\n        }`\n      )\n    } finally {\n    }\n  }\n\n  return (\n    <Page trackPageView={'post slug page'}>\n      <SEO\n        title={post.title}\n        description={richTextToString(post.content)}\n        url={'/post/' + post.slug}\n        shouldIgnore={post.visibility === 'unlisted'}\n      />\n      <Col className=\"mx-auto w-full max-w-2xl p-4\">\n        {!editing && (\n          <Col>\n            <Row>\n              <BackButton className=\"!p-0\" />\n            </Row>\n            <Col className=\"border-canvas-50 pt-4\">\n              <Row className=\" items-center justify-between gap-1 text-2xl font-bold\">\n                <span>\n                  {post.title}{' '}\n                  {post.visibility === 'unlisted' && (\n                    <EyeOffIcon className=\"inline-block h-4 w-4\" />\n                  )}\n                </span>\n              </Row>\n              <Row className=\"mt-3 items-center gap-2 \">\n                {post && (\n                  <ReactButton\n                    contentId={post.id}\n                    contentCreatorId={post.creatorId}\n                    user={currentUser}\n                    contentType={'post'}\n                    contentText={post.title}\n                    trackingLocation={'post page'}\n                    reactionType={'like'}\n                    size={'sm'}\n                    userReactedWith={\n                      currentUser &&\n                      post.likedByUserIds?.includes(currentUser.id)\n                        ? 'like'\n                        : 'none'\n                    }\n                    onReact={handleReact}\n                    onUnreact={handleUnreact}\n                    color={'gray-outline'}\n                    className=\"!p-1.5\"\n                  >\n                    <span className=\"mr-1\">Like</span>\n                  </ReactButton>\n                )}\n                <CopyLinkOrShareButton\n                  color={'gray-outline'}\n                  tooltip=\"Copy link to post\"\n                  url={shareUrl}\n                  eventTrackingName={'copy post link'}\n                >\n                  <span className=\"ml-2\">Share</span>\n                </CopyLinkOrShareButton>\n                {currentUser && (\n                  <FollowPostButton post={post} user={currentUser} />\n                )}\n                {(isAdminOrMod || post.creatorId === currentUser?.id) &&\n                  post && (\n                    <DropdownMenu\n                      items={[\n                        {\n                          name:\n                            post.visibility === 'unlisted'\n                              ? 'Make Public'\n                              : 'Make Unlisted',\n                          icon:\n                            post.visibility === 'unlisted' ? (\n                              <EyeOffIcon className=\"h-5 w-5\" />\n                            ) : (\n                              <EyeOffIcon className=\"h-5 w-5\" />\n                            ),\n                          onClick: togglePostVisibility,\n                        },\n                        {\n                          name: 'Report',\n                          icon: <IoWarning className=\"h-5 w-5\" />,\n                          onClick: async () => {\n                            await toast.promise(\n                              reportContent({\n                                contentId: post.id,\n                                contentType: 'post',\n                                contentOwnerId: post.creatorId,\n                              }),\n                              {\n                                loading: 'Reporting...',\n                                success: `Post reported! Admins will take a look within 24 hours.`,\n                                error: `Error reporting post`,\n                              }\n                            )\n                          },\n                        },\n                      ]}\n                      buttonContent={<DotsHorizontalIcon className=\"h-5 w-5\" />}\n                      buttonClass=\"p-2\"\n                      menuWidth=\"w-40\"\n                    />\n                  )}\n              </Row>\n            </Col>\n\n            <Row className=\"border-canvas-50 items-center justify-between gap-4 border-b py-4\">\n              <UserAvatarAndBadge user={creator} />\n              <span className=\"text-ink-700\">\n                {new Date(post.createdTime).toLocaleDateString('en-US', {\n                  year: 'numeric',\n                  month: 'short',\n                  day: 'numeric',\n                })}\n              </span>\n            </Row>\n          </Col>\n        )}\n        <div className=\"bg-canvas-0 rounded-lg px-6 py-4 sm:py-0\">\n          <div className=\"flex w-full flex-col py-2\">\n            <RichEditPost\n              post={post}\n              onUpdate={setPost}\n              editing={editing}\n              setEditing={setEditing}\n            />\n          </div>\n        </div>\n        <Spacer h={4} />\n        <PostCommentsActivity post={post} comments={comments} />\n      </Col>\n    </Page>\n  )\n}\n\nfunction RichEditPost(props: {\n  post: TopLevelPost\n  children?: React.ReactNode\n  onUpdate?: (post: TopLevelPost) => void\n  editing: boolean\n  setEditing: (isEditing: boolean) => void\n}) {\n  const { post, children, onUpdate, editing, setEditing } = props\n  const user = useUser()\n  const canEdit = user?.id === post.creatorId\n  const [editableTitle, setEditableTitle] = useState(post.title)\n\n  const editor = useTextEditor({\n    defaultValue: post.content,\n    key: `post ${post?.id || ''}`,\n    size: 'lg',\n  })\n\n  return editing ? (\n    <>\n      <ExpandingInput\n        value={editableTitle}\n        onChange={(e) => setEditableTitle(e.target.value || '')}\n        placeholder=\"Post title\"\n        className=\"mb-2 text-2xl font-bold\"\n      />\n      <TextEditor editor={editor} />\n      <Spacer h={2} />\n      <Row className=\"gap-2\">\n        <Button\n          color=\"gray\"\n          onClick={() => {\n            setEditing(false)\n            setEditableTitle(post.title)\n            editor?.commands.focus('end')\n          }}\n        >\n          Cancel\n        </Button>\n        <Button\n          onClick={async () => {\n            if (!editor) return\n            const { post: updatedPost } = await api('update-post', {\n              id: post.id,\n              title: editableTitle,\n              content: editor.getJSON(),\n            })\n            onUpdate?.(updatedPost)\n            setEditing(false)\n          }}\n        >\n          Save\n        </Button>\n      </Row>\n    </>\n  ) : (\n    <Col className=\"gap-2\">\n      <Content size=\"lg\" content={post.content} />\n      {canEdit && (\n        <Row className=\"place-content-end\">\n          <Button\n            color=\"gray-white\"\n            size=\"xs\"\n            onClick={() => {\n              setEditableTitle(post.title)\n              setEditing(true)\n              editor?.commands.focus('end')\n            }}\n          >\n            <PencilIcon className=\"inline h-4 w-4\" />\n          </Button>\n          {children}\n        </Row>\n      )}\n    </Col>\n  )\n}\n"
        }
      ]
    },
    {
      "sha": "0f7d2472b188f3b08c0aee614ec276cc45cd4c67",
      "author": "Ian Philips",
      "date": "2025-05-12 14:28:12 -0700",
      "message": "Don't broadcast admin notifs",
      "stats": {
        "filesChanged": 2,
        "insertions": 12,
        "deletions": 8
      },
      "selectionReason": "Fixes notification broadcasting logic for admin notifications - shows conditional logic implementation",
      "spec": "Modify the notification system's behavior for new posts that are announcements. When such a post is created, ensure that notifications are generated and stored for relevant users, but suppress the real-time broadcast of these specific notifications.",
      "fileStates": [
        {
          "path": "backend/shared/src/notifications/create-new-post-notif.ts",
          "preContent": "import { Notification } from 'common/notification'\nimport { User } from 'common/user'\n\nimport {\n  getNotificationDestinationsForUser,\n  userIsBlocked,\n} from 'common/user-notification-preferences'\nimport { SupabaseDirectClient } from 'shared/supabase/init'\n\nimport { bulkInsertNotifications } from 'shared/supabase/notifications'\nimport { convertPrivateUser } from 'common/supabase/users'\nimport { nanoid } from 'common/util/random'\nimport { TopLevelPost } from 'common/top-level-post'\nimport { getAllUserIds, getUserFollowerIds } from 'shared/supabase/users'\nimport { richTextToString } from 'common/util/parse'\n\nexport const createNewPostFromFollowedUserNotification = async (\n  post: TopLevelPost,\n  creator: User,\n  pg: SupabaseDirectClient\n) => {\n  const bulkNotifications: Notification[] = []\n\n  // Get all followers of the post creator\n  const followerIds = post.isAnnouncement\n    ? await getAllUserIds(pg)\n    : await getUserFollowerIds(creator.id, pg)\n\n  if (post.isAnnouncement) {\n    for (const userId of followerIds) {\n      const notification: Notification = {\n        id: nanoid(6),\n        userId: userId,\n        reason: 'admin',\n        createdTime: Date.now(),\n        isSeen: false,\n        sourceId: post.id,\n        sourceType: 'post',\n        sourceUpdateType: 'created',\n        sourceUserName: creator.name,\n        sourceUserUsername: creator.username,\n        sourceUserAvatarUrl: creator.avatarUrl,\n        sourceText: richTextToString(post.content),\n        sourceSlug: `post/${post.slug}`,\n        sourceTitle: post.title,\n      }\n      bulkNotifications.push(notification)\n    }\n  } else {\n    // Get all private users for the followers\n    const privateUsers = await pg.map(\n      `select * from private_users where id = any($1)`,\n      [followerIds],\n      convertPrivateUser\n    )\n\n    // For each follower, create a notification if they want it\n    for (const privateUser of privateUsers) {\n      if (userIsBlocked(privateUser, creator.id)) continue\n\n      const { sendToBrowser } = getNotificationDestinationsForUser(\n        privateUser,\n        'contract_from_followed_user'\n      )\n\n      if (sendToBrowser) {\n        const notification: Notification = {\n          id: nanoid(6),\n          userId: privateUser.id,\n          reason: 'contract_from_followed_user',\n          createdTime: Date.now(),\n          isSeen: false,\n          sourceId: post.id,\n          sourceType: 'post',\n          sourceUpdateType: 'created',\n          sourceUserName: creator.name,\n          sourceUserUsername: creator.username,\n          sourceUserAvatarUrl: creator.avatarUrl,\n          sourceText: richTextToString(post.content).slice(0, 200),\n          sourceSlug: `post/${post.slug}`,\n          sourceTitle: post.title,\n        }\n        bulkNotifications.push(notification)\n      }\n    }\n  }\n\n  if (bulkNotifications.length > 0) {\n    await bulkInsertNotifications(bulkNotifications, pg)\n  }\n}\n",
          "postContent": "import { Notification } from 'common/notification'\nimport { User } from 'common/user'\n\nimport {\n  getNotificationDestinationsForUser,\n  userIsBlocked,\n} from 'common/user-notification-preferences'\nimport { SupabaseDirectClient } from 'shared/supabase/init'\n\nimport { bulkInsertNotifications } from 'shared/supabase/notifications'\nimport { convertPrivateUser } from 'common/supabase/users'\nimport { nanoid } from 'common/util/random'\nimport { TopLevelPost } from 'common/top-level-post'\nimport { getAllUserIds, getUserFollowerIds } from 'shared/supabase/users'\nimport { richTextToString } from 'common/util/parse'\n\nexport const createNewPostFromFollowedUserNotification = async (\n  post: TopLevelPost,\n  creator: User,\n  pg: SupabaseDirectClient\n) => {\n  const bulkNotifications: Notification[] = []\n  const { isAnnouncement } = post\n  // Get all followers of the post creator\n  const followerIds = isAnnouncement\n    ? await getAllUserIds(pg)\n    : await getUserFollowerIds(creator.id, pg)\n\n  if (isAnnouncement) {\n    for (const userId of followerIds) {\n      const notification: Notification = {\n        id: nanoid(6),\n        userId: userId,\n        reason: 'admin',\n        createdTime: Date.now(),\n        isSeen: false,\n        sourceId: post.id,\n        sourceType: 'post',\n        sourceUpdateType: 'created',\n        sourceUserName: creator.name,\n        sourceUserUsername: creator.username,\n        sourceUserAvatarUrl: creator.avatarUrl,\n        sourceText: richTextToString(post.content),\n        sourceSlug: `post/${post.slug}`,\n        sourceTitle: post.title,\n      }\n      bulkNotifications.push(notification)\n    }\n  } else {\n    // Get all private users for the followers\n    const privateUsers = await pg.map(\n      `select * from private_users where id = any($1)`,\n      [followerIds],\n      convertPrivateUser\n    )\n\n    // For each follower, create a notification if they want it\n    for (const privateUser of privateUsers) {\n      if (userIsBlocked(privateUser, creator.id)) continue\n\n      const { sendToBrowser } = getNotificationDestinationsForUser(\n        privateUser,\n        'contract_from_followed_user'\n      )\n\n      if (sendToBrowser) {\n        const notification: Notification = {\n          id: nanoid(6),\n          userId: privateUser.id,\n          reason: 'contract_from_followed_user',\n          createdTime: Date.now(),\n          isSeen: false,\n          sourceId: post.id,\n          sourceType: 'post',\n          sourceUpdateType: 'created',\n          sourceUserName: creator.name,\n          sourceUserUsername: creator.username,\n          sourceUserAvatarUrl: creator.avatarUrl,\n          sourceText: richTextToString(post.content).slice(0, 200),\n          sourceSlug: `post/${post.slug}`,\n          sourceTitle: post.title,\n        }\n        bulkNotifications.push(notification)\n      }\n    }\n  }\n\n  if (bulkNotifications.length > 0) {\n    await bulkInsertNotifications(bulkNotifications, pg, isAnnouncement)\n  }\n}\n"
        },
        {
          "path": "backend/shared/src/supabase/notifications.ts",
          "preContent": "import { Notification } from 'common/notification'\nimport { SupabaseDirectClient } from 'shared/supabase/init'\nimport { broadcast } from 'shared/websockets/server'\nimport { bulkInsert } from 'shared/supabase/utils'\n\nexport const insertNotificationToSupabase = async (\n  notification: Notification,\n  pg: SupabaseDirectClient\n) => {\n  await pg.none(\n    `insert into postgres.public.user_notifications (user_id, notification_id, data) values ($1, $2, $3) on conflict do nothing`,\n    [notification.userId, notification.id, notification]\n  )\n  broadcast(`user-notifications/${notification.userId}`, { notification })\n}\n\nexport const bulkInsertNotifications = async (\n  notifications: Notification[],\n  pg: SupabaseDirectClient\n) => {\n  await bulkInsert(\n    pg,\n    'user_notifications',\n    notifications.map((n) => ({\n      user_id: n.userId,\n      notification_id: n.id,\n      data: n,\n    }))\n  )\n  notifications.forEach((notification) =>\n    broadcast(`user-notifications/${notification.userId}`, { notification })\n  )\n}\n",
          "postContent": "import { Notification } from 'common/notification'\nimport { SupabaseDirectClient } from 'shared/supabase/init'\nimport { broadcast } from 'shared/websockets/server'\nimport { bulkInsert } from 'shared/supabase/utils'\n\nexport const insertNotificationToSupabase = async (\n  notification: Notification,\n  pg: SupabaseDirectClient\n) => {\n  await pg.none(\n    `insert into postgres.public.user_notifications (user_id, notification_id, data) values ($1, $2, $3) on conflict do nothing`,\n    [notification.userId, notification.id, notification]\n  )\n  broadcast(`user-notifications/${notification.userId}`, { notification })\n}\n\nexport const bulkInsertNotifications = async (\n  notifications: Notification[],\n  pg: SupabaseDirectClient,\n  skipBroadcast: boolean = false\n) => {\n  await bulkInsert(\n    pg,\n    'user_notifications',\n    notifications.map((n) => ({\n      user_id: n.userId,\n      notification_id: n.id,\n      data: n,\n    }))\n  )\n  // Useful for admin notifs as broadcasting 100k notifications probably broke the site\n  if (!skipBroadcast) {\n    notifications.forEach((notification) =>\n      broadcast(`user-notifications/${notification.userId}`, { notification })\n    )\n  }\n}\n"
        }
      ]
    },
    {
      "sha": "1112526b8733e3b2b50fa9c8cf3195fe28302c95",
      "author": "Ian Philips",
      "date": "2025-05-09 12:41:43 -0700",
      "message": "Fix search",
      "stats": {
        "filesChanged": 2,
        "insertions": 13,
        "deletions": 27
      },
      "selectionReason": "Fixes search functionality - a moderate complexity change that improves core platform functionality",
      "spec": "The search functionality requires updates to its results display and data fetching logic. Specifically, the sorting mechanism in `CombinedResults` for mixed contract and post items must be changed: when sorting by 'newest', all items should be sorted together by `createdTime` (descending); for 'score', by `importanceScore` (descending). For all other sort types, contracts should appear first, then posts, with items in both groups retaining their original order from their input arrays, and they should no longer be sorted by `createdTime` as they were previously in these scenarios. Additionally, the `CombinedResults` component should now be rendered if either the `contracts` or `posts` data is defined, regardless of whether these collections are empty. Finally, the post fetching strategy in `useSearchResults` must be refined: a new prerequisite is that posts should only be fetched if fewer than 20 are already loaded. This check complements existing conditions (like sort type). This post fetching process must operate independently of user/topic fetching, and the presence of an `additionalFilter.creatorId` should no longer, on its own, trigger a post fetch if other primary conditions are not met.",
      "fileStates": [
        {
          "path": "web/components/contract/combined-results.tsx",
          "preContent": "import { Contract } from 'common/contract'\nimport { TopLevelPost } from 'common/top-level-post'\nimport { ContractRow } from './contracts-table'\nimport { PostRow } from '../posts/post-row'\nimport { SearchParams, SORT_KEY } from '../search'\nimport { Key } from 'react'\nimport { sortBy } from 'lodash'\nimport { Answer } from 'common/answer'\nimport {\n  boostedColumn,\n  traderColumn,\n  probColumn,\n  actionColumn,\n} from './contract-table-col-formats'\nimport { buildArray } from 'common/util/array'\n\ntype CombinedResultsProps = {\n  contracts: Contract[]\n  posts: TopLevelPost[]\n  searchParams: SearchParams\n  onContractClick?: (contract: Contract) => void\n  highlightContractIds?: string[]\n  answersByContractId?: { [contractId: string]: Answer[] }\n  hideAvatars?: boolean\n  hideActions?: boolean\n  hasBets?: boolean\n}\n\n// Type guard to check if an item is a Contract\nfunction isContract(item: Contract | TopLevelPost): item is Contract {\n  return 'mechanism' in item\n}\n\n// Type guard to check if an item is a Post\nfunction isPost(item: Contract | TopLevelPost): item is TopLevelPost {\n  return 'title' in item && !('mechanism' in item) // Ensure it's not also a contract like object\n}\n\nexport function CombinedResults(props: CombinedResultsProps) {\n  const {\n    contracts,\n    posts,\n    searchParams,\n    onContractClick,\n    highlightContractIds,\n    answersByContractId,\n    hideAvatars,\n    hideActions,\n    hasBets,\n  } = props\n\n  const sort = searchParams[SORT_KEY]\n  let combinedItems: (Contract | TopLevelPost)[] = []\n\n  if (sort === 'newest') {\n    combinedItems = sortBy(\n      [...contracts, ...posts],\n      (item) => item.createdTime\n    ).reverse()\n  } else if (sort === 'score') {\n    const itemsWithScores = [...contracts, ...posts].map((item) => {\n      return { item, score: item.importanceScore ?? -Infinity }\n    })\n    combinedItems = sortBy(itemsWithScores, (obj) => obj.score)\n      .reverse()\n      .map((obj) => obj.item)\n  } else {\n    // For other sorts, just show contracts, then posts by createdTime\n    combinedItems = [...sortBy(contracts, (c) => c.createdTime).reverse()]\n    combinedItems.push(...sortBy(posts, (p) => p.createdTime).reverse())\n  }\n\n  if (!combinedItems.length) return null\n\n  // Define columns for ContractRow, similar to how ContractsTable did\n  const contractDisplayColumns = buildArray([\n    !hasBets && boostedColumn,\n    traderColumn,\n    probColumn,\n    !hideActions && actionColumn,\n  ])\n\n  return (\n    <>\n      {combinedItems.map((item) => {\n        if (isContract(item)) {\n          return (\n            <ContractRow\n              key={item.id as Key}\n              contract={item}\n              onClick={\n                onContractClick ? () => onContractClick(item) : undefined\n              }\n              highlighted={highlightContractIds?.includes(item.id)}\n              answers={answersByContractId?.[item.id]}\n              hideAvatar={hideAvatars}\n              columns={contractDisplayColumns} // Pass the defined columns\n              showPosition={hasBets}\n            />\n          )\n        } else if (isPost(item)) {\n          return (\n            <PostRow\n              key={item.id as Key}\n              post={item}\n              highlighted={highlightContractIds?.includes(item.id)} // Assuming posts can also be highlighted by ID\n              hideAvatar={hideAvatars}\n            />\n          )\n        }\n        return null // Should not be reached if type guards are exhaustive\n      })}\n    </>\n  )\n}\n",
          "postContent": "import { Contract } from 'common/contract'\nimport { TopLevelPost } from 'common/top-level-post'\nimport { ContractRow } from './contracts-table'\nimport { PostRow } from '../posts/post-row'\nimport { SearchParams, SORT_KEY } from '../search'\nimport { Key } from 'react'\nimport { sortBy } from 'lodash'\nimport { Answer } from 'common/answer'\nimport {\n  boostedColumn,\n  traderColumn,\n  probColumn,\n  actionColumn,\n} from './contract-table-col-formats'\nimport { buildArray } from 'common/util/array'\n\ntype CombinedResultsProps = {\n  contracts: Contract[]\n  posts: TopLevelPost[]\n  searchParams: SearchParams\n  onContractClick?: (contract: Contract) => void\n  highlightContractIds?: string[]\n  answersByContractId?: { [contractId: string]: Answer[] }\n  hideAvatars?: boolean\n  hideActions?: boolean\n  hasBets?: boolean\n}\n\n// Type guard to check if an item is a Contract\nfunction isContract(item: Contract | TopLevelPost): item is Contract {\n  return 'mechanism' in item\n}\n\n// Type guard to check if an item is a Post\nfunction isPost(item: Contract | TopLevelPost): item is TopLevelPost {\n  return 'title' in item && !('mechanism' in item) // Ensure it's not also a contract like object\n}\n\nexport function CombinedResults(props: CombinedResultsProps) {\n  const {\n    contracts,\n    posts,\n    searchParams,\n    onContractClick,\n    highlightContractIds,\n    answersByContractId,\n    hideAvatars,\n    hideActions,\n    hasBets,\n  } = props\n\n  const sort = searchParams[SORT_KEY]\n  let combinedItems: (Contract | TopLevelPost)[] = []\n  combinedItems = sortBy([...contracts, ...posts], (item) => {\n    if (sort === 'newest') return -item.createdTime\n    if (sort === 'score') return -item.importanceScore\n    return 0\n  })\n\n  if (!combinedItems.length) return null\n\n  // Define columns for ContractRow, similar to how ContractsTable did\n  const contractDisplayColumns = buildArray([\n    !hasBets && boostedColumn,\n    traderColumn,\n    probColumn,\n    !hideActions && actionColumn,\n  ])\n\n  return (\n    <>\n      {combinedItems.map((item) => {\n        if (isContract(item)) {\n          return (\n            <ContractRow\n              key={item.id as Key}\n              contract={item}\n              onClick={\n                onContractClick ? () => onContractClick(item) : undefined\n              }\n              highlighted={highlightContractIds?.includes(item.id)}\n              answers={answersByContractId?.[item.id]}\n              hideAvatar={hideAvatars}\n              columns={contractDisplayColumns} // Pass the defined columns\n              showPosition={hasBets}\n            />\n          )\n        } else if (isPost(item)) {\n          return (\n            <PostRow\n              key={item.id as Key}\n              post={item}\n              highlighted={highlightContractIds?.includes(item.id)} // Assuming posts can also be highlighted by ID\n              hideAvatar={hideAvatars}\n            />\n          )\n        }\n        return null // Should not be reached if type guards are exhaustive\n      })}\n    </>\n  )\n}\n"
        },
        {
          "path": "web/components/search.tsx",
          "preContent": "'use client'\nimport clsx from 'clsx'\nimport { Contract } from 'common/contract'\nimport { LiteGroup } from 'common/group'\nimport { capitalize, groupBy, minBy, orderBy, sample, uniqBy } from 'lodash'\nimport { ReactNode, useEffect, useRef, useState } from 'react'\nimport { AddContractToGroupButton } from 'web/components/topics/add-contract-to-group-modal'\nimport { useDebouncedEffect } from 'web/hooks/use-debounced-effect'\nimport { useEvent } from 'client-common/hooks/use-event'\nimport { usePersistentInMemoryState } from 'client-common/hooks/use-persistent-in-memory-state'\nimport { usePersistentQueriesState } from 'web/hooks/use-persistent-query-state'\nimport { track } from 'web/lib/service/analytics'\nimport { Col } from './layout/col'\nimport { Row } from './layout/row'\nimport { FullUser } from 'common/api/user-types'\nimport { CONTRACTS_PER_SEARCH_PAGE } from 'common/supabase/contracts'\nimport { buildArray } from 'common/util/array'\nimport { Button } from 'web/components/buttons/button'\nimport { usePersistentLocalState } from 'web/hooks/use-persistent-local-state'\nimport { api, searchGroups } from 'web/lib/api/api'\nimport { searchUsers } from 'web/lib/supabase/users'\n\nimport { LoadingContractRow } from './contract/contracts-table'\nimport { ContractFilters } from './search/contract-filters'\nimport { UserResults } from './search/user-results'\nimport { BrowseTopicPills } from './topics/browse-topic-pills'\nimport { LoadMoreUntilNotVisible } from 'web/components/widgets/visibility-observer'\nimport { BinaryDigit } from 'common/tier'\nimport { useIsMobile } from 'web/hooks/use-is-mobile'\nimport { Spacer } from './layout/spacer'\nimport { useSweepstakes } from './sweepstakes-provider'\nimport { ALL_PARENT_TOPICS, TOPICS_TO_SUBTOPICS } from 'common/topics'\nimport { Carousel } from './widgets/carousel'\nimport { isEqual } from 'lodash'\nimport { SearchInput } from './search/search-input'\nimport { removeEmojis } from 'common/util/string'\nimport { useIsPageVisible } from 'web/hooks/use-page-visible'\nimport { TopLevelPost } from 'common/top-level-post'\nimport { CombinedResults } from './contract/combined-results'\nimport { APIParams } from 'common/api/schema'\n\nconst USERS_PER_PAGE = 100\nconst TOPICS_PER_PAGE = 100\n\nexport const SORTS = [\n  { label: 'Best', value: 'score' },\n  { label: 'Hot', value: 'freshness-score' },\n  { label: 'Liquidity', value: 'liquidity' },\n  { label: 'Subsidy', value: 'subsidy' },\n  { label: 'New', value: 'newest' },\n  { label: 'Closing soon', value: 'close-date' },\n  { label: 'Daily change', value: 'daily-score' },\n  { label: '24h volume', value: '24-hour-vol' },\n  { label: 'Total traders', value: 'most-popular' },\n  { label: 'Last activity', value: 'last-updated' },\n  { label: 'Just resolved', value: 'resolve-date' },\n  { label: 'Bounty amount', value: 'bounty-amount' },\n  { label: 'High %', value: 'prob-descending' },\n  { label: 'Low %', value: 'prob-ascending' },\n  { label: '🎲 Random!', value: 'random' },\n] as const\n\nexport const predictionMarketSorts = new Set([\n  'daily-score',\n  '24-hour-vol',\n  'liquidity',\n  'subsidy',\n  'close-date',\n  'resolve-date',\n  'most-popular',\n  'prob-descending',\n  'prob-ascending',\n  'freshness-score',\n])\n\nexport const bountySorts = new Set(['bounty-amount'])\n\nconst probSorts = new Set(['prob-descending', 'prob-ascending'])\n\nexport const BOUNTY_MARKET_SORTS = SORTS.filter(\n  (item) => !predictionMarketSorts.has(item.value)\n)\n\nexport const POLL_SORTS = BOUNTY_MARKET_SORTS.filter(\n  (item) => !bountySorts.has(item.value)\n)\n\nexport const PREDICTION_MARKET_SORTS = SORTS.filter(\n  (item) => !bountySorts.has(item.value) && !probSorts.has(item.value)\n)\n\nexport const PREDICTION_MARKET_PROB_SORTS = SORTS.filter(\n  (item) => !bountySorts.has(item.value)\n)\n\nexport type Sort = (typeof SORTS)[number]['value']\n\nexport const FILTERS = [\n  { label: 'Any status', value: 'all' },\n  { label: 'Open', value: 'open' },\n  { label: 'Closing in 7 days', value: 'closing-week' },\n  { label: 'Closing in 30 days', value: 'closing-month' },\n  { label: 'Closing in 90 days', value: 'closing-90-days' },\n  { label: 'Closed', value: 'closed' },\n  { label: 'Resolved', value: 'resolved' },\n  { label: 'News', value: 'news' },\n] as const\n\nexport type Filter = (typeof FILTERS)[number]['value']\n\nexport const CONTRACT_TYPES = [\n  { label: 'Any type', value: 'ALL' },\n  { label: 'Yes/No', value: 'BINARY' },\n  { label: 'Multiple Choice', value: 'MULTIPLE_CHOICE' },\n  { label: 'Numeric', value: 'PSEUDO_NUMERIC' },\n  { label: 'Bounty', value: 'BOUNTIED_QUESTION' },\n  { label: 'Stock', value: 'STONK' },\n  { label: 'Poll', value: 'POLL' },\n  { label: 'Posts', value: 'POSTS' },\n] as const\n\nexport const DEFAULT_SORT = 'score'\nexport const DEFAULT_SORTS = ['freshness-score', 'newest']\nexport const DEFAULT_BOUNTY_SORTS = ['bounty-amount']\n\nexport const DEFAULT_FILTERS = []\nexport const DEFAULT_FILTER = 'all'\n\nexport const DEFAULT_CONTRACT_TYPE = 'ALL'\nexport const DEFAULT_CONTRACT_TYPES = []\n\nexport const DEFAULT_TIER = '00000'\n\nexport type ContractTypeType = (typeof CONTRACT_TYPES)[number]['value']\ntype SearchType = 'Users' | 'Questions' | undefined\n\nexport type SearchParams = {\n  [QUERY_KEY]: string\n  [SORT_KEY]: Sort\n  [FILTER_KEY]: Filter\n  [CONTRACT_TYPE_KEY]: ContractTypeType\n  [SEARCH_TYPE_KEY]: SearchType\n  [PRIZE_MARKET_KEY]: BinaryDigit\n  [FOR_YOU_KEY]: BinaryDigit\n  [TOPIC_FILTER_KEY]: string\n  [SWEEPIES_KEY]: '0' | '1' | '2'\n  [GROUP_IDS_KEY]: string\n  [LIQUIDITY_KEY]: string // empty string or stringified number\n  [HAS_BETS_KEY]: '0' | '1'\n}\n\nexport const QUERY_KEY = 'q'\nexport const SORT_KEY = 's'\nexport const FILTER_KEY = 'f'\nexport const CONTRACT_TYPE_KEY = 'ct'\nexport const SEARCH_TYPE_KEY = 't'\nexport const PRIZE_MARKET_KEY = 'p'\nexport const FOR_YOU_KEY = 'fy'\nexport const MARKET_TIER_KEY = 'mt'\nexport const TOPIC_FILTER_KEY = 'tf'\nexport const SWEEPIES_KEY = 'sw'\nexport const GROUP_IDS_KEY = 'gids'\nexport const LIQUIDITY_KEY = 'li'\nexport const HAS_BETS_KEY = 'hb'\n\nexport type SupabaseAdditionalFilter = {\n  creatorId?: string\n  excludeContractIds?: string[]\n  excludeGroupSlugs?: string[]\n  excludeUserIds?: string[]\n}\n\nexport type SearchState = {\n  contracts: Contract[] | undefined\n  users: FullUser[] | undefined\n  topics: LiteGroup[] | undefined\n  shouldLoadMore: boolean\n  posts: TopLevelPost[] | undefined\n}\n\ntype SearchProps = {\n  persistPrefix: string\n  defaultSort?: Sort\n  defaultFilter?: Filter\n  defaultContractType?: ContractTypeType\n  defaultSearchType?: SearchType\n  defaultForYou?: '1' | '0'\n  additionalFilter?: SupabaseAdditionalFilter\n  highlightContractIds?: string[]\n  onContractClick?: (contract: Contract) => void\n  hideActions?: boolean\n  hideSweepsToggle?: boolean\n  headerClassName?: string\n  isWholePage?: boolean\n  // used to determine if search params should be updated in the URL\n  useUrlParams?: boolean\n  autoFocus?: boolean\n  emptyState?: ReactNode\n  hideSearch?: boolean\n  hideContractFilters?: boolean\n  topicSlug?: string\n  contractsOnly?: boolean\n  hideSearchTypes?: boolean\n  hideAvatars?: boolean\n  initialTopics?: LiteGroup[]\n  showTopicsFilterPills?: boolean\n  refreshOnVisible?: boolean\n}\n\nexport function Search(props: SearchProps) {\n  const {\n    defaultSort,\n    defaultFilter,\n    defaultContractType,\n    defaultSearchType,\n    defaultForYou,\n    additionalFilter,\n    onContractClick,\n    hideActions,\n    hideSweepsToggle,\n    highlightContractIds,\n    headerClassName,\n    persistPrefix,\n    isWholePage,\n    useUrlParams,\n    autoFocus,\n    hideContractFilters,\n    topicSlug = '',\n    contractsOnly,\n    hideSearch,\n    hideSearchTypes,\n    hideAvatars,\n    showTopicsFilterPills,\n    refreshOnVisible,\n  } = props\n\n  const isMobile = useIsMobile()\n  const { prefersPlay, setPrefersPlay } = useSweepstakes()\n  const [searchParams, setSearchParams, isReady] = useSearchQueryState({\n    defaultSort,\n    defaultFilter,\n    defaultContractType,\n    defaultSearchType,\n    defaultForYou,\n    useUrlParams,\n    persistPrefix,\n    defaultSweepies: prefersPlay ? '0' : '1',\n  })\n\n  const query = searchParams[QUERY_KEY]\n  const searchType = searchParams[SEARCH_TYPE_KEY]\n  const filter = searchParams[FILTER_KEY]\n  const contractType = searchParams[CONTRACT_TYPE_KEY]\n  const prizeMarketState = searchParams[PRIZE_MARKET_KEY]\n  const sweepiesState = searchParams[SWEEPIES_KEY]\n  const groupIds = searchParams[GROUP_IDS_KEY]\n  const hasBets = searchParams[HAS_BETS_KEY] === '1'\n  useEffect(() => {\n    const isSweeps = sweepiesState === '1'\n    if (prefersPlay !== isSweeps) return\n    setSearchParams({\n      [SWEEPIES_KEY]: prefersPlay ? '0' : '1',\n    })\n  }, [prefersPlay, sweepiesState])\n\n  const showSearchTypes = !!query && !hideSearchTypes && !contractsOnly\n\n  const actuallySearchParams = searchParams\n  if (topicSlug) actuallySearchParams[TOPIC_FILTER_KEY] = topicSlug\n  if (hideSweepsToggle) actuallySearchParams[SWEEPIES_KEY] = '2'\n\n  const {\n    contracts,\n    users,\n    topics,\n    loading,\n    shouldLoadMore,\n    loadMoreContracts,\n    refreshContracts,\n    posts,\n  } = useSearchResults({\n    persistPrefix,\n    searchParams: actuallySearchParams,\n    includeUsersAndTopics: showSearchTypes,\n    isReady,\n    additionalFilter,\n  })\n  const visible = useIsPageVisible()\n  useEffect(() => {\n    if (visible && refreshOnVisible) {\n      refreshContracts()\n    }\n  }, [visible, refreshOnVisible])\n\n  const showTopics = topics && topics.length > 0 && query && query.length > 0\n  const showUsers = users && users.length > 0 && query && query.length > 0\n\n  const onChange = (changes: Partial<SearchParams>) => {\n    const updatedParams = { ...changes }\n\n    setSearchParams(updatedParams)\n    if (isWholePage) window.scrollTo(0, 0)\n  }\n\n  const setQuery = (query: string) => onChange({ [QUERY_KEY]: query })\n\n  const answersWithChanges = contracts?.flatMap((c) =>\n    c.mechanism === 'cpmm-multi-1'\n      ? orderBy(\n          c.answers.filter((a) => Math.abs(a.probChanges.day) > 0.02),\n          (a) => Math.abs(a.probChanges.day),\n          'desc'\n        ).slice(0, 2)\n      : []\n  )\n\n  const answersMatchingQuery = contracts?.flatMap((c) =>\n    c.mechanism === 'cpmm-multi-1'\n      ? c.answers\n          .filter((a) => a.text.toLowerCase().includes(query.toLowerCase()))\n          .slice(0, 2)\n      : []\n  )\n  const answersByContractId =\n    answersWithChanges && filter === 'news'\n      ? groupBy(answersWithChanges, 'contractId')\n      : query !== ''\n      ? groupBy(answersMatchingQuery, 'contractId')\n      : undefined\n  const emptyContractsState =\n    props.emptyState ??\n    (filter !== 'all' ||\n    contractType !== 'ALL' ||\n    prizeMarketState === '1' ||\n    sweepiesState === '1' ? (\n      <Col className=\"mt-2 items-center gap-3\">\n        <span className=\"text-ink-700 text-center\">\n          No {prefersPlay ? 'questions' : 'sweeps questions'} found under this\n          filter.\n        </span>\n        <Col className=\"gap-2\">\n          {!prefersPlay && (\n            <Button onClick={() => setPrefersPlay(true)} color=\"purple\">\n              See mana markets\n            </Button>\n          )}\n\n          <Button\n            onClick={() =>\n              onChange({\n                [FILTER_KEY]: 'all',\n                [CONTRACT_TYPE_KEY]: 'ALL',\n                [TOPIC_FILTER_KEY]: '',\n                p: '0',\n              })\n            }\n            color=\"gray-outline\"\n          >\n            Clear filter\n          </Button>\n        </Col>\n      </Col>\n    ) : query ? (\n      <NoResults />\n    ) : (\n      <Col className=\"text-ink-700 mx-2 my-6 text-center\">\n        No questions yet.\n        {topicSlug && (\n          <Row className={'mt-2 w-full items-center justify-center'}>\n            <AddContractToGroupButton groupSlug={topicSlug} />\n          </Row>\n        )}\n      </Col>\n    ))\n\n  const selectedTopic = groupIds\n    ? ALL_PARENT_TOPICS.find((topic) =>\n        TOPICS_TO_SUBTOPICS[topic].some((subtopic) =>\n          groupIds.split(',').some((id) => subtopic.groupIds.includes(id))\n        )\n      )\n    : undefined\n  const selectedSubTopic = selectedTopic\n    ? TOPICS_TO_SUBTOPICS[selectedTopic].find(\n        (subtopic) => groupIds === subtopic.groupIds.join(',')\n      )\n    : undefined\n  const selectedAll = !selectedTopic && filter !== 'news'\n  const selectedOnlyNews = filter === 'news' && !selectedTopic\n\n  return (\n    <Col className=\"w-full\">\n      <Col className={clsx('bg-canvas-0 sticky top-0 z-20', headerClassName)}>\n        <Col className=\"mb-2\">\n          {showTopicsFilterPills && (\n            <Carousel\n              fadeEdges\n              labelsParentClassName=\"gap-4 items-baseline border-b border-ink-100 dark:border-ink-200 pb-2\"\n            >\n              <button\n                className={clsx(\n                  'font-medium',\n                  selectedAll ? 'text-primary-600' : 'text-ink-500'\n                )}\n                onClick={() => {\n                  if (selectedAll) {\n                    return\n                  } else {\n                    track('select search topic', { topic: 'all' })\n                    const changes: Partial<SearchParams> = {\n                      [GROUP_IDS_KEY]: '',\n                    }\n                    if (filter === 'news') changes[FILTER_KEY] = 'open'\n                    onChange(changes)\n                  }\n                }}\n              >\n                All\n              </button>\n              <button\n                className={clsx(\n                  'font-medium',\n                  selectedOnlyNews ? 'text-primary-600' : 'text-ink-500'\n                )}\n                onClick={() => {\n                  if (selectedOnlyNews) {\n                    onChange({ [FILTER_KEY]: 'open' })\n                  } else {\n                    track('select search topic', { topic: 'news' })\n                    onChange({ [FILTER_KEY]: 'news', [GROUP_IDS_KEY]: '' })\n                  }\n                }}\n              >\n                News\n              </button>\n              {ALL_PARENT_TOPICS.map((topic) => (\n                <button\n                  key={topic}\n                  className={clsx(\n                    'whitespace-nowrap font-medium',\n                    selectedTopic === topic\n                      ? 'text-primary-600'\n                      : 'text-ink-500'\n                  )}\n                  onClick={() => {\n                    if (selectedTopic === topic) {\n                      onChange({ [GROUP_IDS_KEY]: '' })\n                    } else {\n                      track('select search topic', { topic })\n                      // Join all group IDs for this topic's subtopics\n                      const allGroupIds = TOPICS_TO_SUBTOPICS[topic]\n                        .map((subtopic) => subtopic.groupIds)\n                        .flat()\n                      const changes: Partial<SearchParams> = {\n                        [GROUP_IDS_KEY]: allGroupIds.join(','),\n                      }\n                      if (filter === 'news') changes[FILTER_KEY] = 'open'\n                      onChange(changes)\n                    }\n                  }}\n                >\n                  {removeEmojis(topic)}\n                </button>\n              ))}\n            </Carousel>\n          )}\n        </Col>\n        {!hideSearch && (\n          <SearchInput\n            value={query}\n            setValue={setQuery}\n            placeholder={\n              searchType === 'Users'\n                ? 'Search users'\n                : searchType === 'Questions' || contractsOnly\n                ? 'Search questions'\n                : isMobile\n                ? 'Search'\n                : 'Search questions, users, topics, and posts'\n            }\n            autoFocus={autoFocus}\n            loading={loading}\n          />\n        )}\n\n        {/* Subtopics row */}\n        {selectedTopic &&\n          Object.keys(TOPICS_TO_SUBTOPICS).some(\n            (topic) => topic === selectedTopic\n          ) && (\n            <Carousel fadeEdges labelsParentClassName=\"gap-1 mt-3 mb-1.5 \">\n              <button\n                onClick={() => {\n                  onChange({\n                    [GROUP_IDS_KEY]: TOPICS_TO_SUBTOPICS[selectedTopic]\n                      .map((subtopic) => subtopic.groupIds)\n                      .flat()\n                      .join(','),\n                  })\n                }}\n                className={clsx(\n                  'text-ink-500 whitespace-nowrap px-3 py-0.5 text-sm',\n                  !selectedSubTopic &&\n                    'text-primary-700 bg-primary-50 dark:bg-primary-100 rounded-full font-medium'\n                )}\n              >\n                All\n              </button>\n              {TOPICS_TO_SUBTOPICS[selectedTopic]\n                .filter(({ hideFromSearch }) => !hideFromSearch)\n                .map(({ name, groupIds }) => (\n                  <button\n                    key={name}\n                    className={clsx(\n                      'text-ink-500 whitespace-nowrap px-3 py-0.5 text-sm',\n                      searchParams[GROUP_IDS_KEY] === groupIds.join(',') &&\n                        'text-primary-700 bg-primary-50 dark:bg-primary-100 rounded-full font-medium '\n                    )}\n                    onClick={() => {\n                      if (searchParams[GROUP_IDS_KEY] === groupIds.join(',')) {\n                        onChange({\n                          [GROUP_IDS_KEY]: TOPICS_TO_SUBTOPICS[selectedTopic]\n                            .map((subtopic) => subtopic.groupIds)\n                            .flat()\n                            .join(','),\n                        })\n                      } else {\n                        track('select search subtopic', { subtopic: name })\n                        onChange({ [GROUP_IDS_KEY]: groupIds.join(',') })\n                      }\n                    }}\n                  >\n                    {removeEmojis(name)}\n                  </button>\n                ))}\n            </Carousel>\n          )}\n\n        {!hideContractFilters && (\n          <ContractFilters\n            params={searchParams}\n            updateParams={onChange}\n            topicSlug={topicSlug}\n            className={\n              searchType && searchType !== 'Questions' ? 'invisible' : ''\n            }\n            hideSweepsToggle={hideSweepsToggle}\n          />\n        )}\n      </Col>\n      <Spacer h={1} />\n      {showSearchTypes && (\n        <Col>\n          {showTopics && (\n            <>\n              <Row className=\"text-ink-500 items-center gap-1 text-sm\">\n                <hr className=\"border-ink-300 ml-2 grow sm:ml-0\" />\n                <span>\n                  {!query || !topics?.length\n                    ? ''\n                    : topics.length >= 100\n                    ? '100+'\n                    : `${topics.length}`}{' '}\n                  {!query || !topics?.length ? 'Topics' : 'topics'}\n                </span>\n                <hr className=\"border-ink-300 mr-2 grow sm:mr-0\" />\n              </Row>\n              <BrowseTopicPills\n                className={'relative w-full px-2 pb-4'}\n                topics={topics}\n              />\n            </>\n          )}\n          {showUsers && <UserResults userResults={users} />}\n          {(showTopics || showUsers) && (\n            <Row className=\"text-ink-500 items-center gap-1 text-sm\">\n              <hr className=\"border-ink-300 ml-2 grow sm:ml-0\" />\n              <span>\n                {!query || !contracts?.length\n                  ? ''\n                  : contracts.length >= 100\n                  ? '100+'\n                  : shouldLoadMore && !loading\n                  ? `${contracts.length}+`\n                  : `${contracts.length}`}{' '}\n                {!query || !contracts?.length ? 'Questions' : 'questions'}\n              </span>\n              <hr className=\"border-ink-300 mr-2 grow sm:mr-0\" />\n            </Row>\n          )}\n        </Col>\n      )}\n\n      {!contracts && !posts ? (\n        <LoadingContractResults />\n      ) : contracts?.length === 0 && posts?.length === 0 ? (\n        emptyContractsState\n      ) : (\n        <>\n          {(contracts && contracts.length > 0) ||\n          (posts && posts.length > 0) ? (\n            <CombinedResults\n              contracts={contracts ?? []}\n              posts={posts ?? []}\n              searchParams={searchParams}\n              onContractClick={onContractClick}\n              highlightContractIds={highlightContractIds}\n              answersByContractId={answersByContractId}\n              hideAvatars={hideAvatars}\n              hideActions={hideActions}\n              hasBets={hasBets}\n            />\n          ) : null}\n          <LoadMoreUntilNotVisible loadMore={loadMoreContracts} />\n          {shouldLoadMore && <LoadingContractResults />}\n          {!shouldLoadMore && (\n            <NoMoreResults params={searchParams} onChange={onChange} />\n          )}\n        </>\n      )}\n    </Col>\n  )\n}\n\nconst NoResults = () => {\n  const [message] = useState(\n    sample([\n      'no questions found x.x',\n      'no questions found u_u',\n      'no questions found T_T',\n      'no questions found :c',\n      'no questions found :(',\n      'no questions found :(',\n      'no questions found :(',\n      'that search is too bananas for me 🍌',\n      'only nothingness',\n    ])\n  )\n\n  return (\n    <span className=\"text-ink-700 mx-2 my-6 text-center\">\n      {capitalize(message)}\n    </span>\n  )\n}\n\nexport const LoadingContractResults = () => {\n  return (\n    <Col className=\"w-full\">\n      <LoadingContractRow />\n      <LoadingContractRow />\n      <LoadingContractRow />\n    </Col>\n  )\n}\n\nexport const NoMoreResults = (props: {\n  params: SearchParams\n  onChange: (changes: Partial<SearchParams>) => void\n}) => {\n  const { params, onChange } = props\n  const showReset =\n    params[FILTER_KEY] !== 'all' ||\n    params[CONTRACT_TYPE_KEY] !== 'ALL' ||\n    params[PRIZE_MARKET_KEY] === '1'\n  // params[SWEEPIES_KEY] === '1' //TODO\n\n  return (\n    <div className=\"text-ink-500 mx-2 my-8 text-center\">\n      {showReset ? 'No more results under this filter. ' : 'No more results. '}\n      {showReset && (\n        <button\n          className=\"text-primary-500 hover:underline focus:underline\"\n          onClick={() => {\n            onChange({\n              [FILTER_KEY]: 'all',\n              [CONTRACT_TYPE_KEY]: 'ALL',\n              [PRIZE_MARKET_KEY]: '0',\n              // [SWEEPIES_KEY]: '0',\n            })\n          }}\n        >\n          Clear filter\n        </button>\n      )}\n    </div>\n  )\n}\n\nconst FRESH_SEARCH_CHANGED_STATE: SearchState = {\n  contracts: undefined,\n  users: undefined,\n  topics: undefined,\n  shouldLoadMore: true,\n  posts: undefined,\n}\n\nexport const useSearchResults = (props: {\n  persistPrefix: string\n  searchParams: SearchParams\n  includeUsersAndTopics: boolean\n  isReady: boolean\n  additionalFilter?: SupabaseAdditionalFilter\n}) => {\n  const { persistPrefix, searchParams, isReady, additionalFilter } = props\n\n  const [state, setState] = usePersistentInMemoryState<SearchState>(\n    FRESH_SEARCH_CHANGED_STATE,\n    `${persistPrefix}-supabase-contract-search`\n  )\n  const [loading, setLoading] = useState(false)\n\n  const requestId = useRef(0)\n\n  const querySearchResults = useEvent(\n    async (freshQuery?: boolean, contractsOnly?: boolean) => {\n      const {\n        q: query,\n        s: sort,\n        f: filter,\n        ct: contractType,\n        p: isPrizeMarketString,\n        fy: forYou,\n        tf: topicSlug,\n        sw: sweepState,\n        gids,\n        li: liquidity,\n        hb: hasBets,\n      } = searchParams\n\n      const shouldSearchPosts =\n        (sort === 'score' || sort === 'newest') &&\n        (!contractsOnly || !!state.posts?.length) &&\n        !topicSlug &&\n        forYou === '0' &&\n        isPrizeMarketString === '0' &&\n        !liquidity &&\n        hasBets === '0' &&\n        (contractType === 'ALL' || contractType === 'POSTS') &&\n        (filter === 'all' || filter === 'open') &&\n        !gids.length\n\n      const includeUsersAndTopics =\n        !contractsOnly && props.includeUsersAndTopics\n\n      if (freshQuery || state.shouldLoadMore) {\n        const id = ++requestId.current\n        let timeoutId: NodeJS.Timeout | undefined\n        if (freshQuery) {\n          timeoutId = setTimeout(() => {\n            if (id === requestId.current) {\n              setLoading(true)\n            }\n          }, 500)\n        }\n        const postApiParams: APIParams<'get-posts'> = {\n          sortBy: sort === 'score' ? 'importance_score' : 'created_time',\n          term: query,\n          limit: 10,\n          userId: additionalFilter?.creatorId,\n          offset: freshQuery ? 0 : state.posts?.length ?? 0,\n        }\n        try {\n          if (contractType === 'POSTS') {\n            const posts = await api('get-posts', postApiParams)\n            const shouldLoadMore = posts.length === 10\n            setState({\n              contracts: [],\n              users: undefined,\n              topics: undefined,\n              posts: uniqBy(buildArray(state.posts, posts), 'id'),\n              shouldLoadMore,\n            })\n            clearTimeout(timeoutId)\n            setLoading(false)\n            return shouldLoadMore\n          }\n          const searchPromises: Promise<any>[] = [\n            api('search-markets-full', {\n              term: query,\n              filter,\n              sort,\n              contractType,\n              offset: freshQuery ? 0 : state.contracts?.length ?? 0,\n              limit: CONTRACTS_PER_SEARCH_PAGE,\n              topicSlug: topicSlug !== '' ? topicSlug : undefined,\n              creatorId: additionalFilter?.creatorId,\n              isPrizeMarket: isPrizeMarketString,\n              forYou,\n              token:\n                sweepState === '2'\n                  ? 'ALL'\n                  : sweepState === '1'\n                  ? 'CASH'\n                  : 'MANA',\n              gids,\n              liquidity: liquidity === '' ? undefined : parseInt(liquidity),\n              hasBets,\n            }),\n          ]\n\n          if (includeUsersAndTopics) {\n            searchPromises.push(\n              searchUsers(query, USERS_PER_PAGE),\n              searchGroups({\n                term: query,\n                limit: TOPICS_PER_PAGE,\n                type: 'lite',\n              })\n            )\n            if (shouldSearchPosts) {\n              searchPromises.push(api('get-posts', postApiParams))\n            }\n          } else if (shouldSearchPosts || additionalFilter?.creatorId) {\n            searchPromises.push(api('get-posts', postApiParams))\n          }\n\n          const results = await Promise.all(searchPromises)\n\n          if (id === requestId.current) {\n            const newContracts = results[0] as Contract[]\n            let postResultIndex = 1\n            const newUsers = includeUsersAndTopics\n              ? results[postResultIndex++]\n              : undefined\n            const newTopics = includeUsersAndTopics\n              ? results[postResultIndex++]\n              : undefined\n\n            const newPostsResults =\n              (shouldSearchPosts || additionalFilter?.creatorId) &&\n              results.length >= postResultIndex\n                ? (results[postResultIndex] as TopLevelPost[])\n                : undefined\n\n            const freshContracts = freshQuery\n              ? newContracts\n              : buildArray(state.contracts, newContracts)\n            const bottomScoreFromAllContracts =\n              sort === 'score'\n                ? minBy(freshContracts, 'importanceScore')?.importanceScore\n                : minBy(freshContracts, 'createdTime')?.createdTime\n\n            // This is necessary bc the posts are in a different table than the contracts.\n            // TODO: this is bad and will leave posts out of the search results randomly.\n            // We should fix this by joining the posts table to the contracts table or something.\n            let postFilteringThreshold: number | undefined\n            if (sort === 'score') {\n              if (\n                !freshQuery &&\n                state.contracts &&\n                state.contracts.length > 0\n              ) {\n                postFilteringThreshold = minBy(\n                  state.contracts,\n                  'importanceScore'\n                )?.importanceScore\n              } else {\n                postFilteringThreshold = bottomScoreFromAllContracts\n              }\n            } else {\n              if (\n                !freshQuery &&\n                state.contracts &&\n                state.contracts.length > 0\n              ) {\n                postFilteringThreshold = minBy(\n                  state.contracts,\n                  'createdTime'\n                )?.createdTime\n              } else {\n                postFilteringThreshold = bottomScoreFromAllContracts\n              }\n            }\n            const freshPosts =\n              freshQuery || !state.posts\n                ? newPostsResults\n                : uniqBy(\n                    buildArray(\n                      state.posts,\n                      newPostsResults?.filter((p) =>\n                        postFilteringThreshold === undefined\n                          ? true\n                          : sort === 'score'\n                          ? p.importanceScore <= postFilteringThreshold\n                          : p.createdTime <= postFilteringThreshold\n                      )\n                    ),\n                    'id'\n                  )\n\n            const shouldLoadMore =\n              newContracts.length === CONTRACTS_PER_SEARCH_PAGE\n\n            setState({\n              contracts: freshContracts,\n              users: includeUsersAndTopics ? newUsers : state.users,\n              topics: includeUsersAndTopics ? newTopics?.lite : state.topics,\n              posts: freshPosts,\n              shouldLoadMore,\n            })\n            clearTimeout(timeoutId)\n            setLoading(false)\n\n            return shouldLoadMore\n          }\n        } catch (error) {\n          console.error('Error fetching search results:', error)\n          setLoading(false)\n        }\n      }\n      return false\n    }\n  )\n\n  useDebouncedEffect(\n    () => {\n      if (isReady && !state.contracts?.length) {\n        querySearchResults(true)\n      }\n    },\n    50,\n    [isReady]\n  )\n  useDebouncedEffect(\n    () => {\n      if (isReady) {\n        querySearchResults(true)\n      }\n    },\n    50,\n    [JSON.stringify(searchParams)]\n  )\n\n  const contracts = state.contracts\n    ? uniqBy(\n        state.contracts.filter((c) => {\n          return (\n            !additionalFilter?.excludeContractIds?.includes(c.id) &&\n            !additionalFilter?.excludeGroupSlugs?.some((slug) =>\n              c.groupSlugs?.includes(slug)\n            ) &&\n            !additionalFilter?.excludeUserIds?.includes(c.creatorId)\n          )\n        }),\n        'id'\n      )\n    : undefined\n\n  return {\n    contracts,\n    users: state.users,\n    topics: state.topics,\n    loading,\n    shouldLoadMore: state.shouldLoadMore,\n    loadMoreContracts: () => querySearchResults(false, true),\n    refreshContracts: () => querySearchResults(true, true),\n    posts: state.posts,\n  }\n}\n\nexport const useSearchQueryState = (props: {\n  persistPrefix: string\n  defaultSort?: Sort\n  defaultFilter?: Filter\n  defaultContractType?: ContractTypeType\n  defaultSearchType?: SearchType\n  defaultPrizeMarket?: '1' | '0'\n  defaultSweepies?: '2' | '1' | '0'\n  defaultForYou?: '1' | '0'\n  useUrlParams?: boolean\n  defaultTopicFilter?: string\n  defaultLiquidityTier?: string\n}) => {\n  const {\n    persistPrefix,\n    defaultSort,\n    defaultFilter,\n    defaultContractType,\n    defaultSearchType,\n    useUrlParams,\n    defaultPrizeMarket,\n    defaultForYou,\n    defaultTopicFilter,\n    defaultSweepies,\n    defaultLiquidityTier,\n  } = props\n\n  const defaults = {\n    [QUERY_KEY]: '',\n    [SORT_KEY]: defaultSort ?? 'score',\n    [FILTER_KEY]: defaultFilter ?? 'all',\n    [CONTRACT_TYPE_KEY]: defaultContractType ?? 'ALL',\n    [SEARCH_TYPE_KEY]: defaultSearchType,\n    [PRIZE_MARKET_KEY]: defaultPrizeMarket ?? '0',\n    [FOR_YOU_KEY]: defaultForYou ?? '0',\n    [TOPIC_FILTER_KEY]: defaultTopicFilter ?? '',\n    [SWEEPIES_KEY]: defaultSweepies ?? '0',\n    [GROUP_IDS_KEY]: '',\n    [LIQUIDITY_KEY]: defaultLiquidityTier ?? '',\n    [HAS_BETS_KEY]: '0' as '0' | '1',\n  }\n\n  const useHook = useUrlParams ? usePersistentQueriesState : useNothing\n  const [queryState, updateQueryState, queryReady] = useHook(\n    defaults,\n    persistPrefix\n  )\n  const [localState, updateLocalState, localReady] = useLocalPartialUpdater(\n    defaults,\n    persistPrefix\n  )\n\n  // copy query state -> local state iff we are using query params and any params are set\n  // only do this once on first load.\n  useEffect(() => {\n    if (\n      queryReady &&\n      localReady &&\n      useUrlParams &&\n      !isEqual(queryState, defaults)\n    ) {\n      updateLocalState(queryState)\n    }\n  }, [queryReady, localReady])\n\n  const setState = useEvent((newState: Partial<SearchParams>) => {\n    updateLocalState(newState)\n    if (useUrlParams) updateQueryState(newState)\n  })\n\n  return [localState, setState, queryReady && localReady] as const\n}\n\n// shim for hook rules and types\nconst useNothing = <T,>(x: T, _: string) =>\n  [x, (_: Partial<T>) => {}, true] as const satisfies any[]\n\nconst useLocalPartialUpdater = <T extends Record<string, string | undefined>>(\n  defaults: T,\n  persistPrefix: string\n) => {\n  const [state, setState, ready] = usePersistentLocalState(\n    defaults,\n    searchLocalKey(persistPrefix)\n  )\n\n  const updateState = (\n    newState: Partial<T> | ((prevState: T) => Partial<T>)\n  ) => {\n    if (typeof newState === 'function') {\n      setState((prevState) => ({ ...prevState, ...newState(prevState) }))\n    } else {\n      setState((prevState) => ({ ...prevState, ...newState }))\n    }\n  }\n\n  // the first copy of data from local state may be missing values, so we return the full state\n  return [{ ...defaults, ...state }, updateState, ready] as const\n}\n\nexport const searchLocalKey = (persistPrefix: string) =>\n  `${persistPrefix}-local-state`\n",
          "postContent": "'use client'\nimport clsx from 'clsx'\nimport { Contract } from 'common/contract'\nimport { LiteGroup } from 'common/group'\nimport { capitalize, groupBy, minBy, orderBy, sample, uniqBy } from 'lodash'\nimport { ReactNode, useEffect, useRef, useState } from 'react'\nimport { AddContractToGroupButton } from 'web/components/topics/add-contract-to-group-modal'\nimport { useDebouncedEffect } from 'web/hooks/use-debounced-effect'\nimport { useEvent } from 'client-common/hooks/use-event'\nimport { usePersistentInMemoryState } from 'client-common/hooks/use-persistent-in-memory-state'\nimport { usePersistentQueriesState } from 'web/hooks/use-persistent-query-state'\nimport { track } from 'web/lib/service/analytics'\nimport { Col } from './layout/col'\nimport { Row } from './layout/row'\nimport { FullUser } from 'common/api/user-types'\nimport { CONTRACTS_PER_SEARCH_PAGE } from 'common/supabase/contracts'\nimport { buildArray } from 'common/util/array'\nimport { Button } from 'web/components/buttons/button'\nimport { usePersistentLocalState } from 'web/hooks/use-persistent-local-state'\nimport { api, searchGroups } from 'web/lib/api/api'\nimport { searchUsers } from 'web/lib/supabase/users'\n\nimport { LoadingContractRow } from './contract/contracts-table'\nimport { ContractFilters } from './search/contract-filters'\nimport { UserResults } from './search/user-results'\nimport { BrowseTopicPills } from './topics/browse-topic-pills'\nimport { LoadMoreUntilNotVisible } from 'web/components/widgets/visibility-observer'\nimport { BinaryDigit } from 'common/tier'\nimport { useIsMobile } from 'web/hooks/use-is-mobile'\nimport { Spacer } from './layout/spacer'\nimport { useSweepstakes } from './sweepstakes-provider'\nimport { ALL_PARENT_TOPICS, TOPICS_TO_SUBTOPICS } from 'common/topics'\nimport { Carousel } from './widgets/carousel'\nimport { isEqual } from 'lodash'\nimport { SearchInput } from './search/search-input'\nimport { removeEmojis } from 'common/util/string'\nimport { useIsPageVisible } from 'web/hooks/use-page-visible'\nimport { TopLevelPost } from 'common/top-level-post'\nimport { CombinedResults } from './contract/combined-results'\nimport { APIParams } from 'common/api/schema'\n\nconst USERS_PER_PAGE = 100\nconst TOPICS_PER_PAGE = 100\n\nexport const SORTS = [\n  { label: 'Best', value: 'score' },\n  { label: 'Hot', value: 'freshness-score' },\n  { label: 'Liquidity', value: 'liquidity' },\n  { label: 'Subsidy', value: 'subsidy' },\n  { label: 'New', value: 'newest' },\n  { label: 'Closing soon', value: 'close-date' },\n  { label: 'Daily change', value: 'daily-score' },\n  { label: '24h volume', value: '24-hour-vol' },\n  { label: 'Total traders', value: 'most-popular' },\n  { label: 'Last activity', value: 'last-updated' },\n  { label: 'Just resolved', value: 'resolve-date' },\n  { label: 'Bounty amount', value: 'bounty-amount' },\n  { label: 'High %', value: 'prob-descending' },\n  { label: 'Low %', value: 'prob-ascending' },\n  { label: '🎲 Random!', value: 'random' },\n] as const\n\nexport const predictionMarketSorts = new Set([\n  'daily-score',\n  '24-hour-vol',\n  'liquidity',\n  'subsidy',\n  'close-date',\n  'resolve-date',\n  'most-popular',\n  'prob-descending',\n  'prob-ascending',\n  'freshness-score',\n])\n\nexport const bountySorts = new Set(['bounty-amount'])\n\nconst probSorts = new Set(['prob-descending', 'prob-ascending'])\n\nexport const BOUNTY_MARKET_SORTS = SORTS.filter(\n  (item) => !predictionMarketSorts.has(item.value)\n)\n\nexport const POLL_SORTS = BOUNTY_MARKET_SORTS.filter(\n  (item) => !bountySorts.has(item.value)\n)\n\nexport const PREDICTION_MARKET_SORTS = SORTS.filter(\n  (item) => !bountySorts.has(item.value) && !probSorts.has(item.value)\n)\n\nexport const PREDICTION_MARKET_PROB_SORTS = SORTS.filter(\n  (item) => !bountySorts.has(item.value)\n)\n\nexport type Sort = (typeof SORTS)[number]['value']\n\nexport const FILTERS = [\n  { label: 'Any status', value: 'all' },\n  { label: 'Open', value: 'open' },\n  { label: 'Closing in 7 days', value: 'closing-week' },\n  { label: 'Closing in 30 days', value: 'closing-month' },\n  { label: 'Closing in 90 days', value: 'closing-90-days' },\n  { label: 'Closed', value: 'closed' },\n  { label: 'Resolved', value: 'resolved' },\n  { label: 'News', value: 'news' },\n] as const\n\nexport type Filter = (typeof FILTERS)[number]['value']\n\nexport const CONTRACT_TYPES = [\n  { label: 'Any type', value: 'ALL' },\n  { label: 'Yes/No', value: 'BINARY' },\n  { label: 'Multiple Choice', value: 'MULTIPLE_CHOICE' },\n  { label: 'Numeric', value: 'PSEUDO_NUMERIC' },\n  { label: 'Bounty', value: 'BOUNTIED_QUESTION' },\n  { label: 'Stock', value: 'STONK' },\n  { label: 'Poll', value: 'POLL' },\n  { label: 'Posts', value: 'POSTS' },\n] as const\n\nexport const DEFAULT_SORT = 'score'\nexport const DEFAULT_SORTS = ['freshness-score', 'newest']\nexport const DEFAULT_BOUNTY_SORTS = ['bounty-amount']\n\nexport const DEFAULT_FILTERS = []\nexport const DEFAULT_FILTER = 'all'\n\nexport const DEFAULT_CONTRACT_TYPE = 'ALL'\nexport const DEFAULT_CONTRACT_TYPES = []\n\nexport const DEFAULT_TIER = '00000'\n\nexport type ContractTypeType = (typeof CONTRACT_TYPES)[number]['value']\ntype SearchType = 'Users' | 'Questions' | undefined\n\nexport type SearchParams = {\n  [QUERY_KEY]: string\n  [SORT_KEY]: Sort\n  [FILTER_KEY]: Filter\n  [CONTRACT_TYPE_KEY]: ContractTypeType\n  [SEARCH_TYPE_KEY]: SearchType\n  [PRIZE_MARKET_KEY]: BinaryDigit\n  [FOR_YOU_KEY]: BinaryDigit\n  [TOPIC_FILTER_KEY]: string\n  [SWEEPIES_KEY]: '0' | '1' | '2'\n  [GROUP_IDS_KEY]: string\n  [LIQUIDITY_KEY]: string // empty string or stringified number\n  [HAS_BETS_KEY]: '0' | '1'\n}\n\nexport const QUERY_KEY = 'q'\nexport const SORT_KEY = 's'\nexport const FILTER_KEY = 'f'\nexport const CONTRACT_TYPE_KEY = 'ct'\nexport const SEARCH_TYPE_KEY = 't'\nexport const PRIZE_MARKET_KEY = 'p'\nexport const FOR_YOU_KEY = 'fy'\nexport const MARKET_TIER_KEY = 'mt'\nexport const TOPIC_FILTER_KEY = 'tf'\nexport const SWEEPIES_KEY = 'sw'\nexport const GROUP_IDS_KEY = 'gids'\nexport const LIQUIDITY_KEY = 'li'\nexport const HAS_BETS_KEY = 'hb'\n\nexport type SupabaseAdditionalFilter = {\n  creatorId?: string\n  excludeContractIds?: string[]\n  excludeGroupSlugs?: string[]\n  excludeUserIds?: string[]\n}\n\nexport type SearchState = {\n  contracts: Contract[] | undefined\n  users: FullUser[] | undefined\n  topics: LiteGroup[] | undefined\n  shouldLoadMore: boolean\n  posts: TopLevelPost[] | undefined\n}\n\ntype SearchProps = {\n  persistPrefix: string\n  defaultSort?: Sort\n  defaultFilter?: Filter\n  defaultContractType?: ContractTypeType\n  defaultSearchType?: SearchType\n  defaultForYou?: '1' | '0'\n  additionalFilter?: SupabaseAdditionalFilter\n  highlightContractIds?: string[]\n  onContractClick?: (contract: Contract) => void\n  hideActions?: boolean\n  hideSweepsToggle?: boolean\n  headerClassName?: string\n  isWholePage?: boolean\n  // used to determine if search params should be updated in the URL\n  useUrlParams?: boolean\n  autoFocus?: boolean\n  emptyState?: ReactNode\n  hideSearch?: boolean\n  hideContractFilters?: boolean\n  topicSlug?: string\n  contractsOnly?: boolean\n  hideSearchTypes?: boolean\n  hideAvatars?: boolean\n  initialTopics?: LiteGroup[]\n  showTopicsFilterPills?: boolean\n  refreshOnVisible?: boolean\n}\n\nexport function Search(props: SearchProps) {\n  const {\n    defaultSort,\n    defaultFilter,\n    defaultContractType,\n    defaultSearchType,\n    defaultForYou,\n    additionalFilter,\n    onContractClick,\n    hideActions,\n    hideSweepsToggle,\n    highlightContractIds,\n    headerClassName,\n    persistPrefix,\n    isWholePage,\n    useUrlParams,\n    autoFocus,\n    hideContractFilters,\n    topicSlug = '',\n    contractsOnly,\n    hideSearch,\n    hideSearchTypes,\n    hideAvatars,\n    showTopicsFilterPills,\n    refreshOnVisible,\n  } = props\n\n  const isMobile = useIsMobile()\n  const { prefersPlay, setPrefersPlay } = useSweepstakes()\n  const [searchParams, setSearchParams, isReady] = useSearchQueryState({\n    defaultSort,\n    defaultFilter,\n    defaultContractType,\n    defaultSearchType,\n    defaultForYou,\n    useUrlParams,\n    persistPrefix,\n    defaultSweepies: prefersPlay ? '0' : '1',\n  })\n\n  const query = searchParams[QUERY_KEY]\n  const searchType = searchParams[SEARCH_TYPE_KEY]\n  const filter = searchParams[FILTER_KEY]\n  const contractType = searchParams[CONTRACT_TYPE_KEY]\n  const prizeMarketState = searchParams[PRIZE_MARKET_KEY]\n  const sweepiesState = searchParams[SWEEPIES_KEY]\n  const groupIds = searchParams[GROUP_IDS_KEY]\n  const hasBets = searchParams[HAS_BETS_KEY] === '1'\n  useEffect(() => {\n    const isSweeps = sweepiesState === '1'\n    if (prefersPlay !== isSweeps) return\n    setSearchParams({\n      [SWEEPIES_KEY]: prefersPlay ? '0' : '1',\n    })\n  }, [prefersPlay, sweepiesState])\n\n  const showSearchTypes = !!query && !hideSearchTypes && !contractsOnly\n\n  const actuallySearchParams = searchParams\n  if (topicSlug) actuallySearchParams[TOPIC_FILTER_KEY] = topicSlug\n  if (hideSweepsToggle) actuallySearchParams[SWEEPIES_KEY] = '2'\n\n  const {\n    contracts,\n    users,\n    topics,\n    loading,\n    shouldLoadMore,\n    loadMoreContracts,\n    refreshContracts,\n    posts,\n  } = useSearchResults({\n    persistPrefix,\n    searchParams: actuallySearchParams,\n    includeUsersAndTopics: showSearchTypes,\n    isReady,\n    additionalFilter,\n  })\n  const visible = useIsPageVisible()\n  useEffect(() => {\n    if (visible && refreshOnVisible) {\n      refreshContracts()\n    }\n  }, [visible, refreshOnVisible])\n\n  const showTopics = topics && topics.length > 0 && query && query.length > 0\n  const showUsers = users && users.length > 0 && query && query.length > 0\n\n  const onChange = (changes: Partial<SearchParams>) => {\n    const updatedParams = { ...changes }\n\n    setSearchParams(updatedParams)\n    if (isWholePage) window.scrollTo(0, 0)\n  }\n\n  const setQuery = (query: string) => onChange({ [QUERY_KEY]: query })\n\n  const answersWithChanges = contracts?.flatMap((c) =>\n    c.mechanism === 'cpmm-multi-1'\n      ? orderBy(\n          c.answers.filter((a) => Math.abs(a.probChanges.day) > 0.02),\n          (a) => Math.abs(a.probChanges.day),\n          'desc'\n        ).slice(0, 2)\n      : []\n  )\n\n  const answersMatchingQuery = contracts?.flatMap((c) =>\n    c.mechanism === 'cpmm-multi-1'\n      ? c.answers\n          .filter((a) => a.text.toLowerCase().includes(query.toLowerCase()))\n          .slice(0, 2)\n      : []\n  )\n  const answersByContractId =\n    answersWithChanges && filter === 'news'\n      ? groupBy(answersWithChanges, 'contractId')\n      : query !== ''\n      ? groupBy(answersMatchingQuery, 'contractId')\n      : undefined\n  const emptyContractsState =\n    props.emptyState ??\n    (filter !== 'all' ||\n    contractType !== 'ALL' ||\n    prizeMarketState === '1' ||\n    sweepiesState === '1' ? (\n      <Col className=\"mt-2 items-center gap-3\">\n        <span className=\"text-ink-700 text-center\">\n          No {prefersPlay ? 'questions' : 'sweeps questions'} found under this\n          filter.\n        </span>\n        <Col className=\"gap-2\">\n          {!prefersPlay && (\n            <Button onClick={() => setPrefersPlay(true)} color=\"purple\">\n              See mana markets\n            </Button>\n          )}\n\n          <Button\n            onClick={() =>\n              onChange({\n                [FILTER_KEY]: 'all',\n                [CONTRACT_TYPE_KEY]: 'ALL',\n                [TOPIC_FILTER_KEY]: '',\n                p: '0',\n              })\n            }\n            color=\"gray-outline\"\n          >\n            Clear filter\n          </Button>\n        </Col>\n      </Col>\n    ) : query ? (\n      <NoResults />\n    ) : (\n      <Col className=\"text-ink-700 mx-2 my-6 text-center\">\n        No questions yet.\n        {topicSlug && (\n          <Row className={'mt-2 w-full items-center justify-center'}>\n            <AddContractToGroupButton groupSlug={topicSlug} />\n          </Row>\n        )}\n      </Col>\n    ))\n\n  const selectedTopic = groupIds\n    ? ALL_PARENT_TOPICS.find((topic) =>\n        TOPICS_TO_SUBTOPICS[topic].some((subtopic) =>\n          groupIds.split(',').some((id) => subtopic.groupIds.includes(id))\n        )\n      )\n    : undefined\n  const selectedSubTopic = selectedTopic\n    ? TOPICS_TO_SUBTOPICS[selectedTopic].find(\n        (subtopic) => groupIds === subtopic.groupIds.join(',')\n      )\n    : undefined\n  const selectedAll = !selectedTopic && filter !== 'news'\n  const selectedOnlyNews = filter === 'news' && !selectedTopic\n\n  return (\n    <Col className=\"w-full\">\n      <Col className={clsx('bg-canvas-0 sticky top-0 z-20', headerClassName)}>\n        <Col className=\"mb-2\">\n          {showTopicsFilterPills && (\n            <Carousel\n              fadeEdges\n              labelsParentClassName=\"gap-4 items-baseline border-b border-ink-100 dark:border-ink-200 pb-2\"\n            >\n              <button\n                className={clsx(\n                  'font-medium',\n                  selectedAll ? 'text-primary-600' : 'text-ink-500'\n                )}\n                onClick={() => {\n                  if (selectedAll) {\n                    return\n                  } else {\n                    track('select search topic', { topic: 'all' })\n                    const changes: Partial<SearchParams> = {\n                      [GROUP_IDS_KEY]: '',\n                    }\n                    if (filter === 'news') changes[FILTER_KEY] = 'open'\n                    onChange(changes)\n                  }\n                }}\n              >\n                All\n              </button>\n              <button\n                className={clsx(\n                  'font-medium',\n                  selectedOnlyNews ? 'text-primary-600' : 'text-ink-500'\n                )}\n                onClick={() => {\n                  if (selectedOnlyNews) {\n                    onChange({ [FILTER_KEY]: 'open' })\n                  } else {\n                    track('select search topic', { topic: 'news' })\n                    onChange({ [FILTER_KEY]: 'news', [GROUP_IDS_KEY]: '' })\n                  }\n                }}\n              >\n                News\n              </button>\n              {ALL_PARENT_TOPICS.map((topic) => (\n                <button\n                  key={topic}\n                  className={clsx(\n                    'whitespace-nowrap font-medium',\n                    selectedTopic === topic\n                      ? 'text-primary-600'\n                      : 'text-ink-500'\n                  )}\n                  onClick={() => {\n                    if (selectedTopic === topic) {\n                      onChange({ [GROUP_IDS_KEY]: '' })\n                    } else {\n                      track('select search topic', { topic })\n                      // Join all group IDs for this topic's subtopics\n                      const allGroupIds = TOPICS_TO_SUBTOPICS[topic]\n                        .map((subtopic) => subtopic.groupIds)\n                        .flat()\n                      const changes: Partial<SearchParams> = {\n                        [GROUP_IDS_KEY]: allGroupIds.join(','),\n                      }\n                      if (filter === 'news') changes[FILTER_KEY] = 'open'\n                      onChange(changes)\n                    }\n                  }}\n                >\n                  {removeEmojis(topic)}\n                </button>\n              ))}\n            </Carousel>\n          )}\n        </Col>\n        {!hideSearch && (\n          <SearchInput\n            value={query}\n            setValue={setQuery}\n            placeholder={\n              searchType === 'Users'\n                ? 'Search users'\n                : searchType === 'Questions' || contractsOnly\n                ? 'Search questions'\n                : isMobile\n                ? 'Search'\n                : 'Search questions, users, topics, and posts'\n            }\n            autoFocus={autoFocus}\n            loading={loading}\n          />\n        )}\n\n        {/* Subtopics row */}\n        {selectedTopic &&\n          Object.keys(TOPICS_TO_SUBTOPICS).some(\n            (topic) => topic === selectedTopic\n          ) && (\n            <Carousel fadeEdges labelsParentClassName=\"gap-1 mt-3 mb-1.5 \">\n              <button\n                onClick={() => {\n                  onChange({\n                    [GROUP_IDS_KEY]: TOPICS_TO_SUBTOPICS[selectedTopic]\n                      .map((subtopic) => subtopic.groupIds)\n                      .flat()\n                      .join(','),\n                  })\n                }}\n                className={clsx(\n                  'text-ink-500 whitespace-nowrap px-3 py-0.5 text-sm',\n                  !selectedSubTopic &&\n                    'text-primary-700 bg-primary-50 dark:bg-primary-100 rounded-full font-medium'\n                )}\n              >\n                All\n              </button>\n              {TOPICS_TO_SUBTOPICS[selectedTopic]\n                .filter(({ hideFromSearch }) => !hideFromSearch)\n                .map(({ name, groupIds }) => (\n                  <button\n                    key={name}\n                    className={clsx(\n                      'text-ink-500 whitespace-nowrap px-3 py-0.5 text-sm',\n                      searchParams[GROUP_IDS_KEY] === groupIds.join(',') &&\n                        'text-primary-700 bg-primary-50 dark:bg-primary-100 rounded-full font-medium '\n                    )}\n                    onClick={() => {\n                      if (searchParams[GROUP_IDS_KEY] === groupIds.join(',')) {\n                        onChange({\n                          [GROUP_IDS_KEY]: TOPICS_TO_SUBTOPICS[selectedTopic]\n                            .map((subtopic) => subtopic.groupIds)\n                            .flat()\n                            .join(','),\n                        })\n                      } else {\n                        track('select search subtopic', { subtopic: name })\n                        onChange({ [GROUP_IDS_KEY]: groupIds.join(',') })\n                      }\n                    }}\n                  >\n                    {removeEmojis(name)}\n                  </button>\n                ))}\n            </Carousel>\n          )}\n\n        {!hideContractFilters && (\n          <ContractFilters\n            params={searchParams}\n            updateParams={onChange}\n            topicSlug={topicSlug}\n            className={\n              searchType && searchType !== 'Questions' ? 'invisible' : ''\n            }\n            hideSweepsToggle={hideSweepsToggle}\n          />\n        )}\n      </Col>\n      <Spacer h={1} />\n      {showSearchTypes && (\n        <Col>\n          {showTopics && (\n            <>\n              <Row className=\"text-ink-500 items-center gap-1 text-sm\">\n                <hr className=\"border-ink-300 ml-2 grow sm:ml-0\" />\n                <span>\n                  {!query || !topics?.length\n                    ? ''\n                    : topics.length >= 100\n                    ? '100+'\n                    : `${topics.length}`}{' '}\n                  {!query || !topics?.length ? 'Topics' : 'topics'}\n                </span>\n                <hr className=\"border-ink-300 mr-2 grow sm:mr-0\" />\n              </Row>\n              <BrowseTopicPills\n                className={'relative w-full px-2 pb-4'}\n                topics={topics}\n              />\n            </>\n          )}\n          {showUsers && <UserResults userResults={users} />}\n          {(showTopics || showUsers) && (\n            <Row className=\"text-ink-500 items-center gap-1 text-sm\">\n              <hr className=\"border-ink-300 ml-2 grow sm:ml-0\" />\n              <span>\n                {!query || !contracts?.length\n                  ? ''\n                  : contracts.length >= 100\n                  ? '100+'\n                  : shouldLoadMore && !loading\n                  ? `${contracts.length}+`\n                  : `${contracts.length}`}{' '}\n                {!query || !contracts?.length ? 'Questions' : 'questions'}\n              </span>\n              <hr className=\"border-ink-300 mr-2 grow sm:mr-0\" />\n            </Row>\n          )}\n        </Col>\n      )}\n\n      {!contracts && !posts ? (\n        <LoadingContractResults />\n      ) : contracts?.length === 0 && posts?.length === 0 ? (\n        emptyContractsState\n      ) : (\n        <>\n          {contracts || posts ? (\n            <CombinedResults\n              contracts={contracts ?? []}\n              posts={posts ?? []}\n              searchParams={searchParams}\n              onContractClick={onContractClick}\n              highlightContractIds={highlightContractIds}\n              answersByContractId={answersByContractId}\n              hideAvatars={hideAvatars}\n              hideActions={hideActions}\n              hasBets={hasBets}\n            />\n          ) : null}\n          <LoadMoreUntilNotVisible loadMore={loadMoreContracts} />\n          {shouldLoadMore && <LoadingContractResults />}\n          {!shouldLoadMore && (\n            <NoMoreResults params={searchParams} onChange={onChange} />\n          )}\n        </>\n      )}\n    </Col>\n  )\n}\n\nconst NoResults = () => {\n  const [message] = useState(\n    sample([\n      'no questions found x.x',\n      'no questions found u_u',\n      'no questions found T_T',\n      'no questions found :c',\n      'no questions found :(',\n      'no questions found :(',\n      'no questions found :(',\n      'that search is too bananas for me 🍌',\n      'only nothingness',\n    ])\n  )\n\n  return (\n    <span className=\"text-ink-700 mx-2 my-6 text-center\">\n      {capitalize(message)}\n    </span>\n  )\n}\n\nexport const LoadingContractResults = () => {\n  return (\n    <Col className=\"w-full\">\n      <LoadingContractRow />\n      <LoadingContractRow />\n      <LoadingContractRow />\n    </Col>\n  )\n}\n\nexport const NoMoreResults = (props: {\n  params: SearchParams\n  onChange: (changes: Partial<SearchParams>) => void\n}) => {\n  const { params, onChange } = props\n  const showReset =\n    params[FILTER_KEY] !== 'all' ||\n    params[CONTRACT_TYPE_KEY] !== 'ALL' ||\n    params[PRIZE_MARKET_KEY] === '1'\n  // params[SWEEPIES_KEY] === '1' //TODO\n\n  return (\n    <div className=\"text-ink-500 mx-2 my-8 text-center\">\n      {showReset ? 'No more results under this filter. ' : 'No more results. '}\n      {showReset && (\n        <button\n          className=\"text-primary-500 hover:underline focus:underline\"\n          onClick={() => {\n            onChange({\n              [FILTER_KEY]: 'all',\n              [CONTRACT_TYPE_KEY]: 'ALL',\n              [PRIZE_MARKET_KEY]: '0',\n              // [SWEEPIES_KEY]: '0',\n            })\n          }}\n        >\n          Clear filter\n        </button>\n      )}\n    </div>\n  )\n}\n\nconst FRESH_SEARCH_CHANGED_STATE: SearchState = {\n  contracts: undefined,\n  users: undefined,\n  topics: undefined,\n  shouldLoadMore: true,\n  posts: undefined,\n}\n\nexport const useSearchResults = (props: {\n  persistPrefix: string\n  searchParams: SearchParams\n  includeUsersAndTopics: boolean\n  isReady: boolean\n  additionalFilter?: SupabaseAdditionalFilter\n}) => {\n  const { persistPrefix, searchParams, isReady, additionalFilter } = props\n\n  const [state, setState] = usePersistentInMemoryState<SearchState>(\n    FRESH_SEARCH_CHANGED_STATE,\n    `${persistPrefix}-supabase-contract-search`\n  )\n  const [loading, setLoading] = useState(false)\n\n  const requestId = useRef(0)\n\n  const querySearchResults = useEvent(\n    async (freshQuery?: boolean, contractsOnly?: boolean) => {\n      const {\n        q: query,\n        s: sort,\n        f: filter,\n        ct: contractType,\n        p: isPrizeMarketString,\n        fy: forYou,\n        tf: topicSlug,\n        sw: sweepState,\n        gids,\n        li: liquidity,\n        hb: hasBets,\n      } = searchParams\n\n      const shouldSearchPostsWithContracts =\n        (sort === 'score' || sort === 'newest') &&\n        (!contractsOnly || !!state.posts?.length) &&\n        !topicSlug &&\n        forYou === '0' &&\n        isPrizeMarketString === '0' &&\n        !liquidity &&\n        hasBets === '0' &&\n        (contractType === 'ALL' || contractType === 'POSTS') &&\n        (filter === 'all' || filter === 'open') &&\n        !gids.length &&\n        // There aren't that many posts, so we don't need to wait up for them\n        (state.posts?.length ?? 0) < 20\n\n      const includeUsersAndTopics =\n        !contractsOnly && props.includeUsersAndTopics\n\n      if (freshQuery || state.shouldLoadMore) {\n        const id = ++requestId.current\n        let timeoutId: NodeJS.Timeout | undefined\n        if (freshQuery) {\n          timeoutId = setTimeout(() => {\n            if (id === requestId.current) {\n              setLoading(true)\n            }\n          }, 500)\n        }\n        const postApiParams: APIParams<'get-posts'> = {\n          sortBy: sort === 'score' ? 'importance_score' : 'created_time',\n          term: query,\n          limit: 10,\n          userId: additionalFilter?.creatorId,\n          offset: freshQuery ? 0 : state.posts?.length ?? 0,\n        }\n        try {\n          if (contractType === 'POSTS') {\n            const posts = await api('get-posts', postApiParams)\n            const shouldLoadMore = posts.length === 10\n            setState({\n              contracts: [],\n              users: undefined,\n              topics: undefined,\n              posts: uniqBy(buildArray(state.posts, posts), 'id'),\n              shouldLoadMore,\n            })\n            clearTimeout(timeoutId)\n            setLoading(false)\n            return shouldLoadMore\n          }\n          const searchPromises: Promise<any>[] = [\n            api('search-markets-full', {\n              term: query,\n              filter,\n              sort,\n              contractType,\n              offset: freshQuery ? 0 : state.contracts?.length ?? 0,\n              limit: CONTRACTS_PER_SEARCH_PAGE,\n              topicSlug: topicSlug !== '' ? topicSlug : undefined,\n              creatorId: additionalFilter?.creatorId,\n              isPrizeMarket: isPrizeMarketString,\n              forYou,\n              token:\n                sweepState === '2'\n                  ? 'ALL'\n                  : sweepState === '1'\n                  ? 'CASH'\n                  : 'MANA',\n              gids,\n              liquidity: liquidity === '' ? undefined : parseInt(liquidity),\n              hasBets,\n            }),\n          ]\n\n          if (includeUsersAndTopics) {\n            searchPromises.push(\n              searchUsers(query, USERS_PER_PAGE),\n              searchGroups({\n                term: query,\n                limit: TOPICS_PER_PAGE,\n                type: 'lite',\n              })\n            )\n          }\n          if (shouldSearchPostsWithContracts) {\n            searchPromises.push(api('get-posts', postApiParams))\n          }\n\n          const results = await Promise.all(searchPromises)\n\n          if (id === requestId.current) {\n            const newContracts = results[0] as Contract[]\n            let postResultIndex = 1\n            const newUsers = includeUsersAndTopics\n              ? results[postResultIndex++]\n              : undefined\n            const newTopics = includeUsersAndTopics\n              ? results[postResultIndex++]\n              : undefined\n\n            const newPostsResults =\n              shouldSearchPostsWithContracts &&\n              results.length >= postResultIndex\n                ? (results[postResultIndex] as TopLevelPost[])\n                : undefined\n\n            const freshContracts = freshQuery\n              ? newContracts\n              : buildArray(state.contracts, newContracts)\n            const bottomScoreFromAllContracts =\n              sort === 'score'\n                ? minBy(freshContracts, 'importanceScore')?.importanceScore\n                : minBy(freshContracts, 'createdTime')?.createdTime\n\n            // This is necessary bc the posts are in a different table than the contracts.\n            // TODO: this is bad and will leave posts out of the search results randomly.\n            // We should fix this by joining the posts table to the contracts table or something.\n            let postFilteringThreshold: number | undefined\n            if (sort === 'score') {\n              if (\n                !freshQuery &&\n                state.contracts &&\n                state.contracts.length > 0\n              ) {\n                postFilteringThreshold = minBy(\n                  state.contracts,\n                  'importanceScore'\n                )?.importanceScore\n              } else {\n                postFilteringThreshold = bottomScoreFromAllContracts\n              }\n            } else {\n              if (\n                !freshQuery &&\n                state.contracts &&\n                state.contracts.length > 0\n              ) {\n                postFilteringThreshold = minBy(\n                  state.contracts,\n                  'createdTime'\n                )?.createdTime\n              } else {\n                postFilteringThreshold = bottomScoreFromAllContracts\n              }\n            }\n            const freshPosts =\n              freshQuery || !state.posts\n                ? newPostsResults\n                : uniqBy(\n                    buildArray(\n                      state.posts,\n                      newPostsResults?.filter((p) =>\n                        postFilteringThreshold === undefined\n                          ? true\n                          : sort === 'score'\n                          ? p.importanceScore <= postFilteringThreshold\n                          : p.createdTime <= postFilteringThreshold\n                      )\n                    ),\n                    'id'\n                  )\n\n            const shouldLoadMore =\n              newContracts.length === CONTRACTS_PER_SEARCH_PAGE\n\n            setState({\n              contracts: freshContracts,\n              users: includeUsersAndTopics ? newUsers : state.users,\n              topics: includeUsersAndTopics ? newTopics?.lite : state.topics,\n              posts: freshPosts,\n              shouldLoadMore,\n            })\n            clearTimeout(timeoutId)\n            setLoading(false)\n\n            return shouldLoadMore\n          }\n        } catch (error) {\n          console.error('Error fetching search results:', error)\n          setLoading(false)\n        }\n      }\n      return false\n    }\n  )\n\n  useDebouncedEffect(\n    () => {\n      if (isReady && !state.contracts?.length) {\n        querySearchResults(true)\n      }\n    },\n    50,\n    [isReady]\n  )\n  useDebouncedEffect(\n    () => {\n      if (isReady) {\n        querySearchResults(true)\n      }\n    },\n    50,\n    [JSON.stringify(searchParams)]\n  )\n\n  const contracts = state.contracts\n    ? uniqBy(\n        state.contracts.filter((c) => {\n          return (\n            !additionalFilter?.excludeContractIds?.includes(c.id) &&\n            !additionalFilter?.excludeGroupSlugs?.some((slug) =>\n              c.groupSlugs?.includes(slug)\n            ) &&\n            !additionalFilter?.excludeUserIds?.includes(c.creatorId)\n          )\n        }),\n        'id'\n      )\n    : undefined\n\n  return {\n    contracts,\n    users: state.users,\n    topics: state.topics,\n    loading,\n    shouldLoadMore: state.shouldLoadMore,\n    loadMoreContracts: () => querySearchResults(false, true),\n    refreshContracts: () => querySearchResults(true, true),\n    posts: state.posts,\n  }\n}\n\nexport const useSearchQueryState = (props: {\n  persistPrefix: string\n  defaultSort?: Sort\n  defaultFilter?: Filter\n  defaultContractType?: ContractTypeType\n  defaultSearchType?: SearchType\n  defaultPrizeMarket?: '1' | '0'\n  defaultSweepies?: '2' | '1' | '0'\n  defaultForYou?: '1' | '0'\n  useUrlParams?: boolean\n  defaultTopicFilter?: string\n  defaultLiquidityTier?: string\n}) => {\n  const {\n    persistPrefix,\n    defaultSort,\n    defaultFilter,\n    defaultContractType,\n    defaultSearchType,\n    useUrlParams,\n    defaultPrizeMarket,\n    defaultForYou,\n    defaultTopicFilter,\n    defaultSweepies,\n    defaultLiquidityTier,\n  } = props\n\n  const defaults = {\n    [QUERY_KEY]: '',\n    [SORT_KEY]: defaultSort ?? 'score',\n    [FILTER_KEY]: defaultFilter ?? 'all',\n    [CONTRACT_TYPE_KEY]: defaultContractType ?? 'ALL',\n    [SEARCH_TYPE_KEY]: defaultSearchType,\n    [PRIZE_MARKET_KEY]: defaultPrizeMarket ?? '0',\n    [FOR_YOU_KEY]: defaultForYou ?? '0',\n    [TOPIC_FILTER_KEY]: defaultTopicFilter ?? '',\n    [SWEEPIES_KEY]: defaultSweepies ?? '0',\n    [GROUP_IDS_KEY]: '',\n    [LIQUIDITY_KEY]: defaultLiquidityTier ?? '',\n    [HAS_BETS_KEY]: '0' as '0' | '1',\n  }\n\n  const useHook = useUrlParams ? usePersistentQueriesState : useNothing\n  const [queryState, updateQueryState, queryReady] = useHook(\n    defaults,\n    persistPrefix\n  )\n  const [localState, updateLocalState, localReady] = useLocalPartialUpdater(\n    defaults,\n    persistPrefix\n  )\n\n  // copy query state -> local state iff we are using query params and any params are set\n  // only do this once on first load.\n  useEffect(() => {\n    if (\n      queryReady &&\n      localReady &&\n      useUrlParams &&\n      !isEqual(queryState, defaults)\n    ) {\n      updateLocalState(queryState)\n    }\n  }, [queryReady, localReady])\n\n  const setState = useEvent((newState: Partial<SearchParams>) => {\n    updateLocalState(newState)\n    if (useUrlParams) updateQueryState(newState)\n  })\n\n  return [localState, setState, queryReady && localReady] as const\n}\n\n// shim for hook rules and types\nconst useNothing = <T,>(x: T, _: string) =>\n  [x, (_: Partial<T>) => {}, true] as const satisfies any[]\n\nconst useLocalPartialUpdater = <T extends Record<string, string | undefined>>(\n  defaults: T,\n  persistPrefix: string\n) => {\n  const [state, setState, ready] = usePersistentLocalState(\n    defaults,\n    searchLocalKey(persistPrefix)\n  )\n\n  const updateState = (\n    newState: Partial<T> | ((prevState: T) => Partial<T>)\n  ) => {\n    if (typeof newState === 'function') {\n      setState((prevState) => ({ ...prevState, ...newState(prevState) }))\n    } else {\n      setState((prevState) => ({ ...prevState, ...newState }))\n    }\n  }\n\n  // the first copy of data from local state may be missing values, so we return the full state\n  return [{ ...defaults, ...state }, updateState, ready] as const\n}\n\nexport const searchLocalKey = (persistPrefix: string) =>\n  `${persistPrefix}-local-state`\n"
        }
      ]
    },
    {
      "sha": "2075f2b80f47c99aba5996ae700b32d013be47db",
      "author": "Ian Philips",
      "date": "2025-05-09 09:22:30 -0700",
      "message": "Abolish 'votes' and share resolution criteria",
      "stats": {
        "filesChanged": 2,
        "insertions": 20,
        "deletions": 15
      },
      "selectionReason": "Removes voting terminology and updates resolution criteria sharing - demonstrates content/terminology refactoring",
      "spec": "Update the AI's instructions for generating prediction market descriptions and suggesting new markets. For AI-generated descriptions, enforce a strict three-section structure: '#### Resolution criteria', '#### Background', and '#### Considerations', in that order, with no other content. The 'Resolution criteria' section must be first and adhere to new, detailed guidelines. These guidelines must emphasize objective, verifiable outcomes with specific source links, and explicitly prohibit resolution by 'votes', instead directing towards polls for subjective questions or user opinion for first-person questions. The instruction for web search use should become conditional ('if necessary'). For AI-generated market suggestions, replace the existing resolution criteria guidelines with these same new detailed guidelines, and remove the requirement for a 'Reasoning:' section to follow each suggestion.",
      "fileStates": [
        {
          "path": "backend/api/src/generate-ai-description.ts",
          "preContent": "import { APIError, APIHandler } from './helpers/endpoint'\nimport { log } from 'shared/utils'\nimport { track } from 'shared/analytics'\nimport { anythingToRichText } from 'shared/tiptap'\nimport { promptOpenAIWithWebSearch } from 'shared/helpers/openai-utils'\nimport {\n  addAnswersModeDescription,\n  outcomeTypeDescriptions,\n} from 'common/ai-creation-prompts'\nimport { HOUR_MS } from 'common/util/time'\nimport { rateLimitByUser } from './helpers/rate-limit'\n\nexport const generateAIDescription: APIHandler<'generate-ai-description'> =\n  rateLimitByUser(\n    async (props, auth) => {\n      const {\n        question,\n        description,\n        answers,\n        outcomeType,\n        shouldAnswersSumToOne,\n        addAnswersMode,\n      } = props\n      const includeAnswers =\n        answers &&\n        answers.length > 0 &&\n        outcomeType &&\n        ['MULTIPLE_CHOICE', 'POLL'].includes(outcomeType)\n      const outcomeKey =\n        outcomeType == 'MULTIPLE_CHOICE'\n          ? shouldAnswersSumToOne\n            ? 'DEPENDENT_MULTIPLE_CHOICE'\n            : 'INDEPENDENT_MULTIPLE_CHOICE'\n          : outcomeType\n\n      const userQuestionAndDescription = `Question: ${question} ${\n        description && description !== '<p></p>'\n          ? `\\nDescription: ${description}`\n          : ''\n      } ${includeAnswers ? `\\nMaybe: ${answers.join(', ')}` : ''}\n  `\n\n      log('Generating AI description for:', userQuestionAndDescription)\n      try {\n        const prompt = `\n        You are a helpful AI assistant that uses web search to research and generate descriptions for prediction markets. Your goal is to provide relevant context and clear resolution criteria that will help traders make informed predictions.\n        ${\n          outcomeKey\n            ? `Their market is of type ${outcomeKey}\\n${outcomeTypeDescriptions}`\n            : ''\n        }\n        ${\n          addAnswersMode\n            ? `\\nThe user has specified that the addAnswersMode is ${addAnswersMode}\\n${addAnswersModeDescription}`\n            : ''\n        }\n        Guidelines:\n        - Keep descriptions concise but informative, focusing on objective facts rather than opinions\n        - Incorporate any relevant information from the user's description into your own description\n        - If the user supplied answers, provide any relevant background information for each answer\n        - If the market is personal, (i.e. I will attend the most parties, or I will get a girlfriend) word resolution criteria in the first person\n        - Include a \"Resolution criteria\" section first that describes how the market will be resolved.\n          - Include any special additional resolution criteria if edge cases are exceptionally likely. Otherwise, the criteria should be concise and to the point, allowing the creator and traders to use common sense to resolve edge cases.\n        - Include relevant sources and data when available from your web search\n        - Don't repeat the question in the description\n        - If the market has a precondition, such as 'If I attend, will I enjoy the party?', or 'If Biden runs, will he win?', markets should resolve N/A if the precondition is not met\n        - Format the response as markdown\n        - Also include a \"Background\" section that includes information readers/traders may want to know if it's relevant to the user's question AND it's not common knowledge. Keep it concise.\n        - Only include a \"Considerations\" section if there are unexpected considerations that traders may want to know about. E.g. if the question is about something that has never happened before, etc. ${\n          addAnswersMode === 'DISABLED' &&\n          outcomeKey === 'DEPENDENT_MULTIPLE_CHOICE'\n            ? 'E.g. if the answers are not exhaustive, traders should be warned that the market may resolve N/A.'\n            : ''\n        }\n        - Format each separate section with a #### header\n        - Use your web search tool to gather relevant, up-to-date information related to the user's prompt to inform the description. Include information from it in the description that traders or other readers may want to know if it's relevant to the user's question, but keep it concise.\n\n        User's prompt:\n        ${userQuestionAndDescription}\n\n        Only return the markdown description, nothing else.\n        `\n        const gptResponse = await promptOpenAIWithWebSearch(prompt)\n\n        track(auth.uid, 'generate-ai-description', {\n          question: question.substring(0, 100),\n          hasExistingDescription: !!description,\n        })\n\n        return { description: anythingToRichText({ markdown: gptResponse }) }\n      } catch (e) {\n        log.error('Failed to generate description:', { e })\n        throw new APIError(\n          500,\n          'Failed to generate description. Please try again.'\n        )\n      }\n    },\n    { maxCalls: 60, windowMs: HOUR_MS }\n  )\n",
          "postContent": "import { APIError, APIHandler } from './helpers/endpoint'\nimport { log } from 'shared/utils'\nimport { track } from 'shared/analytics'\nimport { anythingToRichText } from 'shared/tiptap'\nimport { promptOpenAIWithWebSearch } from 'shared/helpers/openai-utils'\nimport {\n  addAnswersModeDescription,\n  outcomeTypeDescriptions,\n  resolutionCriteriaPrompt,\n} from 'common/ai-creation-prompts'\nimport { HOUR_MS } from 'common/util/time'\nimport { rateLimitByUser } from './helpers/rate-limit'\n\nexport const generateAIDescription: APIHandler<'generate-ai-description'> =\n  rateLimitByUser(\n    async (props, auth) => {\n      const {\n        question,\n        description,\n        answers,\n        outcomeType,\n        shouldAnswersSumToOne,\n        addAnswersMode,\n      } = props\n      const includeAnswers =\n        answers &&\n        answers.length > 0 &&\n        outcomeType &&\n        ['MULTIPLE_CHOICE', 'POLL'].includes(outcomeType)\n      const outcomeKey =\n        outcomeType == 'MULTIPLE_CHOICE'\n          ? shouldAnswersSumToOne\n            ? 'DEPENDENT_MULTIPLE_CHOICE'\n            : 'INDEPENDENT_MULTIPLE_CHOICE'\n          : outcomeType\n\n      const userQuestionAndDescription = `Question: ${question} ${\n        description && description !== '<p></p>'\n          ? `\\nDescription: ${description}`\n          : ''\n      } ${includeAnswers ? `\\nMaybe: ${answers.join(', ')}` : ''}\n  `\n\n      log('Generating AI description for:', userQuestionAndDescription)\n      try {\n        const prompt = `\n        You are a helpful AI assistant that uses web search to research and generate descriptions for prediction markets. Your goal is to provide relevant context and clear resolution criteria that will help traders make informed predictions.\n        ${\n          outcomeKey\n            ? `Their market is of type ${outcomeKey}\\n${outcomeTypeDescriptions}`\n            : ''\n        }\n        ${\n          addAnswersMode\n            ? `\\nThe user has specified that the addAnswersMode is ${addAnswersMode}\\n${addAnswersModeDescription}`\n            : ''\n        }\n        Guidelines:\n        - Keep descriptions concise but informative, focusing on objective facts rather than opinions\n        - Incorporate any relevant information from the user's description into your own description\n        - If the user supplied answers, provide any relevant background information for each answer\n        - If the market is personal, (i.e. I will attend the most parties, or I will get a girlfriend) word resolution criteria in the first person\n        - Include only up to 3 sections and only 3 sections in the description: Resolution criteria, Background, and Considerations. Do not write anything else.\n        - The \"Resolution criteria\" section should be the first section and describe how the market will be resolved:\n        - ${resolutionCriteriaPrompt}\n        - Include relevant sources and data when available from your web search\n        - Don't repeat the question in the description\n        - If the market has a precondition, such as 'If I attend, will I enjoy the party?', or 'If Biden runs, will he win?', markets should resolve N/A if the precondition is not met\n        - Format the response as markdown\n        - Also include a \"Background\" section that includes information readers/traders may want to know if it's relevant to the user's question AND it's not common knowledge. Keep it concise.\n        - Only include a \"Considerations\" section if there are unexpected considerations that traders may want to know about. E.g. if the question is about something that has never happened before, etc. ${\n          addAnswersMode === 'DISABLED' &&\n          outcomeKey === 'DEPENDENT_MULTIPLE_CHOICE'\n            ? 'E.g. if the answers are not exhaustive, traders should be warned that the market may resolve N/A.'\n            : ''\n        }\n        - Format each separate section with a #### header\n        - Use your web search tool to gather relevant, up-to-date information related to the user's prompt to inform the description if necesaary. Include information from it in the description that traders or other readers may want to know if it's relevant to the user's question, but keep it concise.\n\n        User's prompt:\n        ${userQuestionAndDescription}\n\n        Only return the markdown description, nothing else.\n        `\n        const gptResponse = await promptOpenAIWithWebSearch(prompt)\n\n        track(auth.uid, 'generate-ai-description', {\n          question: question.substring(0, 100),\n          hasExistingDescription: !!description,\n        })\n\n        return { description: anythingToRichText({ markdown: gptResponse }) }\n      } catch (e) {\n        log.error('Failed to generate description:', { e })\n        throw new APIError(\n          500,\n          'Failed to generate description. Please try again.'\n        )\n      }\n    },\n    { maxCalls: 60, windowMs: HOUR_MS }\n  )\n"
        },
        {
          "path": "common/src/ai-creation-prompts.ts",
          "preContent": "import { MONTH_MS } from './util/time'\n\nexport const guidelinesPrompt = `\nA prediction market is a contract that users can trade based on the likelihood of future events. \nUsers buy and sell shares based on their forecasts, with prices reflecting the crowd's collective prediction of how likely an event is to occur.\nMarkets resolve when the outcome is known, with winning positions paying out.\nThe user is interested in creating prediction markets on Manifold, and has asked you for help coming up with market ideas.\n\nWhen designing market suggestions for the user, follow these guidelines:\nEVIDENCE-BASED\n- Markets must be directly related to user's interest and include sources about the topic\n- Focus on natural next steps or developments based on information from relevant sources\n- Avoid markets where one outcome is overwhelmingly likely/unlikely right now\n\nQUICK RESOLUTION (unless otherwise specified by the user)\n- Try to include at least one market that resolves by ${new Date(\n  Date.now() + 1 * MONTH_MS\n).toLocaleDateString('en-US', {\n  year: 'numeric',\n  month: 'long',\n  day: 'numeric',\n})}, unless the user specifies a date that is later\n- At least half of the markets should resolve no later than ${new Date(\n  Date.now() + 3 * MONTH_MS\n).toLocaleDateString('en-US', {\n  year: 'numeric',\n  month: 'long',\n  day: 'numeric',\n})}, unless the user specifies a date that is later\n- None of the markets should resolve later than ${new Date(\n  Date.now() + 6 * MONTH_MS\n).toLocaleDateString('en-US', {\n  year: 'numeric',\n  month: 'long',\n  day: 'numeric',\n})}, unless the user specifies a date that is later\n- Prioritize markets that resolve sooner, using leading indicators when possible, ie stock performance of a company upon earliest possible news release, etc.\n- When possible, include markets with known, upcoming resolution dates, i.e. elections, sports events, sentencing/court dates, etc. as long as they are not too far in the future.\n- Be sure to include 'before [date]' or 'on [event]' in the title\n\nCLEAR, EASY-TO-VERIFY RESOLUTION CRITERIA\n- Markets should have unambiguous outcomes\n- Ideally suggestions should include sources that users can visit and easily see the outcome when it comes time to resolve the market\n- Use specific resolution criteria and trusted sources when crafting the market suggestions\n- Include links to sources for resolution criteria, being as specific as possible, i.e. \"Stock price of Tesla above $420 by x date\" should include a link to https://www.marketwatch.com/investing/stock/tsla and not just https://www.marketwatch.com/\n- Prioritize resolution source links that are easy for users to find their answer at\n- Avoid subjective or feeling-based outcomes unless prompted by the user\n- Avoid situations that resolve N/A, which cancels all trades because a precondition is not met\n\nMULTIPLE CHOICE MARKETS\n- If a market is about a number, range of dates, or other options, include an answers array that includes reasonable options based on the news article/surrounding context.\n- I.e. for a question like \"How many US states will face historic drought conditions by December 31?\", include an answers array that seems reasonable from the context.\n\nPERSONAL QUESTIONS\n- It's possible the user is looking for advice, i.e. their prompt includes the word \"should\" in it, like \"Should I move to a new city?\", \"Should I get a new job?\", etc., in which case the outcome should be \"POLL\"\n  - \"POLL\" outcomes require an answers array for users to vote on, and resolve automatically on the close date based on votes, rather than trades.\n- If a question is about events closely related to the user, the question and description should be worded from the creator's point of view, i.e. 'I move to Colorado by August 1st 2025', 'I get a new job by December 31st 2025', etc.\n- Personal questions may still be markets (i.e. non-POLL outcomes) if they have clear resolution criteria and are not based on opinions.\n\nFollowing each market suggestion, add a \"Reasoning:\" section that addresses the following points:\n1. A clear explanation of why this market follows from the user's prompt and related source material\n2. Why it's a good prediction market (e.g., has clear resolution criteria, neither a yes nor no outcome is overwhelmingly likely, etc. from above)\n`\n\nexport const multiChoiceOutcomeTypeDescriptions = `\n- \"INDEPENDENT_MULTIPLE_CHOICE\" means there are multiple answers, and ANY of them can resolve yes, no, or N/A e.g. What will happen during the next presidential debate? Which companies will express interest in buying twitter?\n- \"DEPENDENT_MULTIPLE_CHOICE\" means there are multiple answers, but ONLY one can resolve yes, (while the rest resolve no, or alternatively the entire market resolves N/A if a precondition is not met) e.g. Who will win the presidential election?, Who will be the first to express interest in buying twitter?\n`\n\nexport const outcomeTypeDescriptions = `\n- \"BINARY\" means there are only two answers, true (yes) or false (no)\n${multiChoiceOutcomeTypeDescriptions}\n- \"POLL\" means the question is about a personal matter, i.e. \"Should I move to a new city?\", \"Should I get a new job?\", etc.\n `\nexport const addAnswersModeDescription = `\n- \"DISABLED\" means that the answers list covers all possible outcomes and no more answers can be added after the market is created\n- \"ONLY_CREATOR\" means that only the creator can add answers after the market is created\n- \"ANYONE\" means that anyone can add answers after the market is created\n- If the addAnswersMode is \"ONLY_CREATOR\" or \"ANYONE\", while the outcomeType is \"DEPENDENT_MULTIPLE_CHOICE\", then Manifold will automatically add the 'Other' option to the answers list, so you do not need to include it in the array.\n`\n\nexport const formattingPrompt = `\n    Convert these prediction market ideas into valid JSON objects that abide by the following Manifold Market schema. Each object should include:\n    - question (string with 120 characters or less, required)\n      - Question should be worded as a statement, i.e. Stock price of Tesla above $420 by x date, not Will the stock price of Tesla be above $420 by x date?\n    - descriptionMarkdown (markdown string, required)\n      - The description should be a concise summary of the market's context, possible outcomes, sources, and resolution criteria.\n    - closeDate (string, date in YYYY-MM-DD format, required)\n      - The close date is when trading stops for the market, and resolution can be made. E.g. if the title includes 'by january 1st 2025', the close date should be 2025-12-31\n    - outcomeType (\"BINARY\", \"INDEPENDENT_MULTIPLE_CHOICE\", \"DEPENDENT_MULTIPLE_CHOICE\", \"POLL\", required)\n      ${outcomeTypeDescriptions}\n    - answers (array of strings, recommended only if outcomeType is one of the \"DEPENDENT_MULTIPLE_CHOICE\" or \"INDEPENDENT_MULTIPLE_CHOICE\" types)\n    - addAnswersMode (\"DISABLED\", \"ONLY_CREATOR\", or \"ANYONE\", required if one of the \"DEPENDENT_MULTIPLE_CHOICE\" or \"INDEPENDENT_MULTIPLE_CHOICE\" types is provided)\n      ${addAnswersModeDescription}\n    - reasoning (string, required - extract the reasoning section from each market suggestion)`\n\nexport const perplexitySystemPrompt = `You are a helpful assistant that creates engaging prediction markets on Manifold Markets.\nYour role is to transform a user's prompt into at least approximately 6 well-structured prediction markets that encourage participation and meaningful forecasting.\n`\nexport const claudeSystemPrompt = `You are a helpful assistant that refines and converts market ideas into valid JSON objects following Manifold's schema. ONLY return a valid JSON array of market objects.`\n",
          "postContent": "import { MONTH_MS } from './util/time'\n\nexport const resolutionCriteriaPrompt = `\nCLEAR, EASY-TO-VERIFY RESOLUTION CRITERIA\n- Markets ideally have unambiguous resolution criteria\n- Ideally resolution criteria include sources that users can visit and easily see the outcome when it comes time to resolve the market\n- Include links to sources for resolution criteria, being as specific as possible, i.e. \"Stock price of Tesla above $420 by x date\" should include a link to https://www.marketwatch.com/investing/stock/tsla and not just https://www.marketwatch.com/\n- Prioritize resolution links that are easy for users to find their answer at\n- Avoid subjective or feeling-based outcomes unless prompted by the user\n- In the resolution criteria, include edge cases if they are particularly likely. Otherwise, the criteria should be concise and to the point, allowing the creator and traders to use common sense to resolve edge cases.\n- Avoid situations that resolve N/A, which cancels all trades because a precondition is not met\n- Markets do NOT resolve via 'votes'. If you can't come up with good, objective resollution criteria you have two options:\n1. Markets resolve to a poll that other users vote on. This is the preferred option and makes sense for subjective questions.\n2. Markets resolve to the user's opinion if their question title includes the first person, like which option will I prefer, or how will I feel about the event/news/thing.\n`\n\nexport const guidelinesPrompt = `\nA prediction market is a contract that users can trade based on the likelihood of future events. \nUsers buy and sell shares based on their forecasts, with prices reflecting the crowd's collective prediction of how likely an event is to occur.\nMarkets resolve when the outcome is known, with winning positions paying out.\nThe user is interested in creating prediction markets on Manifold, and has asked you for help coming up with market ideas.\n\nWhen designing market suggestions for the user, follow these guidelines:\nEVIDENCE-BASED\n- Markets must be directly related to user's interest and include sources about the topic\n- Focus on natural next steps or developments based on information from relevant sources\n- Avoid markets where one outcome is overwhelmingly likely/unlikely right now\n\nQUICK RESOLUTION (unless otherwise specified by the user)\n- Try to include at least one market that resolves by ${new Date(\n  Date.now() + 1 * MONTH_MS\n).toLocaleDateString('en-US', {\n  year: 'numeric',\n  month: 'long',\n  day: 'numeric',\n})}, unless the user specifies a date that is later\n- At least half of the markets should resolve no later than ${new Date(\n  Date.now() + 3 * MONTH_MS\n).toLocaleDateString('en-US', {\n  year: 'numeric',\n  month: 'long',\n  day: 'numeric',\n})}, unless the user specifies a date that is later\n- None of the markets should resolve later than ${new Date(\n  Date.now() + 6 * MONTH_MS\n).toLocaleDateString('en-US', {\n  year: 'numeric',\n  month: 'long',\n  day: 'numeric',\n})}, unless the user specifies a date that is later\n- Prioritize markets that resolve sooner, using leading indicators when possible, ie stock performance of a company upon earliest possible news release, etc.\n- When possible, include markets with known, upcoming resolution dates, i.e. elections, sports events, sentencing/court dates, etc. as long as they are not too far in the future.\n- Be sure to include 'before [date]' or 'on [event]' in the title\n\n${resolutionCriteriaPrompt}\n\nMULTIPLE CHOICE MARKETS\n- If a market is about a number, range of dates, or other options, include an answers array that includes reasonable options based on the news article/surrounding context.\n- I.e. for a question like \"How many US states will face historic drought conditions by December 31?\", include an answers array that seems reasonable from the context.\n\nPERSONAL QUESTIONS\n- It's possible the user is looking for advice, i.e. their prompt includes the word \"should\" in it, like \"Should I move to a new city?\", \"Should I get a new job?\", etc., in which case the outcome should be \"POLL\"\n  - \"POLL\" outcomes require an answers array for users to vote on, and resolve automatically on the close date based on votes, rather than trades.\n- If a question is about events closely related to the user, the question and description should be worded from the creator's point of view, i.e. 'I move to Colorado by August 1st 2025', 'I get a new job by December 31st 2025', etc.\n- Personal questions may still be markets (i.e. non-POLL outcomes) if they have clear resolution criteria and are not based on opinions.\n`\n\nexport const multiChoiceOutcomeTypeDescriptions = `\n- \"INDEPENDENT_MULTIPLE_CHOICE\" means there are multiple answers, and ANY of them can resolve yes, no, or N/A e.g. What will happen during the next presidential debate? Which companies will express interest in buying twitter?\n- \"DEPENDENT_MULTIPLE_CHOICE\" means there are multiple answers, but ONLY one can resolve yes, (while the rest resolve no, or alternatively the entire market resolves N/A if a precondition is not met) e.g. Who will win the presidential election?, Who will be the first to express interest in buying twitter?\n`\n\nexport const outcomeTypeDescriptions = `\n- \"BINARY\" means there are only two answers, true (yes) or false (no)\n${multiChoiceOutcomeTypeDescriptions}\n- \"POLL\" means the question is about a personal matter, i.e. \"Should I move to a new city?\", \"Should I get a new job?\", etc.\n `\nexport const addAnswersModeDescription = `\n- \"DISABLED\" means that the answers list covers all possible outcomes and no more answers can be added after the market is created\n- \"ONLY_CREATOR\" means that only the creator can add answers after the market is created\n- \"ANYONE\" means that anyone can add answers after the market is created\n- If the addAnswersMode is \"ONLY_CREATOR\" or \"ANYONE\", while the outcomeType is \"DEPENDENT_MULTIPLE_CHOICE\", then Manifold will automatically add the 'Other' option to the answers list, so you do not need to include it in the array.\n`\n\nexport const formattingPrompt = `\n    Convert these prediction market ideas into valid JSON objects that abide by the following Manifold Market schema. Each object should include:\n    - question (string with 120 characters or less, required)\n      - Question should be worded as a statement, i.e. Stock price of Tesla above $420 by x date, not Will the stock price of Tesla be above $420 by x date?\n    - descriptionMarkdown (markdown string, required)\n      - The description should be a concise summary of the market's context, possible outcomes, sources, and resolution criteria.\n    - closeDate (string, date in YYYY-MM-DD format, required)\n      - The close date is when trading stops for the market, and resolution can be made. E.g. if the title includes 'by january 1st 2025', the close date should be 2025-12-31\n    - outcomeType (\"BINARY\", \"INDEPENDENT_MULTIPLE_CHOICE\", \"DEPENDENT_MULTIPLE_CHOICE\", \"POLL\", required)\n      ${outcomeTypeDescriptions}\n    - answers (array of strings, recommended only if outcomeType is one of the \"DEPENDENT_MULTIPLE_CHOICE\" or \"INDEPENDENT_MULTIPLE_CHOICE\" types)\n    - addAnswersMode (\"DISABLED\", \"ONLY_CREATOR\", or \"ANYONE\", required if one of the \"DEPENDENT_MULTIPLE_CHOICE\" or \"INDEPENDENT_MULTIPLE_CHOICE\" types is provided)\n      ${addAnswersModeDescription}\n    - reasoning (string, required - extract the reasoning section from each market suggestion)`\n\nexport const perplexitySystemPrompt = `You are a helpful assistant that creates engaging prediction markets on Manifold Markets.\nYour role is to transform a user's prompt into at least approximately 6 well-structured prediction markets that encourage participation and meaningful forecasting.\n`\nexport const claudeSystemPrompt = `You are a helpful assistant that refines and converts market ideas into valid JSON objects following Manifold's schema. ONLY return a valid JSON array of market objects.`\n"
        }
      ]
    },
    {
      "sha": "f6b7d992b1695c64c6e799eba3d0608d087ce753",
      "author": "Ian Philips",
      "date": "2025-05-08 17:06:42 -0700",
      "message": "Dismiss reports button",
      "stats": {
        "filesChanged": 7,
        "insertions": 87,
        "deletions": 3
      },
      "selectionReason": "Adds dismiss reports functionality for moderation - implements admin/moderation features with UI components",
      "spec": "Implement functionality for administrators and moderators to dismiss user reports. This requires:\n1. A mechanism to mark a specific user report as 'dismissed', including recording which administrator or moderator performed the dismissal.\n2. Ensuring that the primary view of user reports (e.g., in an admin panel) only displays reports that have not been dismissed.\n3. Providing an interface element (e.g., a button) on individual user reports, accessible only to administrators and moderators, that triggers the dismissal action for that report. Upon successful dismissal, the report should be removed from the active reports view.",
      "fileStates": [
        {
          "path": "backend/api/src/dismiss-user-report.ts",
          "preContent": "[NEW FILE]",
          "postContent": "import { isAdminId, isModId } from 'common/envs/constants'\nimport { APIError, APIHandler } from './helpers/endpoint'\nimport { createSupabaseDirectClient } from 'shared/supabase/init'\n\nexport const dismissUserReport: APIHandler<'dismiss-user-report'> = async (\n  props,\n  auth\n) => {\n  if (!isAdminId(auth.uid) && !isModId(auth.uid)) {\n    throw new APIError(403, 'Only admins can dismiss user reports.')\n  }\n\n  const { reportId } = props\n\n  const db = createSupabaseDirectClient()\n\n  try {\n    await db.none(\n      'UPDATE reports SET dismissed_by_user_id = $1 WHERE id = $2',\n      [auth.uid, reportId]\n    )\n  } catch (err) {\n    // Log the error and throw an APIError\n    console.error(`Error dismissing report ${reportId}:`, err)\n    if (err instanceof Error) {\n      throw new APIError(500, `Failed to dismiss report: ${err.message}`)\n    }\n    throw new APIError(500, 'Failed to dismiss report due to an unknown error')\n  }\n\n  return { success: true }\n}\n"
        },
        {
          "path": "backend/api/src/routes.ts",
          "preContent": "import { updateMe } from './update-me'\nimport { placeBet } from './place-bet'\nimport { cancelBet } from './cancel-bet'\nimport { sellShares } from './sell-shares'\nimport { createMarket } from './create-market'\nimport { createComment } from './create-comment'\nimport { resolveMarket } from './resolve-market'\nimport { closeMarket } from './close-market'\nimport { getMe } from './get-me'\nimport { saveTwitchCredentials } from './save-twitch-credentials'\nimport { addLiquidity } from './add-liquidity'\nimport { removeLiquidity } from './remove-liquidity'\nimport { searchGroups, searchMyGroups } from './search-groups'\nimport { awardBounty } from './award-bounty'\nimport { addBounty } from './add-bounty'\nimport { createAnswerCPMM } from './create-answer-cpmm'\nimport { managram } from './managram'\nimport { setnews } from './set-news'\nimport { getDashboardFromSlug } from './get-dashboard-from-slug'\nimport { unresolve } from './unresolve'\nimport { updateMarket } from 'api/update-market'\nimport { getCompatibleLovers } from './love/compatible-lovers'\nimport { type APIPath } from 'common/api/schema'\nimport { getMarkets } from 'api/markets'\nimport { hideComment } from './hide-comment'\nimport { pinComment } from './pin-comment'\nimport { getManagrams } from './get-managrams'\nimport { getGroups } from './get-groups'\nimport { getComments } from './get-comments'\nimport { getBetPointsBetween, getBets } from './get-bets'\nimport { getLiteUser, getUser } from './get-user'\nimport { getUsers } from './get-users'\nimport { getUserBalancesByIds, getUsersByIds } from './get-users-by-ids'\nimport { getMarket } from './get-market'\nimport { getMarketProb } from './get-market-prob'\nimport { getMarketProbs } from './get-market-probs'\nimport { getGroup } from './get-group'\nimport { getPositions } from './get-positions'\nimport { getLeagues } from './get-leagues'\nimport { getContract } from './get-contract'\nimport { getSingleAnswer } from './get-answer'\nimport { getContractAnswers } from './get-contract-answers'\nimport { addOrRemoveTopicFromContract } from './add-topic-to-market'\nimport { addOrRemoveTopicFromTopic } from './add-topic-to-topic'\nimport { searchUsers } from './search-users'\nimport { searchMarketsLite, searchMarketsFull } from './search-contracts'\nimport { post } from 'api/post'\nimport { fetchLinkPreview } from './fetch-link-preview'\nimport { type APIHandler } from './helpers/endpoint'\nimport { requestLoan } from 'api/request-loan'\nimport { removePinnedPhoto } from './love/remove-pinned-photo'\nimport { getHeadlines, getPoliticsHeadlines } from './get-headlines'\nimport { getBoostAnalytics } from 'api/get-boost-analytics'\nimport { getCompatibilityQuestions } from './love/get-compatibililty-questions'\nimport { addOrRemoveReaction } from './reaction'\nimport { likeLover } from './love/like-lover'\nimport { shipLovers } from './love/ship-lovers'\nimport { createManalink } from './create-manalink'\nimport { getLikesAndShips } from './love/get-likes-and-ships'\nimport { hasFreeLike } from './love/has-free-like'\nimport { starLover } from './love/star-lover'\nimport { getLovers } from './love/get-lovers'\nimport { unlistAndCancelUserContracts } from './unlist-and-cancel-user-contracts'\nimport { getGroupsWithTopContracts } from 'api/get-topics-with-markets'\nimport { getBalanceChanges } from 'api/get-balance-changes'\nimport { getLoverAnswers } from './love/get-lover-answers'\nimport { placeMultiBet } from 'api/place-multi-bet'\nimport { getPartnerStats } from './get-partner-stats'\nimport { getSeenMarketIds } from 'api/get-seen-market-ids'\nimport { recordContractView } from 'api/record-contract-view'\nimport { createPublicChatMessage } from 'api/create-public-chat-message'\nimport { getFollowedGroups } from './get-followed-groups'\nimport { getUniqueBetGroupCount } from 'api/get-unique-bet-groups'\nimport { deleteGroup } from './delete-group'\nimport { recordContractInteraction } from 'api/record-contract-interaction'\nimport { getUserPortfolio } from './get-user-portfolio'\nimport { createuser } from 'api/create-user'\nimport { verifyPhoneNumber } from 'api/verify-phone-number'\nimport { requestOTP } from 'api/request-phone-otp'\nimport { multiSell } from 'api/multi-sell'\nimport { convertCashToMana } from './convert-cash-to-mana'\nimport { convertSpiceToMana } from './convert-sp-to-mana'\nimport { donate } from './donate'\nimport { getFeed } from 'api/get-feed'\nimport { getManaSupply } from './get-mana-supply'\nimport { getUserPortfolioHistory } from './get-user-portfolio-history'\nimport { deleteMe } from './delete-me'\nimport { updateModReport } from './update-mod-report'\nimport { getModReports } from './get-mod-reports'\nimport { searchContractPositions } from 'api/search-contract-positions'\nimport { blockUser, unblockUser } from './block-user'\nimport { blockGroup, unblockGroup } from './block-group'\nimport { blockMarket, unblockMarket } from './block-market'\nimport { getTxnSummaryStats } from 'api/get-txn-summary-stats'\nimport { getManaSummaryStats } from 'api/get-mana-summary-stats'\nimport { register } from 'api/gidx/register'\nimport { uploadDocument } from 'api/gidx/upload-document'\nimport { identityCallbackGIDX, paymentCallbackGIDX } from 'api/gidx/callback'\nimport { getVerificationStatus } from 'api/gidx/get-verification-status'\nimport { getCurrentPrivateUser } from './get-current-private-user'\nimport { updatePrivateUser } from './update-private-user'\nimport { setPushToken } from './push-token'\nimport { updateNotifSettings } from './update-notif-settings'\nimport { getVerificationDocuments } from 'api/gidx/get-verification-documents'\nimport { getRedeemablePrizeCash } from './get-redeemable-prize-cash'\nimport { getTotalRedeemablePrizeCash } from './get-total-redeemable-prize-cash'\nimport { getMonitorStatus } from 'api/gidx/get-monitor-status'\nimport { getBestComments } from 'api/get-best-comments'\nimport { recordCommentView } from 'api/record-comment-view'\nimport {\n  getChannelMemberships,\n  getChannelMessages,\n  getLastSeenChannelTime,\n  setChannelLastSeenTime,\n} from 'api/get-private-messages'\nimport { getNotifications } from 'api/get-notifications'\nimport { getCheckoutSession } from 'api/gidx/get-checkout-session'\nimport { completeCheckoutSession } from 'api/gidx/complete-checkout-session'\nimport { getContractTopics } from './get-contract-topics'\nimport { getRelatedMarkets } from './get-related-markets'\nimport { getRelatedMarketsByGroup } from './get-related-markets-by-group'\nimport { followContract } from './follow-contract'\nimport { getUserLimitOrdersWithContracts } from 'api/get-user-limit-orders-with-contracts'\nimport { getInterestingGroupsFromViews } from 'api/get-interesting-groups-from-views'\nimport { completeCashoutSession } from 'api/gidx/complete-cashout-session'\nimport { getCashouts } from './get-cashouts'\nimport { getKYCStats } from './get-kyc-stats'\nimport { getTxns } from './get-txns'\nimport { refreshAllClients } from './refresh-all-clients'\nimport { getLeaderboard } from './get-leaderboard'\nimport { toggleSystemTradingStatus } from './toggle-system-status'\nimport { completeCashoutRequest } from './gidx/complete-cashout-request'\nimport { getDailyChangedMetricsAndContracts } from './get-daily-changed-metrics-and-contracts'\nimport { getMarketsByIds } from './get-markets'\nimport { getTopicTopics } from './get-topic-topics'\nimport { getTopicDashboards } from './get-topic-dashboards'\nimport { generateAIMarketSuggestions } from './generate-ai-market-suggestions'\nimport { generateAIMarketSuggestions2 } from './generate-ai-market-suggestions-2'\nimport { generateAIDescription } from './generate-ai-description'\nimport { generateAIAnswers } from './generate-ai-answers'\nimport { getmonthlybets2024 } from './get-monthly-bets-2024'\nimport { getmaxminprofit2024 } from './get-max-min-profit-2024'\nimport { getNextLoanAmount } from './get-next-loan-amount'\nimport { checkSportsEvent } from './check-sports-event'\n\nimport { createTask } from './create-task'\nimport { updateTask } from './update-task'\nimport { createCategory } from './create-category'\nimport { getCategories } from './get-categories'\nimport { updateCategory } from './update-category'\nimport { getTasks } from './get-tasks'\n\nimport { getSiteActivity } from './get-site-activity'\nimport { isSportsInterested } from './is-sports-bettor'\nimport { getSportsGames } from './get-sports-games'\nimport { getMarketProps } from './get-market-props'\nimport { getUserContractMetricsWithContracts } from './get-user-contract-metrics-with-contracts'\nimport { validateiap } from './validate-iap'\nimport { getReactions } from './get-reactions'\nimport { markallnotificationsnew } from './mark-all-notifications-new'\nimport {\n  getContractOptionVoters,\n  getContractVoters,\n} from './get-contract-voters'\nimport { purchaseContractBoost } from './purchase-contract-boost'\nimport {\n  generateAINumericRanges,\n  regenerateNumericMidpoints,\n} from './generate-ai-numeric-ranges'\nimport {\n  generateAIDateRanges,\n  regenerateDateMidpoints,\n} from './generate-ai-date-ranges'\nimport { inferNumericUnit } from './infer-numeric-unit'\nimport { generateConciseTitle } from './generate-concise-title'\nimport { getCloseDateEndpoint } from './get-close-date'\nimport { referUser } from './refer-user'\nimport {\n  saveMarketDraft,\n  getMarketDrafts,\n  deleteMarketDraft,\n} from './market-drafts'\nimport { getSeasonInfo } from './get-season-info'\nimport { markNotificationRead } from './mark-all-notifications'\nimport { createPostComment, updatePostComment } from './create-post-comment'\nimport { createPost, updatePost } from './create-post'\nimport { getPosts } from './get-posts'\n\nexport const handlers: { [k in APIPath]: APIHandler<k> } = {\n  'refresh-all-clients': refreshAllClients,\n  bet: placeBet,\n  'multi-bet': placeMultiBet,\n  'follow-contract': followContract,\n  'bet/cancel/:betId': cancelBet,\n  'market/:contractId/sell': sellShares,\n  bets: getBets,\n  'bet-points': getBetPointsBetween,\n  'get-notifications': getNotifications,\n  'get-channel-memberships': getChannelMemberships,\n  'get-channel-messages': getChannelMessages,\n  'get-channel-seen-time': getLastSeenChannelTime,\n  'set-channel-seen-time': setChannelLastSeenTime,\n  'get-contract': getContract,\n  comment: createComment,\n  'hide-comment': hideComment,\n  'pin-comment': pinComment,\n  comments: getComments,\n  market: createMarket,\n  'market/:contractId/group': addOrRemoveTopicFromContract,\n  'market/:contractId/groups': getContractTopics,\n  'group/:slug': getGroup,\n  'group/by-id/:id': getGroup,\n  'group/by-id/:id/markets': ({ id, limit }, ...rest) =>\n    getMarkets({ groupId: id, limit }, ...rest),\n  'group/:slug/delete': deleteGroup,\n  'group/by-id/:id/delete': deleteGroup,\n  'group/:slug/block': blockGroup,\n  'group/:slug/unblock': unblockGroup,\n  'group/by-id/:topId/group/:bottomId': addOrRemoveTopicFromTopic,\n  'group/:slug/groups': getTopicTopics,\n  'group/:slug/dashboards': getTopicDashboards,\n  'group/by-id/:id/groups': getTopicTopics,\n  groups: getGroups,\n  'market/:id': getMarket,\n  'market/:id/lite': ({ id }) => getMarket({ id, lite: true }),\n  'market/:id/prob': getMarketProb,\n  'market-probs': getMarketProbs,\n  'answer/:answerId': getSingleAnswer,\n  'market/:contractId/answers': getContractAnswers,\n  'markets-by-ids': getMarketsByIds,\n  'slug/:slug': getMarket,\n  'market/:contractId/update': updateMarket,\n  'market/:contractId/close': closeMarket,\n  'market/:contractId/resolve': resolveMarket,\n  'market/:contractId/add-liquidity': addLiquidity,\n  'market/:contractId/remove-liquidity': removeLiquidity,\n  'market/:contractId/add-bounty': addBounty,\n  'market/:contractId/award-bounty': awardBounty,\n  'market/:contractId/answer': createAnswerCPMM,\n  'market/:contractId/block': blockMarket,\n  'market/:contractId/unblock': unblockMarket,\n  'get-user-limit-orders-with-contracts': getUserLimitOrdersWithContracts,\n  'get-interesting-groups-from-views': getInterestingGroupsFromViews,\n  leagues: getLeagues,\n  markets: getMarkets,\n  'search-markets': searchMarketsLite,\n  'search-markets-full': searchMarketsFull,\n  managram: managram,\n  managrams: getManagrams,\n  manalink: createManalink,\n  donate: donate,\n  'convert-cash-to-mana': convertCashToMana,\n  'convert-sp-to-mana': convertSpiceToMana,\n  'market/:id/positions': getPositions,\n  me: getMe,\n  'me/update': updateMe,\n  'me/delete': deleteMe,\n  'me/private': getCurrentPrivateUser,\n  'me/private/update': updatePrivateUser,\n  'user/by-id/:id': getUser,\n  'user/by-id/:id/lite': getLiteUser,\n  'user/:username': getUser,\n  'user/:username/lite': getLiteUser,\n  'user/:username/bets': (...props) => getBets(...props),\n  'user/by-id/:id/block': blockUser,\n  'user/by-id/:id/unblock': unblockUser,\n  users: getUsers,\n  'users/by-id': getUsersByIds,\n  'users/by-id/balance': getUserBalancesByIds,\n  'search-users': searchUsers,\n  react: addOrRemoveReaction,\n  'save-twitch': saveTwitchCredentials,\n  'set-push-token': setPushToken,\n  'update-notif-settings': updateNotifSettings,\n  headlines: getHeadlines,\n  'politics-headlines': getPoliticsHeadlines,\n  'compatible-lovers': getCompatibleLovers,\n  post: post,\n  'fetch-link-preview': fetchLinkPreview,\n  'request-loan': requestLoan,\n  'remove-pinned-photo': removePinnedPhoto,\n  'get-related-markets': getRelatedMarkets,\n  'get-related-markets-by-group': getRelatedMarketsByGroup,\n  'unlist-and-cancel-user-contracts': unlistAndCancelUserContracts,\n  'get-boost-analytics': getBoostAnalytics,\n  'get-compatibility-questions': getCompatibilityQuestions,\n  'like-lover': likeLover,\n  'ship-lovers': shipLovers,\n  'get-likes-and-ships': getLikesAndShips,\n  'has-free-like': hasFreeLike,\n  'star-lover': starLover,\n  'get-lovers': getLovers,\n  'get-lover-answers': getLoverAnswers,\n  'set-news': setnews,\n  'search-groups': searchGroups,\n  'search-my-groups': searchMyGroups,\n  'get-groups-with-top-contracts': getGroupsWithTopContracts,\n  'get-balance-changes': getBalanceChanges,\n  'get-partner-stats': getPartnerStats,\n  'get-posts': getPosts,\n  'get-seen-market-ids': getSeenMarketIds,\n  'record-contract-view': recordContractView,\n  'get-dashboard-from-slug': getDashboardFromSlug,\n  'create-public-chat-message': createPublicChatMessage,\n  unresolve: unresolve,\n  'get-followed-groups': getFollowedGroups,\n  'unique-bet-group-count': getUniqueBetGroupCount,\n  'record-contract-interaction': recordContractInteraction,\n  'get-user-portfolio': getUserPortfolio,\n  'get-user-portfolio-history': getUserPortfolioHistory,\n  createuser: createuser,\n  'verify-phone-number': verifyPhoneNumber,\n  'request-otp': requestOTP,\n  'multi-sell': multiSell,\n  'get-feed': getFeed,\n  'get-mana-supply': getManaSupply,\n  'update-mod-report': updateModReport,\n  'get-mod-reports': getModReports,\n  'search-contract-positions': searchContractPositions,\n  'get-txn-summary-stats': getTxnSummaryStats,\n  'get-mana-summary-stats': getManaSummaryStats,\n  'register-gidx': register,\n  'get-checkout-session-gidx': getCheckoutSession,\n  'complete-checkout-session-gidx': completeCheckoutSession,\n  'complete-cashout-session-gidx': completeCashoutSession,\n  'complete-cashout-request': completeCashoutRequest,\n  'get-verification-status-gidx': getVerificationStatus,\n  'upload-document-gidx': uploadDocument,\n  'identity-callback-gidx': identityCallbackGIDX,\n  'payment-callback-gidx': paymentCallbackGIDX,\n  'get-verification-documents-gidx': getVerificationDocuments,\n  'get-redeemable-prize-cash': getRedeemablePrizeCash,\n  'get-total-redeemable-prize-cash': getTotalRedeemablePrizeCash,\n  'get-monitor-status-gidx': getMonitorStatus,\n  'get-best-comments': getBestComments,\n  'record-comment-view': recordCommentView,\n  'get-cashouts': getCashouts,\n  'get-kyc-stats': getKYCStats,\n  txns: getTxns,\n  'toggle-system-trading-status': toggleSystemTradingStatus,\n  leaderboard: getLeaderboard,\n  'get-daily-changed-metrics-and-contracts': getDailyChangedMetricsAndContracts,\n  'generate-ai-market-suggestions': generateAIMarketSuggestions,\n  'generate-ai-market-suggestions-2': generateAIMarketSuggestions2,\n  'generate-ai-description': generateAIDescription,\n  'generate-ai-answers': generateAIAnswers,\n  'get-monthly-bets-2024': getmonthlybets2024,\n  'get-max-min-profit-2024': getmaxminprofit2024,\n  'get-next-loan-amount': getNextLoanAmount,\n  'check-sports-event': checkSportsEvent,\n  'create-task': createTask,\n  'update-task': updateTask,\n  'create-category': createCategory,\n  'get-categories': getCategories,\n  'update-category': updateCategory,\n  'get-tasks': getTasks,\n  'get-site-activity': getSiteActivity,\n  'is-sports-interested': isSportsInterested,\n  'get-sports-games': getSportsGames,\n  'get-market-props': getMarketProps,\n  'get-user-contract-metrics-with-contracts':\n    getUserContractMetricsWithContracts,\n  validateIap: validateiap,\n  'comment-reactions': getReactions,\n  'mark-all-notifications-new': markallnotificationsnew,\n  'get-contract-voters': getContractVoters,\n  'get-contract-option-voters': getContractOptionVoters,\n  'purchase-contract-boost': purchaseContractBoost,\n  'generate-ai-numeric-ranges': generateAINumericRanges,\n  'regenerate-numeric-midpoints': regenerateNumericMidpoints,\n  'infer-numeric-unit': inferNumericUnit,\n  'generate-ai-date-ranges': generateAIDateRanges,\n  'regenerate-date-midpoints': regenerateDateMidpoints,\n  'generate-concise-title': generateConciseTitle,\n  'get-close-date': getCloseDateEndpoint,\n  'refer-user': referUser,\n  'create-post-comment': createPostComment,\n  'create-post': createPost,\n  'update-post': updatePost,\n  'update-post-comment': updatePostComment,\n  'save-market-draft': saveMarketDraft,\n  'get-market-drafts': getMarketDrafts,\n  'delete-market-draft': deleteMarketDraft,\n  'get-season-info': getSeasonInfo,\n  'mark-notification-read': markNotificationRead,\n} as const\n",
          "postContent": "import { updateMe } from './update-me'\nimport { placeBet } from './place-bet'\nimport { cancelBet } from './cancel-bet'\nimport { sellShares } from './sell-shares'\nimport { createMarket } from './create-market'\nimport { createComment } from './create-comment'\nimport { resolveMarket } from './resolve-market'\nimport { closeMarket } from './close-market'\nimport { getMe } from './get-me'\nimport { saveTwitchCredentials } from './save-twitch-credentials'\nimport { addLiquidity } from './add-liquidity'\nimport { removeLiquidity } from './remove-liquidity'\nimport { searchGroups, searchMyGroups } from './search-groups'\nimport { awardBounty } from './award-bounty'\nimport { addBounty } from './add-bounty'\nimport { createAnswerCPMM } from './create-answer-cpmm'\nimport { managram } from './managram'\nimport { setnews } from './set-news'\nimport { getDashboardFromSlug } from './get-dashboard-from-slug'\nimport { unresolve } from './unresolve'\nimport { updateMarket } from 'api/update-market'\nimport { getCompatibleLovers } from './love/compatible-lovers'\nimport { type APIPath } from 'common/api/schema'\nimport { getMarkets } from 'api/markets'\nimport { hideComment } from './hide-comment'\nimport { pinComment } from './pin-comment'\nimport { getManagrams } from './get-managrams'\nimport { getGroups } from './get-groups'\nimport { getComments } from './get-comments'\nimport { getBetPointsBetween, getBets } from './get-bets'\nimport { getLiteUser, getUser } from './get-user'\nimport { getUsers } from './get-users'\nimport { getUserBalancesByIds, getUsersByIds } from './get-users-by-ids'\nimport { getMarket } from './get-market'\nimport { getMarketProb } from './get-market-prob'\nimport { getMarketProbs } from './get-market-probs'\nimport { getGroup } from './get-group'\nimport { getPositions } from './get-positions'\nimport { getLeagues } from './get-leagues'\nimport { getContract } from './get-contract'\nimport { getSingleAnswer } from './get-answer'\nimport { getContractAnswers } from './get-contract-answers'\nimport { addOrRemoveTopicFromContract } from './add-topic-to-market'\nimport { addOrRemoveTopicFromTopic } from './add-topic-to-topic'\nimport { searchUsers } from './search-users'\nimport { searchMarketsLite, searchMarketsFull } from './search-contracts'\nimport { post } from 'api/post'\nimport { fetchLinkPreview } from './fetch-link-preview'\nimport { type APIHandler } from './helpers/endpoint'\nimport { requestLoan } from 'api/request-loan'\nimport { removePinnedPhoto } from './love/remove-pinned-photo'\nimport { getHeadlines, getPoliticsHeadlines } from './get-headlines'\nimport { getBoostAnalytics } from 'api/get-boost-analytics'\nimport { getCompatibilityQuestions } from './love/get-compatibililty-questions'\nimport { addOrRemoveReaction } from './reaction'\nimport { likeLover } from './love/like-lover'\nimport { shipLovers } from './love/ship-lovers'\nimport { createManalink } from './create-manalink'\nimport { getLikesAndShips } from './love/get-likes-and-ships'\nimport { hasFreeLike } from './love/has-free-like'\nimport { starLover } from './love/star-lover'\nimport { getLovers } from './love/get-lovers'\nimport { unlistAndCancelUserContracts } from './unlist-and-cancel-user-contracts'\nimport { getGroupsWithTopContracts } from 'api/get-topics-with-markets'\nimport { getBalanceChanges } from 'api/get-balance-changes'\nimport { getLoverAnswers } from './love/get-lover-answers'\nimport { placeMultiBet } from 'api/place-multi-bet'\nimport { getPartnerStats } from './get-partner-stats'\nimport { getSeenMarketIds } from 'api/get-seen-market-ids'\nimport { recordContractView } from 'api/record-contract-view'\nimport { createPublicChatMessage } from 'api/create-public-chat-message'\nimport { getFollowedGroups } from './get-followed-groups'\nimport { getUniqueBetGroupCount } from 'api/get-unique-bet-groups'\nimport { deleteGroup } from './delete-group'\nimport { recordContractInteraction } from 'api/record-contract-interaction'\nimport { getUserPortfolio } from './get-user-portfolio'\nimport { createuser } from 'api/create-user'\nimport { verifyPhoneNumber } from 'api/verify-phone-number'\nimport { requestOTP } from 'api/request-phone-otp'\nimport { multiSell } from 'api/multi-sell'\nimport { convertCashToMana } from './convert-cash-to-mana'\nimport { convertSpiceToMana } from './convert-sp-to-mana'\nimport { donate } from './donate'\nimport { getFeed } from 'api/get-feed'\nimport { getManaSupply } from './get-mana-supply'\nimport { getUserPortfolioHistory } from './get-user-portfolio-history'\nimport { deleteMe } from './delete-me'\nimport { updateModReport } from './update-mod-report'\nimport { getModReports } from './get-mod-reports'\nimport { searchContractPositions } from 'api/search-contract-positions'\nimport { blockUser, unblockUser } from './block-user'\nimport { blockGroup, unblockGroup } from './block-group'\nimport { blockMarket, unblockMarket } from './block-market'\nimport { getTxnSummaryStats } from 'api/get-txn-summary-stats'\nimport { getManaSummaryStats } from 'api/get-mana-summary-stats'\nimport { register } from 'api/gidx/register'\nimport { uploadDocument } from 'api/gidx/upload-document'\nimport { identityCallbackGIDX, paymentCallbackGIDX } from 'api/gidx/callback'\nimport { getVerificationStatus } from 'api/gidx/get-verification-status'\nimport { getCurrentPrivateUser } from './get-current-private-user'\nimport { updatePrivateUser } from './update-private-user'\nimport { setPushToken } from './push-token'\nimport { updateNotifSettings } from './update-notif-settings'\nimport { getVerificationDocuments } from 'api/gidx/get-verification-documents'\nimport { getRedeemablePrizeCash } from './get-redeemable-prize-cash'\nimport { getTotalRedeemablePrizeCash } from './get-total-redeemable-prize-cash'\nimport { getMonitorStatus } from 'api/gidx/get-monitor-status'\nimport { getBestComments } from 'api/get-best-comments'\nimport { recordCommentView } from 'api/record-comment-view'\nimport {\n  getChannelMemberships,\n  getChannelMessages,\n  getLastSeenChannelTime,\n  setChannelLastSeenTime,\n} from 'api/get-private-messages'\nimport { getNotifications } from 'api/get-notifications'\nimport { getCheckoutSession } from 'api/gidx/get-checkout-session'\nimport { completeCheckoutSession } from 'api/gidx/complete-checkout-session'\nimport { getContractTopics } from './get-contract-topics'\nimport { getRelatedMarkets } from './get-related-markets'\nimport { getRelatedMarketsByGroup } from './get-related-markets-by-group'\nimport { followContract } from './follow-contract'\nimport { getUserLimitOrdersWithContracts } from 'api/get-user-limit-orders-with-contracts'\nimport { getInterestingGroupsFromViews } from 'api/get-interesting-groups-from-views'\nimport { completeCashoutSession } from 'api/gidx/complete-cashout-session'\nimport { getCashouts } from './get-cashouts'\nimport { getKYCStats } from './get-kyc-stats'\nimport { getTxns } from './get-txns'\nimport { refreshAllClients } from './refresh-all-clients'\nimport { getLeaderboard } from './get-leaderboard'\nimport { toggleSystemTradingStatus } from './toggle-system-status'\nimport { completeCashoutRequest } from './gidx/complete-cashout-request'\nimport { getDailyChangedMetricsAndContracts } from './get-daily-changed-metrics-and-contracts'\nimport { getMarketsByIds } from './get-markets'\nimport { getTopicTopics } from './get-topic-topics'\nimport { getTopicDashboards } from './get-topic-dashboards'\nimport { generateAIMarketSuggestions } from './generate-ai-market-suggestions'\nimport { generateAIMarketSuggestions2 } from './generate-ai-market-suggestions-2'\nimport { generateAIDescription } from './generate-ai-description'\nimport { generateAIAnswers } from './generate-ai-answers'\nimport { getmonthlybets2024 } from './get-monthly-bets-2024'\nimport { getmaxminprofit2024 } from './get-max-min-profit-2024'\nimport { getNextLoanAmount } from './get-next-loan-amount'\nimport { checkSportsEvent } from './check-sports-event'\n\nimport { createTask } from './create-task'\nimport { updateTask } from './update-task'\nimport { createCategory } from './create-category'\nimport { getCategories } from './get-categories'\nimport { updateCategory } from './update-category'\nimport { getTasks } from './get-tasks'\n\nimport { getSiteActivity } from './get-site-activity'\nimport { isSportsInterested } from './is-sports-bettor'\nimport { getSportsGames } from './get-sports-games'\nimport { getMarketProps } from './get-market-props'\nimport { getUserContractMetricsWithContracts } from './get-user-contract-metrics-with-contracts'\nimport { validateiap } from './validate-iap'\nimport { getReactions } from './get-reactions'\nimport { markallnotificationsnew } from './mark-all-notifications-new'\nimport {\n  getContractOptionVoters,\n  getContractVoters,\n} from './get-contract-voters'\nimport { purchaseContractBoost } from './purchase-contract-boost'\nimport {\n  generateAINumericRanges,\n  regenerateNumericMidpoints,\n} from './generate-ai-numeric-ranges'\nimport {\n  generateAIDateRanges,\n  regenerateDateMidpoints,\n} from './generate-ai-date-ranges'\nimport { inferNumericUnit } from './infer-numeric-unit'\nimport { generateConciseTitle } from './generate-concise-title'\nimport { getCloseDateEndpoint } from './get-close-date'\nimport { referUser } from './refer-user'\nimport {\n  saveMarketDraft,\n  getMarketDrafts,\n  deleteMarketDraft,\n} from './market-drafts'\nimport { getSeasonInfo } from './get-season-info'\nimport { markNotificationRead } from './mark-all-notifications'\nimport { createPostComment, updatePostComment } from './create-post-comment'\nimport { createPost, updatePost } from './create-post'\nimport { getPosts } from './get-posts'\nimport { dismissUserReport } from './dismiss-user-report'\n\nexport const handlers: { [k in APIPath]: APIHandler<k> } = {\n  'refresh-all-clients': refreshAllClients,\n  bet: placeBet,\n  'multi-bet': placeMultiBet,\n  'follow-contract': followContract,\n  'bet/cancel/:betId': cancelBet,\n  'market/:contractId/sell': sellShares,\n  bets: getBets,\n  'bet-points': getBetPointsBetween,\n  'get-notifications': getNotifications,\n  'get-channel-memberships': getChannelMemberships,\n  'get-channel-messages': getChannelMessages,\n  'get-channel-seen-time': getLastSeenChannelTime,\n  'set-channel-seen-time': setChannelLastSeenTime,\n  'get-contract': getContract,\n  comment: createComment,\n  'hide-comment': hideComment,\n  'pin-comment': pinComment,\n  comments: getComments,\n  market: createMarket,\n  'market/:contractId/group': addOrRemoveTopicFromContract,\n  'market/:contractId/groups': getContractTopics,\n  'group/:slug': getGroup,\n  'group/by-id/:id': getGroup,\n  'group/by-id/:id/markets': ({ id, limit }, ...rest) =>\n    getMarkets({ groupId: id, limit }, ...rest),\n  'group/:slug/delete': deleteGroup,\n  'group/by-id/:id/delete': deleteGroup,\n  'group/:slug/block': blockGroup,\n  'group/:slug/unblock': unblockGroup,\n  'group/by-id/:topId/group/:bottomId': addOrRemoveTopicFromTopic,\n  'group/:slug/groups': getTopicTopics,\n  'group/:slug/dashboards': getTopicDashboards,\n  'group/by-id/:id/groups': getTopicTopics,\n  groups: getGroups,\n  'market/:id': getMarket,\n  'market/:id/lite': ({ id }) => getMarket({ id, lite: true }),\n  'market/:id/prob': getMarketProb,\n  'market-probs': getMarketProbs,\n  'answer/:answerId': getSingleAnswer,\n  'market/:contractId/answers': getContractAnswers,\n  'markets-by-ids': getMarketsByIds,\n  'slug/:slug': getMarket,\n  'market/:contractId/update': updateMarket,\n  'market/:contractId/close': closeMarket,\n  'market/:contractId/resolve': resolveMarket,\n  'market/:contractId/add-liquidity': addLiquidity,\n  'market/:contractId/remove-liquidity': removeLiquidity,\n  'market/:contractId/add-bounty': addBounty,\n  'market/:contractId/award-bounty': awardBounty,\n  'market/:contractId/answer': createAnswerCPMM,\n  'market/:contractId/block': blockMarket,\n  'market/:contractId/unblock': unblockMarket,\n  'get-user-limit-orders-with-contracts': getUserLimitOrdersWithContracts,\n  'get-interesting-groups-from-views': getInterestingGroupsFromViews,\n  leagues: getLeagues,\n  markets: getMarkets,\n  'search-markets': searchMarketsLite,\n  'search-markets-full': searchMarketsFull,\n  managram: managram,\n  managrams: getManagrams,\n  manalink: createManalink,\n  donate: donate,\n  'convert-cash-to-mana': convertCashToMana,\n  'convert-sp-to-mana': convertSpiceToMana,\n  'market/:id/positions': getPositions,\n  me: getMe,\n  'me/update': updateMe,\n  'me/delete': deleteMe,\n  'me/private': getCurrentPrivateUser,\n  'me/private/update': updatePrivateUser,\n  'user/by-id/:id': getUser,\n  'user/by-id/:id/lite': getLiteUser,\n  'user/:username': getUser,\n  'user/:username/lite': getLiteUser,\n  'user/:username/bets': (...props) => getBets(...props),\n  'user/by-id/:id/block': blockUser,\n  'user/by-id/:id/unblock': unblockUser,\n  users: getUsers,\n  'users/by-id': getUsersByIds,\n  'users/by-id/balance': getUserBalancesByIds,\n  'search-users': searchUsers,\n  react: addOrRemoveReaction,\n  'save-twitch': saveTwitchCredentials,\n  'set-push-token': setPushToken,\n  'update-notif-settings': updateNotifSettings,\n  headlines: getHeadlines,\n  'politics-headlines': getPoliticsHeadlines,\n  'compatible-lovers': getCompatibleLovers,\n  post: post,\n  'fetch-link-preview': fetchLinkPreview,\n  'request-loan': requestLoan,\n  'remove-pinned-photo': removePinnedPhoto,\n  'get-related-markets': getRelatedMarkets,\n  'get-related-markets-by-group': getRelatedMarketsByGroup,\n  'unlist-and-cancel-user-contracts': unlistAndCancelUserContracts,\n  'get-boost-analytics': getBoostAnalytics,\n  'get-compatibility-questions': getCompatibilityQuestions,\n  'like-lover': likeLover,\n  'ship-lovers': shipLovers,\n  'get-likes-and-ships': getLikesAndShips,\n  'has-free-like': hasFreeLike,\n  'star-lover': starLover,\n  'get-lovers': getLovers,\n  'get-lover-answers': getLoverAnswers,\n  'set-news': setnews,\n  'search-groups': searchGroups,\n  'search-my-groups': searchMyGroups,\n  'get-groups-with-top-contracts': getGroupsWithTopContracts,\n  'get-balance-changes': getBalanceChanges,\n  'get-partner-stats': getPartnerStats,\n  'get-posts': getPosts,\n  'get-seen-market-ids': getSeenMarketIds,\n  'record-contract-view': recordContractView,\n  'get-dashboard-from-slug': getDashboardFromSlug,\n  'create-public-chat-message': createPublicChatMessage,\n  unresolve: unresolve,\n  'get-followed-groups': getFollowedGroups,\n  'unique-bet-group-count': getUniqueBetGroupCount,\n  'record-contract-interaction': recordContractInteraction,\n  'get-user-portfolio': getUserPortfolio,\n  'get-user-portfolio-history': getUserPortfolioHistory,\n  createuser: createuser,\n  'verify-phone-number': verifyPhoneNumber,\n  'request-otp': requestOTP,\n  'multi-sell': multiSell,\n  'get-feed': getFeed,\n  'get-mana-supply': getManaSupply,\n  'update-mod-report': updateModReport,\n  'get-mod-reports': getModReports,\n  'search-contract-positions': searchContractPositions,\n  'get-txn-summary-stats': getTxnSummaryStats,\n  'get-mana-summary-stats': getManaSummaryStats,\n  'register-gidx': register,\n  'get-checkout-session-gidx': getCheckoutSession,\n  'complete-checkout-session-gidx': completeCheckoutSession,\n  'complete-cashout-session-gidx': completeCashoutSession,\n  'complete-cashout-request': completeCashoutRequest,\n  'get-verification-status-gidx': getVerificationStatus,\n  'upload-document-gidx': uploadDocument,\n  'identity-callback-gidx': identityCallbackGIDX,\n  'payment-callback-gidx': paymentCallbackGIDX,\n  'get-verification-documents-gidx': getVerificationDocuments,\n  'get-redeemable-prize-cash': getRedeemablePrizeCash,\n  'get-total-redeemable-prize-cash': getTotalRedeemablePrizeCash,\n  'get-monitor-status-gidx': getMonitorStatus,\n  'get-best-comments': getBestComments,\n  'record-comment-view': recordCommentView,\n  'get-cashouts': getCashouts,\n  'get-kyc-stats': getKYCStats,\n  txns: getTxns,\n  'toggle-system-trading-status': toggleSystemTradingStatus,\n  leaderboard: getLeaderboard,\n  'get-daily-changed-metrics-and-contracts': getDailyChangedMetricsAndContracts,\n  'generate-ai-market-suggestions': generateAIMarketSuggestions,\n  'generate-ai-market-suggestions-2': generateAIMarketSuggestions2,\n  'generate-ai-description': generateAIDescription,\n  'generate-ai-answers': generateAIAnswers,\n  'get-monthly-bets-2024': getmonthlybets2024,\n  'get-max-min-profit-2024': getmaxminprofit2024,\n  'get-next-loan-amount': getNextLoanAmount,\n  'check-sports-event': checkSportsEvent,\n  'create-task': createTask,\n  'update-task': updateTask,\n  'create-category': createCategory,\n  'get-categories': getCategories,\n  'update-category': updateCategory,\n  'get-tasks': getTasks,\n  'get-site-activity': getSiteActivity,\n  'is-sports-interested': isSportsInterested,\n  'get-sports-games': getSportsGames,\n  'get-market-props': getMarketProps,\n  'get-user-contract-metrics-with-contracts':\n    getUserContractMetricsWithContracts,\n  validateIap: validateiap,\n  'comment-reactions': getReactions,\n  'mark-all-notifications-new': markallnotificationsnew,\n  'get-contract-voters': getContractVoters,\n  'get-contract-option-voters': getContractOptionVoters,\n  'purchase-contract-boost': purchaseContractBoost,\n  'generate-ai-numeric-ranges': generateAINumericRanges,\n  'regenerate-numeric-midpoints': regenerateNumericMidpoints,\n  'infer-numeric-unit': inferNumericUnit,\n  'generate-ai-date-ranges': generateAIDateRanges,\n  'regenerate-date-midpoints': regenerateDateMidpoints,\n  'generate-concise-title': generateConciseTitle,\n  'get-close-date': getCloseDateEndpoint,\n  'refer-user': referUser,\n  'create-post-comment': createPostComment,\n  'create-post': createPost,\n  'update-post': updatePost,\n  'update-post-comment': updatePostComment,\n  'save-market-draft': saveMarketDraft,\n  'get-market-drafts': getMarketDrafts,\n  'delete-market-draft': deleteMarketDraft,\n  'get-season-info': getSeasonInfo,\n  'mark-notification-read': markNotificationRead,\n  'dismiss-user-report': dismissUserReport,\n} as const\n"
        },
        {
          "path": "backend/supabase/reports.sql",
          "preContent": "-- This file is autogenerated from regen-schema.ts\ncreate table if not exists\n  reports (\n    content_id text not null,\n    content_owner_id text not null,\n    content_type text not null,\n    created_time timestamp with time zone default now(),\n    description text,\n    id text default uuid_generate_v4 () not null,\n    parent_id text,\n    parent_type text,\n    user_id text not null\n  );\n\n-- Foreign Keys\nalter table reports\nadd constraint reports_content_owner_id_fkey foreign key (content_owner_id) references users (id);\n\nalter table reports\nadd constraint reports_user_id_fkey foreign key (user_id) references users (id);\n",
          "postContent": "-- This file is autogenerated from regen-schema.ts\ncreate table if not exists\n  reports (\n    content_id text not null,\n    content_owner_id text not null,\n    content_type text not null,\n    created_time timestamp with time zone default now(),\n    description text,\n    id text default uuid_generate_v4 () not null,\n    parent_id text,\n    parent_type text,\n    user_id text not null,\n    dismissed_by_user_id text\n  );\n\n-- Foreign Keys\nalter table reports\nadd constraint reports_content_owner_id_fkey foreign key (content_owner_id) references users (id);\n\nalter table reports\nadd constraint reports_user_id_fkey foreign key (user_id) references users (id);\n"
        },
        {
          "path": "common/src/api/schema.ts",
          "preContent": "import { z } from 'zod'\nimport {\n  Group,\n  MAX_ID_LENGTH,\n  MySearchGroupShape,\n  LiteGroup,\n  SearchGroupParams,\n  SearchGroupShape,\n  Topic,\n} from 'common/group'\nimport {\n  createMarketProps,\n  resolveMarketProps,\n  type LiteMarket,\n  FullMarket,\n  updateMarketProps,\n} from './market-types'\nimport { type Answer } from 'common/answer'\nimport {\n  CommentWithTotalReplies,\n  MAX_COMMENT_LENGTH,\n  PostComment,\n  type ContractComment,\n} from 'common/comment'\nimport { CandidateBet } from 'common/new-bet'\nimport type { Bet, LimitBet } from 'common/bet'\nimport { coerceBoolean, contentSchema } from 'common/api/zod-types'\nimport { Lover } from 'common/love/lover'\nimport { AIGeneratedMarket, Contract, MarketContract } from 'common/contract'\nimport { CompatibilityScore } from 'common/love/compatibility-score'\nimport type { Txn, ManaPayTxn } from 'common/txn'\nimport { LiquidityProvision } from 'common/liquidity-provision'\nimport { DisplayUser, FullUser } from './user-types'\nimport { League } from 'common/leagues'\nimport { searchProps } from './market-search-types'\nimport { MAX_ANSWER_LENGTH } from 'common/answer'\nimport { type LinkPreview } from 'common/link-preview'\nimport { Headline } from 'common/news'\nimport { Row } from 'common/supabase/utils'\nimport { LikeData, ShipData } from './love-types'\nimport { AnyBalanceChangeType } from 'common/balance-change'\nimport { Dashboard } from 'common/dashboard'\nimport { ChatMessage, PrivateChatMessage } from 'common/chat-message'\nimport { PrivateUser, User } from '../user'\nimport { ManaSupply } from 'common/stats'\nimport { Repost } from 'common/repost'\nimport { PERIODS } from 'common/period'\nimport { SWEEPS_MIN_BET } from 'common/economy'\nimport {\n  LivePortfolioMetrics,\n  PortfolioMetrics,\n} from 'common/portfolio-metrics'\nimport { ModReport } from '../mod-report'\n\nimport { RegistrationReturnType } from 'common/reason-codes'\nimport {\n  CheckoutSession,\n  GIDXDocument,\n  GPSProps,\n  PaymentDetail,\n  checkoutParams,\n  verificationParams,\n  cashoutRequestParams,\n  PendingCashoutStatusData,\n  cashoutParams,\n} from 'common/gidx/gidx'\nimport { notification_preference } from 'common/user-notification-preferences'\nimport { PrivateMessageChannel } from 'common/supabase/private-messages'\nimport { Notification } from 'common/notification'\nimport { NON_POINTS_BETS_LIMIT } from 'common/supabase/bets'\nimport { ContractMetric } from 'common/contract-metric'\n\nimport { JSONContent } from '@tiptap/core'\nimport { Task, TaskCategory } from 'common/todo'\nimport { ChartAnnotation } from 'common/supabase/chart-annotations'\nimport { Dictionary } from 'lodash'\nimport { Reaction } from 'common/reaction'\nimport { YEAR_MS } from 'common/util/time'\nimport { MarketDraft } from 'common/drafts'\nimport { TopLevelPost } from 'common/top-level-post'\n// mqp: very unscientific, just balancing our willingness to accept load\n// with user willingness to put up with stale data\nexport const DEFAULT_CACHE_STRATEGY =\n  'public, max-age=5, stale-while-revalidate=10'\nconst MAX_EXPIRES_AT = 1_000 * YEAR_MS\n\ntype APIGenericSchema = {\n  // GET is for retrieval, POST is to mutate something, PUT is idempotent mutation (can be repeated safely)\n  method: 'GET' | 'POST' | 'PUT'\n  //private APIs can only be called from manifold. undocumented endpoints can change or be deleted at any time!\n  visibility: 'public' | 'undocumented' | 'private'\n  // whether the endpoint requires authentication\n  authed: boolean\n  // zod schema for the request body (or for params for GET requests)\n  props: z.ZodType\n  // note this has to be JSON serializable\n  returns?: Record<string, any>\n  // Cache-Control header. like, 'max-age=60'\n  cache?: string\n  // whether the endpoint should prefer authentication even if not required\n  preferAuth?: boolean\n}\n\nlet _apiTypeCheck: { [x: string]: APIGenericSchema }\nexport const API = (_apiTypeCheck = {\n  'refresh-all-clients': {\n    method: 'POST',\n    visibility: 'public',\n    props: z.object({ message: z.string().optional() }),\n    authed: true,\n  },\n  'toggle-system-trading-status': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        token: z.enum(['MANA', 'CASH']),\n      })\n      .strict(),\n    returns: {} as { status: boolean },\n  },\n  comment: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as ContractComment,\n    props: z\n      .object({\n        contractId: z.string(),\n        content: contentSchema.optional(),\n        html: z.string().optional(),\n        markdown: z.string().optional(),\n        replyToCommentId: z.string().optional(),\n        replyToAnswerId: z.string().optional(),\n        replyToBetId: z.string().optional(),\n      })\n      .strict(),\n  },\n\n  'follow-contract': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: true },\n    props: z\n      .object({\n        contractId: z.string(),\n        follow: z.boolean(),\n      })\n      .strict(),\n  },\n  'get-contract': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as Contract,\n    props: z\n      .object({\n        contractId: z.string(),\n      })\n      .strict(),\n  },\n  'answer/:answerId': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as Answer,\n    props: z.object({ answerId: z.string() }).strict(),\n  },\n  'market/:contractId/answers': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: [] as Answer[],\n    props: z.object({ contractId: z.string() }).strict(),\n  },\n  'hide-comment': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ commentPath: z.string() }).strict(),\n  },\n  'pin-comment': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({ commentPath: z.string() }).strict(),\n  },\n  comments: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    // cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as ContractComment[],\n    props: z\n      .object({\n        contractId: z.string().optional(),\n        contractSlug: z.string().optional(),\n        afterTime: z.coerce.number().optional(),\n        limit: z.coerce.number().gte(0).lte(1000).default(1000),\n        page: z.coerce.number().gte(0).default(0),\n        userId: z.string().optional(),\n        isPolitics: coerceBoolean.optional(),\n      })\n      .strict(),\n  },\n  bet: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as CandidateBet & { betId: string },\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gte(SWEEPS_MIN_BET),\n        replyToCommentId: z.string().optional(),\n        limitProb: z.number().gte(0.01).lte(0.99).optional(),\n        expiresMillisAfter: z.number().lt(MAX_EXPIRES_AT).optional(),\n        silent: z.boolean().optional(),\n        expiresAt: z.number().lt(MAX_EXPIRES_AT).optional(),\n        // Used for binary and new multiple choice contracts (cpmm-multi-1).\n        outcome: z.enum(['YES', 'NO']).default('YES'),\n        //Multi\n        answerId: z.string().optional(),\n        dryRun: z.boolean().optional(),\n        deps: z.array(z.string()).optional(),\n        deterministic: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  createuser: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { user: User; privateUser: PrivateUser },\n    props: z\n      .object({\n        deviceToken: z.string().optional(),\n        adminToken: z.string().optional(),\n        visitedContractIds: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'multi-bet': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as (CandidateBet & { betId: string })[],\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gte(1),\n        limitProb: z.number().gte(0).lte(1).optional(),\n        expiresAt: z.number().lt(MAX_EXPIRES_AT).optional(),\n        answerIds: z.array(z.string()).min(1),\n        deterministic: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  'multi-sell': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as (CandidateBet & { betId: string })[],\n    props: z\n      .object({\n        contractId: z.string(),\n        answerIds: z.array(z.string()).min(1),\n        deterministic: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  leaderboard: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as { userId: string; score: number }[],\n    props: z\n      .object({\n        groupId: z.string().optional(),\n        limit: z.coerce.number().min(1).max(100).default(50),\n        token: z.enum(['MANA', 'CASH']).default('MANA'),\n        kind: z.enum(['creator', 'profit', 'loss', 'volume', 'referral']),\n      })\n      .strict(),\n  },\n  'verify-phone-number': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { status: string },\n    props: z\n      .object({\n        phoneNumber: z.string(),\n        code: z.string(),\n      })\n      .strict(),\n  },\n  'request-otp': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { status: string },\n    props: z\n      .object({\n        phoneNumber: z.string(),\n      })\n      .strict(),\n  },\n  'bet/cancel/:betId': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ betId: z.string() }).strict(),\n    returns: {} as LimitBet,\n  },\n  // sell shares\n  'market/:contractId/sell': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as CandidateBet & { betId: string },\n    props: z\n      .object({\n        contractId: z.string(),\n        shares: z.number().positive().optional(), // leave it out to sell all shares\n        outcome: z.enum(['YES', 'NO']),\n        answerId: z.string().optional(), // Required for multi binary markets\n        deterministic: z.boolean().optional(),\n        deps: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'get-user-limit-orders-with-contracts': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as {\n      bets: LimitBet[]\n      contracts: MarketContract[]\n    },\n    props: z\n      .object({\n        userId: z.string(),\n        count: z.coerce.number().lte(5000),\n        includeExpired: coerceBoolean.optional().default(false),\n        includeCancelled: coerceBoolean.optional().default(false),\n        includeFilled: coerceBoolean.optional().default(false),\n      })\n      .strict(),\n  },\n  'get-interesting-groups-from-views': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as (Group & { hasBet: boolean })[],\n    props: z\n      .object({\n        userId: z.string(),\n        contractIds: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  bets: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Bet[],\n    props: z\n      .object({\n        id: z.string().optional(),\n        userId: z.string().optional(),\n        username: z.string().optional(),\n        contractId: z.string().or(z.array(z.string())).optional(),\n        contractSlug: z.string().optional(),\n        answerId: z.string().optional(),\n        // market: z.string().optional(), // deprecated, synonym for `contractSlug`\n        limit: z.coerce\n          .number()\n          .gte(0)\n          .lte(50000)\n          .default(NON_POINTS_BETS_LIMIT),\n        before: z.string().optional(),\n        after: z.string().optional(),\n        beforeTime: z.coerce.number().optional(),\n        afterTime: z.coerce.number().optional(),\n        order: z.enum(['asc', 'desc']).optional(),\n        kinds: z.enum(['open-limit']).optional(),\n        // undocumented fields. idk what a good api interface would be\n        filterRedemptions: coerceBoolean.optional(),\n        includeZeroShareRedemptions: coerceBoolean.optional(),\n        commentRepliesOnly: coerceBoolean.optional(),\n        count: coerceBoolean.optional(),\n        points: coerceBoolean.optional(),\n      })\n      .strict(),\n  },\n  'bet-points': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: 'public, max-age=600, stale-while-revalidate=60',\n    returns: [] as Bet[],\n    props: z\n      .object({\n        contractId: z.string(),\n        answerId: z.string().optional(),\n        limit: z.coerce.number().gte(0).lte(50000).default(5000),\n        beforeTime: z.coerce.number(),\n        afterTime: z.coerce.number(),\n        filterRedemptions: coerceBoolean.optional(),\n        includeZeroShareRedemptions: coerceBoolean.optional(),\n      })\n      .strict(),\n  },\n  'unique-bet-group-count': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as { count: number },\n    props: z\n      .object({\n        contractId: z.string(),\n      })\n      .strict(),\n  },\n  'get-daily-changed-metrics-and-contracts': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    cache: 'public, max-age=900, stale-while-revalidate=90', // 15 minute cache\n    props: z\n      .object({\n        limit: z.coerce.number(),\n        userId: z.string(),\n        balance: z.coerce.number(),\n      })\n      .strict(),\n    returns: {} as {\n      manaMetrics: ContractMetric[]\n      contracts: MarketContract[]\n      manaProfit: number\n      manaInvestmentValue: number\n      balance: number\n    },\n  },\n  // deprecated. use /bets?username= instead\n  'user/:username/bets': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Bet[],\n    props: z\n      .object({\n        username: z.string(),\n        limit: z.coerce.number().gte(0).lte(1000).default(1000),\n      })\n      .strict(),\n  },\n  'group/:slug': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as Group,\n    props: z.object({ slug: z.string() }),\n  },\n  'group/:slug/groups': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as { above: LiteGroup[]; below: LiteGroup[] },\n    props: z.object({ slug: z.string() }).strict(),\n  },\n  'group/:slug/dashboards': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as {\n      id: string\n      title: string\n      slug: string\n      creatorId: string\n    }[],\n    props: z.object({ slug: z.string() }).strict(),\n  },\n  'group/by-id/:id/groups': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as { above: LiteGroup[]; below: LiteGroup[] },\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'group/by-id/:id': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as Group,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  // deprecated. use /markets?groupId= instead\n  'group/by-id/:id/markets': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as LiteMarket[],\n    props: z\n      .object({\n        id: z.string(),\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n      })\n      .strict(),\n  },\n  'group/:slug/delete': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ slug: z.string() }),\n  },\n  'group/by-id/:id/delete': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ id: z.string() }),\n  },\n  'group/:slug/block': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ slug: z.string() }),\n  },\n  'group/:slug/unblock': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ slug: z.string() }).strict(),\n  },\n  'group/by-id/:topId/group/:bottomId': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        topId: z.string(),\n        bottomId: z.string(),\n        remove: z.boolean().optional(),\n      })\n      .strict(),\n    returns: {} as { status: 'success' },\n  },\n  groups: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Group[],\n    props: z\n      .object({\n        availableToUserId: z.string().optional(),\n        beforeTime: z.coerce.number().int().optional(),\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n      })\n      .strict(),\n  },\n  'market/:id': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as LiteMarket | FullMarket,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z.object({ id: z.string(), lite: coerceBoolean.optional() }),\n  },\n  'market/:id/prob': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as {\n      prob?: number\n      answerProbs?: { [answerId: string]: number }\n    },\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'market-probs': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as {\n      [contractId: string]: {\n        prob?: number\n        answerProbs?: { [answerId: string]: number }\n      }\n    },\n    props: z\n      .object({\n        ids: z.array(z.string()).max(100),\n      })\n      .strict(),\n  },\n  'markets-by-ids': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: [] as Contract[],\n    props: z\n      .object({\n        ids: z.array(z.string()).max(100),\n      })\n      .strict(),\n  },\n  // deprecated. use /market/:id?lite=true instead\n  'market/:id/lite': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as LiteMarket,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z.object({ id: z.string() }),\n  },\n  'slug/:slug': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as LiteMarket | FullMarket,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z.object({ slug: z.string(), lite: coerceBoolean.optional() }),\n  },\n  market: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as LiteMarket,\n    props: createMarketProps,\n  },\n  'market/:contractId/update': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: updateMarketProps,\n    returns: {} as { success: true },\n  },\n  'market/:contractId/close': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    // returns: {} as LiteMarket,\n    props: z\n      .object({\n        contractId: z.string(),\n        closeTime: z.number().int().nonnegative().optional(),\n      })\n      .strict(),\n  },\n  'market/:contractId/resolve': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { message: string },\n    props: resolveMarketProps,\n  },\n  'market/:contractId/add-liquidity': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as LiquidityProvision,\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gt(0).finite(),\n      })\n      .strict(),\n  },\n  'market/:contractId/remove-liquidity': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as LiquidityProvision,\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gt(0).finite(),\n      })\n      .strict(),\n  },\n  'market/:contractId/add-bounty': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as Txn,\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gt(0).finite(),\n      })\n      .strict(),\n  },\n  'market/:contractId/award-bounty': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as Txn,\n    props: z\n      .object({\n        contractId: z.string(),\n        commentId: z.string(),\n        amount: z.number().gt(0).finite(),\n      })\n      .strict(),\n  },\n  'market/:contractId/group': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        contractId: z.string(),\n        groupId: z.string(),\n        remove: z.boolean().default(false),\n      })\n      .strict(),\n    returns: {} as { success: true },\n  },\n  'market/:contractId/groups': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({ contractId: z.string() }),\n    returns: [] as LiteGroup[],\n  },\n  'market/:contractId/answer': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { newAnswerId: string },\n    props: z\n      .object({\n        contractId: z.string().max(MAX_ANSWER_LENGTH),\n        text: z.string().min(1).max(MAX_ANSWER_LENGTH),\n      })\n      .strict(),\n  },\n  'market/:contractId/block': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ contractId: z.string() }).strict(),\n  },\n  'market/:contractId/unblock': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ contractId: z.string() }).strict(),\n  },\n  unresolve: {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { success: true },\n    props: z\n      .object({\n        contractId: z.string().max(MAX_ANSWER_LENGTH),\n        answerId: z.string().max(MAX_ANSWER_LENGTH).optional(),\n      })\n      .strict(),\n  },\n  leagues: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as League[],\n    props: z\n      .object({\n        userId: z.string().optional(),\n        cohort: z.string().optional(),\n        season: z.coerce.number().optional(),\n      })\n      .strict(),\n  },\n  markets: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as LiteMarket[],\n    props: z\n      .object({\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n        sort: z\n          .enum([\n            'created-time',\n            'updated-time',\n            'last-bet-time',\n            'last-comment-time',\n          ])\n          .optional(),\n        order: z.enum(['asc', 'desc']).optional(),\n        before: z.string().optional(),\n        userId: z.string().optional(),\n        groupId: z.string().optional(),\n      })\n      .strict(),\n  },\n  'search-markets': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as LiteMarket[],\n    props: searchProps,\n  },\n  'search-markets-full': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    preferAuth: true,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Contract[],\n    props: searchProps,\n  },\n  managram: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        amount: z.number().finite(),\n        toIds: z.array(z.string()),\n        message: z.string().max(MAX_COMMENT_LENGTH),\n        groupId: z.string().max(MAX_ID_LENGTH).optional(),\n        token: z.enum(['M$', 'CASH']).default('M$'),\n      })\n      .strict(),\n  },\n  manalink: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { slug: string },\n    props: z\n      .object({\n        amount: z.number().positive().finite().safe(),\n        expiresTime: z.number().lt(MAX_EXPIRES_AT).optional(),\n        maxUses: z.number().optional(),\n        message: z.string().optional(),\n      })\n      .strict(),\n  },\n  donate: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        amount: z.number().positive().finite().safe(),\n        to: z.string(),\n      })\n      .strict(),\n  },\n  'convert-sp-to-mana': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ amount: z.number().positive().finite().safe() }).strict(),\n  },\n  'convert-cash-to-mana': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ amount: z.number().positive().finite().safe() }).strict(),\n  },\n  'request-loan': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({}),\n    returns: {} as { payout: number },\n  },\n  // deprecated. use /txns instead\n  managrams: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: [] as ManaPayTxn[],\n    props: z\n      .object({\n        toId: z.string().optional(),\n        fromId: z.string().optional(),\n        limit: z.coerce.number().gte(0).lte(100).default(100),\n        before: z.coerce.number().optional(),\n        after: z.coerce.number().optional(),\n      })\n      .strict(),\n  },\n  'market/:id/positions': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as ContractMetric[],\n    props: z\n      .object({\n        id: z.string(),\n        userId: z.string().optional(),\n        answerId: z.string().optional(),\n        summaryOnly: z.boolean().optional(),\n        top: z.undefined().or(z.coerce.number()),\n        bottom: z.undefined().or(z.coerce.number()),\n        order: z.enum(['shares', 'profit']).optional(),\n      })\n      .strict(),\n  },\n  me: {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z.object({}),\n    returns: {} as FullUser,\n  },\n  'me/update': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({\n      name: z.string().trim().min(1).optional(),\n      username: z.string().trim().min(1).optional(),\n      avatarUrl: z.string().optional(),\n      bio: z.string().optional(),\n      website: z.string().optional(),\n      twitterHandle: z.string().optional(),\n      discordHandle: z.string().optional(),\n      // settings\n      optOutBetWarnings: z.boolean().optional(),\n      isAdvancedTrader: z.boolean().optional(),\n      //internal\n      seenStreakModal: z.boolean().optional(),\n      shouldShowWelcome: z.boolean().optional(),\n      hasSeenContractFollowModal: z.boolean().optional(),\n      hasSeenLoanModal: z.boolean().optional(),\n    }),\n    returns: {} as FullUser,\n  },\n  'me/delete': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({\n      username: z.string(), // just so you're sure\n    }),\n  },\n  'me/private': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z.object({}),\n    returns: {} as PrivateUser,\n  },\n  'me/private/update': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    props: z\n      .object({\n        email: z.string().email().optional(),\n        apiKey: z.string().optional(),\n        pushToken: z.string().optional(),\n        rejectedPushNotificationsOn: z.number().optional(),\n        lastPromptedToEnablePushNotifications: z.number().optional(),\n        interestedInPushNotifications: z.boolean().optional(),\n        hasSeenAppBannerInNotificationsOn: z.number().optional(),\n        installedAppPlatforms: z.array(z.string()).optional(),\n        paymentInfo: z.string().optional(),\n        lastAppReviewTime: z.number().optional(),\n      })\n      .strict(),\n  },\n  'user/:username': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as FullUser,\n    props: z.object({ username: z.string() }).strict(),\n  },\n  'user/:username/lite': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as DisplayUser,\n    props: z.object({ username: z.string() }).strict(),\n  },\n  'user/by-id/:id': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    // Do not add a caching strategy here. New users need up-to-date data.\n    returns: {} as FullUser,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'user/by-id/:id/lite': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as DisplayUser,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'users/by-id': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as DisplayUser[],\n    props: z.object({ ids: z.array(z.string()) }).strict(),\n  },\n  'users/by-id/balance': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as { id: string; balance: number }[],\n    props: z.object({ ids: z.array(z.string()) }).strict(),\n  },\n  'user/by-id/:id/block': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'user/by-id/:id/unblock': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  users: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as FullUser[],\n    props: z\n      .object({\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n        before: z.string().optional(),\n      })\n      .strict(),\n  },\n  'search-users': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as FullUser[],\n    props: z\n      .object({\n        term: z.string(),\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n        page: z.coerce.number().gte(0).default(0),\n      })\n      .strict(),\n  },\n  'search-contract-positions': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as DisplayUser[],\n    props: z\n      .object({\n        term: z.string(),\n        contractId: z.string(),\n        limit: z.coerce.number().gte(0).lte(100).default(10),\n      })\n      .strict(),\n  },\n  'save-twitch': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        twitchInfo: z.object({\n          twitchName: z.string().optional(),\n          controlToken: z.string().optional(),\n          botEnabled: z.boolean().optional(),\n          needsRelinking: z.boolean().optional(),\n        }),\n      })\n      .strict(),\n  },\n  'set-push-token': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({ pushToken: z.string() }).strict(),\n  },\n  'update-notif-settings': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      type: z.string() as z.ZodType<notification_preference>,\n      medium: z.enum(['email', 'browser', 'mobile']),\n      enabled: z.boolean(),\n    }),\n  },\n  headlines: {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: [] as Headline[],\n    props: z.object({\n      slug: z.enum(['politics', 'ai', 'news']).optional(),\n    }),\n  },\n  'politics-headlines': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: [] as Headline[],\n    props: z.object({}),\n  },\n  'set-news': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { success: true },\n    props: z\n      .object({\n        dashboardIds: z.array(z.string()),\n        endpoint: z.enum(['politics', 'ai', 'news']),\n      })\n      .strict(),\n  },\n  react: {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        contentId: z.string(),\n        contentType: z.enum(['comment', 'contract', 'post']),\n        commentParentType: z.enum(['post']).optional(),\n        remove: z.boolean().optional(),\n        reactionType: z.enum(['like', 'dislike']).optional().default('like'),\n      })\n      .strict(),\n    returns: { success: true },\n  },\n  'compatible-lovers': {\n    method: 'GET',\n    visibility: 'private',\n    authed: false,\n    props: z.object({ userId: z.string() }),\n    returns: {} as {\n      lover: Lover\n      compatibleLovers: Lover[]\n      loverCompatibilityScores: {\n        [userId: string]: CompatibilityScore\n      }\n    },\n  },\n  post: {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    returns: {} as ContractComment,\n    props: z\n      .object({\n        contractId: z.string(),\n        betId: z.string().optional(),\n        commentId: z.string().optional(),\n        content: contentSchema.optional(),\n      })\n      .strict(),\n  },\n  'fetch-link-preview': {\n    method: 'GET',\n    visibility: 'private',\n    authed: false,\n    props: z.object({ url: z.string() }).strict(),\n    cache: 'max-age=86400, stale-while-revalidate=86400',\n    returns: {} as LinkPreview,\n  },\n  'remove-pinned-photo': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    returns: { success: true },\n    props: z\n      .object({\n        userId: z.string(),\n      })\n      .strict(),\n  },\n  'get-related-markets': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    props: z\n      .object({\n        contractId: z.string(),\n        limit: z.coerce.number().gte(0).lte(100),\n        userId: z.string().optional(),\n        question: z.string().optional(),\n        uniqueBettorCount: z.coerce.number().gte(0).optional(),\n      })\n      .strict(),\n    returns: {} as {\n      marketsFromEmbeddings: Contract[]\n    },\n    cache: 'public, max-age=3600, stale-while-revalidate=10',\n  },\n  'get-related-markets-by-group': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: 'public, max-age=3600, stale-while-revalidate=10',\n    returns: {} as {\n      groupContracts: Contract[]\n    },\n    props: z\n      .object({\n        contractId: z.string(),\n        limit: z.coerce.number().gte(0).lte(100),\n        offset: z.coerce.number().gte(0),\n      })\n      .strict(),\n  },\n  'unlist-and-cancel-user-contracts': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        userId: z.string(),\n      })\n      .strict(),\n  },\n  'get-boost-analytics': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: false,\n    props: z\n      .object({\n        contractId: z.string(),\n      })\n      .strict(),\n    returns: {} as {\n      uniqueViewers: number\n      totalViews: number\n      uniquePromotedViewers: number\n      totalPromotedViews: number\n      boostPeriods: {\n        startTime: string\n        endTime: string\n      }[]\n    },\n  },\n  'get-seen-market-ids': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      contractIds: z.array(z.string()),\n      types: z.array(z.enum(['page', 'card', 'promoted'])).optional(),\n      since: z.number(),\n    }),\n    returns: [] as string[],\n  },\n  'get-compatibility-questions': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({}),\n    returns: {} as {\n      status: 'success'\n      questions: (Row<'love_questions'> & {\n        answer_count: number\n        score: number\n      })[]\n    },\n  },\n  'like-lover': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    props: z.object({\n      targetUserId: z.string(),\n      remove: z.boolean().optional(),\n    }),\n    returns: {} as {\n      status: 'success'\n    },\n  },\n  'ship-lovers': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    props: z.object({\n      targetUserId1: z.string(),\n      targetUserId2: z.string(),\n      remove: z.boolean().optional(),\n    }),\n    returns: {} as {\n      status: 'success'\n    },\n  },\n\n  'get-likes-and-ships': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z\n      .object({\n        userId: z.string(),\n      })\n      .strict(),\n    returns: {} as {\n      status: 'success'\n      likesReceived: LikeData[]\n      likesGiven: LikeData[]\n      ships: ShipData[]\n    },\n  },\n  'has-free-like': {\n    method: 'GET',\n    visibility: 'private',\n    authed: true,\n    props: z.object({}).strict(),\n    returns: {} as {\n      status: 'success'\n      hasFreeLike: boolean\n    },\n  },\n  'star-lover': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    props: z.object({\n      targetUserId: z.string(),\n      remove: z.boolean().optional(),\n    }),\n    returns: {} as {\n      status: 'success'\n    },\n  },\n  'get-lovers': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({}).strict(),\n    returns: {} as {\n      status: 'success'\n      lovers: Lover[]\n    },\n  },\n  'get-lover-answers': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({ userId: z.string() }).strict(),\n    returns: {} as {\n      status: 'success'\n      answers: Row<'love_compatibility_answers'>[]\n    },\n  },\n  'search-groups': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    // Is there a way to infer return { lite:[] as LiteGroup[] } if type is 'lite'?\n    returns: {\n      full: [] as Group[],\n      lite: [] as LiteGroup[],\n    },\n    props: SearchGroupParams(SearchGroupShape),\n  },\n  'search-my-groups': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {\n      full: [] as Group[],\n      lite: [] as LiteGroup[],\n    },\n    props: SearchGroupParams(MySearchGroupShape),\n  },\n  'get-groups-with-top-contracts': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as { topic: Topic; contracts: Contract[] }[],\n    props: z.object({}),\n  },\n  'get-balance-changes': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: [] as AnyBalanceChangeType[],\n    props: z\n      .object({\n        before: z.coerce.number().optional(),\n        after: z.coerce.number().default(0),\n        userId: z.string(),\n      })\n      .strict(),\n  },\n  'get-partner-stats': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z\n      .object({\n        userId: z.string(),\n      })\n      .strict(),\n    returns: {} as {\n      status: 'success' | 'error'\n      username: string\n      numContractsCreated: number\n      numUniqueBettors: number\n      numReferrals: number\n      numReferralsWhoRetained: number\n      totalTraderIncome: number\n      totalReferralIncome: number\n      dollarsEarned: number\n    },\n  },\n  'record-contract-view': {\n    method: 'POST',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      userId: z.string().optional(),\n      contractId: z.string(),\n      kind: z.enum(['page', 'card', 'promoted']),\n    }),\n    returns: {} as { status: 'success' },\n  },\n  'record-comment-view': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({\n      contractId: z.string(),\n      commentId: z.string(),\n    }),\n    returns: {} as { status: 'success' },\n  },\n  'record-contract-interaction': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({\n      contractId: z.string(),\n      kind: z.enum([\n        'page bet',\n        'page comment',\n        'page repost',\n        'page like',\n        'card bet',\n        'card click',\n        'promoted click',\n        'card like',\n        'page share',\n        'browse click',\n      ]),\n      commentId: z.string().optional(),\n      feedReasons: z.array(z.string()).optional(),\n      feedType: z.string().optional(),\n      betGroupId: z.string().optional(),\n      betId: z.string().optional(),\n    }),\n    returns: {} as { status: 'success' },\n  },\n  'get-dashboard-from-slug': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      dashboardSlug: z.string(),\n    }),\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as Dashboard,\n  },\n  'get-posts': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    preferAuth: true,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z\n      .object({\n        sortBy: z\n          .enum(['created_time', 'importance_score'])\n          .optional()\n          .default('created_time'),\n        term: z.string().optional(),\n        limit: z.coerce.number().gte(0).lte(200).default(100),\n        userId: z.string().optional(),\n        offset: z.coerce.number().gte(0).default(0),\n      })\n      .strict(),\n    returns: [] as TopLevelPost[],\n  },\n  'create-public-chat-message': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as ChatMessage,\n    props: z.object({\n      content: contentSchema,\n      channelId: z.string(),\n    }),\n  },\n  'get-followed-groups': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      userId: z.string(),\n    }),\n    returns: {} as {\n      groups: Group[]\n    },\n  },\n  'get-user-portfolio': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      userId: z.string(),\n    }),\n    returns: {} as LivePortfolioMetrics,\n  },\n  'get-user-portfolio-history': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      userId: z.string(),\n      period: z.enum(PERIODS),\n    }),\n    returns: {} as PortfolioMetrics[],\n  },\n  'get-channel-memberships': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      channelId: z.coerce.number().optional(),\n      createdTime: z.string().optional(),\n      lastUpdatedTime: z.string().optional(),\n      limit: z.coerce.number(),\n    }),\n    returns: {\n      channels: [] as PrivateMessageChannel[],\n      memberIdsByChannelId: {} as { [channelId: string]: string[] },\n    },\n  },\n  'get-channel-messages': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      channelId: z.coerce.number(),\n      limit: z.coerce.number(),\n      id: z.coerce.number().optional(),\n    }),\n    returns: [] as PrivateChatMessage[],\n  },\n  'get-channel-seen-time': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      channelIds: z.array(z.coerce.number()),\n    }),\n    returns: [] as [number, string][],\n  },\n  'set-channel-seen-time': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      channelId: z.coerce.number(),\n    }),\n  },\n  'get-feed': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as {\n      contracts: Contract[]\n      comments: ContractComment[]\n      bets: Bet[]\n      reposts: Repost[]\n      idsToReason: { [id: string]: string }\n    },\n    props: z\n      .object({\n        userId: z.string(),\n        limit: z.coerce.number().gt(0).lte(100).default(100),\n        offset: z.coerce.number().gte(0).default(0),\n        ignoreContractIds: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'get-mana-supply': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as ManaSupply,\n    props: z.object({}).strict(),\n  },\n  'get-notifications': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as Notification[],\n    props: z\n      .object({\n        after: z.coerce.number().optional(),\n        limit: z.coerce.number().gte(0).lte(1000).default(100),\n      })\n      .strict(),\n  },\n  'update-mod-report': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        reportId: z.number(),\n        updates: z\n          .object({\n            status: z\n              .enum(['new', 'under review', 'resolved', 'needs admin'])\n              .optional(),\n            mod_note: z.string().optional(),\n          })\n          .partial(),\n      })\n      .strict(),\n    returns: {} as { status: string; report: ModReport },\n  },\n  'get-mod-reports': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        statuses: z.array(\n          z.enum(['new', 'under review', 'resolved', 'needs admin'])\n        ),\n        limit: z.coerce.number().gte(0).lte(100).default(25),\n        offset: z.coerce.number().gte(0).default(0),\n        count: coerceBoolean.optional(),\n      })\n      .strict(),\n    returns: {} as {\n      status: string\n      count?: number\n      reports: ModReport[]\n    },\n  },\n  'get-txn-summary-stats': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as Row<'txn_summary_stats'>[],\n    props: z\n      .object({\n        ignoreCategories: z.array(z.string()).optional(),\n        fromType: z.string().optional(),\n        toType: z.string().optional(),\n        limitDays: z.coerce.number(),\n      })\n      .strict(),\n  },\n  'get-mana-summary-stats': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as Row<'mana_supply_stats'>[],\n    props: z\n      .object({\n        limitDays: z.coerce.number(),\n      })\n      .strict(),\n  },\n  'register-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: verificationParams,\n    returns: {} as RegistrationReturnType,\n  },\n  'get-verification-status-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      documents?: GIDXDocument[]\n      message?: string\n      documentStatus?: string\n    },\n    props: z.object({}),\n  },\n  'get-monitor-status-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n    },\n    props: z.object({\n      DeviceGPS: GPSProps,\n    }),\n  },\n  'get-checkout-session-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n      session?: CheckoutSession\n    },\n    props: z.object({\n      PayActionCode: z.enum(['PAY', 'PAYOUT']).default('PAY'),\n      DeviceGPS: GPSProps,\n      userId: z.string().optional(),\n      ip: z.string().optional(),\n    }),\n  },\n  'complete-checkout-session-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n      gidxMessage?: string | null\n      details?: PaymentDetail[]\n    },\n    props: z.object(checkoutParams),\n  },\n  'complete-cashout-session-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n      gidxMessage?: string | null\n      details?: PaymentDetail[]\n    },\n    props: z.object(cashoutParams),\n  },\n  'complete-cashout-request': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n      gidxMessage?: string | null\n      details?: PaymentDetail[]\n    },\n    props: z.object(cashoutRequestParams),\n  },\n  'get-verification-documents-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      documents: GIDXDocument[]\n      utilityDocuments: GIDXDocument[]\n      idDocuments: GIDXDocument[]\n      rejectedDocuments: GIDXDocument[]\n    },\n    props: z.object({}),\n  },\n  'upload-document-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { status: string },\n    props: z.object({\n      CategoryType: z.number().gte(1).lte(7),\n      fileName: z.string(),\n      fileUrl: z.string(),\n    }),\n  },\n  'identity-callback-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as { Accepted: boolean },\n    props: z.object({\n      MerchantCustomerID: z.string(),\n      NotificationType: z.string(),\n    }),\n  },\n  'payment-callback-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as { MerchantTransactionID: string },\n    props: z\n      .object({\n        MerchantTransactionID: z.string(),\n        TransactionStatusCode: z.coerce.number(),\n        TransactionStatusMessage: z.string(),\n        StatusCode: z.coerce.number(),\n        SessionID: z.string(),\n        MerchantSessionID: z.string(),\n        SessionScore: z.coerce.number(),\n        ReasonCodes: z.array(z.string()).optional(),\n        ServiceType: z.string(),\n        StatusMessage: z.string(),\n      })\n      .strict(),\n  },\n  'get-best-comments': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { comments: ContractComment[]; contracts: Contract[] },\n    props: z.object({\n      limit: z.coerce.number().gte(0).lte(100).default(20),\n      offset: z.coerce.number().gte(0).default(0),\n      ignoreContractIds: z.array(z.string()).optional(),\n      justLikes: z.coerce.number().optional(),\n    }),\n  },\n  'get-redeemable-prize-cash': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { redeemablePrizeCash: number },\n    props: z.object({}),\n  },\n  'get-total-redeemable-prize-cash': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as { total: number },\n    props: z.object({}),\n  },\n  'get-cashouts': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as PendingCashoutStatusData[],\n    props: z\n      .object({\n        limit: z.coerce.number().gte(0).lte(100).default(10),\n        offset: z.coerce.number().gte(0).default(0),\n        userId: z.string().optional(),\n      })\n      .strict(),\n  },\n  'get-kyc-stats': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({}),\n    returns: {} as {\n      initialVerifications: {\n        count: number\n        day: string\n      }[]\n      phoneVerifications: {\n        count: number\n        day: string\n      }[]\n    },\n  },\n  txns: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z\n      .object({\n        token: z.string().optional(),\n        offset: z.coerce.number().default(0),\n        limit: z.coerce.number().gte(0).lte(100).default(100),\n        before: z.coerce.number().optional(),\n        after: z.coerce.number().optional(),\n        toId: z.string().optional(),\n        fromId: z.string().optional(),\n        category: z.string().optional(),\n        ignoreCategories: z.array(z.string()).optional(),\n      })\n      .strict(),\n    returns: [] as Txn[],\n  },\n  'generate-ai-market-suggestions': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: [] as AIGeneratedMarket[],\n    props: z\n      .object({\n        prompt: z.string(),\n        existingTitles: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'generate-ai-market-suggestions-2': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: [] as AIGeneratedMarket[],\n    props: z\n      .object({\n        prompt: z.string(),\n        existingTitles: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'generate-ai-description': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { description: JSONContent | undefined },\n    props: z\n      .object({\n        question: z.string(),\n        description: z.string().optional(),\n        answers: z.array(z.string()).optional(),\n        outcomeType: z.string().optional(),\n        shouldAnswersSumToOne: coerceBoolean.optional(),\n        addAnswersMode: z\n          .enum(['DISABLED', 'ONLY_CREATOR', 'ANYONE'])\n          .optional(),\n      })\n      .strict(),\n  },\n  'generate-ai-answers': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as {\n      answers: string[]\n      addAnswersMode: 'DISABLED' | 'ONLY_CREATOR' | 'ANYONE'\n    },\n    props: z\n      .object({\n        question: z.string(),\n        answers: z.array(z.string()),\n        shouldAnswersSumToOne: coerceBoolean,\n        description: z.string().optional(),\n      })\n      .strict(),\n  },\n  'get-monthly-bets-2024': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ userId: z.string() }),\n    returns: [] as { month: string; bet_count: number; total_amount: number }[],\n  },\n  'get-max-min-profit-2024': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ userId: z.string() }),\n    returns: [] as {\n      profit: number\n      data: Contract\n      answer_id: string | null\n      has_no_shares: boolean\n      has_yes_shares: boolean\n    }[],\n  },\n  'get-next-loan-amount': {\n    method: 'GET',\n    visibility: 'undocumented',\n    cache: DEFAULT_CACHE_STRATEGY,\n    authed: false,\n    returns: {} as { amount: number },\n    props: z.object({\n      userId: z.string(),\n    }),\n  },\n  'create-task': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as Task,\n    props: z\n      .object({\n        text: z.string(),\n        category_id: z.number().optional(),\n        priority: z.number().default(0),\n        assignee_id: z.string().optional(),\n      })\n      .strict(),\n  },\n  'update-task': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z\n      .object({\n        id: z.number(),\n        text: z.string().optional(),\n        completed: z.boolean().optional(),\n        priority: z.number().optional(),\n        category_id: z.number().optional(),\n        archived: z.boolean().optional(),\n        assignee_id: z.string().optional(),\n      })\n      .strict(),\n  },\n  'create-category': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { id: number },\n    props: z\n      .object({\n        name: z.string(),\n        color: z.string().optional(),\n        displayOrder: z.number().optional(),\n      })\n      .strict(),\n  },\n  'get-categories': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { categories: TaskCategory[] },\n    props: z.object({}).strict(),\n  },\n  'update-category': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z\n      .object({\n        categoryId: z.number(),\n        name: z.string().optional(),\n        color: z.string().optional(),\n        displayOrder: z.number().optional(),\n        archived: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  'get-tasks': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { tasks: Task[] },\n    props: z.object({}).strict(),\n  },\n  'is-sports-interested': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { isSportsInterested: boolean },\n    props: z.object({}).strict(),\n  },\n  'get-site-activity': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as {\n      bets: Bet[]\n      comments: CommentWithTotalReplies[]\n      newContracts: Contract[]\n      relatedContracts: Contract[]\n    },\n    props: z\n      .object({\n        limit: z.coerce.number().default(10),\n        offset: z.coerce.number().default(0),\n        blockedUserIds: z.array(z.string()).optional(),\n        blockedGroupSlugs: z.array(z.string()).optional(),\n        blockedContractIds: z.array(z.string()).optional(),\n        topicIds: z.array(z.string()).optional(),\n        types: z\n          .array(z.enum(['bets', 'comments', 'markets', 'limit-orders']))\n          .optional(),\n        minBetAmount: z.coerce.number().optional(),\n        onlyFollowedTopics: coerceBoolean.optional(),\n        onlyFollowedContracts: coerceBoolean.optional(),\n        onlyFollowedUsers: coerceBoolean.optional(),\n        userId: z.string().optional(),\n      })\n      .strict(),\n  },\n  'get-sports-games': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { schedule: any[] },\n    props: z.object({}).strict(),\n  },\n  'get-market-props': {\n    method: 'GET',\n    visibility: 'public',\n    cache: DEFAULT_CACHE_STRATEGY,\n    // Could set authed false and preferAuth with an api secret if we want it to replace static props\n    authed: true,\n    returns: {} as {\n      manaContract: MarketContract\n      chartAnnotations: ChartAnnotation[]\n      topics: Topic[]\n      comments: ContractComment[]\n      pinnedComments: ContractComment[]\n      userPositionsByOutcome: {\n        YES: ContractMetric[]\n        NO: ContractMetric[]\n      }\n      topContractMetrics: ContractMetric[]\n      totalPositions: number\n      dashboards: Dashboard[]\n      cashContract: MarketContract\n      totalManaBets: number\n      totalCashBets: number\n    },\n    props: z.object({\n      slug: z.string().optional(),\n      id: z.string().optional(),\n    }),\n  },\n  'get-user-contract-metrics-with-contracts': {\n    method: 'GET',\n    visibility: 'public',\n    preferAuth: true,\n    authed: false,\n    returns: {} as {\n      metricsByContract: Dictionary<ContractMetric[]>\n      contracts: MarketContract[]\n    },\n    props: z.object({\n      userId: z.string(),\n      limit: z.coerce.number(),\n      offset: z.coerce.number().gte(0).optional(),\n      perAnswer: coerceBoolean.optional(),\n      inMani: coerceBoolean.optional(),\n    }),\n  },\n  validateIap: {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z.object({\n      receipt: z.string(),\n    }),\n  },\n  'check-sports-event': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as { exists: boolean; existingMarket?: LiteMarket },\n    props: z\n      .object({\n        sportsEventId: z.string(),\n      })\n      .strict(),\n  },\n  'comment-reactions': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Reaction[],\n    props: z\n      .object({\n        contentIds: z.array(z.string()),\n        contentType: z.enum(['comment', 'contract']),\n      })\n      .strict(),\n  },\n  'mark-all-notifications-new': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({}).strict(),\n    returns: {} as { success: boolean },\n  },\n  'get-contract-voters': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        contractId: z.string(),\n      })\n      .strict(),\n    returns: [] as DisplayUser[],\n  },\n  'get-contract-option-voters': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ contractId: z.string(), optionId: z.string() }),\n    returns: [] as DisplayUser[],\n  },\n  'purchase-contract-boost': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        contractId: z.string(),\n        startTime: z.number().positive().finite().safe(),\n        method: z.enum(['mana', 'cash']),\n      })\n      .strict(),\n    returns: {} as { success: boolean; checkoutUrl?: string },\n  },\n  'generate-ai-numeric-ranges': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as {\n      thresholds: { answers: string[]; midpoints: number[] }\n      buckets: { answers: string[]; midpoints: number[] }\n    },\n    props: z\n      .object({\n        question: z.string(),\n        min: z.number(),\n        max: z.number(),\n        description: z.string().optional(),\n        unit: z.string(),\n      })\n      .strict(),\n  },\n  'infer-numeric-unit': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as {\n      unit: string\n    },\n    props: z\n      .object({\n        question: z.string(),\n        description: z.string().optional(),\n      })\n      .strict(),\n  },\n  'generate-ai-date-ranges': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as {\n      buckets: { answers: string[]; midpoints: number[] }\n      thresholds: { answers: string[]; midpoints: number[] }\n    },\n    props: z\n      .object({\n        question: z.string(),\n        min: z.string(),\n        max: z.string(),\n        description: z.string().optional(),\n      })\n      .strict(),\n  },\n  'regenerate-numeric-midpoints': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { midpoints: number[] },\n    props: z\n      .object({\n        description: z.string().optional(),\n        question: z.string(),\n        answers: z.array(z.string()),\n        min: z.number(),\n        max: z.number(),\n        unit: z.string(),\n        tab: z.enum(['thresholds', 'buckets']),\n      })\n      .strict(),\n  },\n  'regenerate-date-midpoints': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { midpoints: number[] },\n    props: z\n      .object({\n        description: z.string().optional(),\n        question: z.string(),\n        answers: z.array(z.string()),\n        min: z.string(),\n        max: z.string(),\n        tab: z.enum(['thresholds', 'buckets']),\n      })\n      .strict(),\n  },\n\n  'generate-concise-title': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        question: z.string(),\n      })\n      .strict(),\n    returns: {} as { title: string },\n  },\n  'get-close-date': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        question: z.string(),\n        utcOffset: z.number().optional(),\n      })\n      .strict(),\n    returns: {} as { closeTime: number },\n  },\n  'refer-user': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        referredByUsername: z.string(),\n        contractId: z.string().optional(),\n      })\n      .strict(),\n    returns: {} as { success: boolean },\n  },\n\n  'save-market-draft': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { id: number },\n    props: z\n      .object({\n        data: z.object({\n          question: z.string(),\n          description: z.any().optional(),\n          outcomeType: z.string(),\n          answers: z.array(z.string()).optional(),\n          closeDate: z.string().optional(),\n          closeHoursMinutes: z.string().optional(),\n          visibility: z.string(),\n          selectedGroups: z.array(z.any()),\n          savedAt: z.number(),\n        }),\n      })\n      .strict(),\n  },\n\n  'get-market-drafts': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: [] as MarketDraft[],\n    props: z.object({}).strict(),\n  },\n\n  'delete-market-draft': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z\n      .object({\n        id: z.coerce.number(),\n      })\n      .strict(),\n  },\n  'get-season-info': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      season: z.coerce.number().int().positive().optional(),\n    }),\n    returns: {} as {\n      season: number\n      startTime: number // epoch ms\n      endTime: number | null // epoch ms, null if a *mystery* for clients\n      status: 'active' | 'processing' | 'complete'\n    },\n  },\n  'mark-notification-read': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z\n      .object({\n        notificationId: z.string(),\n      })\n      .strict(),\n  },\n  'create-post': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { post: TopLevelPost },\n    props: z\n      .object({\n        title: z.string().min(1).max(120),\n        content: contentSchema,\n        isAnnouncement: z.boolean().optional(),\n        visibility: z.enum(['public', 'unlisted']).optional(), \n      })\n      .strict(),\n  },\n  'update-post': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { post: TopLevelPost },\n    props: z\n      .object({\n        id: z.string(),\n        title: z.string().min(1).max(480).optional(),\n        content: contentSchema.optional(),\n        visibility: z.enum(['public', 'unlisted']).optional(),\n      })\n      .strict(),\n  },\n  'create-post-comment': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { comment: PostComment },\n    props: z\n      .object({\n        postId: z.string(),\n        content: contentSchema,\n        replyToCommentId: z.string().optional(),\n      })\n      .strict(),\n  },\n  'update-post-comment': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { comment: PostComment },\n    props: z\n      .object({\n        commentId: z.string(),\n        postId: z.string(),\n        hidden: z.boolean(),\n      })\n      .strict(),\n  },\n} as const)\n\nexport type APIPath = keyof typeof API\nexport type APISchema<N extends APIPath> = (typeof API)[N]\n\nexport type APIParams<N extends APIPath> = z.input<APISchema<N>['props']>\nexport type ValidatedAPIParams<N extends APIPath> = z.output<\n  APISchema<N>['props']\n>\n\nexport type APIResponse<N extends APIPath> = APISchema<N> extends {\n  returns: Record<string, any>\n}\n  ? APISchema<N>['returns']\n  : void\n\nexport type APIResponseOptionalContinue<N extends APIPath> =\n  | { continue: () => Promise<void>; result: APIResponse<N> }\n  | APIResponse<N>\n",
          "postContent": "import { z } from 'zod'\nimport {\n  Group,\n  MAX_ID_LENGTH,\n  MySearchGroupShape,\n  LiteGroup,\n  SearchGroupParams,\n  SearchGroupShape,\n  Topic,\n} from 'common/group'\nimport {\n  createMarketProps,\n  resolveMarketProps,\n  type LiteMarket,\n  FullMarket,\n  updateMarketProps,\n} from './market-types'\nimport { type Answer } from 'common/answer'\nimport {\n  CommentWithTotalReplies,\n  MAX_COMMENT_LENGTH,\n  PostComment,\n  type ContractComment,\n} from 'common/comment'\nimport { CandidateBet } from 'common/new-bet'\nimport type { Bet, LimitBet } from 'common/bet'\nimport { coerceBoolean, contentSchema } from 'common/api/zod-types'\nimport { Lover } from 'common/love/lover'\nimport { AIGeneratedMarket, Contract, MarketContract } from 'common/contract'\nimport { CompatibilityScore } from 'common/love/compatibility-score'\nimport type { Txn, ManaPayTxn } from 'common/txn'\nimport { LiquidityProvision } from 'common/liquidity-provision'\nimport { DisplayUser, FullUser } from './user-types'\nimport { League } from 'common/leagues'\nimport { searchProps } from './market-search-types'\nimport { MAX_ANSWER_LENGTH } from 'common/answer'\nimport { type LinkPreview } from 'common/link-preview'\nimport { Headline } from 'common/news'\nimport { Row } from 'common/supabase/utils'\nimport { LikeData, ShipData } from './love-types'\nimport { AnyBalanceChangeType } from 'common/balance-change'\nimport { Dashboard } from 'common/dashboard'\nimport { ChatMessage, PrivateChatMessage } from 'common/chat-message'\nimport { PrivateUser, User } from '../user'\nimport { ManaSupply } from 'common/stats'\nimport { Repost } from 'common/repost'\nimport { PERIODS } from 'common/period'\nimport { SWEEPS_MIN_BET } from 'common/economy'\nimport {\n  LivePortfolioMetrics,\n  PortfolioMetrics,\n} from 'common/portfolio-metrics'\nimport { ModReport } from '../mod-report'\n\nimport { RegistrationReturnType } from 'common/reason-codes'\nimport {\n  CheckoutSession,\n  GIDXDocument,\n  GPSProps,\n  PaymentDetail,\n  checkoutParams,\n  verificationParams,\n  cashoutRequestParams,\n  PendingCashoutStatusData,\n  cashoutParams,\n} from 'common/gidx/gidx'\nimport { notification_preference } from 'common/user-notification-preferences'\nimport { PrivateMessageChannel } from 'common/supabase/private-messages'\nimport { Notification } from 'common/notification'\nimport { NON_POINTS_BETS_LIMIT } from 'common/supabase/bets'\nimport { ContractMetric } from 'common/contract-metric'\n\nimport { JSONContent } from '@tiptap/core'\nimport { Task, TaskCategory } from 'common/todo'\nimport { ChartAnnotation } from 'common/supabase/chart-annotations'\nimport { Dictionary } from 'lodash'\nimport { Reaction } from 'common/reaction'\nimport { YEAR_MS } from 'common/util/time'\nimport { MarketDraft } from 'common/drafts'\nimport { TopLevelPost } from 'common/top-level-post'\n// mqp: very unscientific, just balancing our willingness to accept load\n// with user willingness to put up with stale data\nexport const DEFAULT_CACHE_STRATEGY =\n  'public, max-age=5, stale-while-revalidate=10'\nconst MAX_EXPIRES_AT = 1_000 * YEAR_MS\n\ntype APIGenericSchema = {\n  // GET is for retrieval, POST is to mutate something, PUT is idempotent mutation (can be repeated safely)\n  method: 'GET' | 'POST' | 'PUT'\n  //private APIs can only be called from manifold. undocumented endpoints can change or be deleted at any time!\n  visibility: 'public' | 'undocumented' | 'private'\n  // whether the endpoint requires authentication\n  authed: boolean\n  // zod schema for the request body (or for params for GET requests)\n  props: z.ZodType\n  // note this has to be JSON serializable\n  returns?: Record<string, any>\n  // Cache-Control header. like, 'max-age=60'\n  cache?: string\n  // whether the endpoint should prefer authentication even if not required\n  preferAuth?: boolean\n}\n\nlet _apiTypeCheck: { [x: string]: APIGenericSchema }\nexport const API = (_apiTypeCheck = {\n  'refresh-all-clients': {\n    method: 'POST',\n    visibility: 'public',\n    props: z.object({ message: z.string().optional() }),\n    authed: true,\n  },\n  'toggle-system-trading-status': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        token: z.enum(['MANA', 'CASH']),\n      })\n      .strict(),\n    returns: {} as { status: boolean },\n  },\n  comment: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as ContractComment,\n    props: z\n      .object({\n        contractId: z.string(),\n        content: contentSchema.optional(),\n        html: z.string().optional(),\n        markdown: z.string().optional(),\n        replyToCommentId: z.string().optional(),\n        replyToAnswerId: z.string().optional(),\n        replyToBetId: z.string().optional(),\n      })\n      .strict(),\n  },\n\n  'follow-contract': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: true },\n    props: z\n      .object({\n        contractId: z.string(),\n        follow: z.boolean(),\n      })\n      .strict(),\n  },\n  'get-contract': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as Contract,\n    props: z\n      .object({\n        contractId: z.string(),\n      })\n      .strict(),\n  },\n  'answer/:answerId': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as Answer,\n    props: z.object({ answerId: z.string() }).strict(),\n  },\n  'market/:contractId/answers': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: [] as Answer[],\n    props: z.object({ contractId: z.string() }).strict(),\n  },\n  'hide-comment': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ commentPath: z.string() }).strict(),\n  },\n  'pin-comment': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({ commentPath: z.string() }).strict(),\n  },\n  comments: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    // cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as ContractComment[],\n    props: z\n      .object({\n        contractId: z.string().optional(),\n        contractSlug: z.string().optional(),\n        afterTime: z.coerce.number().optional(),\n        limit: z.coerce.number().gte(0).lte(1000).default(1000),\n        page: z.coerce.number().gte(0).default(0),\n        userId: z.string().optional(),\n        isPolitics: coerceBoolean.optional(),\n      })\n      .strict(),\n  },\n  bet: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as CandidateBet & { betId: string },\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gte(SWEEPS_MIN_BET),\n        replyToCommentId: z.string().optional(),\n        limitProb: z.number().gte(0.01).lte(0.99).optional(),\n        expiresMillisAfter: z.number().lt(MAX_EXPIRES_AT).optional(),\n        silent: z.boolean().optional(),\n        expiresAt: z.number().lt(MAX_EXPIRES_AT).optional(),\n        // Used for binary and new multiple choice contracts (cpmm-multi-1).\n        outcome: z.enum(['YES', 'NO']).default('YES'),\n        //Multi\n        answerId: z.string().optional(),\n        dryRun: z.boolean().optional(),\n        deps: z.array(z.string()).optional(),\n        deterministic: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  createuser: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { user: User; privateUser: PrivateUser },\n    props: z\n      .object({\n        deviceToken: z.string().optional(),\n        adminToken: z.string().optional(),\n        visitedContractIds: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'multi-bet': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as (CandidateBet & { betId: string })[],\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gte(1),\n        limitProb: z.number().gte(0).lte(1).optional(),\n        expiresAt: z.number().lt(MAX_EXPIRES_AT).optional(),\n        answerIds: z.array(z.string()).min(1),\n        deterministic: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  'multi-sell': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as (CandidateBet & { betId: string })[],\n    props: z\n      .object({\n        contractId: z.string(),\n        answerIds: z.array(z.string()).min(1),\n        deterministic: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  leaderboard: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as { userId: string; score: number }[],\n    props: z\n      .object({\n        groupId: z.string().optional(),\n        limit: z.coerce.number().min(1).max(100).default(50),\n        token: z.enum(['MANA', 'CASH']).default('MANA'),\n        kind: z.enum(['creator', 'profit', 'loss', 'volume', 'referral']),\n      })\n      .strict(),\n  },\n  'verify-phone-number': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { status: string },\n    props: z\n      .object({\n        phoneNumber: z.string(),\n        code: z.string(),\n      })\n      .strict(),\n  },\n  'request-otp': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { status: string },\n    props: z\n      .object({\n        phoneNumber: z.string(),\n      })\n      .strict(),\n  },\n  'bet/cancel/:betId': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ betId: z.string() }).strict(),\n    returns: {} as LimitBet,\n  },\n  // sell shares\n  'market/:contractId/sell': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as CandidateBet & { betId: string },\n    props: z\n      .object({\n        contractId: z.string(),\n        shares: z.number().positive().optional(), // leave it out to sell all shares\n        outcome: z.enum(['YES', 'NO']),\n        answerId: z.string().optional(), // Required for multi binary markets\n        deterministic: z.boolean().optional(),\n        deps: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'get-user-limit-orders-with-contracts': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as {\n      bets: LimitBet[]\n      contracts: MarketContract[]\n    },\n    props: z\n      .object({\n        userId: z.string(),\n        count: z.coerce.number().lte(5000),\n        includeExpired: coerceBoolean.optional().default(false),\n        includeCancelled: coerceBoolean.optional().default(false),\n        includeFilled: coerceBoolean.optional().default(false),\n      })\n      .strict(),\n  },\n  'get-interesting-groups-from-views': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as (Group & { hasBet: boolean })[],\n    props: z\n      .object({\n        userId: z.string(),\n        contractIds: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  bets: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Bet[],\n    props: z\n      .object({\n        id: z.string().optional(),\n        userId: z.string().optional(),\n        username: z.string().optional(),\n        contractId: z.string().or(z.array(z.string())).optional(),\n        contractSlug: z.string().optional(),\n        answerId: z.string().optional(),\n        // market: z.string().optional(), // deprecated, synonym for `contractSlug`\n        limit: z.coerce\n          .number()\n          .gte(0)\n          .lte(50000)\n          .default(NON_POINTS_BETS_LIMIT),\n        before: z.string().optional(),\n        after: z.string().optional(),\n        beforeTime: z.coerce.number().optional(),\n        afterTime: z.coerce.number().optional(),\n        order: z.enum(['asc', 'desc']).optional(),\n        kinds: z.enum(['open-limit']).optional(),\n        // undocumented fields. idk what a good api interface would be\n        filterRedemptions: coerceBoolean.optional(),\n        includeZeroShareRedemptions: coerceBoolean.optional(),\n        commentRepliesOnly: coerceBoolean.optional(),\n        count: coerceBoolean.optional(),\n        points: coerceBoolean.optional(),\n      })\n      .strict(),\n  },\n  'bet-points': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: 'public, max-age=600, stale-while-revalidate=60',\n    returns: [] as Bet[],\n    props: z\n      .object({\n        contractId: z.string(),\n        answerId: z.string().optional(),\n        limit: z.coerce.number().gte(0).lte(50000).default(5000),\n        beforeTime: z.coerce.number(),\n        afterTime: z.coerce.number(),\n        filterRedemptions: coerceBoolean.optional(),\n        includeZeroShareRedemptions: coerceBoolean.optional(),\n      })\n      .strict(),\n  },\n  'unique-bet-group-count': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as { count: number },\n    props: z\n      .object({\n        contractId: z.string(),\n      })\n      .strict(),\n  },\n  'get-daily-changed-metrics-and-contracts': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    cache: 'public, max-age=900, stale-while-revalidate=90', // 15 minute cache\n    props: z\n      .object({\n        limit: z.coerce.number(),\n        userId: z.string(),\n        balance: z.coerce.number(),\n      })\n      .strict(),\n    returns: {} as {\n      manaMetrics: ContractMetric[]\n      contracts: MarketContract[]\n      manaProfit: number\n      manaInvestmentValue: number\n      balance: number\n    },\n  },\n  // deprecated. use /bets?username= instead\n  'user/:username/bets': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Bet[],\n    props: z\n      .object({\n        username: z.string(),\n        limit: z.coerce.number().gte(0).lte(1000).default(1000),\n      })\n      .strict(),\n  },\n  'group/:slug': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as Group,\n    props: z.object({ slug: z.string() }),\n  },\n  'group/:slug/groups': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as { above: LiteGroup[]; below: LiteGroup[] },\n    props: z.object({ slug: z.string() }).strict(),\n  },\n  'group/:slug/dashboards': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as {\n      id: string\n      title: string\n      slug: string\n      creatorId: string\n    }[],\n    props: z.object({ slug: z.string() }).strict(),\n  },\n  'group/by-id/:id/groups': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as { above: LiteGroup[]; below: LiteGroup[] },\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'group/by-id/:id': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as Group,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  // deprecated. use /markets?groupId= instead\n  'group/by-id/:id/markets': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as LiteMarket[],\n    props: z\n      .object({\n        id: z.string(),\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n      })\n      .strict(),\n  },\n  'group/:slug/delete': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ slug: z.string() }),\n  },\n  'group/by-id/:id/delete': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ id: z.string() }),\n  },\n  'group/:slug/block': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ slug: z.string() }),\n  },\n  'group/:slug/unblock': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ slug: z.string() }).strict(),\n  },\n  'group/by-id/:topId/group/:bottomId': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        topId: z.string(),\n        bottomId: z.string(),\n        remove: z.boolean().optional(),\n      })\n      .strict(),\n    returns: {} as { status: 'success' },\n  },\n  groups: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Group[],\n    props: z\n      .object({\n        availableToUserId: z.string().optional(),\n        beforeTime: z.coerce.number().int().optional(),\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n      })\n      .strict(),\n  },\n  'market/:id': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as LiteMarket | FullMarket,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z.object({ id: z.string(), lite: coerceBoolean.optional() }),\n  },\n  'market/:id/prob': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as {\n      prob?: number\n      answerProbs?: { [answerId: string]: number }\n    },\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'market-probs': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as {\n      [contractId: string]: {\n        prob?: number\n        answerProbs?: { [answerId: string]: number }\n      }\n    },\n    props: z\n      .object({\n        ids: z.array(z.string()).max(100),\n      })\n      .strict(),\n  },\n  'markets-by-ids': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: [] as Contract[],\n    props: z\n      .object({\n        ids: z.array(z.string()).max(100),\n      })\n      .strict(),\n  },\n  // deprecated. use /market/:id?lite=true instead\n  'market/:id/lite': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as LiteMarket,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z.object({ id: z.string() }),\n  },\n  'slug/:slug': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as LiteMarket | FullMarket,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z.object({ slug: z.string(), lite: coerceBoolean.optional() }),\n  },\n  market: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as LiteMarket,\n    props: createMarketProps,\n  },\n  'market/:contractId/update': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: updateMarketProps,\n    returns: {} as { success: true },\n  },\n  'market/:contractId/close': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    // returns: {} as LiteMarket,\n    props: z\n      .object({\n        contractId: z.string(),\n        closeTime: z.number().int().nonnegative().optional(),\n      })\n      .strict(),\n  },\n  'market/:contractId/resolve': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { message: string },\n    props: resolveMarketProps,\n  },\n  'market/:contractId/add-liquidity': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as LiquidityProvision,\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gt(0).finite(),\n      })\n      .strict(),\n  },\n  'market/:contractId/remove-liquidity': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as LiquidityProvision,\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gt(0).finite(),\n      })\n      .strict(),\n  },\n  'market/:contractId/add-bounty': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as Txn,\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gt(0).finite(),\n      })\n      .strict(),\n  },\n  'market/:contractId/award-bounty': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as Txn,\n    props: z\n      .object({\n        contractId: z.string(),\n        commentId: z.string(),\n        amount: z.number().gt(0).finite(),\n      })\n      .strict(),\n  },\n  'market/:contractId/group': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        contractId: z.string(),\n        groupId: z.string(),\n        remove: z.boolean().default(false),\n      })\n      .strict(),\n    returns: {} as { success: true },\n  },\n  'market/:contractId/groups': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({ contractId: z.string() }),\n    returns: [] as LiteGroup[],\n  },\n  'market/:contractId/answer': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { newAnswerId: string },\n    props: z\n      .object({\n        contractId: z.string().max(MAX_ANSWER_LENGTH),\n        text: z.string().min(1).max(MAX_ANSWER_LENGTH),\n      })\n      .strict(),\n  },\n  'market/:contractId/block': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ contractId: z.string() }).strict(),\n  },\n  'market/:contractId/unblock': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ contractId: z.string() }).strict(),\n  },\n  unresolve: {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { success: true },\n    props: z\n      .object({\n        contractId: z.string().max(MAX_ANSWER_LENGTH),\n        answerId: z.string().max(MAX_ANSWER_LENGTH).optional(),\n      })\n      .strict(),\n  },\n  leagues: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as League[],\n    props: z\n      .object({\n        userId: z.string().optional(),\n        cohort: z.string().optional(),\n        season: z.coerce.number().optional(),\n      })\n      .strict(),\n  },\n  markets: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as LiteMarket[],\n    props: z\n      .object({\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n        sort: z\n          .enum([\n            'created-time',\n            'updated-time',\n            'last-bet-time',\n            'last-comment-time',\n          ])\n          .optional(),\n        order: z.enum(['asc', 'desc']).optional(),\n        before: z.string().optional(),\n        userId: z.string().optional(),\n        groupId: z.string().optional(),\n      })\n      .strict(),\n  },\n  'search-markets': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as LiteMarket[],\n    props: searchProps,\n  },\n  'search-markets-full': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    preferAuth: true,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Contract[],\n    props: searchProps,\n  },\n  managram: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        amount: z.number().finite(),\n        toIds: z.array(z.string()),\n        message: z.string().max(MAX_COMMENT_LENGTH),\n        groupId: z.string().max(MAX_ID_LENGTH).optional(),\n        token: z.enum(['M$', 'CASH']).default('M$'),\n      })\n      .strict(),\n  },\n  manalink: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { slug: string },\n    props: z\n      .object({\n        amount: z.number().positive().finite().safe(),\n        expiresTime: z.number().lt(MAX_EXPIRES_AT).optional(),\n        maxUses: z.number().optional(),\n        message: z.string().optional(),\n      })\n      .strict(),\n  },\n  donate: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        amount: z.number().positive().finite().safe(),\n        to: z.string(),\n      })\n      .strict(),\n  },\n  'convert-sp-to-mana': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ amount: z.number().positive().finite().safe() }).strict(),\n  },\n  'convert-cash-to-mana': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ amount: z.number().positive().finite().safe() }).strict(),\n  },\n  'request-loan': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({}),\n    returns: {} as { payout: number },\n  },\n  // deprecated. use /txns instead\n  managrams: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: [] as ManaPayTxn[],\n    props: z\n      .object({\n        toId: z.string().optional(),\n        fromId: z.string().optional(),\n        limit: z.coerce.number().gte(0).lte(100).default(100),\n        before: z.coerce.number().optional(),\n        after: z.coerce.number().optional(),\n      })\n      .strict(),\n  },\n  'market/:id/positions': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as ContractMetric[],\n    props: z\n      .object({\n        id: z.string(),\n        userId: z.string().optional(),\n        answerId: z.string().optional(),\n        summaryOnly: z.boolean().optional(),\n        top: z.undefined().or(z.coerce.number()),\n        bottom: z.undefined().or(z.coerce.number()),\n        order: z.enum(['shares', 'profit']).optional(),\n      })\n      .strict(),\n  },\n  me: {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z.object({}),\n    returns: {} as FullUser,\n  },\n  'me/update': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({\n      name: z.string().trim().min(1).optional(),\n      username: z.string().trim().min(1).optional(),\n      avatarUrl: z.string().optional(),\n      bio: z.string().optional(),\n      website: z.string().optional(),\n      twitterHandle: z.string().optional(),\n      discordHandle: z.string().optional(),\n      // settings\n      optOutBetWarnings: z.boolean().optional(),\n      isAdvancedTrader: z.boolean().optional(),\n      //internal\n      seenStreakModal: z.boolean().optional(),\n      shouldShowWelcome: z.boolean().optional(),\n      hasSeenContractFollowModal: z.boolean().optional(),\n      hasSeenLoanModal: z.boolean().optional(),\n    }),\n    returns: {} as FullUser,\n  },\n  'me/delete': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({\n      username: z.string(), // just so you're sure\n    }),\n  },\n  'me/private': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z.object({}),\n    returns: {} as PrivateUser,\n  },\n  'me/private/update': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    props: z\n      .object({\n        email: z.string().email().optional(),\n        apiKey: z.string().optional(),\n        pushToken: z.string().optional(),\n        rejectedPushNotificationsOn: z.number().optional(),\n        lastPromptedToEnablePushNotifications: z.number().optional(),\n        interestedInPushNotifications: z.boolean().optional(),\n        hasSeenAppBannerInNotificationsOn: z.number().optional(),\n        installedAppPlatforms: z.array(z.string()).optional(),\n        paymentInfo: z.string().optional(),\n        lastAppReviewTime: z.number().optional(),\n      })\n      .strict(),\n  },\n  'user/:username': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as FullUser,\n    props: z.object({ username: z.string() }).strict(),\n  },\n  'user/:username/lite': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as DisplayUser,\n    props: z.object({ username: z.string() }).strict(),\n  },\n  'user/by-id/:id': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    // Do not add a caching strategy here. New users need up-to-date data.\n    returns: {} as FullUser,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'user/by-id/:id/lite': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as DisplayUser,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'users/by-id': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as DisplayUser[],\n    props: z.object({ ids: z.array(z.string()) }).strict(),\n  },\n  'users/by-id/balance': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as { id: string; balance: number }[],\n    props: z.object({ ids: z.array(z.string()) }).strict(),\n  },\n  'user/by-id/:id/block': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'user/by-id/:id/unblock': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  users: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as FullUser[],\n    props: z\n      .object({\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n        before: z.string().optional(),\n      })\n      .strict(),\n  },\n  'search-users': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as FullUser[],\n    props: z\n      .object({\n        term: z.string(),\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n        page: z.coerce.number().gte(0).default(0),\n      })\n      .strict(),\n  },\n  'search-contract-positions': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as DisplayUser[],\n    props: z\n      .object({\n        term: z.string(),\n        contractId: z.string(),\n        limit: z.coerce.number().gte(0).lte(100).default(10),\n      })\n      .strict(),\n  },\n  'save-twitch': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        twitchInfo: z.object({\n          twitchName: z.string().optional(),\n          controlToken: z.string().optional(),\n          botEnabled: z.boolean().optional(),\n          needsRelinking: z.boolean().optional(),\n        }),\n      })\n      .strict(),\n  },\n  'set-push-token': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({ pushToken: z.string() }).strict(),\n  },\n  'update-notif-settings': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      type: z.string() as z.ZodType<notification_preference>,\n      medium: z.enum(['email', 'browser', 'mobile']),\n      enabled: z.boolean(),\n    }),\n  },\n  headlines: {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: [] as Headline[],\n    props: z.object({\n      slug: z.enum(['politics', 'ai', 'news']).optional(),\n    }),\n  },\n  'politics-headlines': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: [] as Headline[],\n    props: z.object({}),\n  },\n  'set-news': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { success: true },\n    props: z\n      .object({\n        dashboardIds: z.array(z.string()),\n        endpoint: z.enum(['politics', 'ai', 'news']),\n      })\n      .strict(),\n  },\n  react: {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        contentId: z.string(),\n        contentType: z.enum(['comment', 'contract', 'post']),\n        commentParentType: z.enum(['post']).optional(),\n        remove: z.boolean().optional(),\n        reactionType: z.enum(['like', 'dislike']).optional().default('like'),\n      })\n      .strict(),\n    returns: { success: true },\n  },\n  'compatible-lovers': {\n    method: 'GET',\n    visibility: 'private',\n    authed: false,\n    props: z.object({ userId: z.string() }),\n    returns: {} as {\n      lover: Lover\n      compatibleLovers: Lover[]\n      loverCompatibilityScores: {\n        [userId: string]: CompatibilityScore\n      }\n    },\n  },\n  post: {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    returns: {} as ContractComment,\n    props: z\n      .object({\n        contractId: z.string(),\n        betId: z.string().optional(),\n        commentId: z.string().optional(),\n        content: contentSchema.optional(),\n      })\n      .strict(),\n  },\n  'fetch-link-preview': {\n    method: 'GET',\n    visibility: 'private',\n    authed: false,\n    props: z.object({ url: z.string() }).strict(),\n    cache: 'max-age=86400, stale-while-revalidate=86400',\n    returns: {} as LinkPreview,\n  },\n  'remove-pinned-photo': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    returns: { success: true },\n    props: z\n      .object({\n        userId: z.string(),\n      })\n      .strict(),\n  },\n  'get-related-markets': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    props: z\n      .object({\n        contractId: z.string(),\n        limit: z.coerce.number().gte(0).lte(100),\n        userId: z.string().optional(),\n        question: z.string().optional(),\n        uniqueBettorCount: z.coerce.number().gte(0).optional(),\n      })\n      .strict(),\n    returns: {} as {\n      marketsFromEmbeddings: Contract[]\n    },\n    cache: 'public, max-age=3600, stale-while-revalidate=10',\n  },\n  'get-related-markets-by-group': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: 'public, max-age=3600, stale-while-revalidate=10',\n    returns: {} as {\n      groupContracts: Contract[]\n    },\n    props: z\n      .object({\n        contractId: z.string(),\n        limit: z.coerce.number().gte(0).lte(100),\n        offset: z.coerce.number().gte(0),\n      })\n      .strict(),\n  },\n  'unlist-and-cancel-user-contracts': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        userId: z.string(),\n      })\n      .strict(),\n  },\n  'get-boost-analytics': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: false,\n    props: z\n      .object({\n        contractId: z.string(),\n      })\n      .strict(),\n    returns: {} as {\n      uniqueViewers: number\n      totalViews: number\n      uniquePromotedViewers: number\n      totalPromotedViews: number\n      boostPeriods: {\n        startTime: string\n        endTime: string\n      }[]\n    },\n  },\n  'get-seen-market-ids': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      contractIds: z.array(z.string()),\n      types: z.array(z.enum(['page', 'card', 'promoted'])).optional(),\n      since: z.number(),\n    }),\n    returns: [] as string[],\n  },\n  'get-compatibility-questions': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({}),\n    returns: {} as {\n      status: 'success'\n      questions: (Row<'love_questions'> & {\n        answer_count: number\n        score: number\n      })[]\n    },\n  },\n  'like-lover': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    props: z.object({\n      targetUserId: z.string(),\n      remove: z.boolean().optional(),\n    }),\n    returns: {} as {\n      status: 'success'\n    },\n  },\n  'ship-lovers': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    props: z.object({\n      targetUserId1: z.string(),\n      targetUserId2: z.string(),\n      remove: z.boolean().optional(),\n    }),\n    returns: {} as {\n      status: 'success'\n    },\n  },\n\n  'get-likes-and-ships': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z\n      .object({\n        userId: z.string(),\n      })\n      .strict(),\n    returns: {} as {\n      status: 'success'\n      likesReceived: LikeData[]\n      likesGiven: LikeData[]\n      ships: ShipData[]\n    },\n  },\n  'has-free-like': {\n    method: 'GET',\n    visibility: 'private',\n    authed: true,\n    props: z.object({}).strict(),\n    returns: {} as {\n      status: 'success'\n      hasFreeLike: boolean\n    },\n  },\n  'star-lover': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    props: z.object({\n      targetUserId: z.string(),\n      remove: z.boolean().optional(),\n    }),\n    returns: {} as {\n      status: 'success'\n    },\n  },\n  'get-lovers': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({}).strict(),\n    returns: {} as {\n      status: 'success'\n      lovers: Lover[]\n    },\n  },\n  'get-lover-answers': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({ userId: z.string() }).strict(),\n    returns: {} as {\n      status: 'success'\n      answers: Row<'love_compatibility_answers'>[]\n    },\n  },\n  'search-groups': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    // Is there a way to infer return { lite:[] as LiteGroup[] } if type is 'lite'?\n    returns: {\n      full: [] as Group[],\n      lite: [] as LiteGroup[],\n    },\n    props: SearchGroupParams(SearchGroupShape),\n  },\n  'search-my-groups': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {\n      full: [] as Group[],\n      lite: [] as LiteGroup[],\n    },\n    props: SearchGroupParams(MySearchGroupShape),\n  },\n  'get-groups-with-top-contracts': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as { topic: Topic; contracts: Contract[] }[],\n    props: z.object({}),\n  },\n  'get-balance-changes': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: [] as AnyBalanceChangeType[],\n    props: z\n      .object({\n        before: z.coerce.number().optional(),\n        after: z.coerce.number().default(0),\n        userId: z.string(),\n      })\n      .strict(),\n  },\n  'get-partner-stats': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z\n      .object({\n        userId: z.string(),\n      })\n      .strict(),\n    returns: {} as {\n      status: 'success' | 'error'\n      username: string\n      numContractsCreated: number\n      numUniqueBettors: number\n      numReferrals: number\n      numReferralsWhoRetained: number\n      totalTraderIncome: number\n      totalReferralIncome: number\n      dollarsEarned: number\n    },\n  },\n  'record-contract-view': {\n    method: 'POST',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      userId: z.string().optional(),\n      contractId: z.string(),\n      kind: z.enum(['page', 'card', 'promoted']),\n    }),\n    returns: {} as { status: 'success' },\n  },\n  'record-comment-view': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({\n      contractId: z.string(),\n      commentId: z.string(),\n    }),\n    returns: {} as { status: 'success' },\n  },\n  'record-contract-interaction': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({\n      contractId: z.string(),\n      kind: z.enum([\n        'page bet',\n        'page comment',\n        'page repost',\n        'page like',\n        'card bet',\n        'card click',\n        'promoted click',\n        'card like',\n        'page share',\n        'browse click',\n      ]),\n      commentId: z.string().optional(),\n      feedReasons: z.array(z.string()).optional(),\n      feedType: z.string().optional(),\n      betGroupId: z.string().optional(),\n      betId: z.string().optional(),\n    }),\n    returns: {} as { status: 'success' },\n  },\n  'get-dashboard-from-slug': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      dashboardSlug: z.string(),\n    }),\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as Dashboard,\n  },\n  'get-posts': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    preferAuth: true,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z\n      .object({\n        sortBy: z\n          .enum(['created_time', 'importance_score'])\n          .optional()\n          .default('created_time'),\n        term: z.string().optional(),\n        limit: z.coerce.number().gte(0).lte(200).default(100),\n        userId: z.string().optional(),\n        offset: z.coerce.number().gte(0).default(0),\n      })\n      .strict(),\n    returns: [] as TopLevelPost[],\n  },\n  'create-public-chat-message': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as ChatMessage,\n    props: z.object({\n      content: contentSchema,\n      channelId: z.string(),\n    }),\n  },\n  'get-followed-groups': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      userId: z.string(),\n    }),\n    returns: {} as {\n      groups: Group[]\n    },\n  },\n  'get-user-portfolio': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      userId: z.string(),\n    }),\n    returns: {} as LivePortfolioMetrics,\n  },\n  'get-user-portfolio-history': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      userId: z.string(),\n      period: z.enum(PERIODS),\n    }),\n    returns: {} as PortfolioMetrics[],\n  },\n  'get-channel-memberships': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      channelId: z.coerce.number().optional(),\n      createdTime: z.string().optional(),\n      lastUpdatedTime: z.string().optional(),\n      limit: z.coerce.number(),\n    }),\n    returns: {\n      channels: [] as PrivateMessageChannel[],\n      memberIdsByChannelId: {} as { [channelId: string]: string[] },\n    },\n  },\n  'get-channel-messages': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      channelId: z.coerce.number(),\n      limit: z.coerce.number(),\n      id: z.coerce.number().optional(),\n    }),\n    returns: [] as PrivateChatMessage[],\n  },\n  'get-channel-seen-time': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      channelIds: z.array(z.coerce.number()),\n    }),\n    returns: [] as [number, string][],\n  },\n  'set-channel-seen-time': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      channelId: z.coerce.number(),\n    }),\n  },\n  'get-feed': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as {\n      contracts: Contract[]\n      comments: ContractComment[]\n      bets: Bet[]\n      reposts: Repost[]\n      idsToReason: { [id: string]: string }\n    },\n    props: z\n      .object({\n        userId: z.string(),\n        limit: z.coerce.number().gt(0).lte(100).default(100),\n        offset: z.coerce.number().gte(0).default(0),\n        ignoreContractIds: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'get-mana-supply': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as ManaSupply,\n    props: z.object({}).strict(),\n  },\n  'get-notifications': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as Notification[],\n    props: z\n      .object({\n        after: z.coerce.number().optional(),\n        limit: z.coerce.number().gte(0).lte(1000).default(100),\n      })\n      .strict(),\n  },\n  'update-mod-report': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        reportId: z.number(),\n        updates: z\n          .object({\n            status: z\n              .enum(['new', 'under review', 'resolved', 'needs admin'])\n              .optional(),\n            mod_note: z.string().optional(),\n          })\n          .partial(),\n      })\n      .strict(),\n    returns: {} as { status: string; report: ModReport },\n  },\n  'get-mod-reports': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        statuses: z.array(\n          z.enum(['new', 'under review', 'resolved', 'needs admin'])\n        ),\n        limit: z.coerce.number().gte(0).lte(100).default(25),\n        offset: z.coerce.number().gte(0).default(0),\n        count: coerceBoolean.optional(),\n      })\n      .strict(),\n    returns: {} as {\n      status: string\n      count?: number\n      reports: ModReport[]\n    },\n  },\n  'get-txn-summary-stats': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as Row<'txn_summary_stats'>[],\n    props: z\n      .object({\n        ignoreCategories: z.array(z.string()).optional(),\n        fromType: z.string().optional(),\n        toType: z.string().optional(),\n        limitDays: z.coerce.number(),\n      })\n      .strict(),\n  },\n  'get-mana-summary-stats': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as Row<'mana_supply_stats'>[],\n    props: z\n      .object({\n        limitDays: z.coerce.number(),\n      })\n      .strict(),\n  },\n  'register-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: verificationParams,\n    returns: {} as RegistrationReturnType,\n  },\n  'get-verification-status-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      documents?: GIDXDocument[]\n      message?: string\n      documentStatus?: string\n    },\n    props: z.object({}),\n  },\n  'get-monitor-status-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n    },\n    props: z.object({\n      DeviceGPS: GPSProps,\n    }),\n  },\n  'get-checkout-session-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n      session?: CheckoutSession\n    },\n    props: z.object({\n      PayActionCode: z.enum(['PAY', 'PAYOUT']).default('PAY'),\n      DeviceGPS: GPSProps,\n      userId: z.string().optional(),\n      ip: z.string().optional(),\n    }),\n  },\n  'complete-checkout-session-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n      gidxMessage?: string | null\n      details?: PaymentDetail[]\n    },\n    props: z.object(checkoutParams),\n  },\n  'complete-cashout-session-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n      gidxMessage?: string | null\n      details?: PaymentDetail[]\n    },\n    props: z.object(cashoutParams),\n  },\n  'complete-cashout-request': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n      gidxMessage?: string | null\n      details?: PaymentDetail[]\n    },\n    props: z.object(cashoutRequestParams),\n  },\n  'get-verification-documents-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      documents: GIDXDocument[]\n      utilityDocuments: GIDXDocument[]\n      idDocuments: GIDXDocument[]\n      rejectedDocuments: GIDXDocument[]\n    },\n    props: z.object({}),\n  },\n  'upload-document-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { status: string },\n    props: z.object({\n      CategoryType: z.number().gte(1).lte(7),\n      fileName: z.string(),\n      fileUrl: z.string(),\n    }),\n  },\n  'identity-callback-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as { Accepted: boolean },\n    props: z.object({\n      MerchantCustomerID: z.string(),\n      NotificationType: z.string(),\n    }),\n  },\n  'payment-callback-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as { MerchantTransactionID: string },\n    props: z\n      .object({\n        MerchantTransactionID: z.string(),\n        TransactionStatusCode: z.coerce.number(),\n        TransactionStatusMessage: z.string(),\n        StatusCode: z.coerce.number(),\n        SessionID: z.string(),\n        MerchantSessionID: z.string(),\n        SessionScore: z.coerce.number(),\n        ReasonCodes: z.array(z.string()).optional(),\n        ServiceType: z.string(),\n        StatusMessage: z.string(),\n      })\n      .strict(),\n  },\n  'get-best-comments': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { comments: ContractComment[]; contracts: Contract[] },\n    props: z.object({\n      limit: z.coerce.number().gte(0).lte(100).default(20),\n      offset: z.coerce.number().gte(0).default(0),\n      ignoreContractIds: z.array(z.string()).optional(),\n      justLikes: z.coerce.number().optional(),\n    }),\n  },\n  'get-redeemable-prize-cash': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { redeemablePrizeCash: number },\n    props: z.object({}),\n  },\n  'get-total-redeemable-prize-cash': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as { total: number },\n    props: z.object({}),\n  },\n  'get-cashouts': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as PendingCashoutStatusData[],\n    props: z\n      .object({\n        limit: z.coerce.number().gte(0).lte(100).default(10),\n        offset: z.coerce.number().gte(0).default(0),\n        userId: z.string().optional(),\n      })\n      .strict(),\n  },\n  'get-kyc-stats': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({}),\n    returns: {} as {\n      initialVerifications: {\n        count: number\n        day: string\n      }[]\n      phoneVerifications: {\n        count: number\n        day: string\n      }[]\n    },\n  },\n  txns: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z\n      .object({\n        token: z.string().optional(),\n        offset: z.coerce.number().default(0),\n        limit: z.coerce.number().gte(0).lte(100).default(100),\n        before: z.coerce.number().optional(),\n        after: z.coerce.number().optional(),\n        toId: z.string().optional(),\n        fromId: z.string().optional(),\n        category: z.string().optional(),\n        ignoreCategories: z.array(z.string()).optional(),\n      })\n      .strict(),\n    returns: [] as Txn[],\n  },\n  'generate-ai-market-suggestions': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: [] as AIGeneratedMarket[],\n    props: z\n      .object({\n        prompt: z.string(),\n        existingTitles: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'generate-ai-market-suggestions-2': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: [] as AIGeneratedMarket[],\n    props: z\n      .object({\n        prompt: z.string(),\n        existingTitles: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'generate-ai-description': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { description: JSONContent | undefined },\n    props: z\n      .object({\n        question: z.string(),\n        description: z.string().optional(),\n        answers: z.array(z.string()).optional(),\n        outcomeType: z.string().optional(),\n        shouldAnswersSumToOne: coerceBoolean.optional(),\n        addAnswersMode: z\n          .enum(['DISABLED', 'ONLY_CREATOR', 'ANYONE'])\n          .optional(),\n      })\n      .strict(),\n  },\n  'generate-ai-answers': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as {\n      answers: string[]\n      addAnswersMode: 'DISABLED' | 'ONLY_CREATOR' | 'ANYONE'\n    },\n    props: z\n      .object({\n        question: z.string(),\n        answers: z.array(z.string()),\n        shouldAnswersSumToOne: coerceBoolean,\n        description: z.string().optional(),\n      })\n      .strict(),\n  },\n  'get-monthly-bets-2024': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ userId: z.string() }),\n    returns: [] as { month: string; bet_count: number; total_amount: number }[],\n  },\n  'get-max-min-profit-2024': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ userId: z.string() }),\n    returns: [] as {\n      profit: number\n      data: Contract\n      answer_id: string | null\n      has_no_shares: boolean\n      has_yes_shares: boolean\n    }[],\n  },\n  'get-next-loan-amount': {\n    method: 'GET',\n    visibility: 'undocumented',\n    cache: DEFAULT_CACHE_STRATEGY,\n    authed: false,\n    returns: {} as { amount: number },\n    props: z.object({\n      userId: z.string(),\n    }),\n  },\n  'create-task': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as Task,\n    props: z\n      .object({\n        text: z.string(),\n        category_id: z.number().optional(),\n        priority: z.number().default(0),\n        assignee_id: z.string().optional(),\n      })\n      .strict(),\n  },\n  'update-task': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z\n      .object({\n        id: z.number(),\n        text: z.string().optional(),\n        completed: z.boolean().optional(),\n        priority: z.number().optional(),\n        category_id: z.number().optional(),\n        archived: z.boolean().optional(),\n        assignee_id: z.string().optional(),\n      })\n      .strict(),\n  },\n  'create-category': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { id: number },\n    props: z\n      .object({\n        name: z.string(),\n        color: z.string().optional(),\n        displayOrder: z.number().optional(),\n      })\n      .strict(),\n  },\n  'get-categories': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { categories: TaskCategory[] },\n    props: z.object({}).strict(),\n  },\n  'update-category': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z\n      .object({\n        categoryId: z.number(),\n        name: z.string().optional(),\n        color: z.string().optional(),\n        displayOrder: z.number().optional(),\n        archived: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  'get-tasks': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { tasks: Task[] },\n    props: z.object({}).strict(),\n  },\n  'is-sports-interested': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { isSportsInterested: boolean },\n    props: z.object({}).strict(),\n  },\n  'get-site-activity': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as {\n      bets: Bet[]\n      comments: CommentWithTotalReplies[]\n      newContracts: Contract[]\n      relatedContracts: Contract[]\n    },\n    props: z\n      .object({\n        limit: z.coerce.number().default(10),\n        offset: z.coerce.number().default(0),\n        blockedUserIds: z.array(z.string()).optional(),\n        blockedGroupSlugs: z.array(z.string()).optional(),\n        blockedContractIds: z.array(z.string()).optional(),\n        topicIds: z.array(z.string()).optional(),\n        types: z\n          .array(z.enum(['bets', 'comments', 'markets', 'limit-orders']))\n          .optional(),\n        minBetAmount: z.coerce.number().optional(),\n        onlyFollowedTopics: coerceBoolean.optional(),\n        onlyFollowedContracts: coerceBoolean.optional(),\n        onlyFollowedUsers: coerceBoolean.optional(),\n        userId: z.string().optional(),\n      })\n      .strict(),\n  },\n  'get-sports-games': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { schedule: any[] },\n    props: z.object({}).strict(),\n  },\n  'get-market-props': {\n    method: 'GET',\n    visibility: 'public',\n    cache: DEFAULT_CACHE_STRATEGY,\n    // Could set authed false and preferAuth with an api secret if we want it to replace static props\n    authed: true,\n    returns: {} as {\n      manaContract: MarketContract\n      chartAnnotations: ChartAnnotation[]\n      topics: Topic[]\n      comments: ContractComment[]\n      pinnedComments: ContractComment[]\n      userPositionsByOutcome: {\n        YES: ContractMetric[]\n        NO: ContractMetric[]\n      }\n      topContractMetrics: ContractMetric[]\n      totalPositions: number\n      dashboards: Dashboard[]\n      cashContract: MarketContract\n      totalManaBets: number\n      totalCashBets: number\n    },\n    props: z.object({\n      slug: z.string().optional(),\n      id: z.string().optional(),\n    }),\n  },\n  'get-user-contract-metrics-with-contracts': {\n    method: 'GET',\n    visibility: 'public',\n    preferAuth: true,\n    authed: false,\n    returns: {} as {\n      metricsByContract: Dictionary<ContractMetric[]>\n      contracts: MarketContract[]\n    },\n    props: z.object({\n      userId: z.string(),\n      limit: z.coerce.number(),\n      offset: z.coerce.number().gte(0).optional(),\n      perAnswer: coerceBoolean.optional(),\n      inMani: coerceBoolean.optional(),\n    }),\n  },\n  validateIap: {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z.object({\n      receipt: z.string(),\n    }),\n  },\n  'check-sports-event': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as { exists: boolean; existingMarket?: LiteMarket },\n    props: z\n      .object({\n        sportsEventId: z.string(),\n      })\n      .strict(),\n  },\n  'comment-reactions': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Reaction[],\n    props: z\n      .object({\n        contentIds: z.array(z.string()),\n        contentType: z.enum(['comment', 'contract']),\n      })\n      .strict(),\n  },\n  'mark-all-notifications-new': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({}).strict(),\n    returns: {} as { success: boolean },\n  },\n  'get-contract-voters': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        contractId: z.string(),\n      })\n      .strict(),\n    returns: [] as DisplayUser[],\n  },\n  'get-contract-option-voters': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ contractId: z.string(), optionId: z.string() }),\n    returns: [] as DisplayUser[],\n  },\n  'purchase-contract-boost': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        contractId: z.string(),\n        startTime: z.number().positive().finite().safe(),\n        method: z.enum(['mana', 'cash']),\n      })\n      .strict(),\n    returns: {} as { success: boolean; checkoutUrl?: string },\n  },\n  'generate-ai-numeric-ranges': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as {\n      thresholds: { answers: string[]; midpoints: number[] }\n      buckets: { answers: string[]; midpoints: number[] }\n    },\n    props: z\n      .object({\n        question: z.string(),\n        min: z.number(),\n        max: z.number(),\n        description: z.string().optional(),\n        unit: z.string(),\n      })\n      .strict(),\n  },\n  'infer-numeric-unit': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as {\n      unit: string\n    },\n    props: z\n      .object({\n        question: z.string(),\n        description: z.string().optional(),\n      })\n      .strict(),\n  },\n  'generate-ai-date-ranges': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as {\n      buckets: { answers: string[]; midpoints: number[] }\n      thresholds: { answers: string[]; midpoints: number[] }\n    },\n    props: z\n      .object({\n        question: z.string(),\n        min: z.string(),\n        max: z.string(),\n        description: z.string().optional(),\n      })\n      .strict(),\n  },\n  'regenerate-numeric-midpoints': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { midpoints: number[] },\n    props: z\n      .object({\n        description: z.string().optional(),\n        question: z.string(),\n        answers: z.array(z.string()),\n        min: z.number(),\n        max: z.number(),\n        unit: z.string(),\n        tab: z.enum(['thresholds', 'buckets']),\n      })\n      .strict(),\n  },\n  'regenerate-date-midpoints': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { midpoints: number[] },\n    props: z\n      .object({\n        description: z.string().optional(),\n        question: z.string(),\n        answers: z.array(z.string()),\n        min: z.string(),\n        max: z.string(),\n        tab: z.enum(['thresholds', 'buckets']),\n      })\n      .strict(),\n  },\n\n  'generate-concise-title': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        question: z.string(),\n      })\n      .strict(),\n    returns: {} as { title: string },\n  },\n  'get-close-date': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        question: z.string(),\n        utcOffset: z.number().optional(),\n      })\n      .strict(),\n    returns: {} as { closeTime: number },\n  },\n  'refer-user': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        referredByUsername: z.string(),\n        contractId: z.string().optional(),\n      })\n      .strict(),\n    returns: {} as { success: boolean },\n  },\n\n  'save-market-draft': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { id: number },\n    props: z\n      .object({\n        data: z.object({\n          question: z.string(),\n          description: z.any().optional(),\n          outcomeType: z.string(),\n          answers: z.array(z.string()).optional(),\n          closeDate: z.string().optional(),\n          closeHoursMinutes: z.string().optional(),\n          visibility: z.string(),\n          selectedGroups: z.array(z.any()),\n          savedAt: z.number(),\n        }),\n      })\n      .strict(),\n  },\n\n  'get-market-drafts': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: [] as MarketDraft[],\n    props: z.object({}).strict(),\n  },\n\n  'delete-market-draft': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z\n      .object({\n        id: z.coerce.number(),\n      })\n      .strict(),\n  },\n  'get-season-info': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      season: z.coerce.number().int().positive().optional(),\n    }),\n    returns: {} as {\n      season: number\n      startTime: number // epoch ms\n      endTime: number | null // epoch ms, null if a *mystery* for clients\n      status: 'active' | 'processing' | 'complete'\n    },\n  },\n  'mark-notification-read': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z\n      .object({\n        notificationId: z.string(),\n      })\n      .strict(),\n  },\n  'dismiss-user-report': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        reportId: z.string(),\n      })\n      .strict(),\n    returns: {} as { success: boolean },\n  },\n  'create-post': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { post: TopLevelPost },\n    props: z\n      .object({\n        title: z.string().min(1).max(120),\n        content: contentSchema,\n        isAnnouncement: z.boolean().optional(),\n        visibility: z.enum(['public', 'unlisted']).optional(),\n      })\n      .strict(),\n  },\n  'update-post': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { post: TopLevelPost },\n    props: z\n      .object({\n        id: z.string(),\n        title: z.string().min(1).max(480).optional(),\n        content: contentSchema.optional(),\n        visibility: z.enum(['public', 'unlisted']).optional(),\n      })\n      .strict(),\n  },\n  'create-post-comment': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { comment: PostComment },\n    props: z\n      .object({\n        postId: z.string(),\n        content: contentSchema,\n        replyToCommentId: z.string().optional(),\n      })\n      .strict(),\n  },\n  'update-post-comment': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { comment: PostComment },\n    props: z\n      .object({\n        commentId: z.string(),\n        postId: z.string(),\n        hidden: z.boolean().optional(),\n      })\n      .strict(),\n  },\n} as const)\n\nexport type APIPath = keyof typeof API\nexport type APISchema<N extends APIPath> = (typeof API)[N]\n\nexport type APIParams<N extends APIPath> = z.input<APISchema<N>['props']>\nexport type ValidatedAPIParams<N extends APIPath> = z.output<\n  APISchema<N>['props']\n>\n\nexport type APIResponse<N extends APIPath> = APISchema<N> extends {\n  returns: Record<string, any>\n}\n  ? APISchema<N>['returns']\n  : void\n\nexport type APIResponseOptionalContinue<N extends APIPath> =\n  | { continue: () => Promise<void>; result: APIResponse<N> }\n  | APIResponse<N>\n"
        },
        {
          "path": "common/src/supabase/schema.ts",
          "preContent": "export type Json =\n  | string\n  | number\n  | boolean\n  | null\n  | { [key: string]: Json | undefined }\n  | Json[]\n\nexport type Database = {\n  public: {\n    Tables: {\n      answers: {\n        Row: {\n          color: string | null\n          contract_id: string | null\n          created_time: string | null\n          id: string\n          index: number | null\n          is_other: boolean\n          pool_no: number | null\n          pool_yes: number | null\n          prob: number | null\n          prob_change_day: number | null\n          prob_change_month: number | null\n          prob_change_week: number | null\n          resolution: string | null\n          resolution_probability: number | null\n          resolution_time: string | null\n          resolver_id: string | null\n          subsidy_pool: number | null\n          text: string | null\n          text_fts: unknown | null\n          total_liquidity: number | null\n          user_id: string | null\n          image_url: string | null\n          short_text: string | null\n          midpoint: number | null\n        }\n        Insert: {\n          color?: string | null\n          contract_id?: string | null\n          created_time?: string | null\n          id?: string\n          index?: number | null\n          is_other?: boolean\n          pool_no?: number | null\n          pool_yes?: number | null\n          prob?: number | null\n          prob_change_day?: number | null\n          prob_change_month?: number | null\n          prob_change_week?: number | null\n          resolution?: string | null\n          resolution_probability?: number | null\n          resolution_time?: string | null\n          resolver_id?: string | null\n          subsidy_pool?: number | null\n          text?: string | null\n          text_fts?: unknown | null\n          total_liquidity?: number | null\n          user_id?: string | null\n          image_url?: string | null\n          short_text?: string | null\n          midpoint?: number | null\n        }\n        Update: {\n          color?: string | null\n          contract_id?: string | null\n          created_time?: string | null\n          id?: string\n          index?: number | null\n          is_other?: boolean\n          pool_no?: number | null\n          pool_yes?: number | null\n          prob?: number | null\n          prob_change_day?: number | null\n          prob_change_month?: number | null\n          prob_change_week?: number | null\n          resolution?: string | null\n          resolution_probability?: number | null\n          resolution_time?: string | null\n          resolver_id?: string | null\n          subsidy_pool?: number | null\n          text?: string | null\n          text_fts?: unknown | null\n          total_liquidity?: number | null\n          user_id?: string | null\n          image_url?: string | null\n          short_text?: string | null\n          midpoint?: number | null\n        }\n        Relationships: []\n      }\n      audit_events: {\n        Row: {\n          comment_id: string | null\n          contract_id: string | null\n          created_time: string\n          data: Json | null\n          id: number\n          name: string\n          user_id: string\n        }\n        Insert: {\n          comment_id?: string | null\n          contract_id?: string | null\n          created_time?: string\n          data?: Json | null\n          id?: never\n          name: string\n          user_id: string\n        }\n        Update: {\n          comment_id?: string | null\n          contract_id?: string | null\n          created_time?: string\n          data?: Json | null\n          id?: never\n          name?: string\n          user_id?: string\n        }\n        Relationships: []\n      }\n      chart_annotations: {\n        Row: {\n          answer_id: string | null\n          comment_id: string | null\n          contract_id: string\n          created_time: string\n          creator_avatar_url: string\n          creator_id: string\n          creator_name: string\n          creator_username: string\n          down_votes: number\n          event_time: number\n          external_url: string | null\n          id: number\n          prob_change: number | null\n          text: string | null\n          thumbnail_url: string | null\n          up_votes: number\n          user_id: string | null\n        }\n        Insert: {\n          answer_id?: string | null\n          comment_id?: string | null\n          contract_id: string\n          created_time?: string\n          creator_avatar_url: string\n          creator_id: string\n          creator_name: string\n          creator_username: string\n          down_votes?: number\n          event_time: number\n          external_url?: string | null\n          id?: never\n          prob_change?: number | null\n          text?: string | null\n          thumbnail_url?: string | null\n          up_votes?: number\n          user_id?: string | null\n        }\n        Update: {\n          answer_id?: string | null\n          comment_id?: string | null\n          contract_id?: string\n          created_time?: string\n          creator_avatar_url?: string\n          creator_id?: string\n          creator_name?: string\n          creator_username?: string\n          down_votes?: number\n          event_time?: number\n          external_url?: string | null\n          id?: never\n          prob_change?: number | null\n          text?: string | null\n          thumbnail_url?: string | null\n          up_votes?: number\n          user_id?: string | null\n        }\n        Relationships: []\n      }\n      chat_messages: {\n        Row: {\n          channel_id: string\n          content: Json\n          created_time: string\n          id: number\n          user_id: string\n        }\n        Insert: {\n          channel_id: string\n          content: Json\n          created_time?: string\n          id?: number\n          user_id: string\n        }\n        Update: {\n          channel_id?: string\n          content?: Json\n          created_time?: string\n          id?: number\n          user_id?: string\n        }\n        Relationships: []\n      }\n      contract_bets: {\n        Row: {\n          amount: number | null\n          answer_id: string | null\n          bet_id: string\n          contract_id: string\n          created_time: string\n          data: Json\n          expires_at: string | null\n          is_api: boolean | null\n          is_cancelled: boolean | null\n          is_filled: boolean | null\n          is_redemption: boolean | null\n          loan_amount: number | null\n          outcome: string | null\n          prob_after: number | null\n          prob_before: number | null\n          shares: number | null\n          updated_time: string\n          user_id: string\n        }\n        Insert: {\n          amount?: number | null\n          answer_id?: string | null\n          bet_id?: string\n          contract_id: string\n          created_time?: string\n          data: Json\n          expires_at?: string | null\n          is_api?: boolean | null\n          is_cancelled?: boolean | null\n          is_filled?: boolean | null\n          is_redemption?: boolean | null\n          loan_amount?: number | null\n          outcome?: string | null\n          prob_after?: number | null\n          prob_before?: number | null\n          shares?: number | null\n          updated_time?: string\n          user_id: string\n        }\n        Update: {\n          amount?: number | null\n          answer_id?: string | null\n          bet_id?: string\n          contract_id?: string\n          created_time?: string\n          data?: Json\n          expires_at?: string | null\n          is_api?: boolean | null\n          is_cancelled?: boolean | null\n          is_filled?: boolean | null\n          is_redemption?: boolean | null\n          loan_amount?: number | null\n          outcome?: string | null\n          prob_after?: number | null\n          prob_before?: number | null\n          shares?: number | null\n          updated_time?: string\n          user_id?: string\n        }\n        Relationships: []\n      }\n      contract_boosts: {\n        Row: {\n          contract_id: string\n          end_time: string\n          id: number\n          start_time: string\n          user_id: string\n        }\n        Insert: {\n          contract_id: string\n          end_time: string\n          id?: never\n          start_time: string\n          user_id: string\n        }\n        Update: {\n          contract_id?: string\n          end_time?: string\n          id?: never\n          start_time?: string\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'contract_boosts_contract_id_fkey'\n            columns: ['contract_id']\n            isOneToOne: false\n            referencedRelation: 'contracts'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'contract_boosts_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'user_referrals_profit'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'contract_boosts_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'users'\n            referencedColumns: ['id']\n          }\n        ]\n      }\n      contract_comment_edits: {\n        Row: {\n          comment_id: string\n          contract_id: string\n          created_time: string\n          data: Json\n          editor_id: string\n          id: number\n        }\n        Insert: {\n          comment_id: string\n          contract_id: string\n          created_time?: string\n          data: Json\n          editor_id: string\n          id?: number\n        }\n        Update: {\n          comment_id?: string\n          contract_id?: string\n          created_time?: string\n          data?: Json\n          editor_id?: string\n          id?: number\n        }\n        Relationships: []\n      }\n      contract_comments: {\n        Row: {\n          comment_id: string\n          contract_id: string\n          created_time: string\n          data: Json\n          downvotes: number | null\n          likes: number\n          upvotes: number | null\n          user_id: string\n          visibility: string | null\n        }\n        Insert: {\n          comment_id: string\n          contract_id: string\n          created_time: string\n          data: Json\n          downvotes?: number | null\n          likes?: number\n          upvotes?: number | null\n          user_id: string\n          visibility?: string | null\n        }\n        Update: {\n          comment_id?: string\n          contract_id?: string\n          created_time?: string\n          data?: Json\n          downvotes?: number | null\n          likes?: number\n          upvotes?: number | null\n          user_id?: string\n          visibility?: string | null\n        }\n        Relationships: []\n      }\n      contract_edits: {\n        Row: {\n          contract_id: string\n          created_time: string\n          data: Json\n          editor_id: string\n          id: number\n          idempotency_key: string | null\n          updated_keys: string[] | null\n        }\n        Insert: {\n          contract_id: string\n          created_time?: string\n          data: Json\n          editor_id: string\n          id?: number\n          idempotency_key?: string | null\n          updated_keys?: string[] | null\n        }\n        Update: {\n          contract_id?: string\n          created_time?: string\n          data?: Json\n          editor_id?: string\n          id?: number\n          idempotency_key?: string | null\n          updated_keys?: string[] | null\n        }\n        Relationships: []\n      }\n      contract_embeddings: {\n        Row: {\n          contract_id: string\n          created_at: string\n          embedding: string\n        }\n        Insert: {\n          contract_id: string\n          created_at?: string\n          embedding: string\n        }\n        Update: {\n          contract_id?: string\n          created_at?: string\n          embedding?: string\n        }\n        Relationships: []\n      }\n      contract_follows: {\n        Row: {\n          contract_id: string\n          created_time: string\n          follow_id: string\n        }\n        Insert: {\n          contract_id: string\n          created_time?: string\n          follow_id: string\n        }\n        Update: {\n          contract_id?: string\n          created_time?: string\n          follow_id?: string\n        }\n        Relationships: []\n      }\n      contract_liquidity: {\n        Row: {\n          contract_id: string\n          data: Json\n          liquidity_id: string\n        }\n        Insert: {\n          contract_id: string\n          data: Json\n          liquidity_id: string\n        }\n        Update: {\n          contract_id?: string\n          data?: Json\n          liquidity_id?: string\n        }\n        Relationships: []\n      }\n      contract_movement_notifications: {\n        Row: {\n          answer_id: string | null\n          contract_id: string\n          created_time: string\n          destination: string\n          id: number\n          user_id: string\n          new_val: number\n          new_val_start_time: string\n          prev_val: number\n          prev_val_start_time: string\n        }\n        Insert: {\n          answer_id?: string | null\n          contract_id: string\n          created_time?: string\n          destination: string\n          id?: never\n          user_id: string\n          new_val: number\n          new_val_start_time?: string\n          prev_val: number\n          prev_val_start_time?: string\n        }\n        Update: {\n          answer_id?: string | null\n          contract_id?: string\n          created_time?: string\n          destination?: string\n          id?: never\n          user_id?: string\n          new_val?: number\n          new_val_start_time?: string\n          prev_val?: number\n          prev_val_start_time?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'fk_contract_id'\n            columns: ['contract_id']\n            isOneToOne: false\n            referencedRelation: 'contracts'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'fk_user_id'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'user_referrals_profit'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'fk_user_id'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'users'\n            referencedColumns: ['id']\n          }\n        ]\n      }\n      contracts: {\n        Row: {\n          close_time: string | null\n          conversion_score: number\n          created_time: string | null\n          creator_id: string | null\n          daily_score: number\n          data: Json\n          deleted: boolean | null\n          description_fts: unknown | null\n          freshness_score: number\n          group_slugs: string[] | null\n          id: string\n          importance_score: number\n          is_spice_payout: boolean | null\n          last_bet_time: string | null\n          last_comment_time: string | null\n          last_updated_time: string | null\n          mechanism: string | null\n          outcome_type: string | null\n          popularity_score: number\n          question: string | null\n          question_fts: unknown | null\n          question_nostop_fts: unknown | null\n          resolution: string | null\n          resolution_probability: number | null\n          resolution_time: string | null\n          slug: string | null\n          tier: string | null\n          token: string\n          unique_bettor_count: number\n          view_count: number\n          visibility: string | null\n          boosted: boolean | null\n        }\n        Insert: {\n          close_time?: string | null\n          conversion_score?: number\n          created_time?: string | null\n          creator_id?: string | null\n          daily_score?: number\n          data: Json\n          deleted?: boolean | null\n          description_fts?: unknown | null\n          freshness_score?: number\n          group_slugs?: string[] | null\n          id: string\n          importance_score?: number\n          is_spice_payout?: boolean | null\n          last_bet_time?: string | null\n          last_comment_time?: string | null\n          last_updated_time?: string | null\n          mechanism?: string | null\n          outcome_type?: string | null\n          popularity_score?: number\n          question?: string | null\n          question_fts?: unknown | null\n          question_nostop_fts?: unknown | null\n          resolution?: string | null\n          resolution_probability?: number | null\n          resolution_time?: string | null\n          slug?: string | null\n          tier?: string | null\n          token?: string\n          unique_bettor_count?: number\n          view_count?: number\n          visibility?: string | null\n          boosted?: boolean | null\n        }\n        Update: {\n          close_time?: string | null\n          conversion_score?: number\n          created_time?: string | null\n          creator_id?: string | null\n          daily_score?: number\n          data?: Json\n          deleted?: boolean | null\n          description_fts?: unknown | null\n          freshness_score?: number\n          group_slugs?: string[] | null\n          id?: string\n          importance_score?: number\n          is_spice_payout?: boolean | null\n          last_bet_time?: string | null\n          last_comment_time?: string | null\n          last_updated_time?: string | null\n          mechanism?: string | null\n          outcome_type?: string | null\n          popularity_score?: number\n          question?: string | null\n          question_fts?: unknown | null\n          question_nostop_fts?: unknown | null\n          resolution?: string | null\n          resolution_probability?: number | null\n          resolution_time?: string | null\n          slug?: string | null\n          tier?: string | null\n          token?: string\n          unique_bettor_count?: number\n          view_count?: number\n          visibility?: string | null\n          boosted?: boolean | null\n        }\n        Relationships: []\n      }\n      creator_portfolio_history: {\n        Row: {\n          fees_earned: number\n          id: number\n          ts: string\n          unique_bettors: number\n          user_id: string\n          views: number\n          volume: number\n        }\n        Insert: {\n          fees_earned: number\n          id?: never\n          ts?: string\n          unique_bettors: number\n          user_id: string\n          views: number\n          volume: number\n        }\n        Update: {\n          fees_earned?: number\n          id?: never\n          ts?: string\n          unique_bettors?: number\n          user_id?: string\n          views?: number\n          volume?: number\n        }\n        Relationships: []\n      }\n      daily_stats: {\n        Row: {\n          activation: number | null\n          active_d1_to_d3: number | null\n          avg_user_actions: number | null\n          bet_amount: number | null\n          bet_count: number | null\n          cash_bet_amount: number | null\n          comment_count: number | null\n          contract_count: number | null\n          d1: number | null\n          d1_bet_3_day_average: number | null\n          d1_bet_average: number | null\n          dau: number | null\n          engaged_users: number | null\n          feed_conversion: number | null\n          m1: number | null\n          mau: number | null\n          nd1: number | null\n          nw1: number | null\n          sales: number | null\n          cash_sales: number | null\n          signups: number | null\n          signups_real: number | null\n          start_date: string\n          w1: number | null\n          dav: number | null\n          wav: number | null\n          mav: number | null\n          wau: number | null\n          topic_daus: Json | null\n          cash_bet_count: number | null\n          cash_d1: number | null\n          cash_w1: number | null\n          cash_m1: number | null\n          cash_dau: number | null\n          cash_wau: number | null\n          cash_mau: number | null\n          cash_comment_count: number | null\n          cash_contract_count: number | null\n          cash_avg_user_actions: number | null\n        }\n        Insert: {\n          activation?: number | null\n          active_d1_to_d3?: number | null\n          avg_user_actions?: number | null\n          bet_amount?: number | null\n          bet_count?: number | null\n          cash_bet_amount?: number | null\n          comment_count?: number | null\n          contract_count?: number | null\n          d1?: number | null\n          d1_bet_3_day_average?: number | null\n          d1_bet_average?: number | null\n          dau?: number | null\n          engaged_users?: number | null\n          feed_conversion?: number | null\n          m1?: number | null\n          mau?: number | null\n          nd1?: number | null\n          nw1?: number | null\n          sales?: number | null\n          cash_sales?: number | null\n          signups?: number | null\n          signups_real?: number | null\n          start_date: string\n          w1?: number | null\n          dav?: number | null\n          wav?: number | null\n          mav?: number | null\n          wau?: number | null\n          topic_daus?: Json | null\n          cash_bet_count?: number | null\n          cash_d1?: number | null\n          cash_w1?: number | null\n          cash_m1?: number | null\n          cash_dau?: number | null\n          cash_wau?: number | null\n          cash_mau?: number | null\n          cash_comment_count?: number | null\n          cash_contract_count?: number | null\n          cash_avg_user_actions?: number | null\n        }\n        Update: {\n          activation?: number | null\n          active_d1_to_d3?: number | null\n          avg_user_actions?: number | null\n          bet_amount?: number | null\n          bet_count?: number | null\n          cash_bet_amount?: number | null\n          comment_count?: number | null\n          contract_count?: number | null\n          d1?: number | null\n          d1_bet_3_day_average?: number | null\n          d1_bet_average?: number | null\n          dau?: number | null\n          engaged_users?: number | null\n          feed_conversion?: number | null\n          m1?: number | null\n          dav?: number | null\n          wav?: number | null\n          mav?: number | null\n          mau?: number | null\n          nd1?: number | null\n          nw1?: number | null\n          sales?: number | null\n          cash_sales?: number | null\n          signups?: number | null\n          signups_real?: number | null\n          start_date?: string\n          w1?: number | null\n          wau?: number | null\n          topic_daus?: Json | null\n          cash_bet_count?: number | null\n          cash_d1?: number | null\n          cash_w1?: number | null\n          cash_m1?: number | null\n          cash_dau?: number | null\n          cash_wau?: number | null\n          cash_mau?: number | null\n          cash_comment_count?: number | null\n          cash_contract_count?: number | null\n          cash_avg_user_actions?: number | null\n        }\n        Relationships: []\n      }\n      dashboard_follows: {\n        Row: {\n          created_time: string | null\n          dashboard_id: string\n          follower_id: string\n        }\n        Insert: {\n          created_time?: string | null\n          dashboard_id: string\n          follower_id: string\n        }\n        Update: {\n          created_time?: string | null\n          dashboard_id?: string\n          follower_id?: string\n        }\n        Relationships: []\n      }\n      dashboard_groups: {\n        Row: {\n          dashboard_id: string\n          group_id: string\n        }\n        Insert: {\n          dashboard_id: string\n          group_id: string\n        }\n        Update: {\n          dashboard_id?: string\n          group_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'dashboard_groups_dashboard_id_fkey'\n            columns: ['dashboard_id']\n            isOneToOne: false\n            referencedRelation: 'dashboards'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_dashboard_groups_group_id_fkey'\n            columns: ['group_id']\n            isOneToOne: false\n            referencedRelation: 'group_role'\n            referencedColumns: ['group_id']\n          },\n          {\n            foreignKeyName: 'public_dashboard_groups_group_id_fkey'\n            columns: ['group_id']\n            isOneToOne: false\n            referencedRelation: 'groups'\n            referencedColumns: ['id']\n          }\n        ]\n      }\n      dashboards: {\n        Row: {\n          ai_importance_score: number\n          created_time: string\n          creator_avatar_url: string\n          creator_id: string\n          creator_name: string\n          creator_username: string\n          id: string\n          importance_score: number\n          items: Json | null\n          politics_importance_score: number\n          slug: string\n          title: string\n          title_fts: unknown | null\n          visibility: string | null\n        }\n        Insert: {\n          ai_importance_score?: number\n          created_time?: string\n          creator_avatar_url: string\n          creator_id: string\n          creator_name: string\n          creator_username: string\n          id?: string\n          importance_score?: number\n          items?: Json | null\n          politics_importance_score?: number\n          slug: string\n          title: string\n          title_fts?: unknown | null\n          visibility?: string | null\n        }\n        Update: {\n          ai_importance_score?: number\n          created_time?: string\n          creator_avatar_url?: string\n          creator_id?: string\n          creator_name?: string\n          creator_username?: string\n          id?: string\n          importance_score?: number\n          items?: Json | null\n          politics_importance_score?: number\n          slug?: string\n          title?: string\n          title_fts?: unknown | null\n          visibility?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'dashboards_creator_id_fkey'\n            columns: ['creator_id']\n            isOneToOne: false\n            referencedRelation: 'user_referrals_profit'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'dashboards_creator_id_fkey'\n            columns: ['creator_id']\n            isOneToOne: false\n            referencedRelation: 'users'\n            referencedColumns: ['id']\n          }\n        ]\n      }\n      delete_after_reading: {\n        Row: {\n          created_time: string\n          data: Json | null\n          id: number\n          user_id: string\n        }\n        Insert: {\n          created_time?: string\n          data?: Json | null\n          id?: never\n          user_id: string\n        }\n        Update: {\n          created_time?: string\n          data?: Json | null\n          id?: never\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'delete_after_reading_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'user_referrals_profit'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'delete_after_reading_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'users'\n            referencedColumns: ['id']\n          }\n        ]\n      }\n      discord_messages_markets: {\n        Row: {\n          channel_id: string\n          last_updated_thread_time: number | null\n          market_id: string\n          market_slug: string\n          message_id: string\n          thread_id: string | null\n        }\n        Insert: {\n          channel_id: string\n          last_updated_thread_time?: number | null\n          market_id: string\n          market_slug: string\n          message_id: string\n          thread_id?: string | null\n        }\n        Update: {\n          channel_id?: string\n          last_updated_thread_time?: number | null\n          market_id?: string\n          market_slug?: string\n          message_id?: string\n          thread_id?: string | null\n        }\n        Relationships: []\n      }\n      discord_users: {\n        Row: {\n          api_key: string\n          discord_user_id: string\n          user_id: string\n        }\n        Insert: {\n          api_key: string\n          discord_user_id: string\n          user_id: string\n        }\n        Update: {\n          api_key?: string\n          discord_user_id?: string\n          user_id?: string\n        }\n        Relationships: []\n      }\n      gidx_receipts: {\n        Row: {\n          amount: number | null\n          callback_data: Json | null\n          created_time: string\n          currency: string | null\n          id: number\n          merchant_session_id: string | null\n          merchant_transaction_id: string\n          payment_amount_type: string | null\n          payment_data: Json | null\n          payment_method_type: string | null\n          payment_status_code: string | null\n          payment_status_message: string | null\n          reason_codes: string[] | null\n          service_type: string | null\n          session_id: string\n          session_score: number | null\n          status: string | null\n          status_code: number | null\n          transaction_status_code: string | null\n          transaction_status_message: string | null\n          txn_id: string | null\n          user_id: string | null\n        }\n        Insert: {\n          amount?: number | null\n          callback_data?: Json | null\n          created_time?: string\n          currency?: string | null\n          id?: never\n          merchant_session_id?: string | null\n          merchant_transaction_id: string\n          payment_amount_type?: string | null\n          payment_data?: Json | null\n          payment_method_type?: string | null\n          payment_status_code?: string | null\n          payment_status_message?: string | null\n          reason_codes?: string[] | null\n          service_type?: string | null\n          session_id: string\n          session_score?: number | null\n          status?: string | null\n          status_code?: number | null\n          transaction_status_code?: string | null\n          transaction_status_message?: string | null\n          txn_id?: string | null\n          user_id?: string | null\n        }\n        Update: {\n          amount?: number | null\n          callback_data?: Json | null\n          created_time?: string\n          currency?: string | null\n          id?: never\n          merchant_session_id?: string | null\n          merchant_transaction_id?: string\n          payment_amount_type?: string | null\n          payment_data?: Json | null\n          payment_method_type?: string | null\n          payment_status_code?: string | null\n          payment_status_message?: string | null\n          reason_codes?: string[] | null\n          service_type?: string | null\n          session_id?: string\n          session_score?: number | null\n          status?: string | null\n          status_code?: number | null\n          transaction_status_code?: string | null\n          transaction_status_message?: string | null\n          txn_id?: string | null\n          user_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'gidx_receipts_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'user_referrals_profit'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'gidx_receipts_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'users'\n            referencedColumns: ['id']\n          }\n        ]\n      }\n      group_contracts: {\n        Row: {\n          contract_id: string\n          group_id: string\n        }\n        Insert: {\n          contract_id: string\n          group_id: string\n        }\n        Update: {\n          contract_id?: string\n          group_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'group_contracts_group_id_fkey'\n            columns: ['group_id']\n            isOneToOne: false\n            referencedRelation: 'group_role'\n            referencedColumns: ['group_id']\n          },\n          {\n            foreignKeyName: 'group_contracts_group_id_fkey'\n            columns: ['group_id']\n            isOneToOne: false\n            referencedRelation: 'groups'\n            referencedColumns: ['id']\n          }\n        ]\n      }\n      group_embeddings: {\n        Row: {\n          created_time: string\n          embedding: string\n          group_id: string\n        }\n        Insert: {\n          created_time?: string\n          embedding: string\n          group_id: string\n        }\n        Update: {\n          created_time?: string\n          embedding?: string\n          group_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_group_embeddings_group_id_fkey'\n            columns: ['group_id']\n            isOneToOne: true\n            referencedRelation: 'group_role'\n            referencedColumns: ['group_id']\n          },\n          {\n            foreignKeyName: 'public_group_embeddings_group_id_fkey'\n            columns: ['group_id']\n            isOneToOne: true\n            referencedRelation: 'groups'\n            referencedColumns: ['id']\n          }\n        ]\n      }\n      group_groups: {\n        Row: {\n          bottom_id: string\n          top_id: string\n        }\n        Insert: {\n          bottom_id: string\n          top_id: string\n        }\n        Update: {\n          bottom_id?: string\n          top_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'group_groups_bottom_id_fkey'\n            columns: ['bottom_id']\n            isOneToOne: false\n            referencedRelation: 'group_role'\n            referencedColumns: ['group_id']\n          },\n          {\n            foreignKeyName: 'group_groups_bottom_id_fkey'\n            columns: ['bottom_id']\n            isOneToOne: false\n            referencedRelation: 'groups'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'group_groups_top_id_fkey'\n            columns: ['top_id']\n            isOneToOne: false\n            referencedRelation: 'group_role'\n            referencedColumns: ['group_id']\n          },\n          {\n            foreignKeyName: 'group_groups_top_id_fkey'\n            columns: ['top_id']\n            isOneToOne: false\n            referencedRelation: 'groups'\n            referencedColumns: ['id']\n          }\n        ]\n      }\n      group_invites: {\n        Row: {\n          created_time: string\n          duration: unknown | null\n          expire_time: string | null\n          group_id: string\n          id: string\n          is_forever: boolean | null\n          is_max_uses_reached: boolean | null\n          max_uses: number | null\n          uses: number\n        }\n        Insert: {\n          created_time?: string\n          duration?: unknown | null\n          expire_time?: string | null\n          group_id: string\n          id?: string\n          is_forever?: boolean | null\n          is_max_uses_reached?: boolean | null\n          max_uses?: number | null\n          uses?: number\n        }\n        Update: {\n          created_time?: string\n          duration?: unknown | null\n          expire_time?: string | null\n          group_id?: string\n          id?: string\n          is_forever?: boolean | null\n          is_max_uses_reached?: boolean | null\n          max_uses?: number | null\n          uses?: number\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_group_invites_group_id_fkey'\n            columns: ['group_id']\n            isOneToOne: false\n            referencedRelation: 'group_role'\n            referencedColumns: ['group_id']\n          },\n          {\n            foreignKeyName: 'public_group_invites_group_id_fkey'\n            columns: ['group_id']\n            isOneToOne: false\n            referencedRelation: 'groups'\n            referencedColumns: ['id']\n          }\n        ]\n      }\n      group_members: {\n        Row: {\n          created_time: string | null\n          group_id: string\n          member_id: string\n          role: string\n        }\n        Insert: {\n          created_time?: string | null\n          group_id: string\n          member_id: string\n          role?: string\n        }\n        Update: {\n          created_time?: string | null\n          group_id?: string\n          member_id?: string\n          role?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_group_members_group_id_fkey'\n            columns: ['group_id']\n            isOneToOne: false\n            referencedRelation: 'group_role'\n            referencedColumns: ['group_id']\n          },\n          {\n            foreignKeyName: 'public_group_members_group_id_fkey'\n            columns: ['group_id']\n            isOneToOne: false\n            referencedRelation: 'groups'\n            referencedColumns: ['id']\n          }\n        ]\n      }\n      groups: {\n        Row: {\n          about: Json | null\n          banner_url: string | null\n          created_time: string\n          creator_id: string | null\n          id: string\n          importance_score: number | null\n          name: string\n          name_fts: unknown | null\n          privacy_status: string | null\n          slug: string\n          total_members: number | null\n        }\n        Insert: {\n          about?: Json | null\n          banner_url?: string | null\n          created_time?: string\n          creator_id?: string | null\n          id?: string\n          importance_score?: number | null\n          name: string\n          name_fts?: unknown | null\n          privacy_status?: string | null\n          slug: string\n          total_members?: number | null\n        }\n        Update: {\n          about?: Json | null\n          banner_url?: string | null\n          created_time?: string\n          creator_id?: string | null\n          id?: string\n          importance_score?: number | null\n          name?: string\n          name_fts?: unknown | null\n          privacy_status?: string | null\n          slug?: string\n          total_members?: number | null\n        }\n        Relationships: []\n      }\n      kyc_bonus_rewards: {\n        Row: {\n          claim_time: string | null\n          claimed: boolean | null\n          created_time: string | null\n          reward_amount: number\n          user_id: string\n        }\n        Insert: {\n          claim_time?: string | null\n          claimed?: boolean | null\n          created_time?: string | null\n          reward_amount: number\n          user_id: string\n        }\n        Update: {\n          claim_time?: string | null\n          claimed?: boolean | null\n          created_time?: string | null\n          reward_amount?: number\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'kyc_bonus_rewards_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: true\n            referencedRelation: 'user_referrals_profit'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'kyc_bonus_rewards_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: true\n            referencedRelation: 'users'\n            referencedColumns: ['id']\n          }\n        ]\n      }\n      league_chats: {\n        Row: {\n          channel_id: string\n          cohort: string\n          created_time: string\n          division: number\n          id: number\n          owner_id: string | null\n          season: number\n        }\n        Insert: {\n          channel_id: string\n          cohort: string\n          created_time?: string\n          division: number\n          id?: number\n          owner_id?: string | null\n          season: number\n        }\n        Update: {\n          channel_id?: string\n          cohort?: string\n          created_time?: string\n          division?: number\n          id?: number\n          owner_id?: string | null\n          season?: number\n        }\n        Relationships: []\n      }\n      leagues: {\n        Row: {\n          cohort: string\n          created_time: string\n          division: number\n          id: string\n          mana_earned: number\n          mana_earned_breakdown: Json\n          rank_snapshot: number | null\n          season: number\n          user_id: string\n        }\n        Insert: {\n          cohort: string\n          created_time?: string\n          division: number\n          id?: string\n          mana_earned?: number\n          mana_earned_breakdown?: Json\n          rank_snapshot?: number | null\n          season: number\n          user_id: string\n        }\n        Update: {\n          cohort?: string\n          created_time?: string\n          division?: number\n          id?: string\n          mana_earned?: number\n          mana_earned_breakdown?: Json\n          rank_snapshot?: number | null\n          season?: number\n          user_id?: string\n        }\n        Relationships: []\n      }\n      love_answers: {\n        Row: {\n          created_time: string\n          creator_id: string\n          free_response: string | null\n          id: number\n          integer: number | null\n          multiple_choice: number | null\n          question_id: number\n        }\n        Insert: {\n          created_time?: string\n          creator_id: string\n          free_response?: string | null\n          id?: never\n          integer?: number | null\n          multiple_choice?: number | null\n          question_id: number\n        }\n        Update: {\n          created_time?: string\n          creator_id?: string\n          free_response?: string | null\n          id?: never\n          integer?: number | null\n          multiple_choice?: number | null\n          question_id?: number\n        }\n        Relationships: []\n      }\n      love_compatibility_answers: {\n        Row: {\n          created_time: string\n          creator_id: string\n          explanation: string | null\n          id: number\n          importance: number\n          multiple_choice: number\n          pref_choices: number[]\n          question_id: number\n        }\n        Insert: {\n          created_time?: string\n          creator_id: string\n          explanation?: string | null\n          id?: never\n          importance: number\n          multiple_choice: number\n          pref_choices: number[]\n          question_id: number\n        }\n        Update: {\n          created_time?: string\n          creator_id?: string\n          explanation?: string | null\n          id?: never\n          importance?: number\n          multiple_choice?: number\n          pref_choices?: number[]\n          question_id?: number\n        }\n        Relationships: []\n      }\n      love_likes: {\n        Row: {\n          created_time: string\n          creator_id: string\n          like_id: string\n          target_id: string\n        }\n        Insert: {\n          created_time?: string\n          creator_id: string\n          like_id?: string\n          target_id: string\n        }\n        Update: {\n          created_time?: string\n          creator_id?: string\n          like_id?: string\n          target_id?: string\n        }\n        Relationships: []\n      }\n      love_questions: {\n        Row: {\n          answer_type: string\n          created_time: string\n          creator_id: string\n          id: number\n          importance_score: number\n          multiple_choice_options: Json | null\n          question: string\n        }\n        Insert: {\n          answer_type?: string\n          created_time?: string\n          creator_id: string\n          id?: never\n          importance_score?: number\n          multiple_choice_options?: Json | null\n          question: string\n        }\n        Update: {\n          answer_type?: string\n          created_time?: string\n          creator_id?: string\n          id?: never\n          importance_score?: number\n          multiple_choice_options?: Json | null\n          question?: string\n        }\n        Relationships: []\n      }\n      love_ships: {\n        Row: {\n          created_time: string\n          creator_id: string\n          ship_id: string\n          target1_id: string\n          target2_id: string\n        }\n        Insert: {\n          created_time?: string\n          creator_id: string\n          ship_id?: string\n          target1_id: string\n          target2_id: string\n        }\n        Update: {\n          created_time?: string\n          creator_id?: string\n          ship_id?: string\n          target1_id?: string\n          target2_id?: string\n        }\n        Relationships: []\n      }\n      love_stars: {\n        Row: {\n          created_time: string\n          creator_id: string\n          star_id: string\n          target_id: string\n        }\n        Insert: {\n          created_time?: string\n          creator_id: string\n          star_id?: string\n          target_id: string\n        }\n        Update: {\n          created_time?: string\n          creator_id?: string\n          star_id?: string\n          target_id?: string\n        }\n        Relationships: []\n      }\n      love_waitlist: {\n        Row: {\n          created_time: string\n          email: string\n          id: number\n        }\n        Insert: {\n          created_time?: string\n          email: string\n          id?: never\n        }\n        Update: {\n          created_time?: string\n          email?: string\n          id?: never\n        }\n        Relationships: []\n      }\n      lover_comments: {\n        Row: {\n          content: Json\n          created_time: string\n          hidden: boolean\n          id: number\n          on_user_id: string\n          reply_to_comment_id: number | null\n          user_avatar_url: string\n          user_id: string\n          user_name: string\n          user_username: string\n        }\n        Insert: {\n          content: Json\n          created_time?: string\n          hidden?: boolean\n          id?: never\n          on_user_id: string\n          reply_to_comment_id?: number | null\n          user_avatar_url: string\n          user_id: string\n          user_name: string\n          user_username: string\n        }\n        Update: {\n          content?: Json\n          created_time?: string\n          hidden?: boolean\n          id?: never\n          on_user_id?: string\n          reply_to_comment_id?: number | null\n          user_avatar_url?: string\n          user_id?: string\n          user_name?: string\n          user_username?: string\n        }\n        Relationships: []\n      }\n      lovers: {\n        Row: {\n          age: number\n          bio: Json | null\n          born_in_location: string | null\n          city: string\n          city_latitude: number | null\n          city_longitude: number | null\n          comments_enabled: boolean\n          company: string | null\n          country: string | null\n          created_time: string\n          drinks_per_month: number | null\n          education_level: string | null\n          ethnicity: string[] | null\n          gender: string\n          geodb_city_id: string | null\n          has_kids: number | null\n          height_in_inches: number | null\n          id: number\n          is_smoker: boolean | null\n          is_vegetarian_or_vegan: boolean | null\n          last_online_time: string\n          looking_for_matches: boolean\n          messaging_status: string\n          occupation: string | null\n          occupation_title: string | null\n          photo_urls: string[] | null\n          pinned_url: string | null\n          political_beliefs: string[] | null\n          pref_age_max: number\n          pref_age_min: number\n          pref_gender: string[]\n          pref_relation_styles: string[]\n          referred_by_username: string | null\n          region_code: string | null\n          religious_belief_strength: number | null\n          religious_beliefs: string | null\n          twitter: string | null\n          university: string | null\n          user_id: string\n          visibility: string\n          wants_kids_strength: number\n          website: string | null\n        }\n        Insert: {\n          age?: number\n          bio?: Json | null\n          born_in_location?: string | null\n          city: string\n          city_latitude?: number | null\n          city_longitude?: number | null\n          comments_enabled?: boolean\n          company?: string | null\n          country?: string | null\n          created_time?: string\n          drinks_per_month?: number | null\n          education_level?: string | null\n          ethnicity?: string[] | null\n          gender: string\n          geodb_city_id?: string | null\n          has_kids?: number | null\n          height_in_inches?: number | null\n          id?: never\n          is_smoker?: boolean | null\n          is_vegetarian_or_vegan?: boolean | null\n          last_online_time?: string\n          looking_for_matches?: boolean\n          messaging_status?: string\n          occupation?: string | null\n          occupation_title?: string | null\n          photo_urls?: string[] | null\n          pinned_url?: string | null\n          political_beliefs?: string[] | null\n          pref_age_max?: number\n          pref_age_min?: number\n          pref_gender: string[]\n          pref_relation_styles: string[]\n          referred_by_username?: string | null\n          region_code?: string | null\n          religious_belief_strength?: number | null\n          religious_beliefs?: string | null\n          twitter?: string | null\n          university?: string | null\n          user_id: string\n          visibility?: string\n          wants_kids_strength?: number\n          website?: string | null\n        }\n        Update: {\n          age?: number\n          bio?: Json | null\n          born_in_location?: string | null\n          city?: string\n          city_latitude?: number | null\n          city_longitude?: number | null\n          comments_enabled?: boolean\n          company?: string | null\n          country?: string | null\n          created_time?: string\n          drinks_per_month?: number | null\n          education_level?: string | null\n          ethnicity?: string[] | null\n          gender?: string\n          geodb_city_id?: string | null\n          has_kids?: number | null\n          height_in_inches?: number | null\n          id?: never\n          is_smoker?: boolean | null\n          is_vegetarian_or_vegan?: boolean | null\n          last_online_time?: string\n          looking_for_matches?: boolean\n          messaging_status?: string\n          occupation?: string | null\n          occupation_title?: string | null\n          photo_urls?: string[] | null\n          pinned_url?: string | null\n          political_beliefs?: string[] | null\n          pref_age_max?: number\n          pref_age_min?: number\n          pref_gender?: string[]\n          pref_relation_styles?: string[]\n          referred_by_username?: string | null\n          region_code?: string | null\n          religious_belief_strength?: number | null\n          religious_beliefs?: string | null\n          twitter?: string | null\n          university?: string | null\n          user_id?: string\n          visibility?: string\n          wants_kids_strength?: number\n          website?: string | null\n        }\n        Relationships: []\n      }\n      mana_supply_stats: {\n        Row: {\n          amm_cash_liquidity: number\n          amm_liquidity: number\n          balance: number\n          cash_balance: number\n          cash_investment_value: number\n          created_time: string\n          end_time: string\n          full_investment_value: number | null\n          full_loan_total: number | null\n          full_mana_balance: number | null\n          full_spice_balance: number | null\n          full_total_mana_value: number | null\n          id: number\n          investment_value: number\n          loan_total: number\n          spice_balance: number\n          start_time: string\n          total_cash_value: number\n          total_value: number\n        }\n        Insert: {\n          amm_cash_liquidity?: number\n          amm_liquidity: number\n          balance: number\n          cash_balance?: number\n          cash_investment_value?: number\n          created_time?: string\n          end_time: string\n          full_investment_value?: number | null\n          full_loan_total?: number | null\n          full_mana_balance?: number | null\n          full_spice_balance?: number | null\n          full_total_mana_value?: number | null\n          id?: never\n          investment_value: number\n          loan_total: number\n          spice_balance: number\n          start_time: string\n          total_cash_value?: number\n          total_value: number\n        }\n        Update: {\n          amm_cash_liquidity?: number\n          amm_liquidity?: number\n          balance?: number\n          cash_balance?: number\n          cash_investment_value?: number\n          created_time?: string\n          end_time?: string\n          full_investment_value?: number | null\n          full_loan_total?: number | null\n          full_mana_balance?: number | null\n          full_spice_balance?: number | null\n          full_total_mana_value?: number | null\n          id?: never\n          investment_value?: number\n          loan_total?: number\n          spice_balance?: number\n          start_time?: string\n          total_cash_value?: number\n          total_value?: number\n        }\n        Relationships: []\n      }\n      manachan_tweets: {\n        Row: {\n          cost: number | null\n          created_time: number | null\n          id: string\n          tweet: string | null\n          tweet_id: string | null\n          user_id: string | null\n          username: string | null\n        }\n        Insert: {\n          cost?: number | null\n          created_time?: number | null\n          id?: string\n          tweet?: string | null\n          tweet_id?: string | null\n          user_id?: string | null\n          username?: string | null\n        }\n        Update: {\n          cost?: number | null\n          created_time?: number | null\n          id?: string\n          tweet?: string | null\n          tweet_id?: string | null\n          user_id?: string | null\n          username?: string | null\n        }\n        Relationships: []\n      }\n      manalink_claims: {\n        Row: {\n          manalink_id: string\n          txn_id: string\n        }\n        Insert: {\n          manalink_id: string\n          txn_id: string\n        }\n        Update: {\n          manalink_id?: string\n          txn_id?: string\n        }\n        Relationships: []\n      }\n      manalinks: {\n        Row: {\n          amount: number\n          created_time: string | null\n          creator_id: string\n          expires_time: string | null\n          id: string\n          max_uses: number | null\n          message: string | null\n        }\n        Insert: {\n          amount: number\n          created_time?: string | null\n          creator_id: string\n          expires_time?: string | null\n          id?: string\n          max_uses?: number | null\n          message?: string | null\n        }\n        Update: {\n          amount?: number\n          created_time?: string | null\n          creator_id?: string\n          expires_time?: string | null\n          id?: string\n          max_uses?: number | null\n          message?: string | null\n        }\n        Relationships: []\n      }\n      market_ads: {\n        Row: {\n          cost_per_view: number\n          created_at: string\n          embedding: string\n          funds: number\n          id: string\n          market_id: string\n          user_id: string\n        }\n        Insert: {\n          cost_per_view: number\n          created_at?: string\n          embedding: string\n          funds: number\n          id?: string\n          market_id: string\n          user_id: string\n        }\n        Update: {\n          cost_per_view?: number\n          created_at?: string\n          embedding?: string\n          funds?: number\n          id?: string\n          market_id?: string\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'market_ads_market_id_fkey'\n            columns: ['market_id']\n            isOneToOne: false\n            referencedRelation: 'contracts'\n            referencedColumns: ['id']\n          }\n        ]\n      }\n      mod_reports: {\n        Row: {\n          comment_id: string\n          contract_id: string\n          created_time: string\n          mod_note: string | null\n          report_id: number\n          status: Database['public']['Enums']['status_type']\n          user_id: string\n        }\n        Insert: {\n          comment_id: string\n          contract_id: string\n          created_time?: string\n          mod_note?: string | null\n          report_id?: number\n          status?: Database['public']['Enums']['status_type']\n          user_id: string\n        }\n        Update: {\n          comment_id?: string\n          contract_id?: string\n          created_time?: string\n          mod_note?: string | null\n          report_id?: number\n          status?: Database['public']['Enums']['status_type']\n          user_id?: string\n        }\n        Relationships: []\n      }\n      news: {\n        Row: {\n          author: string | null\n          contract_ids: string[] | null\n          created_time: string\n          description: string | null\n          group_ids: string[] | null\n          id: number\n          image_url: string | null\n          published_time: string\n          source_id: string | null\n          source_name: string | null\n          title: string\n          title_embedding: string\n          url: string\n        }\n        Insert: {\n          author?: string | null\n          contract_ids?: string[] | null\n          created_time?: string\n          description?: string | null\n          group_ids?: string[] | null\n          id?: number\n          image_url?: string | null\n          published_time: string\n          source_id?: string | null\n          source_name?: string | null\n          title: string\n          title_embedding: string\n          url: string\n        }\n        Update: {\n          author?: string | null\n          contract_ids?: string[] | null\n          created_time?: string\n          description?: string | null\n          group_ids?: string[] | null\n          id?: number\n          image_url?: string | null\n          published_time?: string\n          source_id?: string | null\n          source_name?: string | null\n          title?: string\n          title_embedding?: string\n          url?: string\n        }\n        Relationships: []\n      }\n      old_post_comments: {\n        Row: {\n          comment_id: string\n          created_time: string | null\n          data: Json\n          fs_updated_time: string | null\n          post_id: string\n          user_id: string | null\n        }\n        Insert: {\n          comment_id?: string\n          created_time?: string | null\n          data: Json\n          fs_updated_time?: string | null\n          post_id: string\n          user_id?: string | null\n        }\n        Update: {\n          comment_id?: string\n          created_time?: string | null\n          data?: Json\n          fs_updated_time?: string | null\n          post_id?: string\n          user_id?: string | null\n        }\n        Relationships: []\n      }\n      old_posts: {\n        Row: {\n          created_time: string | null\n          creator_id: string | null\n          data: Json\n          group_id: string | null\n          id: string\n          visibility: string | null\n          importance_score: number | null\n        }\n        Insert: {\n          created_time?: string | null\n          creator_id?: string | null\n          data: Json\n          group_id?: string | null\n          id?: string\n          visibility?: string | null\n          importance_score?: number | null\n        }\n        Update: {\n          created_time?: string | null\n          creator_id?: string | null\n          data?: Json\n          group_id?: string | null\n          id?: string\n          visibility?: string | null\n          importance_score?: number | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_old_posts_group_id_fkey'\n            columns: ['group_id']\n            isOneToOne: false\n            referencedRelation: 'group_role'\n            referencedColumns: ['group_id']\n          },\n          {\n            foreignKeyName: 'public_old_posts_group_id_fkey'\n            columns: ['group_id']\n            isOneToOne: false\n            referencedRelation: 'groups'\n            referencedColumns: ['id']\n          }\n        ]\n      }\n      platform_calibration: {\n        Row: {\n          created_time: string\n          data: Json\n          id: number\n        }\n        Insert: {\n          created_time?: string\n          data: Json\n          id?: never\n        }\n        Update: {\n          created_time?: string\n          data?: Json\n          id?: never\n        }\n        Relationships: []\n      }\n      portfolios: {\n        Row: {\n          created_time: string\n          creator_id: string\n          id: string\n          items: Json\n          name: string\n          slug: string\n        }\n        Insert: {\n          created_time?: string\n          creator_id: string\n          id: string\n          items: Json\n          name: string\n          slug: string\n        }\n        Update: {\n          created_time?: string\n          creator_id?: string\n          id?: string\n          items?: Json\n          name?: string\n          slug?: string\n        }\n        Relationships: []\n      }\n      posts: {\n        Row: {\n          bet_id: string | null\n          contract_comment_id: string | null\n          contract_id: string | null\n          created_time: string\n          id: number\n          user_avatar_url: string\n          user_id: string\n          user_name: string\n          user_username: string\n        }\n        Insert: {\n          bet_id?: string | null\n          contract_comment_id?: string | null\n          contract_id?: string | null\n          created_time?: string\n          id?: never\n          user_avatar_url: string\n          user_id: string\n          user_name: string\n          user_username: string\n        }\n        Update: {\n          bet_id?: string | null\n          contract_comment_id?: string | null\n          contract_id?: string | null\n          created_time?: string\n          id?: never\n          user_avatar_url?: string\n          user_id?: string\n          user_name?: string\n          user_username?: string\n        }\n        Relationships: []\n      }\n      private_user_message_channel_members: {\n        Row: {\n          channel_id: number\n          created_time: string\n          id: number\n          notify_after_time: string\n          role: string\n          status: string\n          user_id: string\n        }\n        Insert: {\n          channel_id: number\n          created_time?: string\n          id?: never\n          notify_after_time?: string\n          role?: string\n          status?: string\n          user_id: string\n        }\n        Update: {\n          channel_id?: number\n          created_time?: string\n          id?: never\n          notify_after_time?: string\n          role?: string\n          status?: string\n          user_id?: string\n        }\n        Relationships: []\n      }\n      private_user_message_channels: {\n        Row: {\n          created_time: string\n          id: number\n          last_updated_time: string\n          title: string | null\n        }\n        Insert: {\n          created_time?: string\n          id?: never\n          last_updated_time?: string\n          title?: string | null\n        }\n        Update: {\n          created_time?: string\n          id?: never\n          last_updated_time?: string\n          title?: string | null\n        }\n        Relationships: []\n      }\n      private_user_messages: {\n        Row: {\n          channel_id: number\n          content: Json\n          created_time: string\n          id: number\n          user_id: string\n          visibility: string\n        }\n        Insert: {\n          channel_id: number\n          content: Json\n          created_time?: string\n          id?: never\n          user_id: string\n          visibility?: string\n        }\n        Update: {\n          channel_id?: number\n          content?: Json\n          created_time?: string\n          id?: never\n          user_id?: string\n          visibility?: string\n        }\n        Relationships: []\n      }\n      private_user_phone_numbers: {\n        Row: {\n          created_time: string\n          id: number\n          last_updated_time: string\n          phone_number: string\n          user_id: string\n        }\n        Insert: {\n          created_time?: string\n          id?: never\n          last_updated_time?: string\n          phone_number: string\n          user_id: string\n        }\n        Update: {\n          created_time?: string\n          id?: never\n          last_updated_time?: string\n          phone_number?: string\n          user_id?: string\n        }\n        Relationships: []\n      }\n      private_user_seen_message_channels: {\n        Row: {\n          channel_id: number\n          created_time: string\n          id: number\n          user_id: string\n        }\n        Insert: {\n          channel_id: number\n          created_time?: string\n          id?: never\n          user_id: string\n        }\n        Update: {\n          channel_id?: number\n          created_time?: string\n          id?: never\n          user_id?: string\n        }\n        Relationships: []\n      }\n      private_users: {\n        Row: {\n          data: Json\n          id: string\n          weekly_portfolio_email_sent: boolean | null\n          weekly_trending_email_sent: boolean | null\n        }\n        Insert: {\n          data: Json\n          id: string\n          weekly_portfolio_email_sent?: boolean | null\n          weekly_trending_email_sent?: boolean | null\n        }\n        Update: {\n          data?: Json\n          id?: string\n          weekly_portfolio_email_sent?: boolean | null\n          weekly_trending_email_sent?: boolean | null\n        }\n        Relationships: []\n      }\n      push_notification_tickets: {\n        Row: {\n          created_time: string\n          id: string\n          notification_id: string\n          receipt_error: string | null\n          receipt_status: string\n          status: string\n          user_id: string\n        }\n        Insert: {\n          created_time?: string\n          id: string\n          notification_id: string\n          receipt_error?: string | null\n          receipt_status: string\n          status: string\n          user_id: string\n        }\n        Update: {\n          created_time?: string\n          id?: string\n          notification_id?: string\n          receipt_error?: string | null\n          receipt_status?: string\n          status?: string\n          user_id?: string\n        }\n        Relationships: []\n      }\n      q_and_a: {\n        Row: {\n          bounty: number\n          created_time: string\n          deleted: boolean\n          description: string\n          id: string\n          question: string\n          user_id: string\n        }\n        Insert: {\n          bounty: number\n          created_time?: string\n          deleted?: boolean\n          description: string\n          id: string\n          question: string\n          user_id: string\n        }\n        Update: {\n          bounty?: number\n          created_time?: string\n          deleted?: boolean\n          description?: string\n          id?: string\n          question?: string\n          user_id?: string\n        }\n        Relationships: []\n      }\n      q_and_a_answers: {\n        Row: {\n          award: number\n          created_time: string\n          deleted: boolean\n          id: string\n          q_and_a_id: string\n          text: string\n          user_id: string\n        }\n        Insert: {\n          award?: number\n          created_time?: string\n          deleted?: boolean\n          id: string\n          q_and_a_id: string\n          text: string\n          user_id: string\n        }\n        Update: {\n          award?: number\n          created_time?: string\n          deleted?: boolean\n          id?: string\n          q_and_a_id?: string\n          text?: string\n          user_id?: string\n        }\n        Relationships: []\n      }\n      redemption_status: {\n        Row: {\n          created_time: string\n          id: number\n          session_id: string\n          status: string\n          transaction_id: string\n          txn_id: string\n          user_id: string\n        }\n        Insert: {\n          created_time?: string\n          id?: never\n          session_id: string\n          status: string\n          transaction_id: string\n          txn_id: string\n          user_id: string\n        }\n        Update: {\n          created_time?: string\n          id?: never\n          session_id?: string\n          status?: string\n          transaction_id?: string\n          txn_id?: string\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'redemption_status_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'user_referrals_profit'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'redemption_status_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'users'\n            referencedColumns: ['id']\n          }\n        ]\n      }\n      reports: {\n        Row: {\n          content_id: string\n          content_owner_id: string\n          content_type: string\n          created_time: string | null\n          description: string | null\n          id: string\n          parent_id: string | null\n          parent_type: string | null\n          user_id: string\n        }\n        Insert: {\n          content_id: string\n          content_owner_id: string\n          content_type: string\n          created_time?: string | null\n          description?: string | null\n          id?: string\n          parent_id?: string | null\n          parent_type?: string | null\n          user_id: string\n        }\n        Update: {\n          content_id?: string\n          content_owner_id?: string\n          content_type?: string\n          created_time?: string | null\n          description?: string | null\n          id?: string\n          parent_id?: string | null\n          parent_type?: string | null\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'reports_content_owner_id_fkey'\n            columns: ['content_owner_id']\n            isOneToOne: false\n            referencedRelation: 'user_referrals_profit'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'reports_content_owner_id_fkey'\n            columns: ['content_owner_id']\n            isOneToOne: false\n            referencedRelation: 'users'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'reports_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'user_referrals_profit'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'reports_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'users'\n            referencedColumns: ['id']\n          }\n        ]\n      }\n      reviews: {\n        Row: {\n          content: Json | null\n          created_time: string\n          market_id: string\n          rating: number\n          reviewer_id: string\n          vendor_id: string\n        }\n        Insert: {\n          content?: Json | null\n          created_time?: string\n          market_id: string\n          rating: number\n          reviewer_id: string\n          vendor_id: string\n        }\n        Update: {\n          content?: Json | null\n          created_time?: string\n          market_id?: string\n          rating?: number\n          reviewer_id?: string\n          vendor_id?: string\n        }\n        Relationships: []\n      }\n      scheduler_info: {\n        Row: {\n          created_time: string\n          id: number\n          job_name: string\n          last_end_time: string | null\n          last_start_time: string | null\n        }\n        Insert: {\n          created_time?: string\n          id?: never\n          job_name: string\n          last_end_time?: string | null\n          last_start_time?: string | null\n        }\n        Update: {\n          created_time?: string\n          id?: never\n          job_name?: string\n          last_end_time?: string | null\n          last_start_time?: string | null\n        }\n        Relationships: []\n      }\n      sent_emails: {\n        Row: {\n          created_time: string\n          email_template_id: string\n          id: number\n          user_id: string\n        }\n        Insert: {\n          created_time?: string\n          email_template_id: string\n          id?: never\n          user_id: string\n        }\n        Update: {\n          created_time?: string\n          email_template_id?: string\n          id?: never\n          user_id?: string\n        }\n        Relationships: []\n      }\n      stats: {\n        Row: {\n          daily_values: number[] | null\n          title: string\n        }\n        Insert: {\n          daily_values?: number[] | null\n          title: string\n        }\n        Update: {\n          daily_values?: number[] | null\n          title?: string\n        }\n        Relationships: []\n      }\n      system_trading_status: {\n        Row: {\n          status: boolean\n          token: string\n        }\n        Insert: {\n          status: boolean\n          token: string\n        }\n        Update: {\n          status?: boolean\n          token?: string\n        }\n        Relationships: []\n      }\n      topic_embeddings: {\n        Row: {\n          created_at: string\n          embedding: string\n          topic: string\n        }\n        Insert: {\n          created_at?: string\n          embedding: string\n          topic: string\n        }\n        Update: {\n          created_at?: string\n          embedding?: string\n          topic?: string\n        }\n        Relationships: []\n      }\n      tv_schedule: {\n        Row: {\n          contract_id: string\n          creator_id: string\n          end_time: string\n          id: number\n          is_featured: boolean | null\n          schedule_created_time: string | null\n          source: string\n          start_time: string\n          stream_id: string\n          title: string\n        }\n        Insert: {\n          contract_id: string\n          creator_id: string\n          end_time: string\n          id?: number\n          is_featured?: boolean | null\n          schedule_created_time?: string | null\n          source: string\n          start_time: string\n          stream_id: string\n          title: string\n        }\n        Update: {\n          contract_id?: string\n          creator_id?: string\n          end_time?: string\n          id?: number\n          is_featured?: boolean | null\n          schedule_created_time?: string | null\n          source?: string\n          start_time?: string\n          stream_id?: string\n          title?: string\n        }\n        Relationships: []\n      }\n      txn_summary_stats: {\n        Row: {\n          category: string\n          created_time: string\n          end_time: string\n          from_type: string\n          id: number\n          quest_type: string | null\n          start_time: string\n          to_type: string\n          token: string\n          total_amount: number\n        }\n        Insert: {\n          category: string\n          created_time?: string\n          end_time: string\n          from_type: string\n          id?: never\n          quest_type?: string | null\n          start_time: string\n          to_type: string\n          token: string\n          total_amount: number\n        }\n        Update: {\n          category?: string\n          created_time?: string\n          end_time?: string\n          from_type?: string\n          id?: never\n          quest_type?: string | null\n          start_time?: string\n          to_type?: string\n          token?: string\n          total_amount?: number\n        }\n        Relationships: []\n      }\n      txns: {\n        Row: {\n          amount: number\n          category: string\n          created_time: string\n          data: Json\n          from_id: string\n          from_type: string\n          id: string\n          to_id: string\n          to_type: string\n          token: string\n        }\n        Insert: {\n          amount: number\n          category: string\n          created_time?: string\n          data: Json\n          from_id: string\n          from_type: string\n          id?: string\n          to_id: string\n          to_type: string\n          token?: string\n        }\n        Update: {\n          amount?: number\n          category?: string\n          created_time?: string\n          data?: Json\n          from_id?: string\n          from_type?: string\n          id?: string\n          to_id?: string\n          to_type?: string\n          token?: string\n        }\n        Relationships: []\n      }\n      user_comment_view_events: {\n        Row: {\n          comment_id: string\n          contract_id: string\n          created_time: string\n          id: number\n          user_id: string\n        }\n        Insert: {\n          comment_id: string\n          contract_id: string\n          created_time?: string\n          id?: never\n          user_id: string\n        }\n        Update: {\n          comment_id?: string\n          contract_id?: string\n          created_time?: string\n          id?: never\n          user_id?: string\n        }\n        Relationships: []\n      }\n      user_contract_interactions: {\n        Row: {\n          bet_group_id: string | null\n          bet_id: string | null\n          comment_id: string | null\n          contract_id: string\n          created_time: string\n          feed_reasons: string[] | null\n          feed_type: string | null\n          id: number\n          name: string\n          user_id: string\n        }\n        Insert: {\n          bet_group_id?: string | null\n          bet_id?: string | null\n          comment_id?: string | null\n          contract_id: string\n          created_time?: string\n          feed_reasons?: string[] | null\n          feed_type?: string | null\n          id?: never\n          name: string\n          user_id: string\n        }\n        Update: {\n          bet_group_id?: string | null\n          bet_id?: string | null\n          comment_id?: string | null\n          contract_id?: string\n          created_time?: string\n          feed_reasons?: string[] | null\n          feed_type?: string | null\n          id?: never\n          name?: string\n          user_id?: string\n        }\n        Relationships: []\n      }\n      user_contract_metrics: {\n        Row: {\n          answer_id: string | null\n          contract_id: string\n          data: Json\n          has_no_shares: boolean | null\n          has_shares: boolean | null\n          has_yes_shares: boolean | null\n          id: number\n          profit: number | null\n          total_shares_no: number | null\n          total_shares_yes: number | null\n          user_id: string\n        }\n        Insert: {\n          answer_id?: string | null\n          contract_id: string\n          data: Json\n          has_no_shares?: boolean | null\n          has_shares?: boolean | null\n          has_yes_shares?: boolean | null\n          id?: never\n          profit?: number | null\n          total_shares_no?: number | null\n          total_shares_yes?: number | null\n          user_id: string\n        }\n        Update: {\n          answer_id?: string | null\n          contract_id?: string\n          data?: Json\n          has_no_shares?: boolean | null\n          has_shares?: boolean | null\n          has_yes_shares?: boolean | null\n          id?: never\n          profit?: number | null\n          total_shares_no?: number | null\n          total_shares_yes?: number | null\n          user_id?: string\n        }\n        Relationships: []\n      }\n      user_contract_views: {\n        Row: {\n          card_views: number\n          contract_id: string\n          id: number\n          last_card_view_ts: string | null\n          last_page_view_ts: string | null\n          last_promoted_view_ts: string | null\n          page_views: number\n          promoted_views: number\n          user_id: string | null\n        }\n        Insert: {\n          card_views?: number\n          contract_id: string\n          id?: never\n          last_card_view_ts?: string | null\n          last_page_view_ts?: string | null\n          last_promoted_view_ts?: string | null\n          page_views?: number\n          promoted_views?: number\n          user_id?: string | null\n        }\n        Update: {\n          card_views?: number\n          contract_id?: string\n          id?: never\n          last_card_view_ts?: string | null\n          last_page_view_ts?: string | null\n          last_promoted_view_ts?: string | null\n          page_views?: number\n          promoted_views?: number\n          user_id?: string | null\n        }\n        Relationships: []\n      }\n      user_disinterests: {\n        Row: {\n          comment_id: string | null\n          contract_id: string\n          created_time: string\n          creator_id: string\n          feed_id: number | null\n          id: number\n          user_id: string\n        }\n        Insert: {\n          comment_id?: string | null\n          contract_id: string\n          created_time?: string\n          creator_id: string\n          feed_id?: number | null\n          id?: never\n          user_id: string\n        }\n        Update: {\n          comment_id?: string | null\n          contract_id?: string\n          created_time?: string\n          creator_id?: string\n          feed_id?: number | null\n          id?: never\n          user_id?: string\n        }\n        Relationships: []\n      }\n      user_embeddings: {\n        Row: {\n          contract_view_embedding: string | null\n          created_at: string\n          disinterest_embedding: string | null\n          interest_embedding: string\n          user_id: string\n        }\n        Insert: {\n          contract_view_embedding?: string | null\n          created_at?: string\n          disinterest_embedding?: string | null\n          interest_embedding: string\n          user_id: string\n        }\n        Update: {\n          contract_view_embedding?: string | null\n          created_at?: string\n          disinterest_embedding?: string | null\n          interest_embedding?: string\n          user_id?: string\n        }\n        Relationships: []\n      }\n      user_events: {\n        Row: {\n          ad_id: string | null\n          comment_id: string | null\n          contract_id: string | null\n          data: Json\n          id: number\n          name: string\n          ts: string\n          user_id: string | null\n        }\n        Insert: {\n          ad_id?: string | null\n          comment_id?: string | null\n          contract_id?: string | null\n          data: Json\n          id?: never\n          name: string\n          ts?: string\n          user_id?: string | null\n        }\n        Update: {\n          ad_id?: string | null\n          comment_id?: string | null\n          contract_id?: string | null\n          data?: Json\n          id?: never\n          name?: string\n          ts?: string\n          user_id?: string | null\n        }\n        Relationships: []\n      }\n      user_follows: {\n        Row: {\n          created_time: string\n          follow_id: string\n          user_id: string\n        }\n        Insert: {\n          created_time?: string\n          follow_id: string\n          user_id: string\n        }\n        Update: {\n          created_time?: string\n          follow_id?: string\n          user_id?: string\n        }\n        Relationships: []\n      }\n      user_monitor_status: {\n        Row: {\n          created_time: string | null\n          data: Json\n          fraud_confidence_score: number | null\n          id: number\n          identity_confidence_score: number | null\n          reason_codes: string[] | null\n          user_id: string\n        }\n        Insert: {\n          created_time?: string | null\n          data: Json\n          fraud_confidence_score?: number | null\n          id?: never\n          identity_confidence_score?: number | null\n          reason_codes?: string[] | null\n          user_id: string\n        }\n        Update: {\n          created_time?: string | null\n          data?: Json\n          fraud_confidence_score?: number | null\n          id?: never\n          identity_confidence_score?: number | null\n          reason_codes?: string[] | null\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'user_monitor_status_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'user_referrals_profit'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'user_monitor_status_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'users'\n            referencedColumns: ['id']\n          }\n        ]\n      }\n      user_notifications: {\n        Row: {\n          data: Json\n          notification_id: string\n          user_id: string\n        }\n        Insert: {\n          data: Json\n          notification_id: string\n          user_id: string\n        }\n        Update: {\n          data?: Json\n          notification_id?: string\n          user_id?: string\n        }\n        Relationships: []\n      }\n      user_portfolio_history: {\n        Row: {\n          balance: number | null\n          cash_balance: number\n          cash_investment_value: number\n          id: number\n          investment_value: number | null\n          loan_total: number | null\n          profit: number | null\n          spice_balance: number\n          total_cash_deposits: number\n          total_deposits: number | null\n          ts: string | null\n          user_id: string\n        }\n        Insert: {\n          balance?: number | null\n          cash_balance?: number\n          cash_investment_value?: number\n          id?: never\n          investment_value?: number | null\n          loan_total?: number | null\n          profit?: number | null\n          spice_balance?: number\n          total_cash_deposits?: number\n          total_deposits?: number | null\n          ts?: string | null\n          user_id: string\n        }\n        Update: {\n          balance?: number | null\n          cash_balance?: number\n          cash_investment_value?: number\n          id?: never\n          investment_value?: number | null\n          loan_total?: number | null\n          profit?: number | null\n          spice_balance?: number\n          total_cash_deposits?: number\n          total_deposits?: number | null\n          ts?: string | null\n          user_id?: string\n        }\n        Relationships: []\n      }\n      user_portfolio_history_latest: {\n        Row: {\n          balance: number\n          cash_balance: number\n          cash_investment_value: number\n          investment_value: number\n          last_calculated: string\n          loan_total: number | null\n          profit: number | null\n          spice_balance: number\n          total_cash_deposits: number\n          total_deposits: number\n          ts: string\n          user_id: string\n        }\n        Insert: {\n          balance: number\n          cash_balance?: number\n          cash_investment_value?: number\n          investment_value: number\n          last_calculated: string\n          loan_total?: number | null\n          profit?: number | null\n          spice_balance?: number\n          total_cash_deposits?: number\n          total_deposits: number\n          ts: string\n          user_id: string\n        }\n        Update: {\n          balance?: number\n          cash_balance?: number\n          cash_investment_value?: number\n          investment_value?: number\n          last_calculated?: string\n          loan_total?: number | null\n          profit?: number | null\n          spice_balance?: number\n          total_cash_deposits?: number\n          total_deposits?: number\n          ts?: string\n          user_id?: string\n        }\n        Relationships: []\n      }\n      user_quest_metrics: {\n        Row: {\n          idempotency_key: string | null\n          score_id: string\n          score_value: number\n          user_id: string\n        }\n        Insert: {\n          idempotency_key?: string | null\n          score_id: string\n          score_value: number\n          user_id: string\n        }\n        Update: {\n          idempotency_key?: string | null\n          score_id?: string\n          score_value?: number\n          user_id?: string\n        }\n        Relationships: []\n      }\n      user_reactions: {\n        Row: {\n          content_id: string\n          content_owner_id: string\n          content_type: string\n          created_time: string\n          reaction_id: string\n          reaction_type: string\n          user_id: string\n        }\n        Insert: {\n          content_id: string\n          content_owner_id: string\n          content_type: string\n          created_time?: string\n          reaction_id?: string\n          reaction_type?: string\n          user_id: string\n        }\n        Update: {\n          content_id?: string\n          content_owner_id?: string\n          content_type?: string\n          created_time?: string\n          reaction_id?: string\n          reaction_type?: string\n          user_id?: string\n        }\n        Relationships: []\n      }\n      user_seen_chats: {\n        Row: {\n          channel_id: string\n          created_time: string\n          id: number\n          user_id: string\n        }\n        Insert: {\n          channel_id: string\n          created_time?: string\n          id?: never\n          user_id: string\n        }\n        Update: {\n          channel_id?: string\n          created_time?: string\n          id?: never\n          user_id?: string\n        }\n        Relationships: []\n      }\n      user_topic_interests: {\n        Row: {\n          created_time: string\n          group_ids_to_activity: Json\n          id: number\n          user_id: string\n        }\n        Insert: {\n          created_time?: string\n          group_ids_to_activity: Json\n          id?: never\n          user_id: string\n        }\n        Update: {\n          created_time?: string\n          group_ids_to_activity?: Json\n          id?: never\n          user_id?: string\n        }\n        Relationships: []\n      }\n      user_topics: {\n        Row: {\n          created_at: string\n          topic_embedding: string\n          topics: string[]\n          user_id: string\n        }\n        Insert: {\n          created_at?: string\n          topic_embedding: string\n          topics: string[]\n          user_id: string\n        }\n        Update: {\n          created_at?: string\n          topic_embedding?: string\n          topics?: string[]\n          user_id?: string\n        }\n        Relationships: []\n      }\n      user_view_events: {\n        Row: {\n          ad_id: string | null\n          comment_id: string | null\n          contract_id: string | null\n          created_time: string\n          id: number\n          name: string\n          user_id: string\n        }\n        Insert: {\n          ad_id?: string | null\n          comment_id?: string | null\n          contract_id?: string | null\n          created_time?: string\n          id?: never\n          name: string\n          user_id: string\n        }\n        Update: {\n          ad_id?: string | null\n          comment_id?: string | null\n          contract_id?: string | null\n          created_time?: string\n          id?: never\n          name?: string\n          user_id?: string\n        }\n        Relationships: []\n      }\n      users: {\n        Row: {\n          balance: number\n          cash_balance: number\n          created_time: string\n          data: Json\n          id: string\n          name: string\n          name_username_vector: unknown | null\n          spice_balance: number\n          total_cash_deposits: number\n          total_deposits: number\n          username: string\n        }\n        Insert: {\n          balance?: number\n          cash_balance?: number\n          created_time?: string\n          data: Json\n          id?: string\n          name: string\n          name_username_vector?: unknown | null\n          spice_balance?: number\n          total_cash_deposits?: number\n          total_deposits?: number\n          username: string\n        }\n        Update: {\n          balance?: number\n          cash_balance?: number\n          created_time?: string\n          data?: Json\n          id?: string\n          name?: string\n          name_username_vector?: unknown | null\n          spice_balance?: number\n          total_cash_deposits?: number\n          total_deposits?: number\n          username?: string\n        }\n        Relationships: []\n      }\n      votes: {\n        Row: {\n          contract_id: string\n          created_time: string\n          id: string\n          user_id: string\n        }\n        Insert: {\n          contract_id: string\n          created_time?: string\n          id: string\n          user_id: string\n        }\n        Update: {\n          contract_id?: string\n          created_time?: string\n          id?: string\n          user_id?: string\n        }\n        Relationships: []\n      }\n    }\n    Views: {\n      final_pp_balances: {\n        Row: {\n          amount: number | null\n          user_id: string | null\n        }\n        Insert: {\n          amount?: number | null\n          user_id?: string | null\n        }\n        Update: {\n          amount?: number | null\n          user_id?: string | null\n        }\n        Relationships: []\n      }\n      group_role: {\n        Row: {\n          avatar_url: string | null\n          createdtime: number | null\n          creator_id: string | null\n          group_id: string | null\n          group_name: string | null\n          group_slug: string | null\n          member_id: string | null\n          name: string | null\n          privacy_status: string | null\n          role: string | null\n          total_members: number | null\n          username: string | null\n        }\n        Relationships: []\n      }\n      user_league_info: {\n        Row: {\n          cohort: string | null\n          created_time: string | null\n          division: number | null\n          mana_earned: number | null\n          mana_earned_breakdown: Json | null\n          rank: number | null\n          rank_snapshot: number | null\n          season: number | null\n          user_id: string | null\n        }\n        Relationships: []\n      }\n      user_referrals_profit: {\n        Row: {\n          id: string | null\n          rank: number | null\n          total_referrals: number | null\n          total_referred_cash_profit: number | null\n          total_referred_profit: number | null\n        }\n        Relationships: []\n      }\n    }\n    Functions: {\n      add_creator_name_to_description: {\n        Args: {\n          data: Json\n        }\n        Returns: string\n      }\n      binary_quantize:\n        | {\n            Args: {\n              '': string\n            }\n            Returns: unknown\n          }\n        | {\n            Args: {\n              '': unknown\n            }\n            Returns: unknown\n          }\n      calculate_earth_distance_km: {\n        Args: {\n          lat1: number\n          lon1: number\n          lat2: number\n          lon2: number\n        }\n        Returns: number\n      }\n      can_access_private_messages: {\n        Args: {\n          channel_id: number\n          user_id: string\n        }\n        Returns: boolean\n      }\n      close_contract_embeddings: {\n        Args: {\n          input_contract_id: string\n          similarity_threshold: number\n          match_count: number\n        }\n        Returns: {\n          contract_id: string\n          similarity: number\n          data: Json\n        }[]\n      }\n      count_recent_comments: {\n        Args: {\n          contract_id: string\n        }\n        Returns: number\n      }\n      count_recent_comments_by_contract: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          contract_id: string\n          comment_count: number\n        }[]\n      }\n      creator_leaderboard: {\n        Args: {\n          limit_n: number\n        }\n        Returns: {\n          user_id: string\n          total_traders: number\n          name: string\n          username: string\n          avatar_url: string\n        }[]\n      }\n      creator_rank: {\n        Args: {\n          uid: string\n        }\n        Returns: number\n      }\n      date_to_midnight_pt: {\n        Args: {\n          d: string\n        }\n        Returns: string\n      }\n      extract_text_from_rich_text_json: {\n        Args: {\n          description: Json\n        }\n        Returns: string\n      }\n      firebase_uid: {\n        Args: Record<PropertyKey, never>\n        Returns: string\n      }\n      get_average_rating: {\n        Args: {\n          user_id: string\n        }\n        Returns: number\n      }\n      get_compatibility_questions_with_answer_count: {\n        Args: Record<PropertyKey, never>\n        Returns: Database['public']['CompositeTypes']['love_question_with_count_type'][]\n      }\n      get_contract_voters: {\n        Args: {\n          this_contract_id: string\n        }\n        Returns: {\n          data: Json\n        }[]\n      }\n      get_contracts_in_group_slugs_1: {\n        Args: {\n          contract_ids: string[]\n          p_group_slugs: string[]\n          ignore_slugs: string[]\n        }\n        Returns: {\n          data: Json\n          importance_score: number\n        }[]\n      }\n      get_cpmm_pool_prob: {\n        Args: {\n          pool: Json\n          p: number\n        }\n        Returns: number\n      }\n      get_daily_claimed_boosts: {\n        Args: {\n          user_id: string\n        }\n        Returns: {\n          total: number\n        }[]\n      }\n      get_donations_by_charity: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          charity_id: string\n          num_supporters: number\n          total: number\n        }[]\n      }\n      get_group_contracts: {\n        Args: {\n          this_group_id: string\n        }\n        Returns: {\n          data: Json\n        }[]\n      }\n      get_love_question_answers_and_lovers: {\n        Args: {\n          p_question_id: number\n        }\n        Returns: Database['public']['CompositeTypes']['other_lover_answers_type'][]\n      }\n      get_non_empty_private_message_channel_ids:\n        | {\n            Args: {\n              p_user_id: string\n              p_ignored_statuses: string[]\n              p_limit: number\n            }\n            Returns: {\n              created_time: string\n              id: number\n              last_updated_time: string\n              title: string | null\n            }[]\n          }\n        | {\n            Args: {\n              p_user_id: string\n              p_limit?: number\n            }\n            Returns: {\n              id: number\n            }[]\n          }\n      get_noob_questions: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          close_time: string | null\n          conversion_score: number\n          created_time: string | null\n          creator_id: string | null\n          daily_score: number\n          data: Json\n          deleted: boolean | null\n          description_fts: unknown | null\n          freshness_score: number\n          group_slugs: string[] | null\n          id: string\n          importance_score: number\n          is_spice_payout: boolean | null\n          last_bet_time: string | null\n          last_comment_time: string | null\n          last_updated_time: string | null\n          mechanism: string | null\n          outcome_type: string | null\n          popularity_score: number\n          question: string | null\n          question_fts: unknown | null\n          question_nostop_fts: unknown | null\n          resolution: string | null\n          resolution_probability: number | null\n          resolution_time: string | null\n          slug: string | null\n          tier: string | null\n          token: string\n          unique_bettor_count: number\n          view_count: number\n          visibility: string | null\n        }[]\n      }\n      get_option_voters: {\n        Args: {\n          this_contract_id: string\n          this_option_id: string\n        }\n        Returns: {\n          data: Json\n        }[]\n      }\n      get_rating: {\n        Args: {\n          user_id: string\n        }\n        Returns: {\n          count: number\n          rating: number\n        }[]\n      }\n      get_recently_active_contracts_in_group_slugs_1: {\n        Args: {\n          p_group_slugs: string[]\n          ignore_slugs: string[]\n          max: number\n        }\n        Returns: {\n          data: Json\n          importance_score: number\n        }[]\n      }\n      get_user_bet_contracts: {\n        Args: {\n          this_user_id: string\n          this_limit: number\n        }\n        Returns: {\n          data: Json\n        }[]\n      }\n      get_user_group_id_for_current_user: {\n        Args: Record<PropertyKey, never>\n        Returns: string\n      }\n      get_user_manalink_claims: {\n        Args: {\n          creator_id: string\n        }\n        Returns: {\n          manalink_id: string\n          claimant_id: string\n          ts: number\n        }[]\n      }\n      get_user_topic_interests_2: {\n        Args: {\n          p_user_id: string\n        }\n        Returns: {\n          group_id: string\n          score: number\n        }[]\n      }\n      get_your_contract_ids:\n        | {\n            Args: {\n              uid: string\n            }\n            Returns: {\n              contract_id: string\n            }[]\n          }\n        | {\n            Args: {\n              uid: string\n              n: number\n              start: number\n            }\n            Returns: {\n              contract_id: string\n            }[]\n          }\n      get_your_daily_changed_contracts: {\n        Args: {\n          uid: string\n          n: number\n          start: number\n        }\n        Returns: {\n          data: Json\n          daily_score: number\n        }[]\n      }\n      get_your_recent_contracts: {\n        Args: {\n          uid: string\n          n: number\n          start: number\n        }\n        Returns: {\n          data: Json\n          max_ts: number\n        }[]\n      }\n      gtrgm_compress: {\n        Args: {\n          '': unknown\n        }\n        Returns: unknown\n      }\n      gtrgm_decompress: {\n        Args: {\n          '': unknown\n        }\n        Returns: unknown\n      }\n      gtrgm_in: {\n        Args: {\n          '': unknown\n        }\n        Returns: unknown\n      }\n      gtrgm_options: {\n        Args: {\n          '': unknown\n        }\n        Returns: undefined\n      }\n      gtrgm_out: {\n        Args: {\n          '': unknown\n        }\n        Returns: unknown\n      }\n      halfvec_avg: {\n        Args: {\n          '': number[]\n        }\n        Returns: unknown\n      }\n      halfvec_out: {\n        Args: {\n          '': unknown\n        }\n        Returns: unknown\n      }\n      halfvec_send: {\n        Args: {\n          '': unknown\n        }\n        Returns: string\n      }\n      halfvec_typmod_in: {\n        Args: {\n          '': unknown[]\n        }\n        Returns: number\n      }\n      has_moderator_or_above_role: {\n        Args: {\n          this_group_id: string\n          this_user_id: string\n        }\n        Returns: boolean\n      }\n      hnsw_bit_support: {\n        Args: {\n          '': unknown\n        }\n        Returns: unknown\n      }\n      hnsw_halfvec_support: {\n        Args: {\n          '': unknown\n        }\n        Returns: unknown\n      }\n      hnsw_sparsevec_support: {\n        Args: {\n          '': unknown\n        }\n        Returns: unknown\n      }\n      hnswhandler: {\n        Args: {\n          '': unknown\n        }\n        Returns: unknown\n      }\n      install_available_extensions_and_test: {\n        Args: Record<PropertyKey, never>\n        Returns: boolean\n      }\n      is_admin: {\n        Args: {\n          input_string: string\n        }\n        Returns: boolean\n      }\n      is_group_member: {\n        Args: {\n          this_group_id: string\n          this_user_id: string\n        }\n        Returns: boolean\n      }\n      is_valid_contract: {\n        Args: {\n          ct: unknown\n        }\n        Returns: boolean\n      }\n      ivfflat_bit_support: {\n        Args: {\n          '': unknown\n        }\n        Returns: unknown\n      }\n      ivfflat_halfvec_support: {\n        Args: {\n          '': unknown\n        }\n        Returns: unknown\n      }\n      ivfflathandler: {\n        Args: {\n          '': unknown\n        }\n        Returns: unknown\n      }\n      jsonb_array_to_text_array: {\n        Args: {\n          _js: Json\n        }\n        Returns: string[]\n      }\n      l2_norm:\n        | {\n            Args: {\n              '': unknown\n            }\n            Returns: number\n          }\n        | {\n            Args: {\n              '': unknown\n            }\n            Returns: number\n          }\n      l2_normalize:\n        | {\n            Args: {\n              '': string\n            }\n            Returns: string\n          }\n        | {\n            Args: {\n              '': unknown\n            }\n            Returns: unknown\n          }\n        | {\n            Args: {\n              '': unknown\n            }\n            Returns: unknown\n          }\n      millis_interval: {\n        Args: {\n          start_millis: number\n          end_millis: number\n        }\n        Returns: unknown\n      }\n      millis_to_ts: {\n        Args: {\n          millis: number\n        }\n        Returns: string\n      }\n      profit_leaderboard: {\n        Args: {\n          limit_n: number\n        }\n        Returns: {\n          user_id: string\n          profit: number\n          name: string\n          username: string\n          avatar_url: string\n        }[]\n      }\n      profit_rank: {\n        Args: {\n          uid: string\n          excluded_ids?: string[]\n        }\n        Returns: number\n      }\n      random_alphanumeric: {\n        Args: {\n          length: number\n        }\n        Returns: string\n      }\n      recently_liked_contract_counts: {\n        Args: {\n          since: number\n        }\n        Returns: {\n          contract_id: string\n          n: number\n        }[]\n      }\n      sample_resolved_bets: {\n        Args: {\n          trader_threshold: number\n          p: number\n        }\n        Returns: {\n          prob: number\n          is_yes: boolean\n        }[]\n      }\n      save_user_topics_blank: {\n        Args: {\n          p_user_id: string\n        }\n        Returns: undefined\n      }\n      search_contract_embeddings: {\n        Args: {\n          query_embedding: string\n          similarity_threshold: number\n          match_count: number\n        }\n        Returns: {\n          contract_id: string\n          similarity: number\n        }[]\n      }\n      set_limit: {\n        Args: {\n          '': number\n        }\n        Returns: number\n      }\n      show_limit: {\n        Args: Record<PropertyKey, never>\n        Returns: number\n      }\n      show_trgm: {\n        Args: {\n          '': string\n        }\n        Returns: string[]\n      }\n      sparsevec_out: {\n        Args: {\n          '': unknown\n        }\n        Returns: unknown\n      }\n      sparsevec_send: {\n        Args: {\n          '': unknown\n        }\n        Returns: string\n      }\n      sparsevec_typmod_in: {\n        Args: {\n          '': unknown[]\n        }\n        Returns: number\n      }\n      test: {\n        Args: Record<PropertyKey, never>\n        Returns: undefined\n      }\n      to_jsonb: {\n        Args: {\n          '': Json\n        }\n        Returns: Json\n      }\n      ts_to_millis:\n        | {\n            Args: {\n              ts: string\n            }\n            Returns: number\n          }\n        | {\n            Args: {\n              ts: string\n            }\n            Returns: number\n          }\n      vector_avg: {\n        Args: {\n          '': number[]\n        }\n        Returns: string\n      }\n      vector_dims:\n        | {\n            Args: {\n              '': string\n            }\n            Returns: number\n          }\n        | {\n            Args: {\n              '': unknown\n            }\n            Returns: number\n          }\n      vector_norm: {\n        Args: {\n          '': string\n        }\n        Returns: number\n      }\n      vector_out: {\n        Args: {\n          '': string\n        }\n        Returns: unknown\n      }\n      vector_send: {\n        Args: {\n          '': string\n        }\n        Returns: string\n      }\n      vector_typmod_in: {\n        Args: {\n          '': unknown[]\n        }\n        Returns: number\n      }\n    }\n    Enums: {\n      status_type: 'new' | 'under review' | 'resolved' | 'needs admin'\n    }\n    CompositeTypes: {\n      love_question_with_count_type: {\n        id: number | null\n        creator_id: string | null\n        created_time: string | null\n        question: string | null\n        importance_score: number | null\n        answer_type: string | null\n        multiple_choice_options: Json | null\n        answer_count: number | null\n      }\n      other_lover_answers_type: {\n        question_id: number | null\n        created_time: string | null\n        free_response: string | null\n        multiple_choice: number | null\n        integer: number | null\n        age: number | null\n        gender: string | null\n        city: string | null\n        data: Json | null\n      }\n    }\n  }\n}\n\ntype PublicSchema = Database[Extract<keyof Database, 'public'>]\n\nexport type Tables<\n  PublicTableNameOrOptions extends\n    | keyof (PublicSchema['Tables'] & PublicSchema['Views'])\n    | { schema: keyof Database },\n  TableName extends PublicTableNameOrOptions extends { schema: keyof Database }\n    ? keyof (Database[PublicTableNameOrOptions['schema']]['Tables'] &\n        Database[PublicTableNameOrOptions['schema']]['Views'])\n    : never = never\n> = PublicTableNameOrOptions extends { schema: keyof Database }\n  ? (Database[PublicTableNameOrOptions['schema']]['Tables'] &\n      Database[PublicTableNameOrOptions['schema']]['Views'])[TableName] extends {\n      Row: infer R\n    }\n    ? R\n    : never\n  : PublicTableNameOrOptions extends keyof (PublicSchema['Tables'] &\n      PublicSchema['Views'])\n  ? (PublicSchema['Tables'] &\n      PublicSchema['Views'])[PublicTableNameOrOptions] extends {\n      Row: infer R\n    }\n    ? R\n    : never\n  : never\n\nexport type TablesInsert<\n  PublicTableNameOrOptions extends\n    | keyof PublicSchema['Tables']\n    | { schema: keyof Database },\n  TableName extends PublicTableNameOrOptions extends { schema: keyof Database }\n    ? keyof Database[PublicTableNameOrOptions['schema']]['Tables']\n    : never = never\n> = PublicTableNameOrOptions extends { schema: keyof Database }\n  ? Database[PublicTableNameOrOptions['schema']]['Tables'][TableName] extends {\n      Insert: infer I\n    }\n    ? I\n    : never\n  : PublicTableNameOrOptions extends keyof PublicSchema['Tables']\n  ? PublicSchema['Tables'][PublicTableNameOrOptions] extends {\n      Insert: infer I\n    }\n    ? I\n    : never\n  : never\n\nexport type TablesUpdate<\n  PublicTableNameOrOptions extends\n    | keyof PublicSchema['Tables']\n    | { schema: keyof Database },\n  TableName extends PublicTableNameOrOptions extends { schema: keyof Database }\n    ? keyof Database[PublicTableNameOrOptions['schema']]['Tables']\n    : never = never\n> = PublicTableNameOrOptions extends { schema: keyof Database }\n  ? Database[PublicTableNameOrOptions['schema']]['Tables'][TableName] extends {\n      Update: infer U\n    }\n    ? U\n    : never\n  : PublicTableNameOrOptions extends keyof PublicSchema['Tables']\n  ? PublicSchema['Tables'][PublicTableNameOrOptions] extends {\n      Update: infer U\n    }\n    ? U\n    : never\n  : never\n\nexport type Enums<\n  PublicEnumNameOrOptions extends\n    | keyof PublicSchema['Enums']\n    | { schema: keyof Database },\n  EnumName extends PublicEnumNameOrOptions extends { schema: keyof Database }\n    ? keyof Database[PublicEnumNameOrOptions['schema']]['Enums']\n    : never = never\n> = PublicEnumNameOrOptions extends { schema: keyof Database }\n  ? Database[PublicEnumNameOrOptions['schema']]['Enums'][EnumName]\n  : PublicEnumNameOrOptions extends keyof PublicSchema['Enums']\n  ? PublicSchema['Enums'][PublicEnumNameOrOptions]\n  : never\n\nexport type CompositeTypes<\n  PublicCompositeTypeNameOrOptions extends\n    | keyof PublicSchema['CompositeTypes']\n    | { schema: keyof Database },\n  CompositeTypeName extends PublicCompositeTypeNameOrOptions extends {\n    schema: keyof Database\n  }\n    ? keyof Database[PublicCompositeTypeNameOrOptions['schema']]['CompositeTypes']\n    : never = never\n> = PublicCompositeTypeNameOrOptions extends { schema: keyof Database }\n  ? Database[PublicCompositeTypeNameOrOptions['schema']]['CompositeTypes'][CompositeTypeName]\n  : PublicCompositeTypeNameOrOptions extends keyof PublicSchema['CompositeTypes']\n  ? PublicSchema['CompositeTypes'][PublicCompositeTypeNameOrOptions]\n  : never\n",
          "postContent": "export type Json =\n  | string\n  | number\n  | boolean\n  | null\n  | { [key: string]: Json | undefined }\n  | Json[]\n\nexport type Database = {\n  public: {\n    Tables: {\n      answers: {\n        Row: {\n          color: string | null\n          contract_id: string | null\n          created_time: string | null\n          id: string\n          index: number | null\n          is_other: boolean\n          pool_no: number | null\n          pool_yes: number | null\n          prob: number | null\n          prob_change_day: number | null\n          prob_change_month: number | null\n          prob_change_week: number | null\n          resolution: string | null\n          resolution_probability: number | null\n          resolution_time: string | null\n          resolver_id: string | null\n          subsidy_pool: number | null\n          text: string | null\n          text_fts: unknown | null\n          total_liquidity: number | null\n          user_id: string | null\n          image_url: string | null\n          short_text: string | null\n          midpoint: number | null\n        }\n        Insert: {\n          color?: string | null\n          contract_id?: string | null\n          created_time?: string | null\n          id?: string\n          index?: number | null\n          is_other?: boolean\n          pool_no?: number | null\n          pool_yes?: number | null\n          prob?: number | null\n          prob_change_day?: number | null\n          prob_change_month?: number | null\n          prob_change_week?: number | null\n          resolution?: string | null\n          resolution_probability?: number | null\n          resolution_time?: string | null\n          resolver_id?: string | null\n          subsidy_pool?: number | null\n          text?: string | null\n          text_fts?: unknown | null\n          total_liquidity?: number | null\n          user_id?: string | null\n          image_url?: string | null\n          short_text?: string | null\n          midpoint?: number | null\n        }\n        Update: {\n          color?: string | null\n          contract_id?: string | null\n          created_time?: string | null\n          id?: string\n          index?: number | null\n          is_other?: boolean\n          pool_no?: number | null\n          pool_yes?: number | null\n          prob?: number | null\n          prob_change_day?: number | null\n          prob_change_month?: number | null\n          prob_change_week?: number | null\n          resolution?: string | null\n          resolution_probability?: number | null\n          resolution_time?: string | null\n          resolver_id?: string | null\n          subsidy_pool?: number | null\n          text?: string | null\n          text_fts?: unknown | null\n          total_liquidity?: number | null\n          user_id?: string | null\n          image_url?: string | null\n          short_text?: string | null\n          midpoint?: number | null\n        }\n        Relationships: []\n      }\n      audit_events: {\n        Row: {\n          comment_id: string | null\n          contract_id: string | null\n          created_time: string\n          data: Json | null\n          id: number\n          name: string\n          user_id: string\n        }\n        Insert: {\n          comment_id?: string | null\n          contract_id?: string | null\n          created_time?: string\n          data?: Json | null\n          id?: never\n          name: string\n          user_id: string\n        }\n        Update: {\n          comment_id?: string | null\n          contract_id?: string | null\n          created_time?: string\n          data?: Json | null\n          id?: never\n          name?: string\n          user_id?: string\n        }\n        Relationships: []\n      }\n      chart_annotations: {\n        Row: {\n          answer_id: string | null\n          comment_id: string | null\n          contract_id: string\n          created_time: string\n          creator_avatar_url: string\n          creator_id: string\n          creator_name: string\n          creator_username: string\n          down_votes: number\n          event_time: number\n          external_url: string | null\n          id: number\n          prob_change: number | null\n          text: string | null\n          thumbnail_url: string | null\n          up_votes: number\n          user_id: string | null\n        }\n        Insert: {\n          answer_id?: string | null\n          comment_id?: string | null\n          contract_id: string\n          created_time?: string\n          creator_avatar_url: string\n          creator_id: string\n          creator_name: string\n          creator_username: string\n          down_votes?: number\n          event_time: number\n          external_url?: string | null\n          id?: never\n          prob_change?: number | null\n          text?: string | null\n          thumbnail_url?: string | null\n          up_votes?: number\n          user_id?: string | null\n        }\n        Update: {\n          answer_id?: string | null\n          comment_id?: string | null\n          contract_id?: string\n          created_time?: string\n          creator_avatar_url?: string\n          creator_id?: string\n          creator_name?: string\n          creator_username?: string\n          down_votes?: number\n          event_time?: number\n          external_url?: string | null\n          id?: never\n          prob_change?: number | null\n          text?: string | null\n          thumbnail_url?: string | null\n          up_votes?: number\n          user_id?: string | null\n        }\n        Relationships: []\n      }\n      chat_messages: {\n        Row: {\n          channel_id: string\n          content: Json\n          created_time: string\n          id: number\n          user_id: string\n        }\n        Insert: {\n          channel_id: string\n          content: Json\n          created_time?: string\n          id?: number\n          user_id: string\n        }\n        Update: {\n          channel_id?: string\n          content?: Json\n          created_time?: string\n          id?: number\n          user_id?: string\n        }\n        Relationships: []\n      }\n      contract_bets: {\n        Row: {\n          amount: number | null\n          answer_id: string | null\n          bet_id: string\n          contract_id: string\n          created_time: string\n          data: Json\n          expires_at: string | null\n          is_api: boolean | null\n          is_cancelled: boolean | null\n          is_filled: boolean | null\n          is_redemption: boolean | null\n          loan_amount: number | null\n          outcome: string | null\n          prob_after: number | null\n          prob_before: number | null\n          shares: number | null\n          updated_time: string\n          user_id: string\n        }\n        Insert: {\n          amount?: number | null\n          answer_id?: string | null\n          bet_id?: string\n          contract_id: string\n          created_time?: string\n          data: Json\n          expires_at?: string | null\n          is_api?: boolean | null\n          is_cancelled?: boolean | null\n          is_filled?: boolean | null\n          is_redemption?: boolean | null\n          loan_amount?: number | null\n          outcome?: string | null\n          prob_after?: number | null\n          prob_before?: number | null\n          shares?: number | null\n          updated_time?: string\n          user_id: string\n        }\n        Update: {\n          amount?: number | null\n          answer_id?: string | null\n          bet_id?: string\n          contract_id?: string\n          created_time?: string\n          data?: Json\n          expires_at?: string | null\n          is_api?: boolean | null\n          is_cancelled?: boolean | null\n          is_filled?: boolean | null\n          is_redemption?: boolean | null\n          loan_amount?: number | null\n          outcome?: string | null\n          prob_after?: number | null\n          prob_before?: number | null\n          shares?: number | null\n          updated_time?: string\n          user_id?: string\n        }\n        Relationships: []\n      }\n      contract_boosts: {\n        Row: {\n          contract_id: string\n          end_time: string\n          id: number\n          start_time: string\n          user_id: string\n        }\n        Insert: {\n          contract_id: string\n          end_time: string\n          id?: never\n          start_time: string\n          user_id: string\n        }\n        Update: {\n          contract_id?: string\n          end_time?: string\n          id?: never\n          start_time?: string\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'contract_boosts_contract_id_fkey'\n            columns: ['contract_id']\n            isOneToOne: false\n            referencedRelation: 'contracts'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'contract_boosts_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'user_referrals_profit'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'contract_boosts_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'users'\n            referencedColumns: ['id']\n          }\n        ]\n      }\n      contract_comment_edits: {\n        Row: {\n          comment_id: string\n          contract_id: string\n          created_time: string\n          data: Json\n          editor_id: string\n          id: number\n        }\n        Insert: {\n          comment_id: string\n          contract_id: string\n          created_time?: string\n          data: Json\n          editor_id: string\n          id?: number\n        }\n        Update: {\n          comment_id?: string\n          contract_id?: string\n          created_time?: string\n          data?: Json\n          editor_id?: string\n          id?: number\n        }\n        Relationships: []\n      }\n      contract_comments: {\n        Row: {\n          comment_id: string\n          contract_id: string\n          created_time: string\n          data: Json\n          downvotes: number | null\n          likes: number\n          upvotes: number | null\n          user_id: string\n          visibility: string | null\n        }\n        Insert: {\n          comment_id: string\n          contract_id: string\n          created_time: string\n          data: Json\n          downvotes?: number | null\n          likes?: number\n          upvotes?: number | null\n          user_id: string\n          visibility?: string | null\n        }\n        Update: {\n          comment_id?: string\n          contract_id?: string\n          created_time?: string\n          data?: Json\n          downvotes?: number | null\n          likes?: number\n          upvotes?: number | null\n          user_id?: string\n          visibility?: string | null\n        }\n        Relationships: []\n      }\n      contract_edits: {\n        Row: {\n          contract_id: string\n          created_time: string\n          data: Json\n          editor_id: string\n          id: number\n          idempotency_key: string | null\n          updated_keys: string[] | null\n        }\n        Insert: {\n          contract_id: string\n          created_time?: string\n          data: Json\n          editor_id: string\n          id?: number\n          idempotency_key?: string | null\n          updated_keys?: string[] | null\n        }\n        Update: {\n          contract_id?: string\n          created_time?: string\n          data?: Json\n          editor_id?: string\n          id?: number\n          idempotency_key?: string | null\n          updated_keys?: string[] | null\n        }\n        Relationships: []\n      }\n      contract_embeddings: {\n        Row: {\n          contract_id: string\n          created_at: string\n          embedding: string\n        }\n        Insert: {\n          contract_id: string\n          created_at?: string\n          embedding: string\n        }\n        Update: {\n          contract_id?: string\n          created_at?: string\n          embedding?: string\n        }\n        Relationships: []\n      }\n      contract_follows: {\n        Row: {\n          contract_id: string\n          created_time: string\n          follow_id: string\n        }\n        Insert: {\n          contract_id: string\n          created_time?: string\n          follow_id: string\n        }\n        Update: {\n          contract_id?: string\n          created_time?: string\n          follow_id?: string\n        }\n        Relationships: []\n      }\n      contract_liquidity: {\n        Row: {\n          contract_id: string\n          data: Json\n          liquidity_id: string\n        }\n        Insert: {\n          contract_id: string\n          data: Json\n          liquidity_id: string\n        }\n        Update: {\n          contract_id?: string\n          data?: Json\n          liquidity_id?: string\n        }\n        Relationships: []\n      }\n      contract_movement_notifications: {\n        Row: {\n          answer_id: string | null\n          contract_id: string\n          created_time: string\n          destination: string\n          id: number\n          user_id: string\n          new_val: number\n          new_val_start_time: string\n          prev_val: number\n          prev_val_start_time: string\n        }\n        Insert: {\n          answer_id?: string | null\n          contract_id: string\n          created_time?: string\n          destination: string\n          id?: never\n          user_id: string\n          new_val: number\n          new_val_start_time?: string\n          prev_val: number\n          prev_val_start_time?: string\n        }\n        Update: {\n          answer_id?: string | null\n          contract_id?: string\n          created_time?: string\n          destination?: string\n          id?: never\n          user_id?: string\n          new_val?: number\n          new_val_start_time?: string\n          prev_val?: number\n          prev_val_start_time?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'fk_contract_id'\n            columns: ['contract_id']\n            isOneToOne: false\n            referencedRelation: 'contracts'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'fk_user_id'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'user_referrals_profit'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'fk_user_id'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'users'\n            referencedColumns: ['id']\n          }\n        ]\n      }\n      contracts: {\n        Row: {\n          close_time: string | null\n          conversion_score: number\n          created_time: string | null\n          creator_id: string | null\n          daily_score: number\n          data: Json\n          deleted: boolean | null\n          description_fts: unknown | null\n          freshness_score: number\n          group_slugs: string[] | null\n          id: string\n          importance_score: number\n          is_spice_payout: boolean | null\n          last_bet_time: string | null\n          last_comment_time: string | null\n          last_updated_time: string | null\n          mechanism: string | null\n          outcome_type: string | null\n          popularity_score: number\n          question: string | null\n          question_fts: unknown | null\n          question_nostop_fts: unknown | null\n          resolution: string | null\n          resolution_probability: number | null\n          resolution_time: string | null\n          slug: string | null\n          tier: string | null\n          token: string\n          unique_bettor_count: number\n          view_count: number\n          visibility: string | null\n          boosted: boolean | null\n        }\n        Insert: {\n          close_time?: string | null\n          conversion_score?: number\n          created_time?: string | null\n          creator_id?: string | null\n          daily_score?: number\n          data: Json\n          deleted?: boolean | null\n          description_fts?: unknown | null\n          freshness_score?: number\n          group_slugs?: string[] | null\n          id: string\n          importance_score?: number\n          is_spice_payout?: boolean | null\n          last_bet_time?: string | null\n          last_comment_time?: string | null\n          last_updated_time?: string | null\n          mechanism?: string | null\n          outcome_type?: string | null\n          popularity_score?: number\n          question?: string | null\n          question_fts?: unknown | null\n          question_nostop_fts?: unknown | null\n          resolution?: string | null\n          resolution_probability?: number | null\n          resolution_time?: string | null\n          slug?: string | null\n          tier?: string | null\n          token?: string\n          unique_bettor_count?: number\n          view_count?: number\n          visibility?: string | null\n          boosted?: boolean | null\n        }\n        Update: {\n          close_time?: string | null\n          conversion_score?: number\n          created_time?: string | null\n          creator_id?: string | null\n          daily_score?: number\n          data?: Json\n          deleted?: boolean | null\n          description_fts?: unknown | null\n          freshness_score?: number\n          group_slugs?: string[] | null\n          id?: string\n          importance_score?: number\n          is_spice_payout?: boolean | null\n          last_bet_time?: string | null\n          last_comment_time?: string | null\n          last_updated_time?: string | null\n          mechanism?: string | null\n          outcome_type?: string | null\n          popularity_score?: number\n          question?: string | null\n          question_fts?: unknown | null\n          question_nostop_fts?: unknown | null\n          resolution?: string | null\n          resolution_probability?: number | null\n          resolution_time?: string | null\n          slug?: string | null\n          tier?: string | null\n          token?: string\n          unique_bettor_count?: number\n          view_count?: number\n          visibility?: string | null\n          boosted?: boolean | null\n        }\n        Relationships: []\n      }\n      creator_portfolio_history: {\n        Row: {\n          fees_earned: number\n          id: number\n          ts: string\n          unique_bettors: number\n          user_id: string\n          views: number\n          volume: number\n        }\n        Insert: {\n          fees_earned: number\n          id?: never\n          ts?: string\n          unique_bettors: number\n          user_id: string\n          views: number\n          volume: number\n        }\n        Update: {\n          fees_earned?: number\n          id?: never\n          ts?: string\n          unique_bettors?: number\n          user_id?: string\n          views?: number\n          volume?: number\n        }\n        Relationships: []\n      }\n      daily_stats: {\n        Row: {\n          activation: number | null\n          active_d1_to_d3: number | null\n          avg_user_actions: number | null\n          bet_amount: number | null\n          bet_count: number | null\n          cash_bet_amount: number | null\n          comment_count: number | null\n          contract_count: number | null\n          d1: number | null\n          d1_bet_3_day_average: number | null\n          d1_bet_average: number | null\n          dau: number | null\n          engaged_users: number | null\n          feed_conversion: number | null\n          m1: number | null\n          mau: number | null\n          nd1: number | null\n          nw1: number | null\n          sales: number | null\n          cash_sales: number | null\n          signups: number | null\n          signups_real: number | null\n          start_date: string\n          w1: number | null\n          dav: number | null\n          wav: number | null\n          mav: number | null\n          wau: number | null\n          topic_daus: Json | null\n          cash_bet_count: number | null\n          cash_d1: number | null\n          cash_w1: number | null\n          cash_m1: number | null\n          cash_dau: number | null\n          cash_wau: number | null\n          cash_mau: number | null\n          cash_comment_count: number | null\n          cash_contract_count: number | null\n          cash_avg_user_actions: number | null\n        }\n        Insert: {\n          activation?: number | null\n          active_d1_to_d3?: number | null\n          avg_user_actions?: number | null\n          bet_amount?: number | null\n          bet_count?: number | null\n          cash_bet_amount?: number | null\n          comment_count?: number | null\n          contract_count?: number | null\n          d1?: number | null\n          d1_bet_3_day_average?: number | null\n          d1_bet_average?: number | null\n          dau?: number | null\n          engaged_users?: number | null\n          feed_conversion?: number | null\n          m1?: number | null\n          mau?: number | null\n          nd1?: number | null\n          nw1?: number | null\n          sales?: number | null\n          cash_sales?: number | null\n          signups?: number | null\n          signups_real?: number | null\n          start_date: string\n          w1?: number | null\n          dav?: number | null\n          wav?: number | null\n          mav?: number | null\n          wau?: number | null\n          topic_daus?: Json | null\n          cash_bet_count?: number | null\n          cash_d1?: number | null\n          cash_w1?: number | null\n          cash_m1?: number | null\n          cash_dau?: number | null\n          cash_wau?: number | null\n          cash_mau?: number | null\n          cash_comment_count?: number | null\n          cash_contract_count?: number | null\n          cash_avg_user_actions?: number | null\n        }\n        Update: {\n          activation?: number | null\n          active_d1_to_d3?: number | null\n          avg_user_actions?: number | null\n          bet_amount?: number | null\n          bet_count?: number | null\n          cash_bet_amount?: number | null\n          comment_count?: number | null\n          contract_count?: number | null\n          d1?: number | null\n          d1_bet_3_day_average?: number | null\n          d1_bet_average?: number | null\n          dau?: number | null\n          engaged_users?: number | null\n          feed_conversion?: number | null\n          m1?: number | null\n          dav?: number | null\n          wav?: number | null\n          mav?: number | null\n          mau?: number | null\n          nd1?: number | null\n          nw1?: number | null\n          sales?: number | null\n          cash_sales?: number | null\n          signups?: number | null\n          signups_real?: number | null\n          start_date?: string\n          w1?: number | null\n          wau?: number | null\n          topic_daus?: Json | null\n          cash_bet_count?: number | null\n          cash_d1?: number | null\n          cash_w1?: number | null\n          cash_m1?: number | null\n          cash_dau?: number | null\n          cash_wau?: number | null\n          cash_mau?: number | null\n          cash_comment_count?: number | null\n          cash_contract_count?: number | null\n          cash_avg_user_actions?: number | null\n        }\n        Relationships: []\n      }\n      dashboard_follows: {\n        Row: {\n          created_time: string | null\n          dashboard_id: string\n          follower_id: string\n        }\n        Insert: {\n          created_time?: string | null\n          dashboard_id: string\n          follower_id: string\n        }\n        Update: {\n          created_time?: string | null\n          dashboard_id?: string\n          follower_id?: string\n        }\n        Relationships: []\n      }\n      dashboard_groups: {\n        Row: {\n          dashboard_id: string\n          group_id: string\n        }\n        Insert: {\n          dashboard_id: string\n          group_id: string\n        }\n        Update: {\n          dashboard_id?: string\n          group_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'dashboard_groups_dashboard_id_fkey'\n            columns: ['dashboard_id']\n            isOneToOne: false\n            referencedRelation: 'dashboards'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'public_dashboard_groups_group_id_fkey'\n            columns: ['group_id']\n            isOneToOne: false\n            referencedRelation: 'group_role'\n            referencedColumns: ['group_id']\n          },\n          {\n            foreignKeyName: 'public_dashboard_groups_group_id_fkey'\n            columns: ['group_id']\n            isOneToOne: false\n            referencedRelation: 'groups'\n            referencedColumns: ['id']\n          }\n        ]\n      }\n      dashboards: {\n        Row: {\n          ai_importance_score: number\n          created_time: string\n          creator_avatar_url: string\n          creator_id: string\n          creator_name: string\n          creator_username: string\n          id: string\n          importance_score: number\n          items: Json | null\n          politics_importance_score: number\n          slug: string\n          title: string\n          title_fts: unknown | null\n          visibility: string | null\n        }\n        Insert: {\n          ai_importance_score?: number\n          created_time?: string\n          creator_avatar_url: string\n          creator_id: string\n          creator_name: string\n          creator_username: string\n          id?: string\n          importance_score?: number\n          items?: Json | null\n          politics_importance_score?: number\n          slug: string\n          title: string\n          title_fts?: unknown | null\n          visibility?: string | null\n        }\n        Update: {\n          ai_importance_score?: number\n          created_time?: string\n          creator_avatar_url?: string\n          creator_id?: string\n          creator_name?: string\n          creator_username?: string\n          id?: string\n          importance_score?: number\n          items?: Json | null\n          politics_importance_score?: number\n          slug?: string\n          title?: string\n          title_fts?: unknown | null\n          visibility?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'dashboards_creator_id_fkey'\n            columns: ['creator_id']\n            isOneToOne: false\n            referencedRelation: 'user_referrals_profit'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'dashboards_creator_id_fkey'\n            columns: ['creator_id']\n            isOneToOne: false\n            referencedRelation: 'users'\n            referencedColumns: ['id']\n          }\n        ]\n      }\n      delete_after_reading: {\n        Row: {\n          created_time: string\n          data: Json | null\n          id: number\n          user_id: string\n        }\n        Insert: {\n          created_time?: string\n          data?: Json | null\n          id?: never\n          user_id: string\n        }\n        Update: {\n          created_time?: string\n          data?: Json | null\n          id?: never\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'delete_after_reading_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'user_referrals_profit'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'delete_after_reading_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'users'\n            referencedColumns: ['id']\n          }\n        ]\n      }\n      discord_messages_markets: {\n        Row: {\n          channel_id: string\n          last_updated_thread_time: number | null\n          market_id: string\n          market_slug: string\n          message_id: string\n          thread_id: string | null\n        }\n        Insert: {\n          channel_id: string\n          last_updated_thread_time?: number | null\n          market_id: string\n          market_slug: string\n          message_id: string\n          thread_id?: string | null\n        }\n        Update: {\n          channel_id?: string\n          last_updated_thread_time?: number | null\n          market_id?: string\n          market_slug?: string\n          message_id?: string\n          thread_id?: string | null\n        }\n        Relationships: []\n      }\n      discord_users: {\n        Row: {\n          api_key: string\n          discord_user_id: string\n          user_id: string\n        }\n        Insert: {\n          api_key: string\n          discord_user_id: string\n          user_id: string\n        }\n        Update: {\n          api_key?: string\n          discord_user_id?: string\n          user_id?: string\n        }\n        Relationships: []\n      }\n      gidx_receipts: {\n        Row: {\n          amount: number | null\n          callback_data: Json | null\n          created_time: string\n          currency: string | null\n          id: number\n          merchant_session_id: string | null\n          merchant_transaction_id: string\n          payment_amount_type: string | null\n          payment_data: Json | null\n          payment_method_type: string | null\n          payment_status_code: string | null\n          payment_status_message: string | null\n          reason_codes: string[] | null\n          service_type: string | null\n          session_id: string\n          session_score: number | null\n          status: string | null\n          status_code: number | null\n          transaction_status_code: string | null\n          transaction_status_message: string | null\n          txn_id: string | null\n          user_id: string | null\n        }\n        Insert: {\n          amount?: number | null\n          callback_data?: Json | null\n          created_time?: string\n          currency?: string | null\n          id?: never\n          merchant_session_id?: string | null\n          merchant_transaction_id: string\n          payment_amount_type?: string | null\n          payment_data?: Json | null\n          payment_method_type?: string | null\n          payment_status_code?: string | null\n          payment_status_message?: string | null\n          reason_codes?: string[] | null\n          service_type?: string | null\n          session_id: string\n          session_score?: number | null\n          status?: string | null\n          status_code?: number | null\n          transaction_status_code?: string | null\n          transaction_status_message?: string | null\n          txn_id?: string | null\n          user_id?: string | null\n        }\n        Update: {\n          amount?: number | null\n          callback_data?: Json | null\n          created_time?: string\n          currency?: string | null\n          id?: never\n          merchant_session_id?: string | null\n          merchant_transaction_id?: string\n          payment_amount_type?: string | null\n          payment_data?: Json | null\n          payment_method_type?: string | null\n          payment_status_code?: string | null\n          payment_status_message?: string | null\n          reason_codes?: string[] | null\n          service_type?: string | null\n          session_id?: string\n          session_score?: number | null\n          status?: string | null\n          status_code?: number | null\n          transaction_status_code?: string | null\n          transaction_status_message?: string | null\n          txn_id?: string | null\n          user_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'gidx_receipts_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'user_referrals_profit'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'gidx_receipts_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'users'\n            referencedColumns: ['id']\n          }\n        ]\n      }\n      group_contracts: {\n        Row: {\n          contract_id: string\n          group_id: string\n        }\n        Insert: {\n          contract_id: string\n          group_id: string\n        }\n        Update: {\n          contract_id?: string\n          group_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'group_contracts_group_id_fkey'\n            columns: ['group_id']\n            isOneToOne: false\n            referencedRelation: 'group_role'\n            referencedColumns: ['group_id']\n          },\n          {\n            foreignKeyName: 'group_contracts_group_id_fkey'\n            columns: ['group_id']\n            isOneToOne: false\n            referencedRelation: 'groups'\n            referencedColumns: ['id']\n          }\n        ]\n      }\n      group_embeddings: {\n        Row: {\n          created_time: string\n          embedding: string\n          group_id: string\n        }\n        Insert: {\n          created_time?: string\n          embedding: string\n          group_id: string\n        }\n        Update: {\n          created_time?: string\n          embedding?: string\n          group_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_group_embeddings_group_id_fkey'\n            columns: ['group_id']\n            isOneToOne: true\n            referencedRelation: 'group_role'\n            referencedColumns: ['group_id']\n          },\n          {\n            foreignKeyName: 'public_group_embeddings_group_id_fkey'\n            columns: ['group_id']\n            isOneToOne: true\n            referencedRelation: 'groups'\n            referencedColumns: ['id']\n          }\n        ]\n      }\n      group_groups: {\n        Row: {\n          bottom_id: string\n          top_id: string\n        }\n        Insert: {\n          bottom_id: string\n          top_id: string\n        }\n        Update: {\n          bottom_id?: string\n          top_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'group_groups_bottom_id_fkey'\n            columns: ['bottom_id']\n            isOneToOne: false\n            referencedRelation: 'group_role'\n            referencedColumns: ['group_id']\n          },\n          {\n            foreignKeyName: 'group_groups_bottom_id_fkey'\n            columns: ['bottom_id']\n            isOneToOne: false\n            referencedRelation: 'groups'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'group_groups_top_id_fkey'\n            columns: ['top_id']\n            isOneToOne: false\n            referencedRelation: 'group_role'\n            referencedColumns: ['group_id']\n          },\n          {\n            foreignKeyName: 'group_groups_top_id_fkey'\n            columns: ['top_id']\n            isOneToOne: false\n            referencedRelation: 'groups'\n            referencedColumns: ['id']\n          }\n        ]\n      }\n      group_invites: {\n        Row: {\n          created_time: string\n          duration: unknown | null\n          expire_time: string | null\n          group_id: string\n          id: string\n          is_forever: boolean | null\n          is_max_uses_reached: boolean | null\n          max_uses: number | null\n          uses: number\n        }\n        Insert: {\n          created_time?: string\n          duration?: unknown | null\n          expire_time?: string | null\n          group_id: string\n          id?: string\n          is_forever?: boolean | null\n          is_max_uses_reached?: boolean | null\n          max_uses?: number | null\n          uses?: number\n        }\n        Update: {\n          created_time?: string\n          duration?: unknown | null\n          expire_time?: string | null\n          group_id?: string\n          id?: string\n          is_forever?: boolean | null\n          is_max_uses_reached?: boolean | null\n          max_uses?: number | null\n          uses?: number\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_group_invites_group_id_fkey'\n            columns: ['group_id']\n            isOneToOne: false\n            referencedRelation: 'group_role'\n            referencedColumns: ['group_id']\n          },\n          {\n            foreignKeyName: 'public_group_invites_group_id_fkey'\n            columns: ['group_id']\n            isOneToOne: false\n            referencedRelation: 'groups'\n            referencedColumns: ['id']\n          }\n        ]\n      }\n      group_members: {\n        Row: {\n          created_time: string | null\n          group_id: string\n          member_id: string\n          role: string\n        }\n        Insert: {\n          created_time?: string | null\n          group_id: string\n          member_id: string\n          role?: string\n        }\n        Update: {\n          created_time?: string | null\n          group_id?: string\n          member_id?: string\n          role?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_group_members_group_id_fkey'\n            columns: ['group_id']\n            isOneToOne: false\n            referencedRelation: 'group_role'\n            referencedColumns: ['group_id']\n          },\n          {\n            foreignKeyName: 'public_group_members_group_id_fkey'\n            columns: ['group_id']\n            isOneToOne: false\n            referencedRelation: 'groups'\n            referencedColumns: ['id']\n          }\n        ]\n      }\n      groups: {\n        Row: {\n          about: Json | null\n          banner_url: string | null\n          created_time: string\n          creator_id: string | null\n          id: string\n          importance_score: number | null\n          name: string\n          name_fts: unknown | null\n          privacy_status: string | null\n          slug: string\n          total_members: number | null\n        }\n        Insert: {\n          about?: Json | null\n          banner_url?: string | null\n          created_time?: string\n          creator_id?: string | null\n          id?: string\n          importance_score?: number | null\n          name: string\n          name_fts?: unknown | null\n          privacy_status?: string | null\n          slug: string\n          total_members?: number | null\n        }\n        Update: {\n          about?: Json | null\n          banner_url?: string | null\n          created_time?: string\n          creator_id?: string | null\n          id?: string\n          importance_score?: number | null\n          name?: string\n          name_fts?: unknown | null\n          privacy_status?: string | null\n          slug?: string\n          total_members?: number | null\n        }\n        Relationships: []\n      }\n      kyc_bonus_rewards: {\n        Row: {\n          claim_time: string | null\n          claimed: boolean | null\n          created_time: string | null\n          reward_amount: number\n          user_id: string\n        }\n        Insert: {\n          claim_time?: string | null\n          claimed?: boolean | null\n          created_time?: string | null\n          reward_amount: number\n          user_id: string\n        }\n        Update: {\n          claim_time?: string | null\n          claimed?: boolean | null\n          created_time?: string | null\n          reward_amount?: number\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'kyc_bonus_rewards_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: true\n            referencedRelation: 'user_referrals_profit'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'kyc_bonus_rewards_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: true\n            referencedRelation: 'users'\n            referencedColumns: ['id']\n          }\n        ]\n      }\n      league_chats: {\n        Row: {\n          channel_id: string\n          cohort: string\n          created_time: string\n          division: number\n          id: number\n          owner_id: string | null\n          season: number\n        }\n        Insert: {\n          channel_id: string\n          cohort: string\n          created_time?: string\n          division: number\n          id?: number\n          owner_id?: string | null\n          season: number\n        }\n        Update: {\n          channel_id?: string\n          cohort?: string\n          created_time?: string\n          division?: number\n          id?: number\n          owner_id?: string | null\n          season?: number\n        }\n        Relationships: []\n      }\n      leagues: {\n        Row: {\n          cohort: string\n          created_time: string\n          division: number\n          id: string\n          mana_earned: number\n          mana_earned_breakdown: Json\n          rank_snapshot: number | null\n          season: number\n          user_id: string\n        }\n        Insert: {\n          cohort: string\n          created_time?: string\n          division: number\n          id?: string\n          mana_earned?: number\n          mana_earned_breakdown?: Json\n          rank_snapshot?: number | null\n          season: number\n          user_id: string\n        }\n        Update: {\n          cohort?: string\n          created_time?: string\n          division?: number\n          id?: string\n          mana_earned?: number\n          mana_earned_breakdown?: Json\n          rank_snapshot?: number | null\n          season?: number\n          user_id?: string\n        }\n        Relationships: []\n      }\n      love_answers: {\n        Row: {\n          created_time: string\n          creator_id: string\n          free_response: string | null\n          id: number\n          integer: number | null\n          multiple_choice: number | null\n          question_id: number\n        }\n        Insert: {\n          created_time?: string\n          creator_id: string\n          free_response?: string | null\n          id?: never\n          integer?: number | null\n          multiple_choice?: number | null\n          question_id: number\n        }\n        Update: {\n          created_time?: string\n          creator_id?: string\n          free_response?: string | null\n          id?: never\n          integer?: number | null\n          multiple_choice?: number | null\n          question_id?: number\n        }\n        Relationships: []\n      }\n      love_compatibility_answers: {\n        Row: {\n          created_time: string\n          creator_id: string\n          explanation: string | null\n          id: number\n          importance: number\n          multiple_choice: number\n          pref_choices: number[]\n          question_id: number\n        }\n        Insert: {\n          created_time?: string\n          creator_id: string\n          explanation?: string | null\n          id?: never\n          importance: number\n          multiple_choice: number\n          pref_choices: number[]\n          question_id: number\n        }\n        Update: {\n          created_time?: string\n          creator_id?: string\n          explanation?: string | null\n          id?: never\n          importance?: number\n          multiple_choice?: number\n          pref_choices?: number[]\n          question_id?: number\n        }\n        Relationships: []\n      }\n      love_likes: {\n        Row: {\n          created_time: string\n          creator_id: string\n          like_id: string\n          target_id: string\n        }\n        Insert: {\n          created_time?: string\n          creator_id: string\n          like_id?: string\n          target_id: string\n        }\n        Update: {\n          created_time?: string\n          creator_id?: string\n          like_id?: string\n          target_id?: string\n        }\n        Relationships: []\n      }\n      love_questions: {\n        Row: {\n          answer_type: string\n          created_time: string\n          creator_id: string\n          id: number\n          importance_score: number\n          multiple_choice_options: Json | null\n          question: string\n        }\n        Insert: {\n          answer_type?: string\n          created_time?: string\n          creator_id: string\n          id?: never\n          importance_score?: number\n          multiple_choice_options?: Json | null\n          question: string\n        }\n        Update: {\n          answer_type?: string\n          created_time?: string\n          creator_id?: string\n          id?: never\n          importance_score?: number\n          multiple_choice_options?: Json | null\n          question?: string\n        }\n        Relationships: []\n      }\n      love_ships: {\n        Row: {\n          created_time: string\n          creator_id: string\n          ship_id: string\n          target1_id: string\n          target2_id: string\n        }\n        Insert: {\n          created_time?: string\n          creator_id: string\n          ship_id?: string\n          target1_id: string\n          target2_id: string\n        }\n        Update: {\n          created_time?: string\n          creator_id?: string\n          ship_id?: string\n          target1_id?: string\n          target2_id?: string\n        }\n        Relationships: []\n      }\n      love_stars: {\n        Row: {\n          created_time: string\n          creator_id: string\n          star_id: string\n          target_id: string\n        }\n        Insert: {\n          created_time?: string\n          creator_id: string\n          star_id?: string\n          target_id: string\n        }\n        Update: {\n          created_time?: string\n          creator_id?: string\n          star_id?: string\n          target_id?: string\n        }\n        Relationships: []\n      }\n      love_waitlist: {\n        Row: {\n          created_time: string\n          email: string\n          id: number\n        }\n        Insert: {\n          created_time?: string\n          email: string\n          id?: never\n        }\n        Update: {\n          created_time?: string\n          email?: string\n          id?: never\n        }\n        Relationships: []\n      }\n      lover_comments: {\n        Row: {\n          content: Json\n          created_time: string\n          hidden: boolean\n          id: number\n          on_user_id: string\n          reply_to_comment_id: number | null\n          user_avatar_url: string\n          user_id: string\n          user_name: string\n          user_username: string\n        }\n        Insert: {\n          content: Json\n          created_time?: string\n          hidden?: boolean\n          id?: never\n          on_user_id: string\n          reply_to_comment_id?: number | null\n          user_avatar_url: string\n          user_id: string\n          user_name: string\n          user_username: string\n        }\n        Update: {\n          content?: Json\n          created_time?: string\n          hidden?: boolean\n          id?: never\n          on_user_id?: string\n          reply_to_comment_id?: number | null\n          user_avatar_url?: string\n          user_id?: string\n          user_name?: string\n          user_username?: string\n        }\n        Relationships: []\n      }\n      lovers: {\n        Row: {\n          age: number\n          bio: Json | null\n          born_in_location: string | null\n          city: string\n          city_latitude: number | null\n          city_longitude: number | null\n          comments_enabled: boolean\n          company: string | null\n          country: string | null\n          created_time: string\n          drinks_per_month: number | null\n          education_level: string | null\n          ethnicity: string[] | null\n          gender: string\n          geodb_city_id: string | null\n          has_kids: number | null\n          height_in_inches: number | null\n          id: number\n          is_smoker: boolean | null\n          is_vegetarian_or_vegan: boolean | null\n          last_online_time: string\n          looking_for_matches: boolean\n          messaging_status: string\n          occupation: string | null\n          occupation_title: string | null\n          photo_urls: string[] | null\n          pinned_url: string | null\n          political_beliefs: string[] | null\n          pref_age_max: number\n          pref_age_min: number\n          pref_gender: string[]\n          pref_relation_styles: string[]\n          referred_by_username: string | null\n          region_code: string | null\n          religious_belief_strength: number | null\n          religious_beliefs: string | null\n          twitter: string | null\n          university: string | null\n          user_id: string\n          visibility: string\n          wants_kids_strength: number\n          website: string | null\n        }\n        Insert: {\n          age?: number\n          bio?: Json | null\n          born_in_location?: string | null\n          city: string\n          city_latitude?: number | null\n          city_longitude?: number | null\n          comments_enabled?: boolean\n          company?: string | null\n          country?: string | null\n          created_time?: string\n          drinks_per_month?: number | null\n          education_level?: string | null\n          ethnicity?: string[] | null\n          gender: string\n          geodb_city_id?: string | null\n          has_kids?: number | null\n          height_in_inches?: number | null\n          id?: never\n          is_smoker?: boolean | null\n          is_vegetarian_or_vegan?: boolean | null\n          last_online_time?: string\n          looking_for_matches?: boolean\n          messaging_status?: string\n          occupation?: string | null\n          occupation_title?: string | null\n          photo_urls?: string[] | null\n          pinned_url?: string | null\n          political_beliefs?: string[] | null\n          pref_age_max?: number\n          pref_age_min?: number\n          pref_gender: string[]\n          pref_relation_styles: string[]\n          referred_by_username?: string | null\n          region_code?: string | null\n          religious_belief_strength?: number | null\n          religious_beliefs?: string | null\n          twitter?: string | null\n          university?: string | null\n          user_id: string\n          visibility?: string\n          wants_kids_strength?: number\n          website?: string | null\n        }\n        Update: {\n          age?: number\n          bio?: Json | null\n          born_in_location?: string | null\n          city?: string\n          city_latitude?: number | null\n          city_longitude?: number | null\n          comments_enabled?: boolean\n          company?: string | null\n          country?: string | null\n          created_time?: string\n          drinks_per_month?: number | null\n          education_level?: string | null\n          ethnicity?: string[] | null\n          gender?: string\n          geodb_city_id?: string | null\n          has_kids?: number | null\n          height_in_inches?: number | null\n          id?: never\n          is_smoker?: boolean | null\n          is_vegetarian_or_vegan?: boolean | null\n          last_online_time?: string\n          looking_for_matches?: boolean\n          messaging_status?: string\n          occupation?: string | null\n          occupation_title?: string | null\n          photo_urls?: string[] | null\n          pinned_url?: string | null\n          political_beliefs?: string[] | null\n          pref_age_max?: number\n          pref_age_min?: number\n          pref_gender?: string[]\n          pref_relation_styles?: string[]\n          referred_by_username?: string | null\n          region_code?: string | null\n          religious_belief_strength?: number | null\n          religious_beliefs?: string | null\n          twitter?: string | null\n          university?: string | null\n          user_id?: string\n          visibility?: string\n          wants_kids_strength?: number\n          website?: string | null\n        }\n        Relationships: []\n      }\n      mana_supply_stats: {\n        Row: {\n          amm_cash_liquidity: number\n          amm_liquidity: number\n          balance: number\n          cash_balance: number\n          cash_investment_value: number\n          created_time: string\n          end_time: string\n          full_investment_value: number | null\n          full_loan_total: number | null\n          full_mana_balance: number | null\n          full_spice_balance: number | null\n          full_total_mana_value: number | null\n          id: number\n          investment_value: number\n          loan_total: number\n          spice_balance: number\n          start_time: string\n          total_cash_value: number\n          total_value: number\n        }\n        Insert: {\n          amm_cash_liquidity?: number\n          amm_liquidity: number\n          balance: number\n          cash_balance?: number\n          cash_investment_value?: number\n          created_time?: string\n          end_time: string\n          full_investment_value?: number | null\n          full_loan_total?: number | null\n          full_mana_balance?: number | null\n          full_spice_balance?: number | null\n          full_total_mana_value?: number | null\n          id?: never\n          investment_value: number\n          loan_total: number\n          spice_balance: number\n          start_time: string\n          total_cash_value?: number\n          total_value: number\n        }\n        Update: {\n          amm_cash_liquidity?: number\n          amm_liquidity?: number\n          balance?: number\n          cash_balance?: number\n          cash_investment_value?: number\n          created_time?: string\n          end_time?: string\n          full_investment_value?: number | null\n          full_loan_total?: number | null\n          full_mana_balance?: number | null\n          full_spice_balance?: number | null\n          full_total_mana_value?: number | null\n          id?: never\n          investment_value?: number\n          loan_total?: number\n          spice_balance?: number\n          start_time?: string\n          total_cash_value?: number\n          total_value?: number\n        }\n        Relationships: []\n      }\n      manachan_tweets: {\n        Row: {\n          cost: number | null\n          created_time: number | null\n          id: string\n          tweet: string | null\n          tweet_id: string | null\n          user_id: string | null\n          username: string | null\n        }\n        Insert: {\n          cost?: number | null\n          created_time?: number | null\n          id?: string\n          tweet?: string | null\n          tweet_id?: string | null\n          user_id?: string | null\n          username?: string | null\n        }\n        Update: {\n          cost?: number | null\n          created_time?: number | null\n          id?: string\n          tweet?: string | null\n          tweet_id?: string | null\n          user_id?: string | null\n          username?: string | null\n        }\n        Relationships: []\n      }\n      manalink_claims: {\n        Row: {\n          manalink_id: string\n          txn_id: string\n        }\n        Insert: {\n          manalink_id: string\n          txn_id: string\n        }\n        Update: {\n          manalink_id?: string\n          txn_id?: string\n        }\n        Relationships: []\n      }\n      manalinks: {\n        Row: {\n          amount: number\n          created_time: string | null\n          creator_id: string\n          expires_time: string | null\n          id: string\n          max_uses: number | null\n          message: string | null\n        }\n        Insert: {\n          amount: number\n          created_time?: string | null\n          creator_id: string\n          expires_time?: string | null\n          id?: string\n          max_uses?: number | null\n          message?: string | null\n        }\n        Update: {\n          amount?: number\n          created_time?: string | null\n          creator_id?: string\n          expires_time?: string | null\n          id?: string\n          max_uses?: number | null\n          message?: string | null\n        }\n        Relationships: []\n      }\n      market_ads: {\n        Row: {\n          cost_per_view: number\n          created_at: string\n          embedding: string\n          funds: number\n          id: string\n          market_id: string\n          user_id: string\n        }\n        Insert: {\n          cost_per_view: number\n          created_at?: string\n          embedding: string\n          funds: number\n          id?: string\n          market_id: string\n          user_id: string\n        }\n        Update: {\n          cost_per_view?: number\n          created_at?: string\n          embedding?: string\n          funds?: number\n          id?: string\n          market_id?: string\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'market_ads_market_id_fkey'\n            columns: ['market_id']\n            isOneToOne: false\n            referencedRelation: 'contracts'\n            referencedColumns: ['id']\n          }\n        ]\n      }\n      mod_reports: {\n        Row: {\n          comment_id: string\n          contract_id: string\n          created_time: string\n          mod_note: string | null\n          report_id: number\n          status: Database['public']['Enums']['status_type']\n          user_id: string\n        }\n        Insert: {\n          comment_id: string\n          contract_id: string\n          created_time?: string\n          mod_note?: string | null\n          report_id?: number\n          status?: Database['public']['Enums']['status_type']\n          user_id: string\n        }\n        Update: {\n          comment_id?: string\n          contract_id?: string\n          created_time?: string\n          mod_note?: string | null\n          report_id?: number\n          status?: Database['public']['Enums']['status_type']\n          user_id?: string\n        }\n        Relationships: []\n      }\n      news: {\n        Row: {\n          author: string | null\n          contract_ids: string[] | null\n          created_time: string\n          description: string | null\n          group_ids: string[] | null\n          id: number\n          image_url: string | null\n          published_time: string\n          source_id: string | null\n          source_name: string | null\n          title: string\n          title_embedding: string\n          url: string\n        }\n        Insert: {\n          author?: string | null\n          contract_ids?: string[] | null\n          created_time?: string\n          description?: string | null\n          group_ids?: string[] | null\n          id?: number\n          image_url?: string | null\n          published_time: string\n          source_id?: string | null\n          source_name?: string | null\n          title: string\n          title_embedding: string\n          url: string\n        }\n        Update: {\n          author?: string | null\n          contract_ids?: string[] | null\n          created_time?: string\n          description?: string | null\n          group_ids?: string[] | null\n          id?: number\n          image_url?: string | null\n          published_time?: string\n          source_id?: string | null\n          source_name?: string | null\n          title?: string\n          title_embedding?: string\n          url?: string\n        }\n        Relationships: []\n      }\n      old_post_comments: {\n        Row: {\n          comment_id: string\n          created_time: string | null\n          data: Json\n          fs_updated_time: string | null\n          post_id: string\n          user_id: string | null\n        }\n        Insert: {\n          comment_id?: string\n          created_time?: string | null\n          data: Json\n          fs_updated_time?: string | null\n          post_id: string\n          user_id?: string | null\n        }\n        Update: {\n          comment_id?: string\n          created_time?: string | null\n          data?: Json\n          fs_updated_time?: string | null\n          post_id?: string\n          user_id?: string | null\n        }\n        Relationships: []\n      }\n      old_posts: {\n        Row: {\n          created_time: string | null\n          creator_id: string | null\n          data: Json\n          group_id: string | null\n          id: string\n          visibility: string | null\n          importance_score: number | null\n        }\n        Insert: {\n          created_time?: string | null\n          creator_id?: string | null\n          data: Json\n          group_id?: string | null\n          id?: string\n          visibility?: string | null\n          importance_score?: number | null\n        }\n        Update: {\n          created_time?: string | null\n          creator_id?: string | null\n          data?: Json\n          group_id?: string | null\n          id?: string\n          visibility?: string | null\n          importance_score?: number | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'public_old_posts_group_id_fkey'\n            columns: ['group_id']\n            isOneToOne: false\n            referencedRelation: 'group_role'\n            referencedColumns: ['group_id']\n          },\n          {\n            foreignKeyName: 'public_old_posts_group_id_fkey'\n            columns: ['group_id']\n            isOneToOne: false\n            referencedRelation: 'groups'\n            referencedColumns: ['id']\n          }\n        ]\n      }\n      platform_calibration: {\n        Row: {\n          created_time: string\n          data: Json\n          id: number\n        }\n        Insert: {\n          created_time?: string\n          data: Json\n          id?: never\n        }\n        Update: {\n          created_time?: string\n          data?: Json\n          id?: never\n        }\n        Relationships: []\n      }\n      portfolios: {\n        Row: {\n          created_time: string\n          creator_id: string\n          id: string\n          items: Json\n          name: string\n          slug: string\n        }\n        Insert: {\n          created_time?: string\n          creator_id: string\n          id: string\n          items: Json\n          name: string\n          slug: string\n        }\n        Update: {\n          created_time?: string\n          creator_id?: string\n          id?: string\n          items?: Json\n          name?: string\n          slug?: string\n        }\n        Relationships: []\n      }\n      posts: {\n        Row: {\n          bet_id: string | null\n          contract_comment_id: string | null\n          contract_id: string | null\n          created_time: string\n          id: number\n          user_avatar_url: string\n          user_id: string\n          user_name: string\n          user_username: string\n        }\n        Insert: {\n          bet_id?: string | null\n          contract_comment_id?: string | null\n          contract_id?: string | null\n          created_time?: string\n          id?: never\n          user_avatar_url: string\n          user_id: string\n          user_name: string\n          user_username: string\n        }\n        Update: {\n          bet_id?: string | null\n          contract_comment_id?: string | null\n          contract_id?: string | null\n          created_time?: string\n          id?: never\n          user_avatar_url?: string\n          user_id?: string\n          user_name?: string\n          user_username?: string\n        }\n        Relationships: []\n      }\n      private_user_message_channel_members: {\n        Row: {\n          channel_id: number\n          created_time: string\n          id: number\n          notify_after_time: string\n          role: string\n          status: string\n          user_id: string\n        }\n        Insert: {\n          channel_id: number\n          created_time?: string\n          id?: never\n          notify_after_time?: string\n          role?: string\n          status?: string\n          user_id: string\n        }\n        Update: {\n          channel_id?: number\n          created_time?: string\n          id?: never\n          notify_after_time?: string\n          role?: string\n          status?: string\n          user_id?: string\n        }\n        Relationships: []\n      }\n      private_user_message_channels: {\n        Row: {\n          created_time: string\n          id: number\n          last_updated_time: string\n          title: string | null\n        }\n        Insert: {\n          created_time?: string\n          id?: never\n          last_updated_time?: string\n          title?: string | null\n        }\n        Update: {\n          created_time?: string\n          id?: never\n          last_updated_time?: string\n          title?: string | null\n        }\n        Relationships: []\n      }\n      private_user_messages: {\n        Row: {\n          channel_id: number\n          content: Json\n          created_time: string\n          id: number\n          user_id: string\n          visibility: string\n        }\n        Insert: {\n          channel_id: number\n          content: Json\n          created_time?: string\n          id?: never\n          user_id: string\n          visibility?: string\n        }\n        Update: {\n          channel_id?: number\n          content?: Json\n          created_time?: string\n          id?: never\n          user_id?: string\n          visibility?: string\n        }\n        Relationships: []\n      }\n      private_user_phone_numbers: {\n        Row: {\n          created_time: string\n          id: number\n          last_updated_time: string\n          phone_number: string\n          user_id: string\n        }\n        Insert: {\n          created_time?: string\n          id?: never\n          last_updated_time?: string\n          phone_number: string\n          user_id: string\n        }\n        Update: {\n          created_time?: string\n          id?: never\n          last_updated_time?: string\n          phone_number?: string\n          user_id?: string\n        }\n        Relationships: []\n      }\n      private_user_seen_message_channels: {\n        Row: {\n          channel_id: number\n          created_time: string\n          id: number\n          user_id: string\n        }\n        Insert: {\n          channel_id: number\n          created_time?: string\n          id?: never\n          user_id: string\n        }\n        Update: {\n          channel_id?: number\n          created_time?: string\n          id?: never\n          user_id?: string\n        }\n        Relationships: []\n      }\n      private_users: {\n        Row: {\n          data: Json\n          id: string\n          weekly_portfolio_email_sent: boolean | null\n          weekly_trending_email_sent: boolean | null\n        }\n        Insert: {\n          data: Json\n          id: string\n          weekly_portfolio_email_sent?: boolean | null\n          weekly_trending_email_sent?: boolean | null\n        }\n        Update: {\n          data?: Json\n          id?: string\n          weekly_portfolio_email_sent?: boolean | null\n          weekly_trending_email_sent?: boolean | null\n        }\n        Relationships: []\n      }\n      push_notification_tickets: {\n        Row: {\n          created_time: string\n          id: string\n          notification_id: string\n          receipt_error: string | null\n          receipt_status: string\n          status: string\n          user_id: string\n        }\n        Insert: {\n          created_time?: string\n          id: string\n          notification_id: string\n          receipt_error?: string | null\n          receipt_status: string\n          status: string\n          user_id: string\n        }\n        Update: {\n          created_time?: string\n          id?: string\n          notification_id?: string\n          receipt_error?: string | null\n          receipt_status?: string\n          status?: string\n          user_id?: string\n        }\n        Relationships: []\n      }\n      q_and_a: {\n        Row: {\n          bounty: number\n          created_time: string\n          deleted: boolean\n          description: string\n          id: string\n          question: string\n          user_id: string\n        }\n        Insert: {\n          bounty: number\n          created_time?: string\n          deleted?: boolean\n          description: string\n          id: string\n          question: string\n          user_id: string\n        }\n        Update: {\n          bounty?: number\n          created_time?: string\n          deleted?: boolean\n          description?: string\n          id?: string\n          question?: string\n          user_id?: string\n        }\n        Relationships: []\n      }\n      q_and_a_answers: {\n        Row: {\n          award: number\n          created_time: string\n          deleted: boolean\n          id: string\n          q_and_a_id: string\n          text: string\n          user_id: string\n        }\n        Insert: {\n          award?: number\n          created_time?: string\n          deleted?: boolean\n          id: string\n          q_and_a_id: string\n          text: string\n          user_id: string\n        }\n        Update: {\n          award?: number\n          created_time?: string\n          deleted?: boolean\n          id?: string\n          q_and_a_id?: string\n          text?: string\n          user_id?: string\n        }\n        Relationships: []\n      }\n      redemption_status: {\n        Row: {\n          created_time: string\n          id: number\n          session_id: string\n          status: string\n          transaction_id: string\n          txn_id: string\n          user_id: string\n        }\n        Insert: {\n          created_time?: string\n          id?: never\n          session_id: string\n          status: string\n          transaction_id: string\n          txn_id: string\n          user_id: string\n        }\n        Update: {\n          created_time?: string\n          id?: never\n          session_id?: string\n          status?: string\n          transaction_id?: string\n          txn_id?: string\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'redemption_status_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'user_referrals_profit'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'redemption_status_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'users'\n            referencedColumns: ['id']\n          }\n        ]\n      }\n      reports: {\n        Row: {\n          content_id: string\n          content_owner_id: string\n          content_type: string\n          created_time: string | null\n          description: string | null\n          id: string\n          parent_id: string | null\n          parent_type: string | null\n          user_id: string\n          dismissed_by_user_id: string | null\n        }\n        Insert: {\n          content_id: string\n          content_owner_id: string\n          content_type: string\n          created_time?: string | null\n          description?: string | null\n          id?: string\n          parent_id?: string | null\n          parent_type?: string | null\n          user_id: string\n          dismissed_by_user_id?: string | null\n        }\n        Update: {\n          content_id?: string\n          content_owner_id?: string\n          content_type?: string\n          created_time?: string | null\n          description?: string | null\n          id?: string\n          parent_id?: string | null\n          parent_type?: string | null\n          user_id?: string\n          dismissed_by_user_id?: string | null\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'reports_content_owner_id_fkey'\n            columns: ['content_owner_id']\n            isOneToOne: false\n            referencedRelation: 'user_referrals_profit'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'reports_content_owner_id_fkey'\n            columns: ['content_owner_id']\n            isOneToOne: false\n            referencedRelation: 'users'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'reports_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'user_referrals_profit'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'reports_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'users'\n            referencedColumns: ['id']\n          }\n        ]\n      }\n      reviews: {\n        Row: {\n          content: Json | null\n          created_time: string\n          market_id: string\n          rating: number\n          reviewer_id: string\n          vendor_id: string\n        }\n        Insert: {\n          content?: Json | null\n          created_time?: string\n          market_id: string\n          rating: number\n          reviewer_id: string\n          vendor_id: string\n        }\n        Update: {\n          content?: Json | null\n          created_time?: string\n          market_id?: string\n          rating?: number\n          reviewer_id?: string\n          vendor_id?: string\n        }\n        Relationships: []\n      }\n      scheduler_info: {\n        Row: {\n          created_time: string\n          id: number\n          job_name: string\n          last_end_time: string | null\n          last_start_time: string | null\n        }\n        Insert: {\n          created_time?: string\n          id?: never\n          job_name: string\n          last_end_time?: string | null\n          last_start_time?: string | null\n        }\n        Update: {\n          created_time?: string\n          id?: never\n          job_name?: string\n          last_end_time?: string | null\n          last_start_time?: string | null\n        }\n        Relationships: []\n      }\n      sent_emails: {\n        Row: {\n          created_time: string\n          email_template_id: string\n          id: number\n          user_id: string\n        }\n        Insert: {\n          created_time?: string\n          email_template_id: string\n          id?: never\n          user_id: string\n        }\n        Update: {\n          created_time?: string\n          email_template_id?: string\n          id?: never\n          user_id?: string\n        }\n        Relationships: []\n      }\n      stats: {\n        Row: {\n          daily_values: number[] | null\n          title: string\n        }\n        Insert: {\n          daily_values?: number[] | null\n          title: string\n        }\n        Update: {\n          daily_values?: number[] | null\n          title?: string\n        }\n        Relationships: []\n      }\n      system_trading_status: {\n        Row: {\n          status: boolean\n          token: string\n        }\n        Insert: {\n          status: boolean\n          token: string\n        }\n        Update: {\n          status?: boolean\n          token?: string\n        }\n        Relationships: []\n      }\n      topic_embeddings: {\n        Row: {\n          created_at: string\n          embedding: string\n          topic: string\n        }\n        Insert: {\n          created_at?: string\n          embedding: string\n          topic: string\n        }\n        Update: {\n          created_at?: string\n          embedding?: string\n          topic?: string\n        }\n        Relationships: []\n      }\n      tv_schedule: {\n        Row: {\n          contract_id: string\n          creator_id: string\n          end_time: string\n          id: number\n          is_featured: boolean | null\n          schedule_created_time: string | null\n          source: string\n          start_time: string\n          stream_id: string\n          title: string\n        }\n        Insert: {\n          contract_id: string\n          creator_id: string\n          end_time: string\n          id?: number\n          is_featured?: boolean | null\n          schedule_created_time?: string | null\n          source: string\n          start_time: string\n          stream_id: string\n          title: string\n        }\n        Update: {\n          contract_id?: string\n          creator_id?: string\n          end_time?: string\n          id?: number\n          is_featured?: boolean | null\n          schedule_created_time?: string | null\n          source?: string\n          start_time?: string\n          stream_id?: string\n          title?: string\n        }\n        Relationships: []\n      }\n      txn_summary_stats: {\n        Row: {\n          category: string\n          created_time: string\n          end_time: string\n          from_type: string\n          id: number\n          quest_type: string | null\n          start_time: string\n          to_type: string\n          token: string\n          total_amount: number\n        }\n        Insert: {\n          category: string\n          created_time?: string\n          end_time: string\n          from_type: string\n          id?: never\n          quest_type?: string | null\n          start_time: string\n          to_type: string\n          token: string\n          total_amount: number\n        }\n        Update: {\n          category?: string\n          created_time?: string\n          end_time?: string\n          from_type?: string\n          id?: never\n          quest_type?: string | null\n          start_time?: string\n          to_type?: string\n          token?: string\n          total_amount?: number\n        }\n        Relationships: []\n      }\n      txns: {\n        Row: {\n          amount: number\n          category: string\n          created_time: string\n          data: Json\n          from_id: string\n          from_type: string\n          id: string\n          to_id: string\n          to_type: string\n          token: string\n        }\n        Insert: {\n          amount: number\n          category: string\n          created_time?: string\n          data: Json\n          from_id: string\n          from_type: string\n          id?: string\n          to_id: string\n          to_type: string\n          token?: string\n        }\n        Update: {\n          amount?: number\n          category?: string\n          created_time?: string\n          data?: Json\n          from_id?: string\n          from_type?: string\n          id?: string\n          to_id?: string\n          to_type?: string\n          token?: string\n        }\n        Relationships: []\n      }\n      user_comment_view_events: {\n        Row: {\n          comment_id: string\n          contract_id: string\n          created_time: string\n          id: number\n          user_id: string\n        }\n        Insert: {\n          comment_id: string\n          contract_id: string\n          created_time?: string\n          id?: never\n          user_id: string\n        }\n        Update: {\n          comment_id?: string\n          contract_id?: string\n          created_time?: string\n          id?: never\n          user_id?: string\n        }\n        Relationships: []\n      }\n      user_contract_interactions: {\n        Row: {\n          bet_group_id: string | null\n          bet_id: string | null\n          comment_id: string | null\n          contract_id: string\n          created_time: string\n          feed_reasons: string[] | null\n          feed_type: string | null\n          id: number\n          name: string\n          user_id: string\n        }\n        Insert: {\n          bet_group_id?: string | null\n          bet_id?: string | null\n          comment_id?: string | null\n          contract_id: string\n          created_time?: string\n          feed_reasons?: string[] | null\n          feed_type?: string | null\n          id?: never\n          name: string\n          user_id: string\n        }\n        Update: {\n          bet_group_id?: string | null\n          bet_id?: string | null\n          comment_id?: string | null\n          contract_id?: string\n          created_time?: string\n          feed_reasons?: string[] | null\n          feed_type?: string | null\n          id?: never\n          name?: string\n          user_id?: string\n        }\n        Relationships: []\n      }\n      user_contract_metrics: {\n        Row: {\n          answer_id: string | null\n          contract_id: string\n          data: Json\n          has_no_shares: boolean | null\n          has_shares: boolean | null\n          has_yes_shares: boolean | null\n          id: number\n          profit: number | null\n          total_shares_no: number | null\n          total_shares_yes: number | null\n          user_id: string\n        }\n        Insert: {\n          answer_id?: string | null\n          contract_id: string\n          data: Json\n          has_no_shares?: boolean | null\n          has_shares?: boolean | null\n          has_yes_shares?: boolean | null\n          id?: never\n          profit?: number | null\n          total_shares_no?: number | null\n          total_shares_yes?: number | null\n          user_id: string\n        }\n        Update: {\n          answer_id?: string | null\n          contract_id?: string\n          data?: Json\n          has_no_shares?: boolean | null\n          has_shares?: boolean | null\n          has_yes_shares?: boolean | null\n          id?: never\n          profit?: number | null\n          total_shares_no?: number | null\n          total_shares_yes?: number | null\n          user_id?: string\n        }\n        Relationships: []\n      }\n      user_contract_views: {\n        Row: {\n          card_views: number\n          contract_id: string\n          id: number\n          last_card_view_ts: string | null\n          last_page_view_ts: string | null\n          last_promoted_view_ts: string | null\n          page_views: number\n          promoted_views: number\n          user_id: string | null\n        }\n        Insert: {\n          card_views?: number\n          contract_id: string\n          id?: never\n          last_card_view_ts?: string | null\n          last_page_view_ts?: string | null\n          last_promoted_view_ts?: string | null\n          page_views?: number\n          promoted_views?: number\n          user_id?: string | null\n        }\n        Update: {\n          card_views?: number\n          contract_id?: string\n          id?: never\n          last_card_view_ts?: string | null\n          last_page_view_ts?: string | null\n          last_promoted_view_ts?: string | null\n          page_views?: number\n          promoted_views?: number\n          user_id?: string | null\n        }\n        Relationships: []\n      }\n      user_disinterests: {\n        Row: {\n          comment_id: string | null\n          contract_id: string\n          created_time: string\n          creator_id: string\n          feed_id: number | null\n          id: number\n          user_id: string\n        }\n        Insert: {\n          comment_id?: string | null\n          contract_id: string\n          created_time?: string\n          creator_id: string\n          feed_id?: number | null\n          id?: never\n          user_id: string\n        }\n        Update: {\n          comment_id?: string | null\n          contract_id?: string\n          created_time?: string\n          creator_id?: string\n          feed_id?: number | null\n          id?: never\n          user_id?: string\n        }\n        Relationships: []\n      }\n      user_embeddings: {\n        Row: {\n          contract_view_embedding: string | null\n          created_at: string\n          disinterest_embedding: string | null\n          interest_embedding: string\n          user_id: string\n        }\n        Insert: {\n          contract_view_embedding?: string | null\n          created_at?: string\n          disinterest_embedding?: string | null\n          interest_embedding: string\n          user_id: string\n        }\n        Update: {\n          contract_view_embedding?: string | null\n          created_at?: string\n          disinterest_embedding?: string | null\n          interest_embedding?: string\n          user_id?: string\n        }\n        Relationships: []\n      }\n      user_events: {\n        Row: {\n          ad_id: string | null\n          comment_id: string | null\n          contract_id: string | null\n          data: Json\n          id: number\n          name: string\n          ts: string\n          user_id: string | null\n        }\n        Insert: {\n          ad_id?: string | null\n          comment_id?: string | null\n          contract_id?: string | null\n          data: Json\n          id?: never\n          name: string\n          ts?: string\n          user_id?: string | null\n        }\n        Update: {\n          ad_id?: string | null\n          comment_id?: string | null\n          contract_id?: string | null\n          data?: Json\n          id?: never\n          name?: string\n          ts?: string\n          user_id?: string | null\n        }\n        Relationships: []\n      }\n      user_follows: {\n        Row: {\n          created_time: string\n          follow_id: string\n          user_id: string\n        }\n        Insert: {\n          created_time?: string\n          follow_id: string\n          user_id: string\n        }\n        Update: {\n          created_time?: string\n          follow_id?: string\n          user_id?: string\n        }\n        Relationships: []\n      }\n      user_monitor_status: {\n        Row: {\n          created_time: string | null\n          data: Json\n          fraud_confidence_score: number | null\n          id: number\n          identity_confidence_score: number | null\n          reason_codes: string[] | null\n          user_id: string\n        }\n        Insert: {\n          created_time?: string | null\n          data: Json\n          fraud_confidence_score?: number | null\n          id?: never\n          identity_confidence_score?: number | null\n          reason_codes?: string[] | null\n          user_id: string\n        }\n        Update: {\n          created_time?: string | null\n          data?: Json\n          fraud_confidence_score?: number | null\n          id?: never\n          identity_confidence_score?: number | null\n          reason_codes?: string[] | null\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: 'user_monitor_status_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'user_referrals_profit'\n            referencedColumns: ['id']\n          },\n          {\n            foreignKeyName: 'user_monitor_status_user_id_fkey'\n            columns: ['user_id']\n            isOneToOne: false\n            referencedRelation: 'users'\n            referencedColumns: ['id']\n          }\n        ]\n      }\n      user_notifications: {\n        Row: {\n          data: Json\n          notification_id: string\n          user_id: string\n        }\n        Insert: {\n          data: Json\n          notification_id: string\n          user_id: string\n        }\n        Update: {\n          data?: Json\n          notification_id?: string\n          user_id?: string\n        }\n        Relationships: []\n      }\n      user_portfolio_history: {\n        Row: {\n          balance: number | null\n          cash_balance: number\n          cash_investment_value: number\n          id: number\n          investment_value: number | null\n          loan_total: number | null\n          profit: number | null\n          spice_balance: number\n          total_cash_deposits: number\n          total_deposits: number | null\n          ts: string | null\n          user_id: string\n        }\n        Insert: {\n          balance?: number | null\n          cash_balance?: number\n          cash_investment_value?: number\n          id?: never\n          investment_value?: number | null\n          loan_total?: number | null\n          profit?: number | null\n          spice_balance?: number\n          total_cash_deposits?: number\n          total_deposits?: number | null\n          ts?: string | null\n          user_id: string\n        }\n        Update: {\n          balance?: number | null\n          cash_balance?: number\n          cash_investment_value?: number\n          id?: never\n          investment_value?: number | null\n          loan_total?: number | null\n          profit?: number | null\n          spice_balance?: number\n          total_cash_deposits?: number\n          total_deposits?: number | null\n          ts?: string | null\n          user_id?: string\n        }\n        Relationships: []\n      }\n      user_portfolio_history_latest: {\n        Row: {\n          balance: number\n          cash_balance: number\n          cash_investment_value: number\n          investment_value: number\n          last_calculated: string\n          loan_total: number | null\n          profit: number | null\n          spice_balance: number\n          total_cash_deposits: number\n          total_deposits: number\n          ts: string\n          user_id: string\n        }\n        Insert: {\n          balance: number\n          cash_balance?: number\n          cash_investment_value?: number\n          investment_value: number\n          last_calculated: string\n          loan_total?: number | null\n          profit?: number | null\n          spice_balance?: number\n          total_cash_deposits?: number\n          total_deposits: number\n          ts: string\n          user_id: string\n        }\n        Update: {\n          balance?: number\n          cash_balance?: number\n          cash_investment_value?: number\n          investment_value?: number\n          last_calculated?: string\n          loan_total?: number | null\n          profit?: number | null\n          spice_balance?: number\n          total_cash_deposits?: number\n          total_deposits?: number\n          ts?: string\n          user_id?: string\n        }\n        Relationships: []\n      }\n      user_quest_metrics: {\n        Row: {\n          idempotency_key: string | null\n          score_id: string\n          score_value: number\n          user_id: string\n        }\n        Insert: {\n          idempotency_key?: string | null\n          score_id: string\n          score_value: number\n          user_id: string\n        }\n        Update: {\n          idempotency_key?: string | null\n          score_id?: string\n          score_value?: number\n          user_id?: string\n        }\n        Relationships: []\n      }\n      user_reactions: {\n        Row: {\n          content_id: string\n          content_owner_id: string\n          content_type: string\n          created_time: string\n          reaction_id: string\n          reaction_type: string\n          user_id: string\n        }\n        Insert: {\n          content_id: string\n          content_owner_id: string\n          content_type: string\n          created_time?: string\n          reaction_id?: string\n          reaction_type?: string\n          user_id: string\n        }\n        Update: {\n          content_id?: string\n          content_owner_id?: string\n          content_type?: string\n          created_time?: string\n          reaction_id?: string\n          reaction_type?: string\n          user_id?: string\n        }\n        Relationships: []\n      }\n      user_seen_chats: {\n        Row: {\n          channel_id: string\n          created_time: string\n          id: number\n          user_id: string\n        }\n        Insert: {\n          channel_id: string\n          created_time?: string\n          id?: never\n          user_id: string\n        }\n        Update: {\n          channel_id?: string\n          created_time?: string\n          id?: never\n          user_id?: string\n        }\n        Relationships: []\n      }\n      user_topic_interests: {\n        Row: {\n          created_time: string\n          group_ids_to_activity: Json\n          id: number\n          user_id: string\n        }\n        Insert: {\n          created_time?: string\n          group_ids_to_activity: Json\n          id?: never\n          user_id: string\n        }\n        Update: {\n          created_time?: string\n          group_ids_to_activity?: Json\n          id?: never\n          user_id?: string\n        }\n        Relationships: []\n      }\n      user_topics: {\n        Row: {\n          created_at: string\n          topic_embedding: string\n          topics: string[]\n          user_id: string\n        }\n        Insert: {\n          created_at?: string\n          topic_embedding: string\n          topics: string[]\n          user_id: string\n        }\n        Update: {\n          created_at?: string\n          topic_embedding?: string\n          topics?: string[]\n          user_id?: string\n        }\n        Relationships: []\n      }\n      user_view_events: {\n        Row: {\n          ad_id: string | null\n          comment_id: string | null\n          contract_id: string | null\n          created_time: string\n          id: number\n          name: string\n          user_id: string\n        }\n        Insert: {\n          ad_id?: string | null\n          comment_id?: string | null\n          contract_id?: string | null\n          created_time?: string\n          id?: never\n          name: string\n          user_id: string\n        }\n        Update: {\n          ad_id?: string | null\n          comment_id?: string | null\n          contract_id?: string | null\n          created_time?: string\n          id?: never\n          name?: string\n          user_id?: string\n        }\n        Relationships: []\n      }\n      users: {\n        Row: {\n          balance: number\n          cash_balance: number\n          created_time: string\n          data: Json\n          id: string\n          name: string\n          name_username_vector: unknown | null\n          spice_balance: number\n          total_cash_deposits: number\n          total_deposits: number\n          username: string\n        }\n        Insert: {\n          balance?: number\n          cash_balance?: number\n          created_time?: string\n          data: Json\n          id?: string\n          name: string\n          name_username_vector?: unknown | null\n          spice_balance?: number\n          total_cash_deposits?: number\n          total_deposits?: number\n          username: string\n        }\n        Update: {\n          balance?: number\n          cash_balance?: number\n          created_time?: string\n          data?: Json\n          id?: string\n          name?: string\n          name_username_vector?: unknown | null\n          spice_balance?: number\n          total_cash_deposits?: number\n          total_deposits?: number\n          username?: string\n        }\n        Relationships: []\n      }\n      votes: {\n        Row: {\n          contract_id: string\n          created_time: string\n          id: string\n          user_id: string\n        }\n        Insert: {\n          contract_id: string\n          created_time?: string\n          id: string\n          user_id: string\n        }\n        Update: {\n          contract_id?: string\n          created_time?: string\n          id?: string\n          user_id?: string\n        }\n        Relationships: []\n      }\n    }\n    Views: {\n      final_pp_balances: {\n        Row: {\n          amount: number | null\n          user_id: string | null\n        }\n        Insert: {\n          amount?: number | null\n          user_id?: string | null\n        }\n        Update: {\n          amount?: number | null\n          user_id?: string | null\n        }\n        Relationships: []\n      }\n      group_role: {\n        Row: {\n          avatar_url: string | null\n          createdtime: number | null\n          creator_id: string | null\n          group_id: string | null\n          group_name: string | null\n          group_slug: string | null\n          member_id: string | null\n          name: string | null\n          privacy_status: string | null\n          role: string | null\n          total_members: number | null\n          username: string | null\n        }\n        Relationships: []\n      }\n      user_league_info: {\n        Row: {\n          cohort: string | null\n          created_time: string | null\n          division: number | null\n          mana_earned: number | null\n          mana_earned_breakdown: Json | null\n          rank: number | null\n          rank_snapshot: number | null\n          season: number | null\n          user_id: string | null\n        }\n        Relationships: []\n      }\n      user_referrals_profit: {\n        Row: {\n          id: string | null\n          rank: number | null\n          total_referrals: number | null\n          total_referred_cash_profit: number | null\n          total_referred_profit: number | null\n        }\n        Relationships: []\n      }\n    }\n    Functions: {\n      add_creator_name_to_description: {\n        Args: {\n          data: Json\n        }\n        Returns: string\n      }\n      binary_quantize:\n        | {\n            Args: {\n              '': string\n            }\n            Returns: unknown\n          }\n        | {\n            Args: {\n              '': unknown\n            }\n            Returns: unknown\n          }\n      calculate_earth_distance_km: {\n        Args: {\n          lat1: number\n          lon1: number\n          lat2: number\n          lon2: number\n        }\n        Returns: number\n      }\n      can_access_private_messages: {\n        Args: {\n          channel_id: number\n          user_id: string\n        }\n        Returns: boolean\n      }\n      close_contract_embeddings: {\n        Args: {\n          input_contract_id: string\n          similarity_threshold: number\n          match_count: number\n        }\n        Returns: {\n          contract_id: string\n          similarity: number\n          data: Json\n        }[]\n      }\n      count_recent_comments: {\n        Args: {\n          contract_id: string\n        }\n        Returns: number\n      }\n      count_recent_comments_by_contract: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          contract_id: string\n          comment_count: number\n        }[]\n      }\n      creator_leaderboard: {\n        Args: {\n          limit_n: number\n        }\n        Returns: {\n          user_id: string\n          total_traders: number\n          name: string\n          username: string\n          avatar_url: string\n        }[]\n      }\n      creator_rank: {\n        Args: {\n          uid: string\n        }\n        Returns: number\n      }\n      date_to_midnight_pt: {\n        Args: {\n          d: string\n        }\n        Returns: string\n      }\n      extract_text_from_rich_text_json: {\n        Args: {\n          description: Json\n        }\n        Returns: string\n      }\n      firebase_uid: {\n        Args: Record<PropertyKey, never>\n        Returns: string\n      }\n      get_average_rating: {\n        Args: {\n          user_id: string\n        }\n        Returns: number\n      }\n      get_compatibility_questions_with_answer_count: {\n        Args: Record<PropertyKey, never>\n        Returns: Database['public']['CompositeTypes']['love_question_with_count_type'][]\n      }\n      get_contract_voters: {\n        Args: {\n          this_contract_id: string\n        }\n        Returns: {\n          data: Json\n        }[]\n      }\n      get_contracts_in_group_slugs_1: {\n        Args: {\n          contract_ids: string[]\n          p_group_slugs: string[]\n          ignore_slugs: string[]\n        }\n        Returns: {\n          data: Json\n          importance_score: number\n        }[]\n      }\n      get_cpmm_pool_prob: {\n        Args: {\n          pool: Json\n          p: number\n        }\n        Returns: number\n      }\n      get_daily_claimed_boosts: {\n        Args: {\n          user_id: string\n        }\n        Returns: {\n          total: number\n        }[]\n      }\n      get_donations_by_charity: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          charity_id: string\n          num_supporters: number\n          total: number\n        }[]\n      }\n      get_group_contracts: {\n        Args: {\n          this_group_id: string\n        }\n        Returns: {\n          data: Json\n        }[]\n      }\n      get_love_question_answers_and_lovers: {\n        Args: {\n          p_question_id: number\n        }\n        Returns: Database['public']['CompositeTypes']['other_lover_answers_type'][]\n      }\n      get_non_empty_private_message_channel_ids:\n        | {\n            Args: {\n              p_user_id: string\n              p_ignored_statuses: string[]\n              p_limit: number\n            }\n            Returns: {\n              created_time: string\n              id: number\n              last_updated_time: string\n              title: string | null\n            }[]\n          }\n        | {\n            Args: {\n              p_user_id: string\n              p_limit?: number\n            }\n            Returns: {\n              id: number\n            }[]\n          }\n      get_noob_questions: {\n        Args: Record<PropertyKey, never>\n        Returns: {\n          close_time: string | null\n          conversion_score: number\n          created_time: string | null\n          creator_id: string | null\n          daily_score: number\n          data: Json\n          deleted: boolean | null\n          description_fts: unknown | null\n          freshness_score: number\n          group_slugs: string[] | null\n          id: string\n          importance_score: number\n          is_spice_payout: boolean | null\n          last_bet_time: string | null\n          last_comment_time: string | null\n          last_updated_time: string | null\n          mechanism: string | null\n          outcome_type: string | null\n          popularity_score: number\n          question: string | null\n          question_fts: unknown | null\n          question_nostop_fts: unknown | null\n          resolution: string | null\n          resolution_probability: number | null\n          resolution_time: string | null\n          slug: string | null\n          tier: string | null\n          token: string\n          unique_bettor_count: number\n          view_count: number\n          visibility: string | null\n        }[]\n      }\n      get_option_voters: {\n        Args: {\n          this_contract_id: string\n          this_option_id: string\n        }\n        Returns: {\n          data: Json\n        }[]\n      }\n      get_rating: {\n        Args: {\n          user_id: string\n        }\n        Returns: {\n          count: number\n          rating: number\n        }[]\n      }\n      get_recently_active_contracts_in_group_slugs_1: {\n        Args: {\n          p_group_slugs: string[]\n          ignore_slugs: string[]\n          max: number\n        }\n        Returns: {\n          data: Json\n          importance_score: number\n        }[]\n      }\n      get_user_bet_contracts: {\n        Args: {\n          this_user_id: string\n          this_limit: number\n        }\n        Returns: {\n          data: Json\n        }[]\n      }\n      get_user_group_id_for_current_user: {\n        Args: Record<PropertyKey, never>\n        Returns: string\n      }\n      get_user_manalink_claims: {\n        Args: {\n          creator_id: string\n        }\n        Returns: {\n          manalink_id: string\n          claimant_id: string\n          ts: number\n        }[]\n      }\n      get_user_topic_interests_2: {\n        Args: {\n          p_user_id: string\n        }\n        Returns: {\n          group_id: string\n          score: number\n        }[]\n      }\n      get_your_contract_ids:\n        | {\n            Args: {\n              uid: string\n            }\n            Returns: {\n              contract_id: string\n            }[]\n          }\n        | {\n            Args: {\n              uid: string\n              n: number\n              start: number\n            }\n            Returns: {\n              contract_id: string\n            }[]\n          }\n      get_your_daily_changed_contracts: {\n        Args: {\n          uid: string\n          n: number\n          start: number\n        }\n        Returns: {\n          data: Json\n          daily_score: number\n        }[]\n      }\n      get_your_recent_contracts: {\n        Args: {\n          uid: string\n          n: number\n          start: number\n        }\n        Returns: {\n          data: Json\n          max_ts: number\n        }[]\n      }\n      gtrgm_compress: {\n        Args: {\n          '': unknown\n        }\n        Returns: unknown\n      }\n      gtrgm_decompress: {\n        Args: {\n          '': unknown\n        }\n        Returns: unknown\n      }\n      gtrgm_in: {\n        Args: {\n          '': unknown\n        }\n        Returns: unknown\n      }\n      gtrgm_options: {\n        Args: {\n          '': unknown\n        }\n        Returns: undefined\n      }\n      gtrgm_out: {\n        Args: {\n          '': unknown\n        }\n        Returns: unknown\n      }\n      halfvec_avg: {\n        Args: {\n          '': number[]\n        }\n        Returns: unknown\n      }\n      halfvec_out: {\n        Args: {\n          '': unknown\n        }\n        Returns: unknown\n      }\n      halfvec_send: {\n        Args: {\n          '': unknown\n        }\n        Returns: string\n      }\n      halfvec_typmod_in: {\n        Args: {\n          '': unknown[]\n        }\n        Returns: number\n      }\n      has_moderator_or_above_role: {\n        Args: {\n          this_group_id: string\n          this_user_id: string\n        }\n        Returns: boolean\n      }\n      hnsw_bit_support: {\n        Args: {\n          '': unknown\n        }\n        Returns: unknown\n      }\n      hnsw_halfvec_support: {\n        Args: {\n          '': unknown\n        }\n        Returns: unknown\n      }\n      hnsw_sparsevec_support: {\n        Args: {\n          '': unknown\n        }\n        Returns: unknown\n      }\n      hnswhandler: {\n        Args: {\n          '': unknown\n        }\n        Returns: unknown\n      }\n      install_available_extensions_and_test: {\n        Args: Record<PropertyKey, never>\n        Returns: boolean\n      }\n      is_admin: {\n        Args: {\n          input_string: string\n        }\n        Returns: boolean\n      }\n      is_group_member: {\n        Args: {\n          this_group_id: string\n          this_user_id: string\n        }\n        Returns: boolean\n      }\n      is_valid_contract: {\n        Args: {\n          ct: unknown\n        }\n        Returns: boolean\n      }\n      ivfflat_bit_support: {\n        Args: {\n          '': unknown\n        }\n        Returns: unknown\n      }\n      ivfflat_halfvec_support: {\n        Args: {\n          '': unknown\n        }\n        Returns: unknown\n      }\n      ivfflathandler: {\n        Args: {\n          '': unknown\n        }\n        Returns: unknown\n      }\n      jsonb_array_to_text_array: {\n        Args: {\n          _js: Json\n        }\n        Returns: string[]\n      }\n      l2_norm:\n        | {\n            Args: {\n              '': unknown\n            }\n            Returns: number\n          }\n        | {\n            Args: {\n              '': unknown\n            }\n            Returns: number\n          }\n      l2_normalize:\n        | {\n            Args: {\n              '': string\n            }\n            Returns: string\n          }\n        | {\n            Args: {\n              '': unknown\n            }\n            Returns: unknown\n          }\n        | {\n            Args: {\n              '': unknown\n            }\n            Returns: unknown\n          }\n      millis_interval: {\n        Args: {\n          start_millis: number\n          end_millis: number\n        }\n        Returns: unknown\n      }\n      millis_to_ts: {\n        Args: {\n          millis: number\n        }\n        Returns: string\n      }\n      profit_leaderboard: {\n        Args: {\n          limit_n: number\n        }\n        Returns: {\n          user_id: string\n          profit: number\n          name: string\n          username: string\n          avatar_url: string\n        }[]\n      }\n      profit_rank: {\n        Args: {\n          uid: string\n          excluded_ids?: string[]\n        }\n        Returns: number\n      }\n      random_alphanumeric: {\n        Args: {\n          length: number\n        }\n        Returns: string\n      }\n      recently_liked_contract_counts: {\n        Args: {\n          since: number\n        }\n        Returns: {\n          contract_id: string\n          n: number\n        }[]\n      }\n      sample_resolved_bets: {\n        Args: {\n          trader_threshold: number\n          p: number\n        }\n        Returns: {\n          prob: number\n          is_yes: boolean\n        }[]\n      }\n      save_user_topics_blank: {\n        Args: {\n          p_user_id: string\n        }\n        Returns: undefined\n      }\n      search_contract_embeddings: {\n        Args: {\n          query_embedding: string\n          similarity_threshold: number\n          match_count: number\n        }\n        Returns: {\n          contract_id: string\n          similarity: number\n        }[]\n      }\n      set_limit: {\n        Args: {\n          '': number\n        }\n        Returns: number\n      }\n      show_limit: {\n        Args: Record<PropertyKey, never>\n        Returns: number\n      }\n      show_trgm: {\n        Args: {\n          '': string\n        }\n        Returns: string[]\n      }\n      sparsevec_out: {\n        Args: {\n          '': unknown\n        }\n        Returns: unknown\n      }\n      sparsevec_send: {\n        Args: {\n          '': unknown\n        }\n        Returns: string\n      }\n      sparsevec_typmod_in: {\n        Args: {\n          '': unknown[]\n        }\n        Returns: number\n      }\n      test: {\n        Args: Record<PropertyKey, never>\n        Returns: undefined\n      }\n      to_jsonb: {\n        Args: {\n          '': Json\n        }\n        Returns: Json\n      }\n      ts_to_millis:\n        | {\n            Args: {\n              ts: string\n            }\n            Returns: number\n          }\n        | {\n            Args: {\n              ts: string\n            }\n            Returns: number\n          }\n      vector_avg: {\n        Args: {\n          '': number[]\n        }\n        Returns: string\n      }\n      vector_dims:\n        | {\n            Args: {\n              '': string\n            }\n            Returns: number\n          }\n        | {\n            Args: {\n              '': unknown\n            }\n            Returns: number\n          }\n      vector_norm: {\n        Args: {\n          '': string\n        }\n        Returns: number\n      }\n      vector_out: {\n        Args: {\n          '': string\n        }\n        Returns: unknown\n      }\n      vector_send: {\n        Args: {\n          '': string\n        }\n        Returns: string\n      }\n      vector_typmod_in: {\n        Args: {\n          '': unknown[]\n        }\n        Returns: number\n      }\n    }\n    Enums: {\n      status_type: 'new' | 'under review' | 'resolved' | 'needs admin'\n    }\n    CompositeTypes: {\n      love_question_with_count_type: {\n        id: number | null\n        creator_id: string | null\n        created_time: string | null\n        question: string | null\n        importance_score: number | null\n        answer_type: string | null\n        multiple_choice_options: Json | null\n        answer_count: number | null\n      }\n      other_lover_answers_type: {\n        question_id: number | null\n        created_time: string | null\n        free_response: string | null\n        multiple_choice: number | null\n        integer: number | null\n        age: number | null\n        gender: string | null\n        city: string | null\n        data: Json | null\n      }\n    }\n  }\n}\n\ntype PublicSchema = Database[Extract<keyof Database, 'public'>]\n\nexport type Tables<\n  PublicTableNameOrOptions extends\n    | keyof (PublicSchema['Tables'] & PublicSchema['Views'])\n    | { schema: keyof Database },\n  TableName extends PublicTableNameOrOptions extends { schema: keyof Database }\n    ? keyof (Database[PublicTableNameOrOptions['schema']]['Tables'] &\n        Database[PublicTableNameOrOptions['schema']]['Views'])\n    : never = never\n> = PublicTableNameOrOptions extends { schema: keyof Database }\n  ? (Database[PublicTableNameOrOptions['schema']]['Tables'] &\n      Database[PublicTableNameOrOptions['schema']]['Views'])[TableName] extends {\n      Row: infer R\n    }\n    ? R\n    : never\n  : PublicTableNameOrOptions extends keyof (PublicSchema['Tables'] &\n      PublicSchema['Views'])\n  ? (PublicSchema['Tables'] &\n      PublicSchema['Views'])[PublicTableNameOrOptions] extends {\n      Row: infer R\n    }\n    ? R\n    : never\n  : never\n\nexport type TablesInsert<\n  PublicTableNameOrOptions extends\n    | keyof PublicSchema['Tables']\n    | { schema: keyof Database },\n  TableName extends PublicTableNameOrOptions extends { schema: keyof Database }\n    ? keyof Database[PublicTableNameOrOptions['schema']]['Tables']\n    : never = never\n> = PublicTableNameOrOptions extends { schema: keyof Database }\n  ? Database[PublicTableNameOrOptions['schema']]['Tables'][TableName] extends {\n      Insert: infer I\n    }\n    ? I\n    : never\n  : PublicTableNameOrOptions extends keyof PublicSchema['Tables']\n  ? PublicSchema['Tables'][PublicTableNameOrOptions] extends {\n      Insert: infer I\n    }\n    ? I\n    : never\n  : never\n\nexport type TablesUpdate<\n  PublicTableNameOrOptions extends\n    | keyof PublicSchema['Tables']\n    | { schema: keyof Database },\n  TableName extends PublicTableNameOrOptions extends { schema: keyof Database }\n    ? keyof Database[PublicTableNameOrOptions['schema']]['Tables']\n    : never = never\n> = PublicTableNameOrOptions extends { schema: keyof Database }\n  ? Database[PublicTableNameOrOptions['schema']]['Tables'][TableName] extends {\n      Update: infer U\n    }\n    ? U\n    : never\n  : PublicTableNameOrOptions extends keyof PublicSchema['Tables']\n  ? PublicSchema['Tables'][PublicTableNameOrOptions] extends {\n      Update: infer U\n    }\n    ? U\n    : never\n  : never\n\nexport type Enums<\n  PublicEnumNameOrOptions extends\n    | keyof PublicSchema['Enums']\n    | { schema: keyof Database },\n  EnumName extends PublicEnumNameOrOptions extends { schema: keyof Database }\n    ? keyof Database[PublicEnumNameOrOptions['schema']]['Enums']\n    : never = never\n> = PublicEnumNameOrOptions extends { schema: keyof Database }\n  ? Database[PublicEnumNameOrOptions['schema']]['Enums'][EnumName]\n  : PublicEnumNameOrOptions extends keyof PublicSchema['Enums']\n  ? PublicSchema['Enums'][PublicEnumNameOrOptions]\n  : never\n\nexport type CompositeTypes<\n  PublicCompositeTypeNameOrOptions extends\n    | keyof PublicSchema['CompositeTypes']\n    | { schema: keyof Database },\n  CompositeTypeName extends PublicCompositeTypeNameOrOptions extends {\n    schema: keyof Database\n  }\n    ? keyof Database[PublicCompositeTypeNameOrOptions['schema']]['CompositeTypes']\n    : never = never\n> = PublicCompositeTypeNameOrOptions extends { schema: keyof Database }\n  ? Database[PublicCompositeTypeNameOrOptions['schema']]['CompositeTypes'][CompositeTypeName]\n  : PublicCompositeTypeNameOrOptions extends keyof PublicSchema['CompositeTypes']\n  ? PublicSchema['CompositeTypes'][PublicCompositeTypeNameOrOptions]\n  : never\n"
        },
        {
          "path": "web/components/user-report-item.tsx",
          "preContent": "import Link from 'next/link'\nimport { useEffect, useState } from 'react'\nimport { UserHovercard } from 'web/components/user/user-hovercard'\nimport { Avatar } from 'web/components/widgets/avatar'\nimport { Content } from 'web/components/widgets/editor'\nimport { RelativeTimestamp } from 'web/components/relative-timestamp'\nimport { UserLink, BannedBadge } from 'web/components/widgets/user-link'\nimport { Tooltip } from 'web/components/widgets/tooltip'\nimport { LiteReport } from 'web/pages/admin/reports'\nimport SuperBanControl from 'web/components/SuperBanControl'\n\nexport default function UserReportItem(props: {\n  report: LiteReport\n  bannedIds: string[]\n  onBan: (userId: string) => void\n}) {\n  const {\n    slug,\n    text,\n    owner,\n    reporter,\n    contentType,\n    createdTime,\n    reasonsDescription,\n  } = props.report\n  const { bannedIds, onBan } = props\n  const isBanned = owner.isBannedFromPosting || bannedIds.includes(owner.id)\n  const [showContent, setShowContent] = useState(!isBanned)\n  useEffect(() => {\n    setShowContent(!isBanned)\n  }, [isBanned])\n\n  return (\n    <div className=\"bg-canvas-50 my-4 rounded-lg p-4\">\n      <div className=\"flex items-center justify-between\">\n        <div className=\"flex items-center gap-2\">\n          <UserHovercard userId={owner.id}>\n            <div className=\"flex items-center\">\n              <Avatar\n                username={owner.username}\n                avatarUrl={owner.avatarUrl}\n                size=\"sm\"\n              />\n              <UserLink user={owner} className=\"text-ink-800 ml-2\" />\n              {isBanned && <BannedBadge />}\n            </div>\n          </UserHovercard>\n\n          <div>\n            {contentType === 'user' ? (\n              'was reported'\n            ) : (\n              <>\n                <Tooltip\n                  text={\n                    <div className=\"flex gap-1\">\n                      <Avatar\n                        username={reporter.username}\n                        avatarUrl={reporter.avatarUrl}\n                        size=\"xs\"\n                      />\n                      <UserLink user={reporter} />\n                    </div>\n                  }\n                >\n                  was reported for this{' '}\n                </Tooltip>\n                <Link href={slug} className=\"text-primary-700 text-md my-1\">\n                  {contentType}\n                </Link>\n              </>\n            )}\n          </div>\n        </div>\n        <div className=\"flex items-center gap-2\">\n          <SuperBanControl\n            userId={owner.id}\n            onBan={() => onBan(owner.id)}\n            disabled={isBanned}\n          />\n          {createdTime && <RelativeTimestamp time={createdTime} />}\n        </div>\n      </div>\n\n      {contentType !== 'user' && (\n        <>\n          {isBanned && (\n            <button\n              onClick={() => setShowContent(!showContent)}\n              className=\"text-ink-500 mt-2 cursor-pointer text-sm hover:underline\"\n            >\n              {showContent ? 'Hide content' : 'Show content from banned user'}\n            </button>\n          )}\n          {showContent && (\n            <div className=\"bg-canvas-0 my-2 max-h-[300px] overflow-y-auto rounded-lg p-2\">\n              <Content size=\"md\" content={text} />\n            </div>\n          )}\n        </>\n      )}\n\n      {reasonsDescription && (\n        <div className=\"text-ink-700 mt-2\">{reasonsDescription}</div>\n      )}\n    </div>\n  )\n}\n",
          "postContent": "import Link from 'next/link'\nimport { useEffect, useState } from 'react'\nimport { UserHovercard } from 'web/components/user/user-hovercard'\nimport { Avatar } from 'web/components/widgets/avatar'\nimport { Content } from 'web/components/widgets/editor'\nimport { RelativeTimestamp } from 'web/components/relative-timestamp'\nimport { UserLink, BannedBadge } from 'web/components/widgets/user-link'\nimport { Tooltip } from 'web/components/widgets/tooltip'\nimport { LiteReport } from 'web/pages/admin/reports'\nimport SuperBanControl from 'web/components/SuperBanControl'\nimport { useAdmin } from 'web/hooks/use-admin'\nimport { api } from 'web/lib/api/api'\nimport toast from 'react-hot-toast'\nimport { Button } from 'web/components/buttons/button'\n\nexport default function UserReportItem(props: {\n  report: LiteReport\n  bannedIds: string[]\n  onBan: (userId: string) => void\n}) {\n  const {\n    slug,\n    text,\n    owner,\n    reporter,\n    contentType,\n    createdTime,\n    reasonsDescription,\n    id: reportId,\n  } = props.report\n  const { bannedIds, onBan } = props\n  const isBanned = owner.isBannedFromPosting || bannedIds.includes(owner.id)\n  const [showContent, setShowContent] = useState(!isBanned)\n  const [isDismissedLocal, setIsDismissedLocal] = useState(false)\n  const isAdmin = useAdmin()\n\n  useEffect(() => {\n    setShowContent(!isBanned)\n  }, [isBanned])\n\n  const handleDismiss = async () => {\n    if (!reportId) return\n    try {\n      await toast.promise(api('dismiss-user-report', { reportId }), {\n        loading: 'Dismissing report...',\n        success: 'Report dismissed',\n        error: 'Failed to dismiss report',\n      })\n      setIsDismissedLocal(true)\n    } catch (e) {\n      console.error('Error dismissing report:', e)\n    }\n  }\n\n  if (isDismissedLocal) return null\n\n  return (\n    <div className=\"bg-canvas-50 my-4 rounded-lg p-4\">\n      <div className=\"flex items-center justify-between\">\n        <div className=\"flex items-center gap-2\">\n          <UserHovercard userId={owner.id}>\n            <div className=\"flex items-center\">\n              <Avatar\n                username={owner.username}\n                avatarUrl={owner.avatarUrl}\n                size=\"sm\"\n              />\n              <UserLink user={owner} className=\"text-ink-800 ml-2\" />\n              {isBanned && <BannedBadge />}\n            </div>\n          </UserHovercard>\n\n          <div>\n            {contentType === 'user' ? (\n              'was reported'\n            ) : (\n              <>\n                <Tooltip\n                  text={\n                    <div className=\"flex gap-1\">\n                      <Avatar\n                        username={reporter.username}\n                        avatarUrl={reporter.avatarUrl}\n                        size=\"xs\"\n                      />\n                      <UserLink user={reporter} />\n                    </div>\n                  }\n                >\n                  was reported for this{' '}\n                </Tooltip>\n                <Link href={slug} className=\"text-primary-700 text-md my-1\">\n                  {contentType}\n                </Link>\n              </>\n            )}\n          </div>\n        </div>\n        <div className=\"flex items-center gap-2\">\n          <SuperBanControl\n            userId={owner.id}\n            onBan={() => onBan(owner.id)}\n            disabled={isBanned}\n          />\n          {isAdmin && (\n            <Button\n              color=\"red-outline\"\n              size=\"xs\"\n              onClick={handleDismiss}\n              className=\"whitespace-nowrap\"\n            >\n              Dismiss Report\n            </Button>\n          )}\n          {createdTime && <RelativeTimestamp time={createdTime} />}\n        </div>\n      </div>\n\n      {contentType !== 'user' && (\n        <>\n          {isBanned && (\n            <button\n              onClick={() => setShowContent(!showContent)}\n              className=\"text-ink-500 mt-2 cursor-pointer text-sm hover:underline\"\n            >\n              {showContent ? 'Hide content' : 'Show content from banned user'}\n            </button>\n          )}\n          {showContent && (\n            <div className=\"bg-canvas-0 my-2 max-h-[300px] overflow-y-auto rounded-lg p-2\">\n              <Content size=\"md\" content={text} />\n            </div>\n          )}\n        </>\n      )}\n\n      {reasonsDescription && (\n        <div className=\"text-ink-700 mt-2\">{reasonsDescription}</div>\n      )}\n    </div>\n  )\n}\n"
        },
        {
          "path": "web/pages/admin/reports.tsx",
          "preContent": "import { JSONContent } from '@tiptap/core'\nimport { contractPath } from 'common/contract'\nimport { Row, millisToTs, run, tsToMillis } from 'common/supabase/utils'\nimport { filterDefined } from 'common/util/array'\nimport { groupBy } from 'lodash'\nimport Link from 'next/link'\nimport { NoSEO } from 'web/components/NoSEO'\nimport { Page } from 'web/components/layout/page'\nimport { RelativeTimestamp } from 'web/components/relative-timestamp'\nimport { UserHovercard } from 'web/components/user/user-hovercard'\nimport { Avatar } from 'web/components/widgets/avatar'\nimport { Content } from 'web/components/widgets/editor'\nimport { PaginationNextPrev } from 'web/components/widgets/pagination'\nimport { Title } from 'web/components/widgets/title'\nimport { Tooltip } from 'web/components/widgets/tooltip'\nimport { BannedBadge, UserLink } from 'web/components/widgets/user-link'\nimport { useAdmin } from 'web/hooks/use-admin'\nimport { usePagination } from 'web/hooks/use-pagination'\nimport { api } from 'web/lib/api/api'\nimport { getComment } from 'web/lib/supabase/comments'\nimport { db } from 'web/lib/supabase/db'\nimport { DisplayUser, getUserById } from 'web/lib/supabase/users'\nimport { convertPost } from 'common/top-level-post'\n\nconst PAGE_SIZE = 20\n\nexport async function getStaticProps() {\n  try {\n    const reports = await getReports({ limit: PAGE_SIZE })\n    return { props: { reports }, revalidate: 60 }\n  } catch (e) {\n    console.error(e)\n    return { props: { reports: [] }, revalidate: 60 }\n  }\n}\n\nexport default function Reports(props: { reports: LiteReport[] }) {\n  const pagination = usePagination<LiteReport>({\n    pageSize: PAGE_SIZE,\n    q: getReports,\n    prefix: props.reports,\n  })\n\n  const reportsByContent = Object.values(groupBy(pagination.items, 'contentId'))\n\n  const isAdmin = useAdmin()\n  if (!isAdmin) return <></>\n\n  return (\n    <Page trackPageView={false} className=\"px-2\">\n      <NoSEO />\n      <Title>Reports</Title>\n      <div className=\"flex w-full flex-col\">\n        <PaginationNextPrev {...pagination} />\n\n        {!pagination.isLoading &&\n          reportsByContent.map((reports) => {\n            const { slug, text, owner, contentId, contentType, createdTime } =\n              reports[0]\n\n            return (\n              <div key={contentId} className=\"my-4\">\n                <div className=\"flex items-center justify-between\">\n                  <div className=\"flex items-center gap-2\">\n                    <UserHovercard userId={owner.id}>\n                      <div className=\"flex items-center\">\n                        <Avatar\n                          username={owner.username}\n                          avatarUrl={owner.avatarUrl}\n                          size=\"sm\"\n                        />\n                        <UserLink user={owner} className=\"text-ink-800 ml-2\" />\n                        {owner.isBannedFromPosting && <BannedBadge />}\n                      </div>\n                    </UserHovercard>\n\n                    <div>\n                      {contentType === 'user' ? (\n                        'was reported'\n                      ) : (\n                        <>\n                          <Tooltip\n                            text={reports.map(({ reporter }, i) => (\n                              <div key={i} className=\"flex gap-1\">\n                                <Avatar\n                                  username={reporter.username}\n                                  avatarUrl={reporter.avatarUrl}\n                                  size=\"xs\"\n                                />\n                                <UserLink user={reporter} />\n                              </div>\n                            ))}\n                          >\n                            {/* TODO: show reporting users? */}\n                            was reported\n                            {reports.length > 1 && (\n                              <> {reports.length} times</>\n                            )}{' '}\n                            for this{' '}\n                          </Tooltip>\n                          <Link\n                            href={slug}\n                            className=\"text-primary-700 text-md my-1\"\n                          >\n                            {contentType}\n                          </Link>\n                        </>\n                      )}\n                    </div>\n                  </div>\n                  {createdTime && <RelativeTimestamp time={createdTime} />}\n                </div>\n\n                {contentType !== 'user' && (\n                  <div className=\"bg-canvas-0 my-2 max-h-[300px] overflow-y-auto rounded-lg p-2\">\n                    <Content size=\"md\" content={text} />\n                  </div>\n                )}\n\n                <div className=\"mt-2\">\n                  {reports\n                    .filter((report) => report.reasonsDescription)\n                    .map((report) => (\n                      <div key={report.id} className=\"text-ink-700\">\n                        {report.reasonsDescription}\n                      </div>\n                    ))}\n                </div>\n              </div>\n            )\n          })}\n        {!pagination.isLoading && (\n          <PaginationNextPrev {...pagination} className=\"mb-8\" />\n        )}\n      </div>\n    </Page>\n  )\n}\n\nexport const getReports = async (p: {\n  limit: number\n  offset?: number\n  after?: { createdTime?: number | undefined }\n}) => {\n  const q = db\n    .from('reports')\n    .select()\n    .order('created_time', { ascending: false })\n\n  if (p.offset) {\n    q.range(p.offset, p.limit + p.offset)\n  } else {\n    q.limit(p.limit)\n  }\n\n  if (p.after?.createdTime) {\n    q.lt('created_time', millisToTs(p.after.createdTime))\n  }\n\n  const { data } = await run(q)\n  return await convertReports(data)\n}\n\n// adapted from api/v0/reports\n\nexport type LiteReport = {\n  slug: string\n  id: string\n  text: string | JSONContent\n  owner: DisplayUser\n  reporter: DisplayUser\n  reasonsDescription: string | null\n  contentId: string\n  contentType: string\n  createdTime?: number\n}\n\nconst convertReports = async (\n  rows: Row<'reports'>[]\n): Promise<LiteReport[]> => {\n  return filterDefined(\n    await Promise.all(\n      rows.map(async (report) => {\n        const {\n          content_id: contentId,\n          content_type: contentType,\n          content_owner_id: contentOwnerId,\n          parent_type: parentType,\n          parent_id: parentId,\n          user_id: userId,\n          created_time: createdTime,\n          id,\n          description,\n        } = report\n\n        let partialReport: { slug: string; text: JSONContent | string } | null =\n          null\n        // Reported contract\n        if (contentType === 'contract') {\n          const contract = await api('market/:id', {\n            id: contentId,\n            lite: true,\n          })\n          partialReport = contract\n            ? {\n                slug: contractPath(contract),\n                text: contract.question,\n              }\n            : null\n          // Reported comment on a contract\n        } else if (\n          contentType === 'comment' &&\n          parentType === 'contract' &&\n          parentId\n        ) {\n          const contract = await api('market/:id', { id: parentId, lite: true })\n          if (contract) {\n            const comment = await getComment(contentId)\n            partialReport = comment && {\n              slug: contractPath(contract) + '#' + comment.id,\n              text: comment.content,\n            }\n          }\n        } else if (contentType === 'user') {\n          const reportedUser = await getUserById(contentId)\n          partialReport = {\n            slug: `/${reportedUser?.username}`,\n            text: reportedUser?.name ?? '',\n          }\n        } else if (contentType === 'post') {\n          const { data: postRow, error: postError } = await db\n            .from('old_posts')\n            .select('*')\n            .eq('id', contentId)\n            .single()\n\n          if (postError || !postRow) {\n            console.error(\n              `Error fetching post ${contentId} for report:`,\n              postError\n            )\n            partialReport = null\n          } else {\n            const post = convertPost(postRow)\n            partialReport = {\n              slug: `/post/${post.slug}`,\n              text: post.content,\n            }\n          }\n        }\n\n        const owner = await getUserById(contentOwnerId)\n        const reporter = await getUserById(userId)\n\n        return partialReport && owner\n          ? {\n              ...partialReport,\n              reasonsDescription: description,\n              owner,\n              reporter,\n              contentType,\n              contentId,\n              id,\n              createdTime: tsToMillis(createdTime as any),\n            }\n          : null\n      })\n    )\n  )\n}\n",
          "postContent": "import { JSONContent } from '@tiptap/core'\nimport { contractPath } from 'common/contract'\nimport { Row, millisToTs, run, tsToMillis } from 'common/supabase/utils'\nimport { filterDefined } from 'common/util/array'\nimport { groupBy } from 'lodash'\nimport Link from 'next/link'\nimport { NoSEO } from 'web/components/NoSEO'\nimport { Page } from 'web/components/layout/page'\nimport { RelativeTimestamp } from 'web/components/relative-timestamp'\nimport { UserHovercard } from 'web/components/user/user-hovercard'\nimport { Avatar } from 'web/components/widgets/avatar'\nimport { Content } from 'web/components/widgets/editor'\nimport { PaginationNextPrev } from 'web/components/widgets/pagination'\nimport { Title } from 'web/components/widgets/title'\nimport { Tooltip } from 'web/components/widgets/tooltip'\nimport { BannedBadge, UserLink } from 'web/components/widgets/user-link'\nimport { useAdmin } from 'web/hooks/use-admin'\nimport { usePagination } from 'web/hooks/use-pagination'\nimport { api } from 'web/lib/api/api'\nimport { getComment } from 'web/lib/supabase/comments'\nimport { db } from 'web/lib/supabase/db'\nimport { DisplayUser, getUserById } from 'web/lib/supabase/users'\nimport { convertPost } from 'common/top-level-post'\n\nconst PAGE_SIZE = 20\n\nexport async function getStaticProps() {\n  try {\n    const reports = await getReports({ limit: PAGE_SIZE })\n    return { props: { reports }, revalidate: 60 }\n  } catch (e) {\n    console.error(e)\n    return { props: { reports: [] }, revalidate: 60 }\n  }\n}\n\nexport default function Reports(props: { reports: LiteReport[] }) {\n  const pagination = usePagination<LiteReport>({\n    pageSize: PAGE_SIZE,\n    q: getReports,\n    prefix: props.reports,\n  })\n\n  const reportsByContent = Object.values(groupBy(pagination.items, 'contentId'))\n\n  const isAdmin = useAdmin()\n  if (!isAdmin) return <></>\n\n  return (\n    <Page trackPageView={false} className=\"px-2\">\n      <NoSEO />\n      <Title>Reports</Title>\n      <div className=\"flex w-full flex-col\">\n        <PaginationNextPrev {...pagination} />\n\n        {!pagination.isLoading &&\n          reportsByContent.map((reports) => {\n            const { slug, text, owner, contentId, contentType, createdTime } =\n              reports[0]\n\n            return (\n              <div key={contentId} className=\"my-4\">\n                <div className=\"flex items-center justify-between\">\n                  <div className=\"flex items-center gap-2\">\n                    <UserHovercard userId={owner.id}>\n                      <div className=\"flex items-center\">\n                        <Avatar\n                          username={owner.username}\n                          avatarUrl={owner.avatarUrl}\n                          size=\"sm\"\n                        />\n                        <UserLink user={owner} className=\"text-ink-800 ml-2\" />\n                        {owner.isBannedFromPosting && <BannedBadge />}\n                      </div>\n                    </UserHovercard>\n\n                    <div>\n                      {contentType === 'user' ? (\n                        'was reported'\n                      ) : (\n                        <>\n                          <Tooltip\n                            text={reports.map(({ reporter }, i) => (\n                              <div key={i} className=\"flex gap-1\">\n                                <Avatar\n                                  username={reporter.username}\n                                  avatarUrl={reporter.avatarUrl}\n                                  size=\"xs\"\n                                />\n                                <UserLink user={reporter} />\n                              </div>\n                            ))}\n                          >\n                            {/* TODO: show reporting users? */}\n                            was reported\n                            {reports.length > 1 && (\n                              <> {reports.length} times</>\n                            )}{' '}\n                            for this{' '}\n                          </Tooltip>\n                          <Link\n                            href={slug}\n                            className=\"text-primary-700 text-md my-1\"\n                          >\n                            {contentType}\n                          </Link>\n                        </>\n                      )}\n                    </div>\n                  </div>\n                  {createdTime && <RelativeTimestamp time={createdTime} />}\n                </div>\n\n                {contentType !== 'user' && (\n                  <div className=\"bg-canvas-0 my-2 max-h-[300px] overflow-y-auto rounded-lg p-2\">\n                    <Content size=\"md\" content={text} />\n                  </div>\n                )}\n\n                <div className=\"mt-2\">\n                  {reports\n                    .filter((report) => report.reasonsDescription)\n                    .map((report) => (\n                      <div key={report.id} className=\"text-ink-700\">\n                        {report.reasonsDescription}\n                      </div>\n                    ))}\n                </div>\n              </div>\n            )\n          })}\n        {!pagination.isLoading && (\n          <PaginationNextPrev {...pagination} className=\"mb-8\" />\n        )}\n      </div>\n    </Page>\n  )\n}\n\nexport const getReports = async (p: {\n  limit: number\n  offset?: number\n  after?: { createdTime?: number | undefined }\n}) => {\n  const q = db\n    .from('reports')\n    .select()\n    .is('dismissed_by_user_id', null)\n    .order('created_time', { ascending: false })\n\n  if (p.offset) {\n    q.range(p.offset, p.limit + p.offset)\n  } else {\n    q.limit(p.limit)\n  }\n\n  if (p.after?.createdTime) {\n    q.lt('created_time', millisToTs(p.after.createdTime))\n  }\n\n  const { data } = await run(q)\n  return await convertReports(data)\n}\n\n// adapted from api/v0/reports\n\nexport type LiteReport = {\n  slug: string\n  id: string\n  text: string | JSONContent\n  owner: DisplayUser\n  reporter: DisplayUser\n  reasonsDescription: string | null\n  contentId: string\n  contentType: string\n  createdTime?: number\n}\n\nconst convertReports = async (\n  rows: Row<'reports'>[]\n): Promise<LiteReport[]> => {\n  return filterDefined(\n    await Promise.all(\n      rows.map(async (report) => {\n        const {\n          content_id: contentId,\n          content_type: contentType,\n          content_owner_id: contentOwnerId,\n          parent_type: parentType,\n          parent_id: parentId,\n          user_id: userId,\n          created_time: createdTime,\n          id,\n          description,\n        } = report\n\n        let partialReport: { slug: string; text: JSONContent | string } | null =\n          null\n        // Reported contract\n        if (contentType === 'contract') {\n          const contract = await api('market/:id', {\n            id: contentId,\n            lite: true,\n          })\n          partialReport = contract\n            ? {\n                slug: contractPath(contract),\n                text: contract.question,\n              }\n            : null\n          // Reported comment on a contract\n        } else if (\n          contentType === 'comment' &&\n          parentType === 'contract' &&\n          parentId\n        ) {\n          const contract = await api('market/:id', { id: parentId, lite: true })\n          if (contract) {\n            const comment = await getComment(contentId)\n            partialReport = comment && {\n              slug: contractPath(contract) + '#' + comment.id,\n              text: comment.content,\n            }\n          }\n        } else if (contentType === 'user') {\n          const reportedUser = await getUserById(contentId)\n          partialReport = {\n            slug: `/${reportedUser?.username}`,\n            text: reportedUser?.name ?? '',\n          }\n        } else if (contentType === 'post') {\n          const { data: postRow, error: postError } = await db\n            .from('old_posts')\n            .select('*')\n            .eq('id', contentId)\n            .single()\n\n          if (postError || !postRow) {\n            console.error(\n              `Error fetching post ${contentId} for report:`,\n              postError\n            )\n            partialReport = null\n          } else {\n            const post = convertPost(postRow)\n            partialReport = {\n              slug: `/post/${post.slug}`,\n              text: post.content,\n            }\n          }\n        }\n\n        const owner = await getUserById(contentOwnerId)\n        const reporter = await getUserById(userId)\n\n        return partialReport && owner\n          ? {\n              ...partialReport,\n              reasonsDescription: description,\n              owner,\n              reporter,\n              contentType,\n              contentId,\n              id,\n              createdTime: tsToMillis(createdTime as any),\n            }\n          : null\n      })\n    )\n  )\n}\n"
        }
      ]
    },
    {
      "sha": "42437392a458473ba6752a2fc379f5f309e30ab9",
      "author": "Ian Philips",
      "date": "2025-05-08 16:50:46 -0700",
      "message": "Report posts",
      "stats": {
        "filesChanged": 4,
        "insertions": 43,
        "deletions": 2
      },
      "selectionReason": "Implements post reporting feature - adds user-facing reporting functionality with backend integration",
      "spec": "Enable the reporting of 'post' content. First, update the backend reporting system and shared data models to recognize 'post' as a valid `contentType` for reports. Second, enhance the admin reports interface to correctly fetch and display reports for posts; for each reported post, this interface must show a link to the post (e.g., `/post/[post_slug]`) and its content, in addition to standard report details. Third, add a 'Report' option to the dropdown menu on individual post pages. Activating this option should submit a report to the backend, providing the post's ID, its `contentType` as 'post', and the post creator's ID as the `contentOwnerId`. Ensure user feedback (loading, success, error states) is provided during the reporting process.",
      "fileStates": [
        {
          "path": "backend/api/src/report.ts",
          "preContent": "import { z } from 'zod'\nimport type { ReportProps } from 'common/src/report'\nimport { APIError, authEndpoint, validate } from './helpers/endpoint'\nimport { createSupabaseClient } from 'shared/supabase/init'\n\nconst schema: z.ZodSchema<ReportProps> = z\n  .object({\n    contentOwnerId: z.string(),\n    contentType: z.enum(['user', 'comment', 'contract']),\n    contentId: z.string(),\n    description: z.string().optional(),\n    parentId: z.string().optional(),\n    parentType: z.enum(['contract', 'post']).optional(),\n  })\n  .strict()\n\n// abusable: people can report the wrong person, that didn't write the comment\n// but in practice we check it manually and nothing bad happens to them automatically\nexport const report = authEndpoint(async (req, auth) => {\n  const {\n    contentOwnerId,\n    contentType,\n    contentId,\n    description,\n    parentId,\n    parentType,\n  } = validate(schema, req.body)\n\n  const db = createSupabaseClient()\n\n  const result = await db.from('reports').insert({\n    user_id: auth.uid,\n    content_owner_id: contentOwnerId,\n    content_type: contentType,\n    content_id: contentId,\n    description,\n    parent_id: parentId,\n    parent_type: parentType,\n  })\n\n  if (result.error) {\n    throw new APIError(500, 'Failed to create report: ' + result.error.message)\n  }\n\n  return { success: true }\n})\n",
          "postContent": "import { z } from 'zod'\nimport type { ReportProps } from 'common/src/report'\nimport { APIError, authEndpoint, validate } from './helpers/endpoint'\nimport { createSupabaseClient } from 'shared/supabase/init'\n\nconst schema: z.ZodSchema<ReportProps> = z\n  .object({\n    contentOwnerId: z.string(),\n    contentType: z.enum(['user', 'comment', 'contract', 'post']),\n    contentId: z.string(),\n    description: z.string().optional(),\n    parentId: z.string().optional(),\n    parentType: z.enum(['contract', 'post']).optional(),\n  })\n  .strict()\n\n// abusable: people can report the wrong person, that didn't write the comment\n// but in practice we check it manually and nothing bad happens to them automatically\nexport const report = authEndpoint(async (req, auth) => {\n  const {\n    contentOwnerId,\n    contentType,\n    contentId,\n    description,\n    parentId,\n    parentType,\n  } = validate(schema, req.body)\n\n  const db = createSupabaseClient()\n\n  const result = await db.from('reports').insert({\n    user_id: auth.uid,\n    content_owner_id: contentOwnerId,\n    content_type: contentType,\n    content_id: contentId,\n    description,\n    parent_id: parentId,\n    parent_type: parentType,\n  })\n\n  if (result.error) {\n    throw new APIError(500, 'Failed to create report: ' + result.error.message)\n  }\n\n  return { success: true }\n})\n"
        },
        {
          "path": "common/src/report.ts",
          "preContent": "type Report = {\n  id: string\n  // Reporter user ID\n  userId: string\n  createdTime: number\n  contentOwnerId: string\n  contentType: ReportContentTypes\n  contentId: string\n\n  // in case the user would like to say why they reported the content\n  description?: string\n\n  // in the case of a comment, the comment's contract id\n  parentId?: string\n  parentType?: 'contract' | 'post' | 'user'\n}\n\nexport type ReportContentTypes = 'user' | 'comment' | 'contract'\n\nexport type ReportProps = Omit<Report, 'id' | 'createdTime' | 'userId'>\n",
          "postContent": "type Report = {\n  id: string\n  // Reporter user ID\n  userId: string\n  createdTime: number\n  contentOwnerId: string\n  contentType: ReportContentTypes\n  contentId: string\n\n  // in case the user would like to say why they reported the content\n  description?: string\n\n  // in the case of a comment, the comment's contract id\n  parentId?: string\n  parentType?: 'contract' | 'post' | 'user'\n}\n\nexport type ReportContentTypes = 'user' | 'comment' | 'contract' | 'post'\n\nexport type ReportProps = Omit<Report, 'id' | 'createdTime' | 'userId'>\n"
        },
        {
          "path": "web/pages/admin/reports.tsx",
          "preContent": "import { JSONContent } from '@tiptap/core'\nimport { contractPath } from 'common/contract'\nimport { Row, millisToTs, run, tsToMillis } from 'common/supabase/utils'\nimport { filterDefined } from 'common/util/array'\nimport { groupBy } from 'lodash'\nimport Link from 'next/link'\nimport { NoSEO } from 'web/components/NoSEO'\nimport { Page } from 'web/components/layout/page'\nimport { RelativeTimestamp } from 'web/components/relative-timestamp'\nimport { UserHovercard } from 'web/components/user/user-hovercard'\nimport { Avatar } from 'web/components/widgets/avatar'\nimport { Content } from 'web/components/widgets/editor'\nimport { PaginationNextPrev } from 'web/components/widgets/pagination'\nimport { Title } from 'web/components/widgets/title'\nimport { Tooltip } from 'web/components/widgets/tooltip'\nimport { BannedBadge, UserLink } from 'web/components/widgets/user-link'\nimport { useAdmin } from 'web/hooks/use-admin'\nimport { usePagination } from 'web/hooks/use-pagination'\nimport { api } from 'web/lib/api/api'\nimport { getComment } from 'web/lib/supabase/comments'\nimport { db } from 'web/lib/supabase/db'\nimport { DisplayUser, getUserById } from 'web/lib/supabase/users'\n\nconst PAGE_SIZE = 20\n\nexport async function getStaticProps() {\n  try {\n    const reports = await getReports({ limit: PAGE_SIZE })\n    return { props: { reports }, revalidate: 60 }\n  } catch (e) {\n    console.error(e)\n    return { props: { reports: [] }, revalidate: 60 }\n  }\n}\n\nexport default function Reports(props: { reports: LiteReport[] }) {\n  const pagination = usePagination<LiteReport>({\n    pageSize: PAGE_SIZE,\n    q: getReports,\n    prefix: props.reports,\n  })\n\n  const reportsByContent = Object.values(groupBy(pagination.items, 'contentId'))\n\n  const isAdmin = useAdmin()\n  if (!isAdmin) return <></>\n\n  return (\n    <Page trackPageView={false} className=\"px-2\">\n      <NoSEO />\n      <Title>Reports</Title>\n      <div className=\"flex w-full flex-col\">\n        <PaginationNextPrev {...pagination} />\n\n        {!pagination.isLoading &&\n          reportsByContent.map((reports) => {\n            const { slug, text, owner, contentId, contentType, createdTime } =\n              reports[0]\n\n            return (\n              <div key={contentId} className=\"my-4\">\n                <div className=\"flex items-center justify-between\">\n                  <div className=\"flex items-center gap-2\">\n                    <UserHovercard userId={owner.id}>\n                      <div className=\"flex items-center\">\n                        <Avatar\n                          username={owner.username}\n                          avatarUrl={owner.avatarUrl}\n                          size=\"sm\"\n                        />\n                        <UserLink user={owner} className=\"text-ink-800 ml-2\" />\n                        {owner.isBannedFromPosting && <BannedBadge />}\n                      </div>\n                    </UserHovercard>\n\n                    <div>\n                      {contentType === 'user' ? (\n                        'was reported'\n                      ) : (\n                        <>\n                          <Tooltip\n                            text={reports.map(({ reporter }, i) => (\n                              <div key={i} className=\"flex gap-1\">\n                                <Avatar\n                                  username={reporter.username}\n                                  avatarUrl={reporter.avatarUrl}\n                                  size=\"xs\"\n                                />\n                                <UserLink user={reporter} />\n                              </div>\n                            ))}\n                          >\n                            {/* TODO: show reporting users? */}\n                            was reported\n                            {reports.length > 1 && (\n                              <> {reports.length} times</>\n                            )}{' '}\n                            for this{' '}\n                          </Tooltip>\n                          <Link\n                            href={slug}\n                            className=\"text-primary-700 text-md my-1\"\n                          >\n                            {contentType}\n                          </Link>\n                        </>\n                      )}\n                    </div>\n                  </div>\n                  {createdTime && <RelativeTimestamp time={createdTime} />}\n                </div>\n\n                {contentType !== 'user' && (\n                  <div className=\"bg-canvas-0 my-2 max-h-[300px] overflow-y-auto rounded-lg p-2\">\n                    <Content size=\"md\" content={text} />\n                  </div>\n                )}\n\n                <div className=\"mt-2\">\n                  {reports\n                    .filter((report) => report.reasonsDescription)\n                    .map((report) => (\n                      <div key={report.id} className=\"text-ink-700\">\n                        {report.reasonsDescription}\n                      </div>\n                    ))}\n                </div>\n              </div>\n            )\n          })}\n        {!pagination.isLoading && (\n          <PaginationNextPrev {...pagination} className=\"mb-8\" />\n        )}\n      </div>\n    </Page>\n  )\n}\n\nexport const getReports = async (p: {\n  limit: number\n  offset?: number\n  after?: { createdTime?: number | undefined }\n}) => {\n  const q = db\n    .from('reports')\n    .select()\n    .order('created_time', { ascending: false })\n\n  if (p.offset) {\n    q.range(p.offset, p.limit + p.offset)\n  } else {\n    q.limit(p.limit)\n  }\n\n  if (p.after?.createdTime) {\n    q.lt('created_time', millisToTs(p.after.createdTime))\n  }\n\n  const { data } = await run(q)\n  return await convertReports(data)\n}\n\n// adapted from api/v0/reports\n\nexport type LiteReport = {\n  slug: string\n  id: string\n  text: string | JSONContent\n  owner: DisplayUser\n  reporter: DisplayUser\n  reasonsDescription: string | null\n  contentId: string\n  contentType: string\n  createdTime?: number\n}\n\nconst convertReports = async (\n  rows: Row<'reports'>[]\n): Promise<LiteReport[]> => {\n  return filterDefined(\n    await Promise.all(\n      rows.map(async (report) => {\n        const {\n          content_id: contentId,\n          content_type: contentType,\n          content_owner_id: contentOwnerId,\n          parent_type: parentType,\n          parent_id: parentId,\n          user_id: userId,\n          created_time: createdTime,\n          id,\n          description,\n        } = report\n\n        let partialReport: { slug: string; text: JSONContent | string } | null =\n          null\n        // Reported contract\n        if (contentType === 'contract') {\n          const contract = await api('market/:id', {\n            id: contentId,\n            lite: true,\n          })\n          partialReport = contract\n            ? {\n                slug: contractPath(contract),\n                text: contract.question,\n              }\n            : null\n          // Reported comment on a contract\n        } else if (\n          contentType === 'comment' &&\n          parentType === 'contract' &&\n          parentId\n        ) {\n          const contract = await api('market/:id', { id: parentId, lite: true })\n          if (contract) {\n            const comment = await getComment(contentId)\n            partialReport = comment && {\n              slug: contractPath(contract) + '#' + comment.id,\n              text: comment.content,\n            }\n          }\n        } else if (contentType === 'user') {\n          const reportedUser = await getUserById(contentId)\n          partialReport = {\n            slug: `/${reportedUser?.username}`,\n            text: reportedUser?.name ?? '',\n          }\n        }\n\n        const owner = await getUserById(contentOwnerId)\n        const reporter = await getUserById(userId)\n\n        return partialReport && owner\n          ? {\n              ...partialReport,\n              reasonsDescription: description,\n              owner,\n              reporter,\n              contentType,\n              contentId,\n              id,\n              createdTime: tsToMillis(createdTime as any),\n            }\n          : null\n      })\n    )\n  )\n}\n",
          "postContent": "import { JSONContent } from '@tiptap/core'\nimport { contractPath } from 'common/contract'\nimport { Row, millisToTs, run, tsToMillis } from 'common/supabase/utils'\nimport { filterDefined } from 'common/util/array'\nimport { groupBy } from 'lodash'\nimport Link from 'next/link'\nimport { NoSEO } from 'web/components/NoSEO'\nimport { Page } from 'web/components/layout/page'\nimport { RelativeTimestamp } from 'web/components/relative-timestamp'\nimport { UserHovercard } from 'web/components/user/user-hovercard'\nimport { Avatar } from 'web/components/widgets/avatar'\nimport { Content } from 'web/components/widgets/editor'\nimport { PaginationNextPrev } from 'web/components/widgets/pagination'\nimport { Title } from 'web/components/widgets/title'\nimport { Tooltip } from 'web/components/widgets/tooltip'\nimport { BannedBadge, UserLink } from 'web/components/widgets/user-link'\nimport { useAdmin } from 'web/hooks/use-admin'\nimport { usePagination } from 'web/hooks/use-pagination'\nimport { api } from 'web/lib/api/api'\nimport { getComment } from 'web/lib/supabase/comments'\nimport { db } from 'web/lib/supabase/db'\nimport { DisplayUser, getUserById } from 'web/lib/supabase/users'\nimport { convertPost } from 'common/top-level-post'\n\nconst PAGE_SIZE = 20\n\nexport async function getStaticProps() {\n  try {\n    const reports = await getReports({ limit: PAGE_SIZE })\n    return { props: { reports }, revalidate: 60 }\n  } catch (e) {\n    console.error(e)\n    return { props: { reports: [] }, revalidate: 60 }\n  }\n}\n\nexport default function Reports(props: { reports: LiteReport[] }) {\n  const pagination = usePagination<LiteReport>({\n    pageSize: PAGE_SIZE,\n    q: getReports,\n    prefix: props.reports,\n  })\n\n  const reportsByContent = Object.values(groupBy(pagination.items, 'contentId'))\n\n  const isAdmin = useAdmin()\n  if (!isAdmin) return <></>\n\n  return (\n    <Page trackPageView={false} className=\"px-2\">\n      <NoSEO />\n      <Title>Reports</Title>\n      <div className=\"flex w-full flex-col\">\n        <PaginationNextPrev {...pagination} />\n\n        {!pagination.isLoading &&\n          reportsByContent.map((reports) => {\n            const { slug, text, owner, contentId, contentType, createdTime } =\n              reports[0]\n\n            return (\n              <div key={contentId} className=\"my-4\">\n                <div className=\"flex items-center justify-between\">\n                  <div className=\"flex items-center gap-2\">\n                    <UserHovercard userId={owner.id}>\n                      <div className=\"flex items-center\">\n                        <Avatar\n                          username={owner.username}\n                          avatarUrl={owner.avatarUrl}\n                          size=\"sm\"\n                        />\n                        <UserLink user={owner} className=\"text-ink-800 ml-2\" />\n                        {owner.isBannedFromPosting && <BannedBadge />}\n                      </div>\n                    </UserHovercard>\n\n                    <div>\n                      {contentType === 'user' ? (\n                        'was reported'\n                      ) : (\n                        <>\n                          <Tooltip\n                            text={reports.map(({ reporter }, i) => (\n                              <div key={i} className=\"flex gap-1\">\n                                <Avatar\n                                  username={reporter.username}\n                                  avatarUrl={reporter.avatarUrl}\n                                  size=\"xs\"\n                                />\n                                <UserLink user={reporter} />\n                              </div>\n                            ))}\n                          >\n                            {/* TODO: show reporting users? */}\n                            was reported\n                            {reports.length > 1 && (\n                              <> {reports.length} times</>\n                            )}{' '}\n                            for this{' '}\n                          </Tooltip>\n                          <Link\n                            href={slug}\n                            className=\"text-primary-700 text-md my-1\"\n                          >\n                            {contentType}\n                          </Link>\n                        </>\n                      )}\n                    </div>\n                  </div>\n                  {createdTime && <RelativeTimestamp time={createdTime} />}\n                </div>\n\n                {contentType !== 'user' && (\n                  <div className=\"bg-canvas-0 my-2 max-h-[300px] overflow-y-auto rounded-lg p-2\">\n                    <Content size=\"md\" content={text} />\n                  </div>\n                )}\n\n                <div className=\"mt-2\">\n                  {reports\n                    .filter((report) => report.reasonsDescription)\n                    .map((report) => (\n                      <div key={report.id} className=\"text-ink-700\">\n                        {report.reasonsDescription}\n                      </div>\n                    ))}\n                </div>\n              </div>\n            )\n          })}\n        {!pagination.isLoading && (\n          <PaginationNextPrev {...pagination} className=\"mb-8\" />\n        )}\n      </div>\n    </Page>\n  )\n}\n\nexport const getReports = async (p: {\n  limit: number\n  offset?: number\n  after?: { createdTime?: number | undefined }\n}) => {\n  const q = db\n    .from('reports')\n    .select()\n    .order('created_time', { ascending: false })\n\n  if (p.offset) {\n    q.range(p.offset, p.limit + p.offset)\n  } else {\n    q.limit(p.limit)\n  }\n\n  if (p.after?.createdTime) {\n    q.lt('created_time', millisToTs(p.after.createdTime))\n  }\n\n  const { data } = await run(q)\n  return await convertReports(data)\n}\n\n// adapted from api/v0/reports\n\nexport type LiteReport = {\n  slug: string\n  id: string\n  text: string | JSONContent\n  owner: DisplayUser\n  reporter: DisplayUser\n  reasonsDescription: string | null\n  contentId: string\n  contentType: string\n  createdTime?: number\n}\n\nconst convertReports = async (\n  rows: Row<'reports'>[]\n): Promise<LiteReport[]> => {\n  return filterDefined(\n    await Promise.all(\n      rows.map(async (report) => {\n        const {\n          content_id: contentId,\n          content_type: contentType,\n          content_owner_id: contentOwnerId,\n          parent_type: parentType,\n          parent_id: parentId,\n          user_id: userId,\n          created_time: createdTime,\n          id,\n          description,\n        } = report\n\n        let partialReport: { slug: string; text: JSONContent | string } | null =\n          null\n        // Reported contract\n        if (contentType === 'contract') {\n          const contract = await api('market/:id', {\n            id: contentId,\n            lite: true,\n          })\n          partialReport = contract\n            ? {\n                slug: contractPath(contract),\n                text: contract.question,\n              }\n            : null\n          // Reported comment on a contract\n        } else if (\n          contentType === 'comment' &&\n          parentType === 'contract' &&\n          parentId\n        ) {\n          const contract = await api('market/:id', { id: parentId, lite: true })\n          if (contract) {\n            const comment = await getComment(contentId)\n            partialReport = comment && {\n              slug: contractPath(contract) + '#' + comment.id,\n              text: comment.content,\n            }\n          }\n        } else if (contentType === 'user') {\n          const reportedUser = await getUserById(contentId)\n          partialReport = {\n            slug: `/${reportedUser?.username}`,\n            text: reportedUser?.name ?? '',\n          }\n        } else if (contentType === 'post') {\n          const { data: postRow, error: postError } = await db\n            .from('old_posts')\n            .select('*')\n            .eq('id', contentId)\n            .single()\n\n          if (postError || !postRow) {\n            console.error(\n              `Error fetching post ${contentId} for report:`,\n              postError\n            )\n            partialReport = null\n          } else {\n            const post = convertPost(postRow)\n            partialReport = {\n              slug: `/post/${post.slug}`,\n              text: post.content,\n            }\n          }\n        }\n\n        const owner = await getUserById(contentOwnerId)\n        const reporter = await getUserById(userId)\n\n        return partialReport && owner\n          ? {\n              ...partialReport,\n              reasonsDescription: description,\n              owner,\n              reporter,\n              contentType,\n              contentId,\n              id,\n              createdTime: tsToMillis(createdTime as any),\n            }\n          : null\n      })\n    )\n  )\n}\n"
        },
        {
          "path": "web/pages/post/[slug]/index.tsx",
          "preContent": "import { Page } from 'web/components/layout/page'\nimport { Spacer } from 'web/components/layout/spacer'\nimport {\n  Content,\n  TextEditor,\n  useTextEditor,\n} from 'web/components/widgets/editor'\nimport {\n  EyeOffIcon,\n  PencilIcon,\n  DotsHorizontalIcon,\n} from '@heroicons/react/solid'\nimport { Button } from 'web/components/buttons/button'\nimport { useState, useEffect } from 'react'\nimport { Row } from 'web/components/layout/row'\nimport { Col } from 'web/components/layout/col'\nimport Custom404 from 'web/pages/404'\nimport { UserAvatarAndBadge } from 'web/components/widgets/user-link'\nimport { SEO } from 'web/components/SEO'\nimport { richTextToString } from 'common/util/parse'\nimport { CopyLinkOrShareButton } from 'web/components/buttons/copy-link-button'\nimport { DisplayUser, getUserById } from 'web/lib/supabase/users'\nimport { getPostShareUrl, TopLevelPost } from 'common/src/top-level-post'\nimport { useUser } from 'web/hooks/use-user'\nimport { api } from 'web/lib/api/api'\nimport { getCommentsOnPost } from 'web/lib/supabase/comments'\nimport { PostComment } from 'common/comment'\nimport {\n  PostCommentsActivity,\n  useNewPostComments,\n} from 'web/components/top-level-posts/post-comments'\nimport { ExpandingInput } from 'web/components/widgets/expanding-input'\nimport { useAdminOrMod } from 'web/hooks/use-admin'\nimport toast from 'react-hot-toast'\nimport { ReactButton } from 'web/components/contract/react-button'\nimport { getPostBySlug } from 'web/lib/supabase/posts'\nimport { useSaveReferral } from 'web/hooks/use-save-referral'\nimport DropdownMenu from 'web/components/widgets/dropdown-menu'\nimport { BackButton } from 'web/components/contract/back-button'\n\nexport async function getStaticProps(props: { params: { slug: string } }) {\n  const { slug } = props.params\n\n  const postData = await getPostBySlug(slug)\n  const creator = postData ? await getUserById(postData.creatorId) : null\n  const comments = postData ? await getCommentsOnPost(postData.id) : []\n  const watched: string[] = []\n  const skipped: string[] = []\n\n  return {\n    props: {\n      post: postData,\n      creator,\n      comments,\n      watched,\n      skipped,\n    },\n\n    revalidate: 60, // regenerate after a minute\n  }\n}\n\nexport async function getStaticPaths() {\n  return { paths: [], fallback: 'blocking' }\n}\n\nexport default function PostPage(props: {\n  post: TopLevelPost | null\n  creator: DisplayUser | null\n  comments: PostComment[]\n  watched?: string[] //user ids\n  skipped?: string[] //user ids\n}) {\n  const { creator } = props\n  const { comments: newComments } = useNewPostComments(props.post?.id ?? '_')\n  const comments = [...newComments, ...props.comments]\n  const [post, setPost] = useState(props.post)\n  const isAdminOrMod = useAdminOrMod()\n  const [editing, setEditing] = useState(false)\n  const currentUser = useUser()\n  useSaveReferral(currentUser, {\n    defaultReferrerUsername: post?.creatorUsername,\n  })\n\n  useEffect(() => {\n    setPost(props.post)\n  }, [props.post])\n\n  if (!post || !creator) {\n    return <Custom404 />\n  }\n  const shareUrl = getPostShareUrl(post, currentUser?.username)\n\n  const handleReact = () => {\n    if (!currentUser || !post) return\n    setPost((prevPost) => {\n      if (!prevPost) return null\n      const newLikedByUserIds = [\n        ...(prevPost.likedByUserIds ?? []),\n        currentUser.id,\n      ]\n      return {\n        ...prevPost,\n        likedByUserCount: (prevPost.likedByUserCount ?? 0) + 1,\n        likedByUserIds: newLikedByUserIds,\n      }\n    })\n  }\n\n  const handleUnreact = () => {\n    if (!currentUser || !post) return\n    setPost((prevPost) => {\n      if (!prevPost) return null\n      const newLikedByUserIds =\n        prevPost.likedByUserIds?.filter((id) => id !== currentUser.id) ?? []\n      return {\n        ...prevPost,\n        likedByUserCount: Math.max(0, (prevPost.likedByUserCount ?? 0) - 1),\n        likedByUserIds: newLikedByUserIds,\n      }\n    })\n  }\n\n  const togglePostVisibility = async () => {\n    if (!post) return\n    const newVisibility = post.visibility === 'unlisted' ? 'public' : 'unlisted'\n    try {\n      await api('update-post', {\n        id: post.id,\n        visibility: newVisibility,\n      })\n      setPost((prevPost) =>\n        prevPost ? { ...prevPost, visibility: newVisibility } : null\n      )\n      toast.success(\n        `Post successfully made ${\n          newVisibility === 'public' ? 'public' : 'unlisted'\n        }.`\n      )\n    } catch (error) {\n      console.error('Error updating post visibility:', error)\n      toast.error(\n        `Failed to update post visibility. ${\n          error instanceof Error ? error.message : ''\n        }`\n      )\n    } finally {\n    }\n  }\n\n  return (\n    <Page trackPageView={'post slug page'}>\n      <SEO\n        title={post.title}\n        description={richTextToString(post.content)}\n        url={'/post/' + post.slug}\n        shouldIgnore={post.visibility === 'unlisted'}\n      />\n      <Col className=\"mx-auto w-full max-w-2xl p-4\">\n        {!editing && (\n          <Col>\n            <Row>\n              <BackButton className=\"!p-0\" />\n            </Row>\n            <Col className=\"border-canvas-50 pt-4\">\n              <Row className=\" items-center justify-between gap-1 text-2xl font-bold\">\n                <span>\n                  {post.title}{' '}\n                  {post.visibility === 'unlisted' && (\n                    <EyeOffIcon className=\"inline-block h-4 w-4\" />\n                  )}\n                </span>\n              </Row>\n              <Row className=\"mt-3 items-center gap-2 \">\n                <CopyLinkOrShareButton\n                  tooltip=\"Copy link to post\"\n                  url={shareUrl}\n                  eventTrackingName={'copy post link'}\n                />\n                {post && (\n                  <ReactButton\n                    contentId={post.id}\n                    contentCreatorId={post.creatorId}\n                    user={currentUser}\n                    contentType={'post'}\n                    contentText={post.title}\n                    trackingLocation={'post page'}\n                    reactionType={'like'}\n                    size={'sm'}\n                    userReactedWith={\n                      currentUser &&\n                      post.likedByUserIds?.includes(currentUser.id)\n                        ? 'like'\n                        : 'none'\n                    }\n                    onReact={handleReact}\n                    onUnreact={handleUnreact}\n                  />\n                )}\n                {(isAdminOrMod || post.creatorId === currentUser?.id) &&\n                  post && (\n                    <DropdownMenu\n                      items={[\n                        {\n                          name:\n                            post.visibility === 'unlisted'\n                              ? 'Make Public'\n                              : 'Make Unlisted',\n                          icon:\n                            post.visibility === 'unlisted' ? (\n                              <EyeOffIcon className=\"h-5 w-5\" />\n                            ) : (\n                              <EyeOffIcon className=\"h-5 w-5\" />\n                            ),\n                          onClick: togglePostVisibility,\n                        },\n                      ]}\n                      buttonContent={<DotsHorizontalIcon className=\"h-5 w-5\" />}\n                      buttonClass=\"p-2\"\n                      menuWidth=\"w-40\"\n                    />\n                  )}\n              </Row>\n            </Col>\n\n            <Row className=\"border-canvas-50 items-center justify-between gap-4 border-b py-4\">\n              <UserAvatarAndBadge user={creator} />\n              <span className=\"text-ink-700\">\n                {new Date(post.createdTime).toLocaleDateString('en-US', {\n                  year: 'numeric',\n                  month: 'short',\n                  day: 'numeric',\n                })}\n              </span>\n            </Row>\n          </Col>\n        )}\n        <div className=\"bg-canvas-0 rounded-lg px-6 py-4 sm:py-0\">\n          <div className=\"flex w-full flex-col py-2\">\n            <RichEditPost\n              post={post}\n              onUpdate={setPost}\n              editing={editing}\n              setEditing={setEditing}\n            />\n          </div>\n        </div>\n        <Spacer h={4} />\n        <PostCommentsActivity post={post} comments={comments} />\n      </Col>\n    </Page>\n  )\n}\n\nfunction RichEditPost(props: {\n  post: TopLevelPost\n  children?: React.ReactNode\n  onUpdate?: (post: TopLevelPost) => void\n  editing: boolean\n  setEditing: (isEditing: boolean) => void\n}) {\n  const { post, children, onUpdate, editing, setEditing } = props\n  const user = useUser()\n  const canEdit = user?.id === post.creatorId\n  const [editableTitle, setEditableTitle] = useState(post.title)\n\n  const editor = useTextEditor({\n    defaultValue: post.content,\n    key: `post ${post?.id || ''}`,\n    size: 'lg',\n  })\n\n  return editing ? (\n    <>\n      <ExpandingInput\n        value={editableTitle}\n        onChange={(e) => setEditableTitle(e.target.value || '')}\n        placeholder=\"Post title\"\n        className=\"mb-2 text-2xl font-bold\"\n      />\n      <TextEditor editor={editor} />\n      <Spacer h={2} />\n      <Row className=\"gap-2\">\n        <Button\n          color=\"gray\"\n          onClick={() => {\n            setEditing(false)\n            setEditableTitle(post.title)\n            editor?.commands.focus('end')\n          }}\n        >\n          Cancel\n        </Button>\n        <Button\n          onClick={async () => {\n            if (!editor) return\n            const { post: updatedPost } = await api('update-post', {\n              id: post.id,\n              title: editableTitle,\n              content: editor.getJSON(),\n            })\n            onUpdate?.(updatedPost)\n            setEditing(false)\n          }}\n        >\n          Save\n        </Button>\n      </Row>\n    </>\n  ) : (\n    <Col className=\"gap-2\">\n      <Content size=\"lg\" content={post.content} />\n      {canEdit && (\n        <Row className=\"place-content-end\">\n          <Button\n            color=\"gray-white\"\n            size=\"xs\"\n            onClick={() => {\n              setEditableTitle(post.title)\n              setEditing(true)\n              editor?.commands.focus('end')\n            }}\n          >\n            <PencilIcon className=\"inline h-4 w-4\" />\n          </Button>\n          {children}\n        </Row>\n      )}\n    </Col>\n  )\n}\n",
          "postContent": "import { Page } from 'web/components/layout/page'\nimport { Spacer } from 'web/components/layout/spacer'\nimport {\n  Content,\n  TextEditor,\n  useTextEditor,\n} from 'web/components/widgets/editor'\nimport {\n  EyeOffIcon,\n  PencilIcon,\n  DotsHorizontalIcon,\n} from '@heroicons/react/solid'\nimport { Button } from 'web/components/buttons/button'\nimport { useState, useEffect } from 'react'\nimport { Row } from 'web/components/layout/row'\nimport { Col } from 'web/components/layout/col'\nimport Custom404 from 'web/pages/404'\nimport { UserAvatarAndBadge } from 'web/components/widgets/user-link'\nimport { SEO } from 'web/components/SEO'\nimport { richTextToString } from 'common/util/parse'\nimport { CopyLinkOrShareButton } from 'web/components/buttons/copy-link-button'\nimport { DisplayUser, getUserById } from 'web/lib/supabase/users'\nimport { getPostShareUrl, TopLevelPost } from 'common/src/top-level-post'\nimport { useUser } from 'web/hooks/use-user'\nimport { api } from 'web/lib/api/api'\nimport { getCommentsOnPost } from 'web/lib/supabase/comments'\nimport { PostComment } from 'common/comment'\nimport {\n  PostCommentsActivity,\n  useNewPostComments,\n} from 'web/components/top-level-posts/post-comments'\nimport { ExpandingInput } from 'web/components/widgets/expanding-input'\nimport { useAdminOrMod } from 'web/hooks/use-admin'\nimport toast from 'react-hot-toast'\nimport { ReactButton } from 'web/components/contract/react-button'\nimport { getPostBySlug } from 'web/lib/supabase/posts'\nimport { useSaveReferral } from 'web/hooks/use-save-referral'\nimport DropdownMenu from 'web/components/widgets/dropdown-menu'\nimport { BackButton } from 'web/components/contract/back-button'\nimport { report as reportContent } from 'web/lib/api/api'\nimport { IoWarning } from 'react-icons/io5'\n\nexport async function getStaticProps(props: { params: { slug: string } }) {\n  const { slug } = props.params\n\n  const postData = await getPostBySlug(slug)\n  const creator = postData ? await getUserById(postData.creatorId) : null\n  const comments = postData ? await getCommentsOnPost(postData.id) : []\n  const watched: string[] = []\n  const skipped: string[] = []\n\n  return {\n    props: {\n      post: postData,\n      creator,\n      comments,\n      watched,\n      skipped,\n    },\n\n    revalidate: 60, // regenerate after a minute\n  }\n}\n\nexport async function getStaticPaths() {\n  return { paths: [], fallback: 'blocking' }\n}\n\nexport default function PostPage(props: {\n  post: TopLevelPost | null\n  creator: DisplayUser | null\n  comments: PostComment[]\n  watched?: string[] //user ids\n  skipped?: string[] //user ids\n}) {\n  const { creator } = props\n  const { comments: newComments } = useNewPostComments(props.post?.id ?? '_')\n  const comments = [...newComments, ...props.comments]\n  const [post, setPost] = useState(props.post)\n  const isAdminOrMod = useAdminOrMod()\n  const [editing, setEditing] = useState(false)\n  const currentUser = useUser()\n  useSaveReferral(currentUser, {\n    defaultReferrerUsername: post?.creatorUsername,\n  })\n\n  useEffect(() => {\n    setPost(props.post)\n  }, [props.post])\n\n  if (!post || !creator) {\n    return <Custom404 />\n  }\n  const shareUrl = getPostShareUrl(post, currentUser?.username)\n\n  const handleReact = () => {\n    if (!currentUser || !post) return\n    setPost((prevPost) => {\n      if (!prevPost) return null\n      const newLikedByUserIds = [\n        ...(prevPost.likedByUserIds ?? []),\n        currentUser.id,\n      ]\n      return {\n        ...prevPost,\n        likedByUserCount: (prevPost.likedByUserCount ?? 0) + 1,\n        likedByUserIds: newLikedByUserIds,\n      }\n    })\n  }\n\n  const handleUnreact = () => {\n    if (!currentUser || !post) return\n    setPost((prevPost) => {\n      if (!prevPost) return null\n      const newLikedByUserIds =\n        prevPost.likedByUserIds?.filter((id) => id !== currentUser.id) ?? []\n      return {\n        ...prevPost,\n        likedByUserCount: Math.max(0, (prevPost.likedByUserCount ?? 0) - 1),\n        likedByUserIds: newLikedByUserIds,\n      }\n    })\n  }\n\n  const togglePostVisibility = async () => {\n    if (!post) return\n    const newVisibility = post.visibility === 'unlisted' ? 'public' : 'unlisted'\n    try {\n      await api('update-post', {\n        id: post.id,\n        visibility: newVisibility,\n      })\n      setPost((prevPost) =>\n        prevPost ? { ...prevPost, visibility: newVisibility } : null\n      )\n      toast.success(\n        `Post successfully made ${\n          newVisibility === 'public' ? 'public' : 'unlisted'\n        }.`\n      )\n    } catch (error) {\n      console.error('Error updating post visibility:', error)\n      toast.error(\n        `Failed to update post visibility. ${\n          error instanceof Error ? error.message : ''\n        }`\n      )\n    } finally {\n    }\n  }\n\n  return (\n    <Page trackPageView={'post slug page'}>\n      <SEO\n        title={post.title}\n        description={richTextToString(post.content)}\n        url={'/post/' + post.slug}\n        shouldIgnore={post.visibility === 'unlisted'}\n      />\n      <Col className=\"mx-auto w-full max-w-2xl p-4\">\n        {!editing && (\n          <Col>\n            <Row>\n              <BackButton className=\"!p-0\" />\n            </Row>\n            <Col className=\"border-canvas-50 pt-4\">\n              <Row className=\" items-center justify-between gap-1 text-2xl font-bold\">\n                <span>\n                  {post.title}{' '}\n                  {post.visibility === 'unlisted' && (\n                    <EyeOffIcon className=\"inline-block h-4 w-4\" />\n                  )}\n                </span>\n              </Row>\n              <Row className=\"mt-3 items-center gap-2 \">\n                <CopyLinkOrShareButton\n                  tooltip=\"Copy link to post\"\n                  url={shareUrl}\n                  eventTrackingName={'copy post link'}\n                />\n                {post && (\n                  <ReactButton\n                    contentId={post.id}\n                    contentCreatorId={post.creatorId}\n                    user={currentUser}\n                    contentType={'post'}\n                    contentText={post.title}\n                    trackingLocation={'post page'}\n                    reactionType={'like'}\n                    size={'sm'}\n                    userReactedWith={\n                      currentUser &&\n                      post.likedByUserIds?.includes(currentUser.id)\n                        ? 'like'\n                        : 'none'\n                    }\n                    onReact={handleReact}\n                    onUnreact={handleUnreact}\n                  />\n                )}\n                {(isAdminOrMod || post.creatorId === currentUser?.id) &&\n                  post && (\n                    <DropdownMenu\n                      items={[\n                        {\n                          name:\n                            post.visibility === 'unlisted'\n                              ? 'Make Public'\n                              : 'Make Unlisted',\n                          icon:\n                            post.visibility === 'unlisted' ? (\n                              <EyeOffIcon className=\"h-5 w-5\" />\n                            ) : (\n                              <EyeOffIcon className=\"h-5 w-5\" />\n                            ),\n                          onClick: togglePostVisibility,\n                        },\n                        {\n                          name: 'Report',\n                          icon: <IoWarning className=\"h-5 w-5\" />,\n                          onClick: async () => {\n                            await toast.promise(\n                              reportContent({\n                                contentId: post.id,\n                                contentType: 'post',\n                                contentOwnerId: post.creatorId,\n                              }),\n                              {\n                                loading: 'Reporting...',\n                                success: `Post reported! Admins will take a look within 24 hours.`,\n                                error: `Error reporting post`,\n                              }\n                            )\n                          },\n                        },\n                      ]}\n                      buttonContent={<DotsHorizontalIcon className=\"h-5 w-5\" />}\n                      buttonClass=\"p-2\"\n                      menuWidth=\"w-40\"\n                    />\n                  )}\n              </Row>\n            </Col>\n\n            <Row className=\"border-canvas-50 items-center justify-between gap-4 border-b py-4\">\n              <UserAvatarAndBadge user={creator} />\n              <span className=\"text-ink-700\">\n                {new Date(post.createdTime).toLocaleDateString('en-US', {\n                  year: 'numeric',\n                  month: 'short',\n                  day: 'numeric',\n                })}\n              </span>\n            </Row>\n          </Col>\n        )}\n        <div className=\"bg-canvas-0 rounded-lg px-6 py-4 sm:py-0\">\n          <div className=\"flex w-full flex-col py-2\">\n            <RichEditPost\n              post={post}\n              onUpdate={setPost}\n              editing={editing}\n              setEditing={setEditing}\n            />\n          </div>\n        </div>\n        <Spacer h={4} />\n        <PostCommentsActivity post={post} comments={comments} />\n      </Col>\n    </Page>\n  )\n}\n\nfunction RichEditPost(props: {\n  post: TopLevelPost\n  children?: React.ReactNode\n  onUpdate?: (post: TopLevelPost) => void\n  editing: boolean\n  setEditing: (isEditing: boolean) => void\n}) {\n  const { post, children, onUpdate, editing, setEditing } = props\n  const user = useUser()\n  const canEdit = user?.id === post.creatorId\n  const [editableTitle, setEditableTitle] = useState(post.title)\n\n  const editor = useTextEditor({\n    defaultValue: post.content,\n    key: `post ${post?.id || ''}`,\n    size: 'lg',\n  })\n\n  return editing ? (\n    <>\n      <ExpandingInput\n        value={editableTitle}\n        onChange={(e) => setEditableTitle(e.target.value || '')}\n        placeholder=\"Post title\"\n        className=\"mb-2 text-2xl font-bold\"\n      />\n      <TextEditor editor={editor} />\n      <Spacer h={2} />\n      <Row className=\"gap-2\">\n        <Button\n          color=\"gray\"\n          onClick={() => {\n            setEditing(false)\n            setEditableTitle(post.title)\n            editor?.commands.focus('end')\n          }}\n        >\n          Cancel\n        </Button>\n        <Button\n          onClick={async () => {\n            if (!editor) return\n            const { post: updatedPost } = await api('update-post', {\n              id: post.id,\n              title: editableTitle,\n              content: editor.getJSON(),\n            })\n            onUpdate?.(updatedPost)\n            setEditing(false)\n          }}\n        >\n          Save\n        </Button>\n      </Row>\n    </>\n  ) : (\n    <Col className=\"gap-2\">\n      <Content size=\"lg\" content={post.content} />\n      {canEdit && (\n        <Row className=\"place-content-end\">\n          <Button\n            color=\"gray-white\"\n            size=\"xs\"\n            onClick={() => {\n              setEditableTitle(post.title)\n              setEditing(true)\n              editor?.commands.focus('end')\n            }}\n          >\n            <PencilIcon className=\"inline h-4 w-4\" />\n          </Button>\n          {children}\n        </Row>\n      )}\n    </Col>\n  )\n}\n"
        }
      ]
    },
    {
      "sha": "4b22792501aa09964f64af2c1a0d4ed5f84980de",
      "author": "Ian Philips",
      "date": "2025-05-07 16:01:04 -0700",
      "message": "Add read voter identity as creator-only polls",
      "stats": {
        "filesChanged": 8,
        "insertions": 128,
        "deletions": 32
      },
      "selectionReason": "Adds voter identity reading for creator-only polls - implements privacy controls and permission-based features",
      "spec": "Implement a feature for polls that allows the creator to control who can see the list of voters for each poll option. When creating a poll, provide an option to set 'voter visibility' to either 'Everyone' (default) or 'Creator only'. If 'Everyone' is selected, any authenticated user can see the list of voters for each option. If 'Creator only' is selected, only the user who created the poll can see the list of voters; other users will be restricted from viewing this information and should see a message indicating that voter identities are private. API endpoints for retrieving poll voters must now require authentication and enforce these visibility rules, returning an error if an unauthorized user attempts to access voter lists for a 'Creator only' poll.",
      "fileStates": [
        {
          "path": "backend/api/src/create-market.ts",
          "preContent": "import { onCreateMarket } from 'api/helpers/on-create-market'\nimport {\n  createBinarySchema,\n  createBountySchema,\n  createNumberSchema,\n  createMultiSchema,\n  createNumericSchema,\n  createPollSchema,\n  toLiteMarket,\n  createMultiNumericSchema,\n  createMultiDateSchema,\n} from 'common/api/market-types'\nimport { ValidatedAPIParams } from 'common/api/schema'\nimport {\n  Contract,\n  NO_CLOSE_TIME_TYPES,\n  OutcomeType,\n  add_answers_mode,\n  contractUrl,\n  nativeContractColumnsArray,\n  NUMBER_CREATION_ENABLED,\n} from 'common/contract'\nimport { getAnte } from 'common/economy'\nimport { MAX_GROUPS_PER_MARKET } from 'common/group'\nimport { getNewContract } from 'common/new-contract'\nimport { getPseudoProbability } from 'common/pseudo-numeric'\nimport { STONK_INITIAL_PROB } from 'common/stonk'\nimport { removeUndefinedProps } from 'common/util/object'\nimport { randomString } from 'common/util/random'\nimport { slugify } from 'common/util/slugify'\nimport { getCloseDate } from 'shared/helpers/ai-close-date'\nimport {\n  generateContractEmbeddings,\n  getContractsDirect,\n} from 'shared/supabase/contracts'\nimport {\n  SupabaseDirectClient,\n  createSupabaseDirectClient,\n  pgp,\n} from 'shared/supabase/init'\nimport { anythingToRichText } from 'shared/tiptap'\nimport { runTxnOutsideBetQueue } from 'shared/txn/run-txn'\nimport {\n  addGroupToContract,\n  canUserAddGroupToMarket,\n} from 'shared/update-group-contracts-internal'\nimport { contractColumnsToSelect, htmlToRichText, log } from 'shared/utils'\nimport {\n  broadcastNewAnswer,\n  broadcastNewContract,\n} from 'shared/websockets/helpers'\nimport { APIError, AuthedUser, type APIHandler } from './helpers/endpoint'\nimport { Row } from 'common/supabase/utils'\nimport { bulkInsertQuery } from 'shared/supabase/utils'\nimport { z } from 'zod'\nimport { answerToRow } from 'shared/supabase/answers'\nimport { convertAnswer } from 'common/supabase/contracts'\nimport { generateAntes } from 'shared/create-contract-helpers'\nimport { betsQueue } from 'shared/helpers/fn-queue'\nimport { convertUser } from 'common/supabase/users'\nimport { camelCase, first } from 'lodash'\nimport { getMultiNumericAnswerBucketRangeNames } from 'common/number'\ntype Body = ValidatedAPIParams<'market'>\n\nexport const createMarket: APIHandler<'market'> = async (body, auth) => {\n  const pg = createSupabaseDirectClient()\n  const { groupIds } = body\n  const groups = groupIds\n    ? await Promise.all(\n        groupIds.map(async (gId) => getGroupCheckPermissions(pg, gId, auth.uid))\n      )\n    : null\n\n  const { contract: market, user } = await createMarketHelper(body, auth)\n  // TODO upload answer images to GCP if provided\n  if (groups) {\n    await Promise.allSettled(\n      groups.map(async (g) => {\n        await addGroupToContract(pg, market, g)\n      })\n    )\n  }\n  // Should have the embedding ready for the related contracts cache\n  return {\n    result: toLiteMarket(market),\n    continue: async () => {\n      const embedding = await generateContractEmbeddings(market, pg).catch(\n        (e) =>\n          log.error(`Failed to generate embeddings, returning ${market.id} `, e)\n      )\n      broadcastNewContract(market, user)\n      if ('answers' in market) {\n        market.answers.forEach(broadcastNewAnswer)\n      }\n      await onCreateMarket(market, embedding)\n    },\n  }\n}\n\nexport async function createMarketHelper(body: Body, auth: AuthedUser) {\n  const {\n    question,\n    description,\n    descriptionHtml,\n    descriptionMarkdown,\n    descriptionJson,\n    closeTime: closeTimeRaw,\n    outcomeType,\n    extraLiquidity,\n    isTwitchContract,\n    utcOffset,\n    min,\n    max,\n    initialProb,\n    isLogScale,\n    answers,\n    addAnswersMode,\n    shouldAnswersSumToOne,\n    totalBounty,\n    isAutoBounty,\n    visibility,\n    idempotencyKey,\n    sportsStartTimestamp,\n    sportsEventId,\n    sportsLeague,\n    answerShortTexts,\n    answerImageUrls,\n    takerAPIOrdersDisabled,\n    liquidityTier,\n    unit,\n    midpoints,\n    timezone,\n  } = validateMarketBody(body)\n\n  const userId = auth.uid\n\n  const pg = createSupabaseDirectClient()\n\n  const hasOtherAnswer = addAnswersMode !== 'DISABLED' && shouldAnswersSumToOne\n  const numAnswers = (answers?.length ?? 0) + (hasOtherAnswer ? 1 : 0)\n\n  const ante =\n    outcomeType === 'BOUNTIED_QUESTION' && totalBounty\n      ? totalBounty\n      : getAnte(outcomeType, numAnswers, liquidityTier)\n  const totalMarketCost = ante + (extraLiquidity ?? 0)\n  if (ante < 1) throw new APIError(400, 'Ante must be at least 1')\n\n  const closeTime = await getCloseTimestamp(\n    closeTimeRaw,\n    question,\n    outcomeType,\n    utcOffset\n  )\n\n  if (closeTime && closeTime < Date.now())\n    throw new APIError(400, 'Question must close in the future')\n\n  const duplicateSubmissionUrl = await getDuplicateSubmissionUrl(\n    idempotencyKey,\n    pg\n  )\n  if (duplicateSubmissionUrl) {\n    throw new APIError(\n      400,\n      'Contract has already been created at ' + duplicateSubmissionUrl\n    )\n  }\n\n  return await betsQueue.enqueueFn(async () => {\n    return pg.tx(async (tx) => {\n      const proposedSlug = slugify(question)\n\n      const userAndSlugResult = await tx.multi(\n        `select * from users where id = $1 limit 1;\n        select 1 from contracts where slug = $2 limit 1;`,\n        [userId, proposedSlug]\n      )\n      const user = first(userAndSlugResult[0].map(convertUser))\n      if (!user) throw new APIError(401, 'Your account was not found')\n      if (user.isBannedFromPosting) throw new APIError(403, 'You are banned')\n\n      if (totalMarketCost > user.balance)\n        throw new APIError(403, `Balance must be at least ${totalMarketCost}.`)\n\n      const slug = getSlug(!!first(userAndSlugResult[1]), proposedSlug)\n\n      const contract = getNewContract(\n        removeUndefinedProps({\n          id: idempotencyKey ?? randomString(),\n          slug,\n          creator: user,\n          question,\n          outcomeType,\n          description:\n            typeof description !== 'string' && description\n              ? description\n              : anythingToRichText({\n                  raw: description,\n                  html: descriptionHtml,\n                  markdown: descriptionMarkdown,\n                  jsonString: descriptionJson,\n                  // default: use a single empty space as the description\n                }) ?? htmlToRichText(`<p> </p>`),\n          initialProb: initialProb ?? 50,\n          ante,\n          closeTime,\n          visibility,\n          isTwitchContract,\n          min: min ?? 0,\n          max: max ?? 0,\n          isLogScale: isLogScale ?? false,\n          answers: answers ?? [],\n          answerShortTexts,\n          answerImageUrls,\n          addAnswersMode,\n          shouldAnswersSumToOne,\n          isAutoBounty,\n          token: 'MANA',\n          sportsStartTimestamp,\n          sportsEventId,\n          sportsLeague,\n          takerAPIOrdersDisabled,\n          unit: unit ?? '',\n          midpoints: midpoints,\n          timezone: timezone,\n        })\n      )\n      const nativeKeys = nativeContractColumnsArray.map(camelCase)\n      const nativeValues = nativeKeys\n        .filter((col) => col in contract)\n        .map((col) => contract[col as keyof Contract])\n\n      const contractDataToInsert = Object.fromEntries(\n        Object.entries(contract).filter(([key]) => !nativeKeys.includes(key))\n      )\n      const insertAnswersQuery =\n        contract.mechanism === 'cpmm-multi-1'\n          ? bulkInsertQuery('answers', contract.answers.map(answerToRow), true)\n          : 'select 1 where false'\n      const contractQuery = pgp.as.format(\n        `insert into contracts \n        (id, ${contractColumnsToSelect})\n         values ($1, $2, ${nativeValues.map((_, i) => `$${i + 3}`)});`,\n        [contract.id, JSON.stringify(contractDataToInsert), ...nativeValues]\n      )\n      const result = await tx.multi(\n        `${contractQuery};\n       ${insertAnswersQuery};`\n      )\n\n      if (result[1].length > 0 && contract.mechanism === 'cpmm-multi-1') {\n        contract.answers = result[1].map(convertAnswer)\n      }\n      await runTxnOutsideBetQueue(tx, {\n        fromId: userId,\n        fromType: 'USER',\n        toId: contract.id,\n        toType: 'CONTRACT',\n        amount: ante,\n        token: 'M$',\n        category: 'CREATE_CONTRACT_ANTE',\n      })\n\n      log('created contract ', {\n        userUserName: user.username,\n        userId: user.id,\n        question,\n        ante: ante || 0,\n      })\n\n      await generateAntes(\n        tx,\n        userId,\n        contract,\n        outcomeType,\n        ante,\n        totalMarketCost\n      )\n\n      return { contract, user }\n    })\n  }, [userId])\n}\n\nasync function getDuplicateSubmissionUrl(\n  idempotencyKey: string | undefined,\n  pg: SupabaseDirectClient\n): Promise<string | undefined> {\n  if (!idempotencyKey) return undefined\n  const contracts = await getContractsDirect([idempotencyKey], pg)\n  if (contracts.length > 0) {\n    return contractUrl(contracts[0])\n  }\n  return undefined\n}\n\nasync function getCloseTimestamp(\n  closeTime: number | Date | undefined,\n  question: string,\n  outcomeType: OutcomeType,\n  utcOffset?: number\n): Promise<number | undefined> {\n  return closeTime\n    ? typeof closeTime === 'number'\n      ? closeTime\n      : closeTime.getTime()\n    : NO_CLOSE_TIME_TYPES.includes(outcomeType)\n    ? closeTime\n    : (await getCloseDate(question, utcOffset)) ??\n      Date.now() + 7 * 24 * 60 * 60 * 1000\n}\n\nconst getSlug = (preexistingContract: boolean, proposedSlug: string) => {\n  return preexistingContract\n    ? proposedSlug + '-' + randomString()\n    : proposedSlug\n}\n\nfunction validateMarketBody(body: Body) {\n  const {\n    question,\n    description,\n    descriptionHtml,\n    descriptionMarkdown,\n    descriptionJson,\n    closeTime,\n    outcomeType,\n    groupIds,\n    visibility = 'public',\n    isTwitchContract,\n    utcOffset,\n    extraLiquidity,\n    liquidityTier,\n    idempotencyKey,\n    sportsStartTimestamp,\n    sportsEventId,\n    sportsLeague,\n    takerAPIOrdersDisabled,\n  } = body\n\n  if (groupIds && groupIds.length > MAX_GROUPS_PER_MARKET)\n    throw new APIError(\n      400,\n      `You may only tag up to ${MAX_GROUPS_PER_MARKET} topics on a question`\n    )\n\n  let min: number | undefined,\n    max: number | undefined,\n    initialProb: number | undefined,\n    isLogScale: boolean | undefined,\n    answers: string[] | undefined,\n    answerShortTexts: string[] | undefined,\n    answerImageUrls: string[] | undefined,\n    addAnswersMode: add_answers_mode | undefined,\n    shouldAnswersSumToOne: boolean | undefined,\n    totalBounty: number | undefined,\n    isAutoBounty: boolean | undefined,\n    unit: string | undefined,\n    midpoints: number[] | undefined,\n    timezone: string | undefined\n\n  if (outcomeType === 'PSEUDO_NUMERIC') {\n    const parsed = validateMarketType(outcomeType, createNumericSchema, body)\n\n    ;({ min, max, isLogScale } = parsed)\n    const { initialValue } = parsed\n\n    if (max - min <= 0.01)\n      throw new APIError(400, 'Max must be greater than min by more than 0.01')\n    if (initialValue <= min || initialValue >= max)\n      throw new APIError(400, 'Invalid range.')\n\n    initialProb = getPseudoProbability(initialValue, min, max, isLogScale) * 100\n\n    if (initialProb < 1 || initialProb > 99)\n      if (outcomeType === 'PSEUDO_NUMERIC')\n        throw new APIError(\n          400,\n          `Initial value is too ${initialProb < 1 ? 'low' : 'high'}`\n        )\n      else throw new APIError(400, 'Invalid initial probability.')\n  }\n  if (outcomeType === 'STONK') {\n    initialProb = STONK_INITIAL_PROB\n  }\n\n  if (outcomeType === 'BINARY') {\n    const parsed = validateMarketType(outcomeType, createBinarySchema, body)\n\n    ;({ initialProb } = parsed)\n  }\n  if (outcomeType === 'NUMBER') {\n    if (!NUMBER_CREATION_ENABLED)\n      throw new APIError(\n        400,\n        'Creating numeric markets is not currently enabled.'\n      )\n    ;({ min, max } = validateMarketType(outcomeType, createNumberSchema, body))\n    if (min >= max)\n      throw new APIError(400, 'Numeric markets must have min < max.')\n    const { precision } = validateMarketType(\n      outcomeType,\n      createNumberSchema,\n      body\n    )\n    answers = getMultiNumericAnswerBucketRangeNames(min, max, precision)\n    if (answers.length < 2)\n      throw new APIError(\n        400,\n        'Numeric markets must have at least 2 answer buckets.'\n      )\n  }\n  if (outcomeType === 'MULTI_NUMERIC') {\n    ;({ answers, midpoints, unit, shouldAnswersSumToOne } = validateMarketType(\n      outcomeType,\n      createMultiNumericSchema,\n      body\n    ))\n    if (answers.length < 2)\n      throw new APIError(\n        400,\n        'Numeric markets must have at least 2 answer buckets.'\n      )\n    if (answers.length !== midpoints.length)\n      throw new APIError(\n        400,\n        'Number of answers must match number of midpoints.'\n      )\n  }\n  if (outcomeType === 'DATE') {\n    ;({ answers, midpoints, shouldAnswersSumToOne, timezone } =\n      validateMarketType(outcomeType, createMultiDateSchema, body))\n    if (answers.length < 2)\n      throw new APIError(\n        400,\n        'Numeric markets must have at least 2 answer buckets.'\n      )\n    if (answers.length !== midpoints.length)\n      throw new APIError(\n        400,\n        'Number of answers must match number of midpoints.'\n      )\n  }\n\n  if (outcomeType === 'MULTIPLE_CHOICE') {\n    ;({\n      answers,\n      answerShortTexts,\n      answerImageUrls,\n      addAnswersMode,\n      shouldAnswersSumToOne,\n    } = validateMarketType(outcomeType, createMultiSchema, body))\n    if (answers.length < 2 && addAnswersMode === 'DISABLED')\n      throw new APIError(\n        400,\n        'Multiple choice markets must have at least 2 answers if adding answers is disabled.'\n      )\n  }\n\n  if (outcomeType === 'BOUNTIED_QUESTION') {\n    ;({ totalBounty, isAutoBounty } = validateMarketType(\n      outcomeType,\n      createBountySchema,\n      body\n    ))\n  }\n\n  if (outcomeType === 'POLL') {\n    ;({ answers } = validateMarketType(outcomeType, createPollSchema, body))\n  }\n\n  return {\n    question,\n    description,\n    descriptionHtml,\n    descriptionMarkdown,\n    descriptionJson,\n    closeTime,\n    outcomeType,\n    groupIds,\n    visibility,\n    extraLiquidity,\n    isTwitchContract,\n    utcOffset,\n    min,\n    max,\n    initialProb,\n    isLogScale,\n    answers,\n    addAnswersMode,\n    shouldAnswersSumToOne,\n    totalBounty,\n    isAutoBounty,\n    liquidityTier,\n    idempotencyKey,\n    sportsStartTimestamp,\n    sportsEventId,\n    sportsLeague,\n    answerShortTexts,\n    answerImageUrls,\n    takerAPIOrdersDisabled,\n    unit,\n    midpoints,\n    timezone,\n  }\n}\n\nfunction validateMarketType<T extends z.ZodType>(\n  outcome: string,\n  schema: T,\n  val: unknown\n) {\n  const result = schema.safeParse(val)\n  if (result.success) return result.data as z.infer<T>\n  throw new APIError(\n    400,\n    `Wrong props for ${outcome} question.`,\n    result.error.message\n  )\n}\n\nasync function getGroupCheckPermissions(\n  pg: SupabaseDirectClient,\n  groupId: string,\n  userId: string\n) {\n  const result = await pg.oneOrNone<\n    Row<'groups'> & { member_role: string | null }\n  >(\n    `\n    select g.*, gm.role as member_role\n    from groups g\n    left join group_members gm on g.id = gm.group_id and gm.member_id = $2\n    where g.id = $1\n  `,\n    [groupId, userId]\n  )\n\n  if (!result) {\n    throw new APIError(404, 'No group exists with the given group ID.')\n  }\n\n  const { member_role, ...group } = result\n  const membership = member_role\n    ? {\n        role: member_role,\n        group_id: group.id,\n        member_id: userId,\n        created_time: null,\n      }\n    : undefined\n\n  if (\n    !canUserAddGroupToMarket({\n      userId,\n      group,\n      membership,\n    })\n  ) {\n    throw new APIError(\n      403,\n      `User does not have permission to add this market to group \"${group.name}\".`\n    )\n  }\n\n  return group\n}\n",
          "postContent": "import { onCreateMarket } from 'api/helpers/on-create-market'\nimport {\n  createBinarySchema,\n  createBountySchema,\n  createNumberSchema,\n  createMultiSchema,\n  createNumericSchema,\n  createPollSchema,\n  toLiteMarket,\n  createMultiNumericSchema,\n  createMultiDateSchema,\n} from 'common/api/market-types'\nimport { ValidatedAPIParams } from 'common/api/schema'\nimport {\n  Contract,\n  NO_CLOSE_TIME_TYPES,\n  OutcomeType,\n  add_answers_mode,\n  contractUrl,\n  nativeContractColumnsArray,\n  NUMBER_CREATION_ENABLED,\n  PollVoterVisibility,\n} from 'common/contract'\nimport { getAnte } from 'common/economy'\nimport { MAX_GROUPS_PER_MARKET } from 'common/group'\nimport { getNewContract } from 'common/new-contract'\nimport { getPseudoProbability } from 'common/pseudo-numeric'\nimport { STONK_INITIAL_PROB } from 'common/stonk'\nimport { removeUndefinedProps } from 'common/util/object'\nimport { randomString } from 'common/util/random'\nimport { slugify } from 'common/util/slugify'\nimport { getCloseDate } from 'shared/helpers/ai-close-date'\nimport {\n  generateContractEmbeddings,\n  getContractsDirect,\n} from 'shared/supabase/contracts'\nimport {\n  SupabaseDirectClient,\n  createSupabaseDirectClient,\n  pgp,\n} from 'shared/supabase/init'\nimport { anythingToRichText } from 'shared/tiptap'\nimport { runTxnOutsideBetQueue } from 'shared/txn/run-txn'\nimport {\n  addGroupToContract,\n  canUserAddGroupToMarket,\n} from 'shared/update-group-contracts-internal'\nimport { contractColumnsToSelect, htmlToRichText, log } from 'shared/utils'\nimport {\n  broadcastNewAnswer,\n  broadcastNewContract,\n} from 'shared/websockets/helpers'\nimport { APIError, AuthedUser, type APIHandler } from './helpers/endpoint'\nimport { Row } from 'common/supabase/utils'\nimport { bulkInsertQuery } from 'shared/supabase/utils'\nimport { z } from 'zod'\nimport { answerToRow } from 'shared/supabase/answers'\nimport { convertAnswer } from 'common/supabase/contracts'\nimport { generateAntes } from 'shared/create-contract-helpers'\nimport { betsQueue } from 'shared/helpers/fn-queue'\nimport { convertUser } from 'common/supabase/users'\nimport { camelCase, first } from 'lodash'\nimport { getMultiNumericAnswerBucketRangeNames } from 'common/number'\ntype Body = ValidatedAPIParams<'market'>\n\nexport const createMarket: APIHandler<'market'> = async (body, auth) => {\n  const pg = createSupabaseDirectClient()\n  const { groupIds } = body\n  const groups = groupIds\n    ? await Promise.all(\n        groupIds.map(async (gId) => getGroupCheckPermissions(pg, gId, auth.uid))\n      )\n    : null\n\n  const { contract: market, user } = await createMarketHelper(body, auth)\n  // TODO upload answer images to GCP if provided\n  if (groups) {\n    await Promise.allSettled(\n      groups.map(async (g) => {\n        await addGroupToContract(pg, market, g)\n      })\n    )\n  }\n  // Should have the embedding ready for the related contracts cache\n  return {\n    result: toLiteMarket(market),\n    continue: async () => {\n      const embedding = await generateContractEmbeddings(market, pg).catch(\n        (e) =>\n          log.error(`Failed to generate embeddings, returning ${market.id} `, e)\n      )\n      broadcastNewContract(market, user)\n      if ('answers' in market) {\n        market.answers.forEach(broadcastNewAnswer)\n      }\n      await onCreateMarket(market, embedding)\n    },\n  }\n}\n\nexport async function createMarketHelper(body: Body, auth: AuthedUser) {\n  const {\n    question,\n    description,\n    descriptionHtml,\n    descriptionMarkdown,\n    descriptionJson,\n    closeTime: closeTimeRaw,\n    outcomeType,\n    extraLiquidity,\n    isTwitchContract,\n    utcOffset,\n    min,\n    max,\n    initialProb,\n    isLogScale,\n    answers,\n    addAnswersMode,\n    shouldAnswersSumToOne,\n    totalBounty,\n    isAutoBounty,\n    visibility,\n    idempotencyKey,\n    sportsStartTimestamp,\n    sportsEventId,\n    sportsLeague,\n    answerShortTexts,\n    answerImageUrls,\n    takerAPIOrdersDisabled,\n    liquidityTier,\n    unit,\n    midpoints,\n    timezone,\n    voterVisibility,\n  } = validateMarketBody(body)\n\n  const userId = auth.uid\n\n  const pg = createSupabaseDirectClient()\n\n  const hasOtherAnswer = addAnswersMode !== 'DISABLED' && shouldAnswersSumToOne\n  const numAnswers = (answers?.length ?? 0) + (hasOtherAnswer ? 1 : 0)\n\n  const ante =\n    outcomeType === 'BOUNTIED_QUESTION' && totalBounty\n      ? totalBounty\n      : getAnte(outcomeType, numAnswers, liquidityTier)\n  const totalMarketCost = ante + (extraLiquidity ?? 0)\n  if (ante < 1) throw new APIError(400, 'Ante must be at least 1')\n\n  const closeTime = await getCloseTimestamp(\n    closeTimeRaw,\n    question,\n    outcomeType,\n    utcOffset\n  )\n\n  if (closeTime && closeTime < Date.now())\n    throw new APIError(400, 'Question must close in the future')\n\n  const duplicateSubmissionUrl = await getDuplicateSubmissionUrl(\n    idempotencyKey,\n    pg\n  )\n  if (duplicateSubmissionUrl) {\n    throw new APIError(\n      400,\n      'Contract has already been created at ' + duplicateSubmissionUrl\n    )\n  }\n\n  return await betsQueue.enqueueFn(async () => {\n    return pg.tx(async (tx) => {\n      const proposedSlug = slugify(question)\n\n      const userAndSlugResult = await tx.multi(\n        `select * from users where id = $1 limit 1;\n        select 1 from contracts where slug = $2 limit 1;`,\n        [userId, proposedSlug]\n      )\n      const user = first(userAndSlugResult[0].map(convertUser))\n      if (!user) throw new APIError(401, 'Your account was not found')\n      if (user.isBannedFromPosting) throw new APIError(403, 'You are banned')\n\n      if (totalMarketCost > user.balance)\n        throw new APIError(403, `Balance must be at least ${totalMarketCost}.`)\n\n      const slug = getSlug(!!first(userAndSlugResult[1]), proposedSlug)\n\n      const contract = getNewContract(\n        removeUndefinedProps({\n          id: idempotencyKey ?? randomString(),\n          slug,\n          creator: user,\n          question,\n          outcomeType,\n          description:\n            typeof description !== 'string' && description\n              ? description\n              : anythingToRichText({\n                  raw: description,\n                  html: descriptionHtml,\n                  markdown: descriptionMarkdown,\n                  jsonString: descriptionJson,\n                  // default: use a single empty space as the description\n                }) ?? htmlToRichText(`<p> </p>`),\n          initialProb: initialProb ?? 50,\n          ante,\n          closeTime,\n          visibility,\n          isTwitchContract,\n          min: min ?? 0,\n          max: max ?? 0,\n          isLogScale: isLogScale ?? false,\n          answers: answers ?? [],\n          answerShortTexts,\n          answerImageUrls,\n          addAnswersMode,\n          shouldAnswersSumToOne,\n          isAutoBounty,\n          token: 'MANA',\n          sportsStartTimestamp,\n          sportsEventId,\n          sportsLeague,\n          takerAPIOrdersDisabled,\n          unit: unit ?? '',\n          midpoints: midpoints,\n          timezone: timezone,\n          voterVisibility: voterVisibility as PollVoterVisibility | undefined,\n        })\n      )\n      const nativeKeys = nativeContractColumnsArray.map(camelCase)\n      const nativeValues = nativeKeys\n        .filter((col) => col in contract)\n        .map((col) => contract[col as keyof Contract])\n\n      const contractDataToInsert = Object.fromEntries(\n        Object.entries(contract).filter(([key]) => !nativeKeys.includes(key))\n      )\n      const insertAnswersQuery =\n        contract.mechanism === 'cpmm-multi-1'\n          ? bulkInsertQuery('answers', contract.answers.map(answerToRow), true)\n          : 'select 1 where false'\n      const contractQuery = pgp.as.format(\n        `insert into contracts \n        (id, ${contractColumnsToSelect})\n         values ($1, $2, ${nativeValues.map((_, i) => `$${i + 3}`)});`,\n        [contract.id, JSON.stringify(contractDataToInsert), ...nativeValues]\n      )\n      const result = await tx.multi(\n        `${contractQuery};\n       ${insertAnswersQuery};`\n      )\n\n      if (result[1].length > 0 && contract.mechanism === 'cpmm-multi-1') {\n        contract.answers = result[1].map(convertAnswer)\n      }\n      await runTxnOutsideBetQueue(tx, {\n        fromId: userId,\n        fromType: 'USER',\n        toId: contract.id,\n        toType: 'CONTRACT',\n        amount: ante,\n        token: 'M$',\n        category: 'CREATE_CONTRACT_ANTE',\n      })\n\n      log('created contract ', {\n        userUserName: user.username,\n        userId: user.id,\n        question,\n        ante: ante || 0,\n      })\n\n      await generateAntes(\n        tx,\n        userId,\n        contract,\n        outcomeType,\n        ante,\n        totalMarketCost\n      )\n\n      return { contract, user }\n    })\n  }, [userId])\n}\n\nasync function getDuplicateSubmissionUrl(\n  idempotencyKey: string | undefined,\n  pg: SupabaseDirectClient\n): Promise<string | undefined> {\n  if (!idempotencyKey) return undefined\n  const contracts = await getContractsDirect([idempotencyKey], pg)\n  if (contracts.length > 0) {\n    return contractUrl(contracts[0])\n  }\n  return undefined\n}\n\nasync function getCloseTimestamp(\n  closeTime: number | Date | undefined,\n  question: string,\n  outcomeType: OutcomeType,\n  utcOffset?: number\n): Promise<number | undefined> {\n  return closeTime\n    ? typeof closeTime === 'number'\n      ? closeTime\n      : closeTime.getTime()\n    : NO_CLOSE_TIME_TYPES.includes(outcomeType)\n    ? closeTime\n    : (await getCloseDate(question, utcOffset)) ??\n      Date.now() + 7 * 24 * 60 * 60 * 1000\n}\n\nconst getSlug = (preexistingContract: boolean, proposedSlug: string) => {\n  return preexistingContract\n    ? proposedSlug + '-' + randomString()\n    : proposedSlug\n}\n\nfunction validateMarketBody(body: Body) {\n  const {\n    question,\n    description,\n    descriptionHtml,\n    descriptionMarkdown,\n    descriptionJson,\n    closeTime,\n    outcomeType,\n    groupIds,\n    visibility = 'public',\n    isTwitchContract,\n    utcOffset,\n    extraLiquidity,\n    liquidityTier,\n    idempotencyKey,\n    sportsStartTimestamp,\n    sportsEventId,\n    sportsLeague,\n    takerAPIOrdersDisabled,\n  } = body\n\n  if (groupIds && groupIds.length > MAX_GROUPS_PER_MARKET)\n    throw new APIError(\n      400,\n      `You may only tag up to ${MAX_GROUPS_PER_MARKET} topics on a question`\n    )\n\n  let min: number | undefined,\n    max: number | undefined,\n    initialProb: number | undefined,\n    isLogScale: boolean | undefined,\n    answers: string[] | undefined,\n    answerShortTexts: string[] | undefined,\n    answerImageUrls: string[] | undefined,\n    addAnswersMode: add_answers_mode | undefined,\n    shouldAnswersSumToOne: boolean | undefined,\n    totalBounty: number | undefined,\n    isAutoBounty: boolean | undefined,\n    unit: string | undefined,\n    midpoints: number[] | undefined,\n    timezone: string | undefined,\n    voterVisibility: PollVoterVisibility | undefined\n\n  if (outcomeType === 'PSEUDO_NUMERIC') {\n    const parsed = validateMarketType(outcomeType, createNumericSchema, body)\n\n    ;({ min, max, isLogScale } = parsed)\n    const { initialValue } = parsed\n\n    if (max - min <= 0.01)\n      throw new APIError(400, 'Max must be greater than min by more than 0.01')\n    if (initialValue <= min || initialValue >= max)\n      throw new APIError(400, 'Invalid range.')\n\n    initialProb = getPseudoProbability(initialValue, min, max, isLogScale) * 100\n\n    if (initialProb < 1 || initialProb > 99)\n      if (outcomeType === 'PSEUDO_NUMERIC')\n        throw new APIError(\n          400,\n          `Initial value is too ${initialProb < 1 ? 'low' : 'high'}`\n        )\n      else throw new APIError(400, 'Invalid initial probability.')\n  }\n  if (outcomeType === 'STONK') {\n    initialProb = STONK_INITIAL_PROB\n  }\n\n  if (outcomeType === 'BINARY') {\n    const parsed = validateMarketType(outcomeType, createBinarySchema, body)\n\n    ;({ initialProb } = parsed)\n  }\n  if (outcomeType === 'NUMBER') {\n    if (!NUMBER_CREATION_ENABLED)\n      throw new APIError(\n        400,\n        'Creating numeric markets is not currently enabled.'\n      )\n    ;({ min, max } = validateMarketType(outcomeType, createNumberSchema, body))\n    if (min >= max)\n      throw new APIError(400, 'Numeric markets must have min < max.')\n    const { precision } = validateMarketType(\n      outcomeType,\n      createNumberSchema,\n      body\n    )\n    answers = getMultiNumericAnswerBucketRangeNames(min, max, precision)\n    if (answers.length < 2)\n      throw new APIError(\n        400,\n        'Numeric markets must have at least 2 answer buckets.'\n      )\n  }\n  if (outcomeType === 'MULTI_NUMERIC') {\n    ;({ answers, midpoints, unit, shouldAnswersSumToOne } = validateMarketType(\n      outcomeType,\n      createMultiNumericSchema,\n      body\n    ))\n    if (answers.length < 2)\n      throw new APIError(\n        400,\n        'Numeric markets must have at least 2 answer buckets.'\n      )\n    if (answers.length !== midpoints.length)\n      throw new APIError(\n        400,\n        'Number of answers must match number of midpoints.'\n      )\n  }\n  if (outcomeType === 'DATE') {\n    ;({ answers, midpoints, shouldAnswersSumToOne, timezone } =\n      validateMarketType(outcomeType, createMultiDateSchema, body))\n    if (answers.length < 2)\n      throw new APIError(\n        400,\n        'Numeric markets must have at least 2 answer buckets.'\n      )\n    if (answers.length !== midpoints.length)\n      throw new APIError(\n        400,\n        'Number of answers must match number of midpoints.'\n      )\n  }\n\n  if (outcomeType === 'MULTIPLE_CHOICE') {\n    ;({\n      answers,\n      answerShortTexts,\n      answerImageUrls,\n      addAnswersMode,\n      shouldAnswersSumToOne,\n    } = validateMarketType(outcomeType, createMultiSchema, body))\n    if (answers.length < 2 && addAnswersMode === 'DISABLED')\n      throw new APIError(\n        400,\n        'Multiple choice markets must have at least 2 answers if adding answers is disabled.'\n      )\n  }\n\n  if (outcomeType === 'BOUNTIED_QUESTION') {\n    ;({ totalBounty, isAutoBounty } = validateMarketType(\n      outcomeType,\n      createBountySchema,\n      body\n    ))\n  }\n\n  if (outcomeType === 'POLL') {\n    ;({ answers, voterVisibility } = validateMarketType(\n      outcomeType,\n      createPollSchema,\n      body\n    ))\n  }\n\n  return {\n    question,\n    description,\n    descriptionHtml,\n    descriptionMarkdown,\n    descriptionJson,\n    closeTime,\n    outcomeType,\n    groupIds,\n    visibility,\n    extraLiquidity,\n    isTwitchContract,\n    utcOffset,\n    min,\n    max,\n    initialProb,\n    isLogScale,\n    answers,\n    addAnswersMode,\n    shouldAnswersSumToOne,\n    totalBounty,\n    isAutoBounty,\n    liquidityTier,\n    idempotencyKey,\n    sportsStartTimestamp,\n    sportsEventId,\n    sportsLeague,\n    answerShortTexts,\n    answerImageUrls,\n    takerAPIOrdersDisabled,\n    unit,\n    midpoints,\n    timezone,\n    voterVisibility,\n  }\n}\n\nfunction validateMarketType<T extends z.ZodType>(\n  outcome: string,\n  schema: T,\n  val: unknown\n) {\n  const result = schema.safeParse(val)\n  if (result.success) return result.data as z.infer<T>\n  throw new APIError(\n    400,\n    `Wrong props for ${outcome} question.`,\n    result.error.message\n  )\n}\n\nasync function getGroupCheckPermissions(\n  pg: SupabaseDirectClient,\n  groupId: string,\n  userId: string\n) {\n  const result = await pg.oneOrNone<\n    Row<'groups'> & { member_role: string | null }\n  >(\n    `\n    select g.*, gm.role as member_role\n    from groups g\n    left join group_members gm on g.id = gm.group_id and gm.member_id = $2\n    where g.id = $1\n  `,\n    [groupId, userId]\n  )\n\n  if (!result) {\n    throw new APIError(404, 'No group exists with the given group ID.')\n  }\n\n  const { member_role, ...group } = result\n  const membership = member_role\n    ? {\n        role: member_role,\n        group_id: group.id,\n        member_id: userId,\n        created_time: null,\n      }\n    : undefined\n\n  if (\n    !canUserAddGroupToMarket({\n      userId,\n      group,\n      membership,\n    })\n  ) {\n    throw new APIError(\n      403,\n      `User does not have permission to add this market to group \"${group.name}\".`\n    )\n  }\n\n  return group\n}\n"
        },
        {
          "path": "backend/api/src/get-contract-voters.ts",
          "preContent": "import { APIHandler } from 'api/helpers/endpoint'\nimport { convertUser, prefixedDisplayUserColumns } from 'common/supabase/users'\nimport { createSupabaseDirectClient } from 'shared/supabase/init'\n\nexport const getContractVoters: APIHandler<'get-contract-voters'> = async (\n  props\n) => {\n  const { contractId } = props\n  const pg = createSupabaseDirectClient()\n\n  return await pg.map(\n    `select ${prefixedDisplayUserColumns} from users u\n     join votes on votes.user_id = u.id where votes.contract_id = $1`,\n    [contractId],\n    convertUser\n  )\n}\n\nexport const getContractOptionVoters: APIHandler<\n  'get-contract-option-voters'\n> = async (props) => {\n  const { contractId, optionId } = props\n  const pg = createSupabaseDirectClient()\n\n  return await pg.map(\n    `select ${prefixedDisplayUserColumns} from users u\n     join votes on votes.user_id = u.id where votes.contract_id = $1 and votes.id = $2`,\n    [contractId, optionId],\n    convertUser\n  )\n}\n",
          "postContent": "import { APIError, APIHandler, AuthedUser } from 'api/helpers/endpoint'\nimport { convertUser, prefixedDisplayUserColumns } from 'common/supabase/users'\nimport { createSupabaseDirectClient } from 'shared/supabase/init'\nimport { getContract } from 'shared/utils'\nimport { PollContract } from 'common/contract'\n\nexport const getContractVoters: APIHandler<'get-contract-voters'> = async (\n  props,\n  auth\n) => {\n  const { contractId } = props\n  const pg = createSupabaseDirectClient()\n  await checkAccess(contractId, auth)\n  return await pg.map(\n    `select ${prefixedDisplayUserColumns} from users u\n     join votes on votes.user_id = u.id where votes.contract_id = $1`,\n    [contractId],\n    convertUser\n  )\n}\nconst checkAccess = async (contractId: string, auth: AuthedUser) => {\n  const pg = createSupabaseDirectClient()\n  const contract = (await getContract(pg, contractId)) as PollContract\n  if (!contract) {\n    throw new APIError(404, 'Contract not found')\n  }\n  const isCreator = auth.uid === contract.creatorId\n  const canShowVoters =\n    !contract.voterVisibility ||\n    contract.voterVisibility === 'everyone' ||\n    (contract.voterVisibility === 'creator' && isCreator)\n  if (!canShowVoters) {\n    throw new APIError(403, 'You are not allowed to see the voters')\n  }\n}\nexport const getContractOptionVoters: APIHandler<\n  'get-contract-option-voters'\n> = async (props, auth) => {\n  const { contractId, optionId } = props\n  const pg = createSupabaseDirectClient()\n  await checkAccess(contractId, auth)\n  return await pg.map(\n    `select ${prefixedDisplayUserColumns} from users u\n     join votes on votes.user_id = u.id where votes.contract_id = $1 and votes.id = $2`,\n    [contractId, optionId],\n    convertUser\n  )\n}\n"
        },
        {
          "path": "common/src/api/market-types.ts",
          "preContent": "import { JSONContent } from '@tiptap/core'\nimport { Answer, MAX_ANSWERS } from 'common/answer'\nimport { getAnswerProbability, getProbability } from 'common/calculate'\nimport {\n  Contract,\n  MAX_QUESTION_LENGTH,\n  MultiContract,\n  RESOLUTIONS,\n  VISIBILITIES,\n} from 'common/contract'\nimport { MINIMUM_BOUNTY } from 'common/economy'\nimport { DOMAIN } from 'common/envs/constants'\nimport { MAX_ID_LENGTH } from 'common/group'\nimport { getMappedValue } from 'common/pseudo-numeric'\nimport { removeUndefinedProps } from 'common/util/object'\nimport { richTextToString } from 'common/util/parse'\nimport { z } from 'zod'\nimport { coerceBoolean, contentSchema } from './zod-types'\nimport { randomStringRegex } from 'common/util/random'\nimport { MAX_MULTI_NUMERIC_ANSWERS } from 'common/multi-numeric'\nimport { liquidityTiers } from 'common/tier'\n\nexport type LiteMarket = {\n  // Unique identifier for this market\n  id: string\n\n  // Attributes about the creator\n  creatorId: string\n  creatorUsername: string\n  creatorName: string\n  createdTime: number\n  creatorAvatarUrl?: string\n\n  // Market attributes. All times are in milliseconds since epoch\n  closeTime?: number\n  question: string\n  slug: string\n  url: string\n  outcomeType: string\n  mechanism: string\n\n  pool?: { [outcome: string]: number }\n  probability?: number\n  p?: number\n  totalLiquidity?: number\n  // For pseudo-numeric\n  value?: number\n  min?: number\n  max?: number\n\n  volume: number\n  volume24Hours: number\n\n  isResolved: boolean\n  resolution?: string\n  resolutionTime?: number\n  resolutionProbability?: number\n\n  uniqueBettorCount: number\n  lastUpdatedTime?: number\n  lastBetTime?: number\n  sportsStartTimestamp?: string\n  sportsEventId?: string\n  sportsLeague?: string\n}\nexport type ApiAnswer = Omit<\n  Answer & {\n    probability: number\n    pool: { YES: number; NO: number }\n  },\n  'prob' | 'poolYes' | 'poolNo'\n>\nexport type FullMarket = LiteMarket & {\n  // bets?: Bet[]\n  // comments?: Comment[]\n\n  // multi markets only\n  answers?: ApiAnswer[]\n  shouldAnswersSumToOne?: boolean\n  addAnswersMode?: 'ANYONE' | 'ONLY_CREATOR' | 'DISABLED'\n\n  // poll only\n  options?: { text: string; votes: number }[]\n\n  // bounty only\n  totalBounty?: number\n  bountyLeft?: number\n\n  description: string | JSONContent\n  textDescription: string // string version of description\n  coverImageUrl?: string\n  groupSlugs?: string[]\n}\n\nexport function toLiteMarket(contract: Contract): LiteMarket {\n  const {\n    id,\n    creatorId,\n    creatorUsername,\n    creatorName,\n    createdTime,\n    creatorAvatarUrl,\n    closeTime,\n    question,\n    slug,\n    outcomeType,\n    mechanism,\n    volume,\n    volume24Hours,\n    isResolved,\n    resolution,\n    resolutionTime,\n    resolutionProbability,\n    resolverId,\n    uniqueBettorCount,\n    lastUpdatedTime,\n    lastBetTime,\n    lastCommentTime,\n    loverUserId1,\n    loverUserId2,\n    matchCreatorId,\n    isLove,\n    token,\n    siblingContractId,\n  } = contract\n\n  const { p, totalLiquidity } = contract as any\n\n  const probability =\n    outcomeType === 'BINARY' || outcomeType === 'PSEUDO_NUMERIC'\n      ? getProbability(contract)\n      : undefined\n\n  let numericValues = {}\n  if (contract.outcomeType === 'PSEUDO_NUMERIC') {\n    const value = getMappedValue(contract, contract.prob)\n    const { min, max, isLogScale } = contract\n    numericValues = { value, min, max, isLogScale }\n  }\n\n  return removeUndefinedProps({\n    id,\n    creatorId,\n    creatorUsername,\n    creatorName,\n    createdTime,\n    creatorAvatarUrl,\n    closeTime:\n      resolutionTime && closeTime\n        ? Math.min(resolutionTime, closeTime)\n        : closeTime,\n    question,\n    slug,\n    url: `https://${DOMAIN}/${creatorUsername}/${slug}`,\n    pool: 'pool' in contract ? contract.pool : undefined,\n    probability,\n    p,\n    totalLiquidity,\n    outcomeType,\n    mechanism,\n    volume,\n    volume24Hours,\n    isResolved,\n    resolution,\n    resolutionTime,\n    resolutionProbability,\n    resolverId,\n    uniqueBettorCount,\n    lastUpdatedTime,\n    lastBetTime,\n    lastCommentTime,\n    ...numericValues,\n    token,\n    siblingContractId,\n\n    // Manifold love props.\n    loverUserId1,\n    loverUserId2,\n    matchCreatorId,\n    isLove,\n  })\n}\n\nexport function toFullMarket(contract: Contract): FullMarket {\n  const liteMarket = toLiteMarket(contract)\n  const { outcomeType } = contract\n  const answers =\n    outcomeType === 'MULTIPLE_CHOICE' && contract.answers\n      ? contract.answers.map((answer) =>\n          augmentAnswerWithProbability(contract, answer)\n        )\n      : undefined\n\n  let multiValues = {}\n  if (outcomeType === 'MULTIPLE_CHOICE') {\n    if (contract.mechanism === 'cpmm-multi-1') {\n      multiValues = {\n        shouldAnswersSumToOne: contract.shouldAnswersSumToOne,\n        addAnswersMode: contract.addAnswersMode,\n      }\n    } else {\n      multiValues = {\n        shouldAnswersSumToOne: true,\n        addAnswersMode: 'DISABLED',\n      }\n    }\n  }\n  const options =\n    outcomeType === 'POLL'\n      ? contract.options.map(({ text, votes }) => ({ text, votes }))\n      : undefined\n\n  const bountyValues =\n    outcomeType === 'BOUNTIED_QUESTION'\n      ? {\n          totalBounty: contract.totalBounty,\n          bountyLeft: contract.bountyLeft,\n        }\n      : {}\n\n  const { description, coverImageUrl, groupSlugs } = contract\n\n  return {\n    ...liteMarket,\n    ...bountyValues,\n    ...multiValues,\n    answers,\n    options,\n    description,\n    coverImageUrl,\n    groupSlugs,\n    textDescription:\n      typeof description === 'string'\n        ? description\n        : richTextToString(description),\n  }\n}\n\nfunction augmentAnswerWithProbability(\n  contract: MultiContract,\n  answer: Answer\n): ApiAnswer {\n  const probability = getAnswerProbability(contract, answer.id)\n  const { poolYes, poolNo, prob: _, ...other } = answer\n  const pool = {\n    YES: poolYes,\n    NO: poolNo,\n  }\n  return {\n    ...other,\n    pool,\n    probability,\n  }\n}\n\n// ZOD TYPES\n\n// create market\n\nexport const createBinarySchema = z.object({\n  outcomeType: z.enum(['BINARY', 'STONK']),\n  initialProb: z.number().min(1).max(99).optional(),\n})\n\nexport const createNumericSchema = z.object({\n  outcomeType: z.enum(['PSEUDO_NUMERIC']),\n  min: z.number().safe(),\n  max: z.number().safe(),\n  initialValue: z.number().safe(),\n  isLogScale: z.boolean().optional(),\n})\n\nexport const createMultiSchema = z.object({\n  outcomeType: z.enum(['MULTIPLE_CHOICE']),\n  answers: z.array(z.string().trim().min(1)).max(MAX_ANSWERS),\n  answerShortTexts: z\n    .array(z.string().trim().min(1))\n    .max(MAX_ANSWERS)\n    .optional(),\n  answerImageUrls: z\n    .array(z.string().trim().min(1))\n    .max(MAX_ANSWERS)\n    .optional(),\n  addAnswersMode: z\n    .enum(['DISABLED', 'ONLY_CREATOR', 'ANYONE'])\n    .default('DISABLED'),\n  shouldAnswersSumToOne: z.boolean().optional(),\n})\n\nexport const createNumberSchema = z.object({\n  outcomeType: z.enum(['NUMBER']),\n  min: z.number().safe(),\n  max: z.number().safe(),\n  precision: z.number().gt(0),\n})\n\nexport const createMultiNumericSchema = z.object({\n  outcomeType: z.enum(['MULTI_NUMERIC']),\n  answers: z.array(z.string().trim().min(1)).max(MAX_MULTI_NUMERIC_ANSWERS),\n  midpoints: z.array(z.number().safe()).max(MAX_MULTI_NUMERIC_ANSWERS),\n  shouldAnswersSumToOne: z.boolean(),\n  addAnswersMode: z.enum(['DISABLED']).default('DISABLED'),\n  unit: z.string(),\n})\n\nexport const createMultiDateSchema = z.object({\n  outcomeType: z.enum(['DATE']),\n  answers: z.array(z.string().trim().min(1)).max(MAX_MULTI_NUMERIC_ANSWERS),\n  midpoints: z.array(z.number().safe()).max(MAX_MULTI_NUMERIC_ANSWERS),\n  shouldAnswersSumToOne: z.boolean(),\n  addAnswersMode: z.enum(['DISABLED']).default('DISABLED'),\n  timezone: z.string(),\n})\n\nexport const createBountySchema = z.object({\n  outcomeType: z.enum(['BOUNTIED_QUESTION']),\n  totalBounty: z.number().min(MINIMUM_BOUNTY),\n  isAutoBounty: z.boolean().optional(),\n})\n\nexport const createPollSchema = z.object({\n  outcomeType: z.enum(['POLL']),\n  answers: z.array(z.string().trim().min(1)).min(2).max(MAX_ANSWERS),\n})\n\nexport const createMarketProps = z\n  .object({\n    question: z.string().min(1).max(MAX_QUESTION_LENGTH),\n    description: contentSchema.or(z.string()).optional(),\n    descriptionHtml: z.string().optional(),\n    descriptionMarkdown: z.string().optional(),\n    descriptionJson: z.string().optional(),\n    closeTime: z\n      .union([z.date(), z.number()])\n      .refine(\n        (date) =>\n          (typeof date === 'number' ? date : date.getTime()) > Date.now(),\n        'Close time must be in the future.'\n      )\n      .optional(),\n    groupIds: z.array(z.string().min(1).max(MAX_ID_LENGTH)).optional(),\n    visibility: z.enum(VISIBILITIES).default('public').optional(),\n    isTwitchContract: z.boolean().optional(),\n    utcOffset: z.number().optional(),\n    extraLiquidity: z.number().min(1).optional(),\n    liquidityTier: z.number().min(liquidityTiers[0]),\n    idempotencyKey: z.string().regex(randomStringRegex).length(10).optional(),\n    sportsStartTimestamp: z.string().optional(),\n    sportsEventId: z.string().optional(),\n    sportsLeague: z.string().optional(),\n    takerAPIOrdersDisabled: coerceBoolean.optional(),\n  })\n  .and(\n    z.union([\n      createMultiSchema,\n      createNumericSchema,\n      createBountySchema,\n      createPollSchema,\n      createBinarySchema,\n      createNumberSchema,\n      createMultiNumericSchema,\n      createMultiDateSchema,\n    ])\n  )\n\nexport const updateMarketProps = z\n  .object({\n    contractId: z.string(),\n    question: z.string().min(1).max(MAX_QUESTION_LENGTH).optional(),\n    visibility: z.enum(['unlisted', 'public']).optional(),\n    closeTime: z.number().optional(),\n    addAnswersMode: z.enum(['ONLY_CREATOR', 'ANYONE']).optional(),\n    coverImageUrl: z.string().or(z.null()).optional(),\n    sort: z.string().optional(),\n    description: z.string().optional(),\n    descriptionHtml: z.string().optional(),\n    descriptionMarkdown: z.string().optional(),\n    descriptionJson: z.string().optional(),\n    display: z.enum(['clock', 'default']).optional(),\n  })\n  .strict()\n\n// resolve market\n\nexport const resolveBinarySchema = z\n  .object({\n    outcome: z.enum(RESOLUTIONS),\n    probabilityInt: z.number().gte(0).lte(100).optional(),\n\n    // To resolve one answer of multiple choice. Only independent answers supported (shouldAnswersSumToOne = false)\n    answerId: z.string().optional(),\n  })\n  .passthrough() // overlaps with pseudo-numeric\n\n// For multiple choice with shouldAnswersSumToOne = true\nexport const resolveMultiSchema = z.union([\n  z.object({\n    outcome: z.literal('CANCEL'),\n  }),\n  z.object({\n    outcome: z.literal('CHOOSE_ONE'),\n    answerId: z.string(),\n  }),\n  z.object({\n    outcome: z.literal('CHOOSE_MULTIPLE'),\n    resolutions: z.array(\n      z.object({\n        answerId: z.string(),\n        pct: z.number().gte(0).lte(100),\n      })\n    ),\n  }),\n])\n\nexport const resolvePseudoNumericSchema = z.union([\n  z.object({\n    outcome: z.literal('CANCEL'),\n  }),\n  z.object({\n    outcome: z.literal('MKT'),\n    value: z.number(),\n    probabilityInt: z.number().gte(0).lte(100),\n  }),\n])\n\nexport const resolveMarketProps = z\n  .object({\n    contractId: z.string(),\n  })\n  .and(\n    z.union([\n      resolveBinarySchema,\n      resolveMultiSchema,\n      resolvePseudoNumericSchema,\n    ])\n  )\n",
          "postContent": "import { JSONContent } from '@tiptap/core'\nimport { Answer, MAX_ANSWERS } from 'common/answer'\nimport { getAnswerProbability, getProbability } from 'common/calculate'\nimport {\n  Contract,\n  MAX_QUESTION_LENGTH,\n  MultiContract,\n  RESOLUTIONS,\n  VISIBILITIES,\n} from 'common/contract'\nimport { MINIMUM_BOUNTY } from 'common/economy'\nimport { DOMAIN } from 'common/envs/constants'\nimport { MAX_ID_LENGTH } from 'common/group'\nimport { getMappedValue } from 'common/pseudo-numeric'\nimport { removeUndefinedProps } from 'common/util/object'\nimport { richTextToString } from 'common/util/parse'\nimport { z } from 'zod'\nimport { coerceBoolean, contentSchema } from './zod-types'\nimport { randomStringRegex } from 'common/util/random'\nimport { MAX_MULTI_NUMERIC_ANSWERS } from 'common/multi-numeric'\nimport { liquidityTiers } from 'common/tier'\n\nexport type LiteMarket = {\n  // Unique identifier for this market\n  id: string\n\n  // Attributes about the creator\n  creatorId: string\n  creatorUsername: string\n  creatorName: string\n  createdTime: number\n  creatorAvatarUrl?: string\n\n  // Market attributes. All times are in milliseconds since epoch\n  closeTime?: number\n  question: string\n  slug: string\n  url: string\n  outcomeType: string\n  mechanism: string\n\n  pool?: { [outcome: string]: number }\n  probability?: number\n  p?: number\n  totalLiquidity?: number\n  // For pseudo-numeric\n  value?: number\n  min?: number\n  max?: number\n\n  volume: number\n  volume24Hours: number\n\n  isResolved: boolean\n  resolution?: string\n  resolutionTime?: number\n  resolutionProbability?: number\n\n  uniqueBettorCount: number\n  lastUpdatedTime?: number\n  lastBetTime?: number\n  sportsStartTimestamp?: string\n  sportsEventId?: string\n  sportsLeague?: string\n}\nexport type ApiAnswer = Omit<\n  Answer & {\n    probability: number\n    pool: { YES: number; NO: number }\n  },\n  'prob' | 'poolYes' | 'poolNo'\n>\nexport type FullMarket = LiteMarket & {\n  // bets?: Bet[]\n  // comments?: Comment[]\n\n  // multi markets only\n  answers?: ApiAnswer[]\n  shouldAnswersSumToOne?: boolean\n  addAnswersMode?: 'ANYONE' | 'ONLY_CREATOR' | 'DISABLED'\n\n  // poll only\n  options?: { text: string; votes: number }[]\n\n  // bounty only\n  totalBounty?: number\n  bountyLeft?: number\n\n  description: string | JSONContent\n  textDescription: string // string version of description\n  coverImageUrl?: string\n  groupSlugs?: string[]\n}\n\nexport function toLiteMarket(contract: Contract): LiteMarket {\n  const {\n    id,\n    creatorId,\n    creatorUsername,\n    creatorName,\n    createdTime,\n    creatorAvatarUrl,\n    closeTime,\n    question,\n    slug,\n    outcomeType,\n    mechanism,\n    volume,\n    volume24Hours,\n    isResolved,\n    resolution,\n    resolutionTime,\n    resolutionProbability,\n    resolverId,\n    uniqueBettorCount,\n    lastUpdatedTime,\n    lastBetTime,\n    lastCommentTime,\n    loverUserId1,\n    loverUserId2,\n    matchCreatorId,\n    isLove,\n    token,\n    siblingContractId,\n  } = contract\n\n  const { p, totalLiquidity } = contract as any\n\n  const probability =\n    outcomeType === 'BINARY' || outcomeType === 'PSEUDO_NUMERIC'\n      ? getProbability(contract)\n      : undefined\n\n  let numericValues = {}\n  if (contract.outcomeType === 'PSEUDO_NUMERIC') {\n    const value = getMappedValue(contract, contract.prob)\n    const { min, max, isLogScale } = contract\n    numericValues = { value, min, max, isLogScale }\n  }\n\n  return removeUndefinedProps({\n    id,\n    creatorId,\n    creatorUsername,\n    creatorName,\n    createdTime,\n    creatorAvatarUrl,\n    closeTime:\n      resolutionTime && closeTime\n        ? Math.min(resolutionTime, closeTime)\n        : closeTime,\n    question,\n    slug,\n    url: `https://${DOMAIN}/${creatorUsername}/${slug}`,\n    pool: 'pool' in contract ? contract.pool : undefined,\n    probability,\n    p,\n    totalLiquidity,\n    outcomeType,\n    mechanism,\n    volume,\n    volume24Hours,\n    isResolved,\n    resolution,\n    resolutionTime,\n    resolutionProbability,\n    resolverId,\n    uniqueBettorCount,\n    lastUpdatedTime,\n    lastBetTime,\n    lastCommentTime,\n    ...numericValues,\n    token,\n    siblingContractId,\n\n    // Manifold love props.\n    loverUserId1,\n    loverUserId2,\n    matchCreatorId,\n    isLove,\n  })\n}\n\nexport function toFullMarket(contract: Contract): FullMarket {\n  const liteMarket = toLiteMarket(contract)\n  const { outcomeType } = contract\n  const answers =\n    outcomeType === 'MULTIPLE_CHOICE' && contract.answers\n      ? contract.answers.map((answer) =>\n          augmentAnswerWithProbability(contract, answer)\n        )\n      : undefined\n\n  let multiValues = {}\n  if (outcomeType === 'MULTIPLE_CHOICE') {\n    if (contract.mechanism === 'cpmm-multi-1') {\n      multiValues = {\n        shouldAnswersSumToOne: contract.shouldAnswersSumToOne,\n        addAnswersMode: contract.addAnswersMode,\n      }\n    } else {\n      multiValues = {\n        shouldAnswersSumToOne: true,\n        addAnswersMode: 'DISABLED',\n      }\n    }\n  }\n  const options =\n    outcomeType === 'POLL'\n      ? contract.options.map(({ text, votes }) => ({ text, votes }))\n      : undefined\n\n  const bountyValues =\n    outcomeType === 'BOUNTIED_QUESTION'\n      ? {\n          totalBounty: contract.totalBounty,\n          bountyLeft: contract.bountyLeft,\n        }\n      : {}\n\n  const { description, coverImageUrl, groupSlugs } = contract\n\n  return {\n    ...liteMarket,\n    ...bountyValues,\n    ...multiValues,\n    answers,\n    options,\n    description,\n    coverImageUrl,\n    groupSlugs,\n    textDescription:\n      typeof description === 'string'\n        ? description\n        : richTextToString(description),\n  }\n}\n\nfunction augmentAnswerWithProbability(\n  contract: MultiContract,\n  answer: Answer\n): ApiAnswer {\n  const probability = getAnswerProbability(contract, answer.id)\n  const { poolYes, poolNo, prob: _, ...other } = answer\n  const pool = {\n    YES: poolYes,\n    NO: poolNo,\n  }\n  return {\n    ...other,\n    pool,\n    probability,\n  }\n}\n\n// ZOD TYPES\n\n// create market\n\nexport const createBinarySchema = z.object({\n  outcomeType: z.enum(['BINARY', 'STONK']),\n  initialProb: z.number().min(1).max(99).optional(),\n})\n\nexport const createNumericSchema = z.object({\n  outcomeType: z.enum(['PSEUDO_NUMERIC']),\n  min: z.number().safe(),\n  max: z.number().safe(),\n  initialValue: z.number().safe(),\n  isLogScale: z.boolean().optional(),\n})\n\nexport const createMultiSchema = z.object({\n  outcomeType: z.enum(['MULTIPLE_CHOICE']),\n  answers: z.array(z.string().trim().min(1)).max(MAX_ANSWERS),\n  answerShortTexts: z\n    .array(z.string().trim().min(1))\n    .max(MAX_ANSWERS)\n    .optional(),\n  answerImageUrls: z\n    .array(z.string().trim().min(1))\n    .max(MAX_ANSWERS)\n    .optional(),\n  addAnswersMode: z\n    .enum(['DISABLED', 'ONLY_CREATOR', 'ANYONE'])\n    .default('DISABLED'),\n  shouldAnswersSumToOne: z.boolean().optional(),\n})\n\nexport const createNumberSchema = z.object({\n  outcomeType: z.enum(['NUMBER']),\n  min: z.number().safe(),\n  max: z.number().safe(),\n  precision: z.number().gt(0),\n})\n\nexport const createMultiNumericSchema = z.object({\n  outcomeType: z.enum(['MULTI_NUMERIC']),\n  answers: z.array(z.string().trim().min(1)).max(MAX_MULTI_NUMERIC_ANSWERS),\n  midpoints: z.array(z.number().safe()).max(MAX_MULTI_NUMERIC_ANSWERS),\n  shouldAnswersSumToOne: z.boolean(),\n  addAnswersMode: z.enum(['DISABLED']).default('DISABLED'),\n  unit: z.string(),\n})\n\nexport const createMultiDateSchema = z.object({\n  outcomeType: z.enum(['DATE']),\n  answers: z.array(z.string().trim().min(1)).max(MAX_MULTI_NUMERIC_ANSWERS),\n  midpoints: z.array(z.number().safe()).max(MAX_MULTI_NUMERIC_ANSWERS),\n  shouldAnswersSumToOne: z.boolean(),\n  addAnswersMode: z.enum(['DISABLED']).default('DISABLED'),\n  timezone: z.string(),\n})\n\nexport const createBountySchema = z.object({\n  outcomeType: z.enum(['BOUNTIED_QUESTION']),\n  totalBounty: z.number().min(MINIMUM_BOUNTY),\n  isAutoBounty: z.boolean().optional(),\n})\n\nexport const createPollSchema = z.object({\n  outcomeType: z.enum(['POLL']),\n  answers: z.array(z.string().trim().min(1)).min(2).max(MAX_ANSWERS),\n  voterVisibility: z.enum(['creator', 'everyone']).optional(),\n})\n\nexport const createMarketProps = z\n  .object({\n    question: z.string().min(1).max(MAX_QUESTION_LENGTH),\n    description: contentSchema.or(z.string()).optional(),\n    descriptionHtml: z.string().optional(),\n    descriptionMarkdown: z.string().optional(),\n    descriptionJson: z.string().optional(),\n    closeTime: z\n      .union([z.date(), z.number()])\n      .refine(\n        (date) =>\n          (typeof date === 'number' ? date : date.getTime()) > Date.now(),\n        'Close time must be in the future.'\n      )\n      .optional(),\n    groupIds: z.array(z.string().min(1).max(MAX_ID_LENGTH)).optional(),\n    visibility: z.enum(VISIBILITIES).default('public').optional(),\n    isTwitchContract: z.boolean().optional(),\n    utcOffset: z.number().optional(),\n    extraLiquidity: z.number().min(1).optional(),\n    liquidityTier: z.number().min(liquidityTiers[0]),\n    idempotencyKey: z.string().regex(randomStringRegex).length(10).optional(),\n    sportsStartTimestamp: z.string().optional(),\n    sportsEventId: z.string().optional(),\n    sportsLeague: z.string().optional(),\n    takerAPIOrdersDisabled: coerceBoolean.optional(),\n  })\n  .and(\n    z.union([\n      createMultiSchema,\n      createNumericSchema,\n      createBountySchema,\n      createPollSchema,\n      createBinarySchema,\n      createNumberSchema,\n      createMultiNumericSchema,\n      createMultiDateSchema,\n    ])\n  )\n\nexport const updateMarketProps = z\n  .object({\n    contractId: z.string(),\n    question: z.string().min(1).max(MAX_QUESTION_LENGTH).optional(),\n    visibility: z.enum(['unlisted', 'public']).optional(),\n    closeTime: z.number().optional(),\n    addAnswersMode: z.enum(['ONLY_CREATOR', 'ANYONE']).optional(),\n    coverImageUrl: z.string().or(z.null()).optional(),\n    sort: z.string().optional(),\n    description: z.string().optional(),\n    descriptionHtml: z.string().optional(),\n    descriptionMarkdown: z.string().optional(),\n    descriptionJson: z.string().optional(),\n    display: z.enum(['clock', 'default']).optional(),\n  })\n  .strict()\n\n// resolve market\n\nexport const resolveBinarySchema = z\n  .object({\n    outcome: z.enum(RESOLUTIONS),\n    probabilityInt: z.number().gte(0).lte(100).optional(),\n\n    // To resolve one answer of multiple choice. Only independent answers supported (shouldAnswersSumToOne = false)\n    answerId: z.string().optional(),\n  })\n  .passthrough() // overlaps with pseudo-numeric\n\n// For multiple choice with shouldAnswersSumToOne = true\nexport const resolveMultiSchema = z.union([\n  z.object({\n    outcome: z.literal('CANCEL'),\n  }),\n  z.object({\n    outcome: z.literal('CHOOSE_ONE'),\n    answerId: z.string(),\n  }),\n  z.object({\n    outcome: z.literal('CHOOSE_MULTIPLE'),\n    resolutions: z.array(\n      z.object({\n        answerId: z.string(),\n        pct: z.number().gte(0).lte(100),\n      })\n    ),\n  }),\n])\n\nexport const resolvePseudoNumericSchema = z.union([\n  z.object({\n    outcome: z.literal('CANCEL'),\n  }),\n  z.object({\n    outcome: z.literal('MKT'),\n    value: z.number(),\n    probabilityInt: z.number().gte(0).lte(100),\n  }),\n])\n\nexport const resolveMarketProps = z\n  .object({\n    contractId: z.string(),\n  })\n  .and(\n    z.union([\n      resolveBinarySchema,\n      resolveMultiSchema,\n      resolvePseudoNumericSchema,\n    ])\n  )\n"
        },
        {
          "path": "common/src/api/schema.ts",
          "preContent": "import { z } from 'zod'\nimport {\n  Group,\n  MAX_ID_LENGTH,\n  MySearchGroupShape,\n  LiteGroup,\n  SearchGroupParams,\n  SearchGroupShape,\n  Topic,\n} from 'common/group'\nimport {\n  createMarketProps,\n  resolveMarketProps,\n  type LiteMarket,\n  FullMarket,\n  updateMarketProps,\n} from './market-types'\nimport { type Answer } from 'common/answer'\nimport {\n  CommentWithTotalReplies,\n  MAX_COMMENT_LENGTH,\n  type ContractComment,\n} from 'common/comment'\nimport { CandidateBet } from 'common/new-bet'\nimport type { Bet, LimitBet } from 'common/bet'\nimport { coerceBoolean, contentSchema } from 'common/api/zod-types'\nimport { Lover } from 'common/love/lover'\nimport { AIGeneratedMarket, Contract, MarketContract } from 'common/contract'\nimport { CompatibilityScore } from 'common/love/compatibility-score'\nimport type { Txn, ManaPayTxn } from 'common/txn'\nimport { LiquidityProvision } from 'common/liquidity-provision'\nimport { DisplayUser, FullUser } from './user-types'\nimport { League } from 'common/leagues'\nimport { searchProps } from './market-search-types'\nimport { MAX_ANSWER_LENGTH } from 'common/answer'\nimport { type LinkPreview } from 'common/link-preview'\nimport { Headline } from 'common/news'\nimport { Row } from 'common/supabase/utils'\nimport { LikeData, ShipData } from './love-types'\nimport { AnyBalanceChangeType } from 'common/balance-change'\nimport { Dashboard } from 'common/dashboard'\nimport { ChatMessage, PrivateChatMessage } from 'common/chat-message'\nimport { PrivateUser, User } from '../user'\nimport { ManaSupply } from 'common/stats'\nimport { Repost } from 'common/repost'\nimport { PERIODS } from 'common/period'\nimport { SWEEPS_MIN_BET } from 'common/economy'\nimport {\n  LivePortfolioMetrics,\n  PortfolioMetrics,\n} from 'common/portfolio-metrics'\nimport { ModReport } from '../mod-report'\n\nimport { RegistrationReturnType } from 'common/reason-codes'\nimport {\n  CheckoutSession,\n  GIDXDocument,\n  GPSProps,\n  PaymentDetail,\n  checkoutParams,\n  verificationParams,\n  cashoutRequestParams,\n  PendingCashoutStatusData,\n  cashoutParams,\n} from 'common/gidx/gidx'\nimport { notification_preference } from 'common/user-notification-preferences'\nimport { PrivateMessageChannel } from 'common/supabase/private-messages'\nimport { Notification } from 'common/notification'\nimport { NON_POINTS_BETS_LIMIT } from 'common/supabase/bets'\nimport { ContractMetric } from 'common/contract-metric'\n\nimport { JSONContent } from '@tiptap/core'\nimport { Task, TaskCategory } from 'common/todo'\nimport { ChartAnnotation } from 'common/supabase/chart-annotations'\nimport { Dictionary } from 'lodash'\nimport { Reaction } from 'common/reaction'\nimport { YEAR_MS } from 'common/util/time'\nimport { MarketDraft } from 'common/drafts'\n// mqp: very unscientific, just balancing our willingness to accept load\n// with user willingness to put up with stale data\nexport const DEFAULT_CACHE_STRATEGY =\n  'public, max-age=5, stale-while-revalidate=10'\nconst MAX_EXPIRES_AT = 1_000 * YEAR_MS\n\ntype APIGenericSchema = {\n  // GET is for retrieval, POST is to mutate something, PUT is idempotent mutation (can be repeated safely)\n  method: 'GET' | 'POST' | 'PUT'\n  //private APIs can only be called from manifold. undocumented endpoints can change or be deleted at any time!\n  visibility: 'public' | 'undocumented' | 'private'\n  // whether the endpoint requires authentication\n  authed: boolean\n  // zod schema for the request body (or for params for GET requests)\n  props: z.ZodType\n  // note this has to be JSON serializable\n  returns?: Record<string, any>\n  // Cache-Control header. like, 'max-age=60'\n  cache?: string\n  // whether the endpoint should prefer authentication even if not required\n  preferAuth?: boolean\n}\n\nlet _apiTypeCheck: { [x: string]: APIGenericSchema }\nexport const API = (_apiTypeCheck = {\n  'refresh-all-clients': {\n    method: 'POST',\n    visibility: 'public',\n    props: z.object({ message: z.string().optional() }),\n    authed: true,\n  },\n  'toggle-system-trading-status': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        token: z.enum(['MANA', 'CASH']),\n      })\n      .strict(),\n    returns: {} as { status: boolean },\n  },\n  comment: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as ContractComment,\n    props: z\n      .object({\n        contractId: z.string(),\n        content: contentSchema.optional(),\n        html: z.string().optional(),\n        markdown: z.string().optional(),\n        replyToCommentId: z.string().optional(),\n        replyToAnswerId: z.string().optional(),\n        replyToBetId: z.string().optional(),\n      })\n      .strict(),\n  },\n\n  'follow-contract': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: true },\n    props: z\n      .object({\n        contractId: z.string(),\n        follow: z.boolean(),\n      })\n      .strict(),\n  },\n  'get-contract': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as Contract,\n    props: z\n      .object({\n        contractId: z.string(),\n      })\n      .strict(),\n  },\n  'answer/:answerId': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as Answer,\n    props: z.object({ answerId: z.string() }).strict(),\n  },\n  'market/:contractId/answers': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: [] as Answer[],\n    props: z.object({ contractId: z.string() }).strict(),\n  },\n  'hide-comment': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ commentPath: z.string() }).strict(),\n  },\n  'pin-comment': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({ commentPath: z.string() }).strict(),\n  },\n  comments: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    // cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as ContractComment[],\n    props: z\n      .object({\n        contractId: z.string().optional(),\n        contractSlug: z.string().optional(),\n        afterTime: z.coerce.number().optional(),\n        limit: z.coerce.number().gte(0).lte(1000).default(1000),\n        page: z.coerce.number().gte(0).default(0),\n        userId: z.string().optional(),\n        isPolitics: coerceBoolean.optional(),\n      })\n      .strict(),\n  },\n  bet: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as CandidateBet & { betId: string },\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gte(SWEEPS_MIN_BET),\n        replyToCommentId: z.string().optional(),\n        limitProb: z.number().gte(0.01).lte(0.99).optional(),\n        expiresMillisAfter: z.number().lt(MAX_EXPIRES_AT).optional(),\n        silent: z.boolean().optional(),\n        expiresAt: z.number().lt(MAX_EXPIRES_AT).optional(),\n        // Used for binary and new multiple choice contracts (cpmm-multi-1).\n        outcome: z.enum(['YES', 'NO']).default('YES'),\n        //Multi\n        answerId: z.string().optional(),\n        dryRun: z.boolean().optional(),\n        deps: z.array(z.string()).optional(),\n        deterministic: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  createuser: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { user: User; privateUser: PrivateUser },\n    props: z\n      .object({\n        deviceToken: z.string().optional(),\n        adminToken: z.string().optional(),\n        visitedContractIds: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'multi-bet': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as (CandidateBet & { betId: string })[],\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gte(1),\n        limitProb: z.number().gte(0).lte(1).optional(),\n        expiresAt: z.number().lt(MAX_EXPIRES_AT).optional(),\n        answerIds: z.array(z.string()).min(1),\n        deterministic: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  'multi-sell': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as (CandidateBet & { betId: string })[],\n    props: z\n      .object({\n        contractId: z.string(),\n        answerIds: z.array(z.string()).min(1),\n        deterministic: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  leaderboard: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as { userId: string; score: number }[],\n    props: z\n      .object({\n        groupId: z.string().optional(),\n        limit: z.coerce.number().min(1).max(100).default(50),\n        token: z.enum(['MANA', 'CASH']).default('MANA'),\n        kind: z.enum(['creator', 'profit', 'loss', 'volume', 'referral']),\n      })\n      .strict(),\n  },\n  'verify-phone-number': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { status: string },\n    props: z\n      .object({\n        phoneNumber: z.string(),\n        code: z.string(),\n      })\n      .strict(),\n  },\n  'request-otp': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { status: string },\n    props: z\n      .object({\n        phoneNumber: z.string(),\n      })\n      .strict(),\n  },\n  'bet/cancel/:betId': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ betId: z.string() }).strict(),\n    returns: {} as LimitBet,\n  },\n  // sell shares\n  'market/:contractId/sell': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as CandidateBet & { betId: string },\n    props: z\n      .object({\n        contractId: z.string(),\n        shares: z.number().positive().optional(), // leave it out to sell all shares\n        outcome: z.enum(['YES', 'NO']),\n        answerId: z.string().optional(), // Required for multi binary markets\n        deterministic: z.boolean().optional(),\n        deps: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'get-user-limit-orders-with-contracts': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as {\n      bets: LimitBet[]\n      contracts: MarketContract[]\n    },\n    props: z\n      .object({\n        userId: z.string(),\n        count: z.coerce.number().lte(5000),\n        includeExpired: coerceBoolean.optional().default(false),\n        includeCancelled: coerceBoolean.optional().default(false),\n        includeFilled: coerceBoolean.optional().default(false),\n      })\n      .strict(),\n  },\n  'get-interesting-groups-from-views': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as (Group & { hasBet: boolean })[],\n    props: z\n      .object({\n        userId: z.string(),\n        contractIds: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  bets: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Bet[],\n    props: z\n      .object({\n        id: z.string().optional(),\n        userId: z.string().optional(),\n        username: z.string().optional(),\n        contractId: z.string().or(z.array(z.string())).optional(),\n        contractSlug: z.string().optional(),\n        answerId: z.string().optional(),\n        // market: z.string().optional(), // deprecated, synonym for `contractSlug`\n        limit: z.coerce\n          .number()\n          .gte(0)\n          .lte(50000)\n          .default(NON_POINTS_BETS_LIMIT),\n        before: z.string().optional(),\n        after: z.string().optional(),\n        beforeTime: z.coerce.number().optional(),\n        afterTime: z.coerce.number().optional(),\n        order: z.enum(['asc', 'desc']).optional(),\n        kinds: z.enum(['open-limit']).optional(),\n        // undocumented fields. idk what a good api interface would be\n        filterRedemptions: coerceBoolean.optional(),\n        includeZeroShareRedemptions: coerceBoolean.optional(),\n        commentRepliesOnly: coerceBoolean.optional(),\n        count: coerceBoolean.optional(),\n        points: coerceBoolean.optional(),\n      })\n      .strict(),\n  },\n  'bet-points': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: 'public, max-age=600, stale-while-revalidate=60',\n    returns: [] as Bet[],\n    props: z\n      .object({\n        contractId: z.string(),\n        answerId: z.string().optional(),\n        limit: z.coerce.number().gte(0).lte(50000).default(5000),\n        beforeTime: z.coerce.number(),\n        afterTime: z.coerce.number(),\n        filterRedemptions: coerceBoolean.optional(),\n        includeZeroShareRedemptions: coerceBoolean.optional(),\n      })\n      .strict(),\n  },\n  'unique-bet-group-count': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as { count: number },\n    props: z\n      .object({\n        contractId: z.string(),\n      })\n      .strict(),\n  },\n  'get-daily-changed-metrics-and-contracts': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    cache: 'public, max-age=900, stale-while-revalidate=90', // 15 minute cache\n    props: z\n      .object({\n        limit: z.coerce.number(),\n        userId: z.string(),\n        balance: z.coerce.number(),\n      })\n      .strict(),\n    returns: {} as {\n      manaMetrics: ContractMetric[]\n      contracts: MarketContract[]\n      manaProfit: number\n      manaInvestmentValue: number\n      balance: number\n    },\n  },\n  // deprecated. use /bets?username= instead\n  'user/:username/bets': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Bet[],\n    props: z\n      .object({\n        username: z.string(),\n        limit: z.coerce.number().gte(0).lte(1000).default(1000),\n      })\n      .strict(),\n  },\n  'group/:slug': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as Group,\n    props: z.object({ slug: z.string() }),\n  },\n  'group/:slug/groups': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as { above: LiteGroup[]; below: LiteGroup[] },\n    props: z.object({ slug: z.string() }).strict(),\n  },\n  'group/:slug/dashboards': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as {\n      id: string\n      title: string\n      slug: string\n      creatorId: string\n    }[],\n    props: z.object({ slug: z.string() }).strict(),\n  },\n  'group/by-id/:id/groups': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as { above: LiteGroup[]; below: LiteGroup[] },\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'group/by-id/:id': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as Group,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  // deprecated. use /markets?groupId= instead\n  'group/by-id/:id/markets': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as LiteMarket[],\n    props: z\n      .object({\n        id: z.string(),\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n      })\n      .strict(),\n  },\n  'group/:slug/delete': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ slug: z.string() }),\n  },\n  'group/by-id/:id/delete': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ id: z.string() }),\n  },\n  'group/:slug/block': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ slug: z.string() }),\n  },\n  'group/:slug/unblock': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ slug: z.string() }).strict(),\n  },\n  'group/by-id/:topId/group/:bottomId': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        topId: z.string(),\n        bottomId: z.string(),\n        remove: z.boolean().optional(),\n      })\n      .strict(),\n    returns: {} as { status: 'success' },\n  },\n  groups: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Group[],\n    props: z\n      .object({\n        availableToUserId: z.string().optional(),\n        beforeTime: z.coerce.number().int().optional(),\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n      })\n      .strict(),\n  },\n  'market/:id': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as LiteMarket | FullMarket,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z.object({ id: z.string(), lite: coerceBoolean.optional() }),\n  },\n  'market/:id/prob': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as {\n      prob?: number\n      answerProbs?: { [answerId: string]: number }\n    },\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'market-probs': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as {\n      [contractId: string]: {\n        prob?: number\n        answerProbs?: { [answerId: string]: number }\n      }\n    },\n    props: z\n      .object({\n        ids: z.array(z.string()).max(100),\n      })\n      .strict(),\n  },\n  'markets-by-ids': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: [] as Contract[],\n    props: z\n      .object({\n        ids: z.array(z.string()).max(100),\n      })\n      .strict(),\n  },\n  // deprecated. use /market/:id?lite=true instead\n  'market/:id/lite': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as LiteMarket,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z.object({ id: z.string() }),\n  },\n  'slug/:slug': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as LiteMarket | FullMarket,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z.object({ slug: z.string(), lite: coerceBoolean.optional() }),\n  },\n  market: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as LiteMarket,\n    props: createMarketProps,\n  },\n  'market/:contractId/update': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: updateMarketProps,\n    returns: {} as { success: true },\n  },\n  'market/:contractId/close': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    // returns: {} as LiteMarket,\n    props: z\n      .object({\n        contractId: z.string(),\n        closeTime: z.number().int().nonnegative().optional(),\n      })\n      .strict(),\n  },\n  'market/:contractId/resolve': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { message: string },\n    props: resolveMarketProps,\n  },\n  'market/:contractId/add-liquidity': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as LiquidityProvision,\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gt(0).finite(),\n      })\n      .strict(),\n  },\n  'market/:contractId/remove-liquidity': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as LiquidityProvision,\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gt(0).finite(),\n      })\n      .strict(),\n  },\n  'market/:contractId/add-bounty': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as Txn,\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gt(0).finite(),\n      })\n      .strict(),\n  },\n  'market/:contractId/award-bounty': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as Txn,\n    props: z\n      .object({\n        contractId: z.string(),\n        commentId: z.string(),\n        amount: z.number().gt(0).finite(),\n      })\n      .strict(),\n  },\n  'market/:contractId/group': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        contractId: z.string(),\n        groupId: z.string(),\n        remove: z.boolean().default(false),\n      })\n      .strict(),\n    returns: {} as { success: true },\n  },\n  'market/:contractId/groups': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({ contractId: z.string() }),\n    returns: [] as LiteGroup[],\n  },\n  'market/:contractId/answer': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { newAnswerId: string },\n    props: z\n      .object({\n        contractId: z.string().max(MAX_ANSWER_LENGTH),\n        text: z.string().min(1).max(MAX_ANSWER_LENGTH),\n      })\n      .strict(),\n  },\n  'market/:contractId/block': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ contractId: z.string() }).strict(),\n  },\n  'market/:contractId/unblock': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ contractId: z.string() }).strict(),\n  },\n  unresolve: {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { success: true },\n    props: z\n      .object({\n        contractId: z.string().max(MAX_ANSWER_LENGTH),\n        answerId: z.string().max(MAX_ANSWER_LENGTH).optional(),\n      })\n      .strict(),\n  },\n  leagues: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as League[],\n    props: z\n      .object({\n        userId: z.string().optional(),\n        cohort: z.string().optional(),\n        season: z.coerce.number().optional(),\n      })\n      .strict(),\n  },\n  markets: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as LiteMarket[],\n    props: z\n      .object({\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n        sort: z\n          .enum([\n            'created-time',\n            'updated-time',\n            'last-bet-time',\n            'last-comment-time',\n          ])\n          .optional(),\n        order: z.enum(['asc', 'desc']).optional(),\n        before: z.string().optional(),\n        userId: z.string().optional(),\n        groupId: z.string().optional(),\n      })\n      .strict(),\n  },\n  'search-markets': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as LiteMarket[],\n    props: searchProps,\n  },\n  'search-markets-full': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    preferAuth: true,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Contract[],\n    props: searchProps,\n  },\n  managram: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        amount: z.number().finite(),\n        toIds: z.array(z.string()),\n        message: z.string().max(MAX_COMMENT_LENGTH),\n        groupId: z.string().max(MAX_ID_LENGTH).optional(),\n        token: z.enum(['M$', 'CASH']).default('M$'),\n      })\n      .strict(),\n  },\n  manalink: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { slug: string },\n    props: z\n      .object({\n        amount: z.number().positive().finite().safe(),\n        expiresTime: z.number().lt(MAX_EXPIRES_AT).optional(),\n        maxUses: z.number().optional(),\n        message: z.string().optional(),\n      })\n      .strict(),\n  },\n  donate: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        amount: z.number().positive().finite().safe(),\n        to: z.string(),\n      })\n      .strict(),\n  },\n  'convert-sp-to-mana': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ amount: z.number().positive().finite().safe() }).strict(),\n  },\n  'convert-cash-to-mana': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ amount: z.number().positive().finite().safe() }).strict(),\n  },\n  'request-loan': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({}),\n    returns: {} as { payout: number },\n  },\n  // deprecated. use /txns instead\n  managrams: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: [] as ManaPayTxn[],\n    props: z\n      .object({\n        toId: z.string().optional(),\n        fromId: z.string().optional(),\n        limit: z.coerce.number().gte(0).lte(100).default(100),\n        before: z.coerce.number().optional(),\n        after: z.coerce.number().optional(),\n      })\n      .strict(),\n  },\n  'market/:id/positions': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as ContractMetric[],\n    props: z\n      .object({\n        id: z.string(),\n        userId: z.string().optional(),\n        answerId: z.string().optional(),\n        summaryOnly: z.boolean().optional(),\n        top: z.undefined().or(z.coerce.number()),\n        bottom: z.undefined().or(z.coerce.number()),\n        order: z.enum(['shares', 'profit']).optional(),\n      })\n      .strict(),\n  },\n  me: {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z.object({}),\n    returns: {} as FullUser,\n  },\n  'me/update': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({\n      name: z.string().trim().min(1).optional(),\n      username: z.string().trim().min(1).optional(),\n      avatarUrl: z.string().optional(),\n      bio: z.string().optional(),\n      website: z.string().optional(),\n      twitterHandle: z.string().optional(),\n      discordHandle: z.string().optional(),\n      // settings\n      optOutBetWarnings: z.boolean().optional(),\n      isAdvancedTrader: z.boolean().optional(),\n      //internal\n      seenStreakModal: z.boolean().optional(),\n      shouldShowWelcome: z.boolean().optional(),\n      hasSeenContractFollowModal: z.boolean().optional(),\n      hasSeenLoanModal: z.boolean().optional(),\n    }),\n    returns: {} as FullUser,\n  },\n  'me/delete': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({\n      username: z.string(), // just so you're sure\n    }),\n  },\n  'me/private': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z.object({}),\n    returns: {} as PrivateUser,\n  },\n  'me/private/update': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    props: z\n      .object({\n        email: z.string().email().optional(),\n        apiKey: z.string().optional(),\n        pushToken: z.string().optional(),\n        rejectedPushNotificationsOn: z.number().optional(),\n        lastPromptedToEnablePushNotifications: z.number().optional(),\n        interestedInPushNotifications: z.boolean().optional(),\n        hasSeenAppBannerInNotificationsOn: z.number().optional(),\n        installedAppPlatforms: z.array(z.string()).optional(),\n        paymentInfo: z.string().optional(),\n        lastAppReviewTime: z.number().optional(),\n      })\n      .strict(),\n  },\n  'user/:username': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as FullUser,\n    props: z.object({ username: z.string() }).strict(),\n  },\n  'user/:username/lite': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as DisplayUser,\n    props: z.object({ username: z.string() }).strict(),\n  },\n  'user/by-id/:id': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    // Do not add a caching strategy here. New users need up-to-date data.\n    returns: {} as FullUser,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'user/by-id/:id/lite': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as DisplayUser,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'users/by-id': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as DisplayUser[],\n    props: z.object({ ids: z.array(z.string()) }).strict(),\n  },\n  'users/by-id/balance': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as { id: string; balance: number }[],\n    props: z.object({ ids: z.array(z.string()) }).strict(),\n  },\n  'user/by-id/:id/block': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'user/by-id/:id/unblock': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  users: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as FullUser[],\n    props: z\n      .object({\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n        before: z.string().optional(),\n      })\n      .strict(),\n  },\n  'search-users': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as FullUser[],\n    props: z\n      .object({\n        term: z.string(),\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n        page: z.coerce.number().gte(0).default(0),\n      })\n      .strict(),\n  },\n  'search-contract-positions': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as DisplayUser[],\n    props: z\n      .object({\n        term: z.string(),\n        contractId: z.string(),\n        limit: z.coerce.number().gte(0).lte(100).default(10),\n      })\n      .strict(),\n  },\n  'save-twitch': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        twitchInfo: z.object({\n          twitchName: z.string().optional(),\n          controlToken: z.string().optional(),\n          botEnabled: z.boolean().optional(),\n          needsRelinking: z.boolean().optional(),\n        }),\n      })\n      .strict(),\n  },\n  'set-push-token': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({ pushToken: z.string() }).strict(),\n  },\n  'update-notif-settings': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      type: z.string() as z.ZodType<notification_preference>,\n      medium: z.enum(['email', 'browser', 'mobile']),\n      enabled: z.boolean(),\n    }),\n  },\n  headlines: {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: [] as Headline[],\n    props: z.object({\n      slug: z.enum(['politics', 'ai', 'news']).optional(),\n    }),\n  },\n  'politics-headlines': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: [] as Headline[],\n    props: z.object({}),\n  },\n  'set-news': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { success: true },\n    props: z\n      .object({\n        dashboardIds: z.array(z.string()),\n        endpoint: z.enum(['politics', 'ai', 'news']),\n      })\n      .strict(),\n  },\n  react: {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        contentId: z.string(),\n        contentType: z.enum(['comment', 'contract']),\n        remove: z.boolean().optional(),\n        reactionType: z.enum(['like', 'dislike']).optional().default('like'),\n      })\n      .strict(),\n    returns: { success: true },\n  },\n  'compatible-lovers': {\n    method: 'GET',\n    visibility: 'private',\n    authed: false,\n    props: z.object({ userId: z.string() }),\n    returns: {} as {\n      lover: Lover\n      compatibleLovers: Lover[]\n      loverCompatibilityScores: {\n        [userId: string]: CompatibilityScore\n      }\n    },\n  },\n  post: {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    returns: {} as ContractComment,\n    props: z\n      .object({\n        contractId: z.string(),\n        betId: z.string().optional(),\n        commentId: z.string().optional(),\n        content: contentSchema.optional(),\n      })\n      .strict(),\n  },\n  'fetch-link-preview': {\n    method: 'GET',\n    visibility: 'private',\n    authed: false,\n    props: z.object({ url: z.string() }).strict(),\n    cache: 'max-age=86400, stale-while-revalidate=86400',\n    returns: {} as LinkPreview,\n  },\n  'remove-pinned-photo': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    returns: { success: true },\n    props: z\n      .object({\n        userId: z.string(),\n      })\n      .strict(),\n  },\n  'get-related-markets': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    props: z\n      .object({\n        contractId: z.string(),\n        limit: z.coerce.number().gte(0).lte(100),\n        userId: z.string().optional(),\n        question: z.string().optional(),\n        uniqueBettorCount: z.coerce.number().gte(0).optional(),\n      })\n      .strict(),\n    returns: {} as {\n      marketsFromEmbeddings: Contract[]\n    },\n    cache: 'public, max-age=3600, stale-while-revalidate=10',\n  },\n  'get-related-markets-by-group': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: 'public, max-age=3600, stale-while-revalidate=10',\n    returns: {} as {\n      groupContracts: Contract[]\n    },\n    props: z\n      .object({\n        contractId: z.string(),\n        limit: z.coerce.number().gte(0).lte(100),\n        offset: z.coerce.number().gte(0),\n      })\n      .strict(),\n  },\n  'unlist-and-cancel-user-contracts': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        userId: z.string(),\n      })\n      .strict(),\n  },\n  'get-boost-analytics': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: false,\n    props: z\n      .object({\n        contractId: z.string(),\n      })\n      .strict(),\n    returns: {} as {\n      uniqueViewers: number\n      totalViews: number\n      uniquePromotedViewers: number\n      totalPromotedViews: number\n      boostPeriods: {\n        startTime: string\n        endTime: string\n      }[]\n    },\n  },\n  'get-seen-market-ids': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      contractIds: z.array(z.string()),\n      types: z.array(z.enum(['page', 'card', 'promoted'])).optional(),\n      since: z.number(),\n    }),\n    returns: [] as string[],\n  },\n  'get-compatibility-questions': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({}),\n    returns: {} as {\n      status: 'success'\n      questions: (Row<'love_questions'> & {\n        answer_count: number\n        score: number\n      })[]\n    },\n  },\n  'like-lover': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    props: z.object({\n      targetUserId: z.string(),\n      remove: z.boolean().optional(),\n    }),\n    returns: {} as {\n      status: 'success'\n    },\n  },\n  'ship-lovers': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    props: z.object({\n      targetUserId1: z.string(),\n      targetUserId2: z.string(),\n      remove: z.boolean().optional(),\n    }),\n    returns: {} as {\n      status: 'success'\n    },\n  },\n\n  'get-likes-and-ships': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z\n      .object({\n        userId: z.string(),\n      })\n      .strict(),\n    returns: {} as {\n      status: 'success'\n      likesReceived: LikeData[]\n      likesGiven: LikeData[]\n      ships: ShipData[]\n    },\n  },\n  'has-free-like': {\n    method: 'GET',\n    visibility: 'private',\n    authed: true,\n    props: z.object({}).strict(),\n    returns: {} as {\n      status: 'success'\n      hasFreeLike: boolean\n    },\n  },\n  'star-lover': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    props: z.object({\n      targetUserId: z.string(),\n      remove: z.boolean().optional(),\n    }),\n    returns: {} as {\n      status: 'success'\n    },\n  },\n  'get-lovers': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({}).strict(),\n    returns: {} as {\n      status: 'success'\n      lovers: Lover[]\n    },\n  },\n  'get-lover-answers': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({ userId: z.string() }).strict(),\n    returns: {} as {\n      status: 'success'\n      answers: Row<'love_compatibility_answers'>[]\n    },\n  },\n  'search-groups': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    // Is there a way to infer return { lite:[] as LiteGroup[] } if type is 'lite'?\n    returns: {\n      full: [] as Group[],\n      lite: [] as LiteGroup[],\n    },\n    props: SearchGroupParams(SearchGroupShape),\n  },\n  'search-my-groups': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {\n      full: [] as Group[],\n      lite: [] as LiteGroup[],\n    },\n    props: SearchGroupParams(MySearchGroupShape),\n  },\n  'get-groups-with-top-contracts': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as { topic: Topic; contracts: Contract[] }[],\n    props: z.object({}),\n  },\n  'get-balance-changes': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: [] as AnyBalanceChangeType[],\n    props: z\n      .object({\n        before: z.coerce.number().optional(),\n        after: z.coerce.number().default(0),\n        userId: z.string(),\n      })\n      .strict(),\n  },\n  'get-partner-stats': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z\n      .object({\n        userId: z.string(),\n      })\n      .strict(),\n    returns: {} as {\n      status: 'success' | 'error'\n      username: string\n      numContractsCreated: number\n      numUniqueBettors: number\n      numReferrals: number\n      numReferralsWhoRetained: number\n      totalTraderIncome: number\n      totalReferralIncome: number\n      dollarsEarned: number\n    },\n  },\n  'record-contract-view': {\n    method: 'POST',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      userId: z.string().optional(),\n      contractId: z.string(),\n      kind: z.enum(['page', 'card', 'promoted']),\n    }),\n    returns: {} as { status: 'success' },\n  },\n  'record-comment-view': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({\n      contractId: z.string(),\n      commentId: z.string(),\n    }),\n    returns: {} as { status: 'success' },\n  },\n  'record-contract-interaction': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({\n      contractId: z.string(),\n      kind: z.enum([\n        'page bet',\n        'page comment',\n        'page repost',\n        'page like',\n        'card bet',\n        'card click',\n        'promoted click',\n        'card like',\n        'page share',\n        'browse click',\n      ]),\n      commentId: z.string().optional(),\n      feedReasons: z.array(z.string()).optional(),\n      feedType: z.string().optional(),\n      betGroupId: z.string().optional(),\n      betId: z.string().optional(),\n    }),\n    returns: {} as { status: 'success' },\n  },\n  'get-dashboard-from-slug': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      dashboardSlug: z.string(),\n    }),\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as Dashboard,\n  },\n  'create-public-chat-message': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as ChatMessage,\n    props: z.object({\n      content: contentSchema,\n      channelId: z.string(),\n    }),\n  },\n  'get-followed-groups': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      userId: z.string(),\n    }),\n    returns: {} as {\n      groups: Group[]\n    },\n  },\n  'get-user-portfolio': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      userId: z.string(),\n    }),\n    returns: {} as LivePortfolioMetrics,\n  },\n  'get-user-portfolio-history': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      userId: z.string(),\n      period: z.enum(PERIODS),\n    }),\n    returns: {} as PortfolioMetrics[],\n  },\n  'get-channel-memberships': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      channelId: z.coerce.number().optional(),\n      createdTime: z.string().optional(),\n      lastUpdatedTime: z.string().optional(),\n      limit: z.coerce.number(),\n    }),\n    returns: {\n      channels: [] as PrivateMessageChannel[],\n      memberIdsByChannelId: {} as { [channelId: string]: string[] },\n    },\n  },\n  'get-channel-messages': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      channelId: z.coerce.number(),\n      limit: z.coerce.number(),\n      id: z.coerce.number().optional(),\n    }),\n    returns: [] as PrivateChatMessage[],\n  },\n  'get-channel-seen-time': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      channelIds: z.array(z.coerce.number()),\n    }),\n    returns: [] as [number, string][],\n  },\n  'set-channel-seen-time': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      channelId: z.coerce.number(),\n    }),\n  },\n  'get-feed': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as {\n      contracts: Contract[]\n      comments: ContractComment[]\n      bets: Bet[]\n      reposts: Repost[]\n      idsToReason: { [id: string]: string }\n    },\n    props: z\n      .object({\n        userId: z.string(),\n        limit: z.coerce.number().gt(0).lte(100).default(100),\n        offset: z.coerce.number().gte(0).default(0),\n        ignoreContractIds: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'get-mana-supply': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as ManaSupply,\n    props: z.object({}).strict(),\n  },\n  'get-notifications': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as Notification[],\n    props: z\n      .object({\n        after: z.coerce.number().optional(),\n        limit: z.coerce.number().gte(0).lte(1000).default(100),\n      })\n      .strict(),\n  },\n  'update-mod-report': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        reportId: z.number(),\n        updates: z\n          .object({\n            status: z\n              .enum(['new', 'under review', 'resolved', 'needs admin'])\n              .optional(),\n            mod_note: z.string().optional(),\n          })\n          .partial(),\n      })\n      .strict(),\n    returns: {} as { status: string; report: ModReport },\n  },\n  'get-mod-reports': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        statuses: z.array(\n          z.enum(['new', 'under review', 'resolved', 'needs admin'])\n        ),\n        limit: z.coerce.number().gte(0).lte(100).default(25),\n        offset: z.coerce.number().gte(0).default(0),\n        count: coerceBoolean.optional(),\n      })\n      .strict(),\n    returns: {} as {\n      status: string\n      count?: number\n      reports: ModReport[]\n    },\n  },\n  'get-txn-summary-stats': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as Row<'txn_summary_stats'>[],\n    props: z\n      .object({\n        ignoreCategories: z.array(z.string()).optional(),\n        fromType: z.string().optional(),\n        toType: z.string().optional(),\n        limitDays: z.coerce.number(),\n      })\n      .strict(),\n  },\n  'get-mana-summary-stats': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as Row<'mana_supply_stats'>[],\n    props: z\n      .object({\n        limitDays: z.coerce.number(),\n      })\n      .strict(),\n  },\n  'register-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: verificationParams,\n    returns: {} as RegistrationReturnType,\n  },\n  'get-verification-status-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      documents?: GIDXDocument[]\n      message?: string\n      documentStatus?: string\n    },\n    props: z.object({}),\n  },\n  'get-monitor-status-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n    },\n    props: z.object({\n      DeviceGPS: GPSProps,\n    }),\n  },\n  'get-checkout-session-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n      session?: CheckoutSession\n    },\n    props: z.object({\n      PayActionCode: z.enum(['PAY', 'PAYOUT']).default('PAY'),\n      DeviceGPS: GPSProps,\n      userId: z.string().optional(),\n      ip: z.string().optional(),\n    }),\n  },\n  'complete-checkout-session-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n      gidxMessage?: string | null\n      details?: PaymentDetail[]\n    },\n    props: z.object(checkoutParams),\n  },\n  'complete-cashout-session-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n      gidxMessage?: string | null\n      details?: PaymentDetail[]\n    },\n    props: z.object(cashoutParams),\n  },\n  'complete-cashout-request': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n      gidxMessage?: string | null\n      details?: PaymentDetail[]\n    },\n    props: z.object(cashoutRequestParams),\n  },\n  'get-verification-documents-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      documents: GIDXDocument[]\n      utilityDocuments: GIDXDocument[]\n      idDocuments: GIDXDocument[]\n      rejectedDocuments: GIDXDocument[]\n    },\n    props: z.object({}),\n  },\n  'upload-document-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { status: string },\n    props: z.object({\n      CategoryType: z.number().gte(1).lte(7),\n      fileName: z.string(),\n      fileUrl: z.string(),\n    }),\n  },\n  'identity-callback-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as { Accepted: boolean },\n    props: z.object({\n      MerchantCustomerID: z.string(),\n      NotificationType: z.string(),\n    }),\n  },\n  'payment-callback-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as { MerchantTransactionID: string },\n    props: z\n      .object({\n        MerchantTransactionID: z.string(),\n        TransactionStatusCode: z.coerce.number(),\n        TransactionStatusMessage: z.string(),\n        StatusCode: z.coerce.number(),\n        SessionID: z.string(),\n        MerchantSessionID: z.string(),\n        SessionScore: z.coerce.number(),\n        ReasonCodes: z.array(z.string()).optional(),\n        ServiceType: z.string(),\n        StatusMessage: z.string(),\n      })\n      .strict(),\n  },\n  'get-best-comments': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { comments: ContractComment[]; contracts: Contract[] },\n    props: z.object({\n      limit: z.coerce.number().gte(0).lte(100).default(20),\n      offset: z.coerce.number().gte(0).default(0),\n      ignoreContractIds: z.array(z.string()).optional(),\n      justLikes: z.coerce.number().optional(),\n    }),\n  },\n  'get-redeemable-prize-cash': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { redeemablePrizeCash: number },\n    props: z.object({}),\n  },\n  'get-total-redeemable-prize-cash': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as { total: number },\n    props: z.object({}),\n  },\n  'get-cashouts': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as PendingCashoutStatusData[],\n    props: z\n      .object({\n        limit: z.coerce.number().gte(0).lte(100).default(10),\n        offset: z.coerce.number().gte(0).default(0),\n        userId: z.string().optional(),\n      })\n      .strict(),\n  },\n  'get-kyc-stats': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({}),\n    returns: {} as {\n      initialVerifications: {\n        count: number\n        day: string\n      }[]\n      phoneVerifications: {\n        count: number\n        day: string\n      }[]\n    },\n  },\n  txns: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z\n      .object({\n        token: z.string().optional(),\n        offset: z.coerce.number().default(0),\n        limit: z.coerce.number().gte(0).lte(100).default(100),\n        before: z.coerce.number().optional(),\n        after: z.coerce.number().optional(),\n        toId: z.string().optional(),\n        fromId: z.string().optional(),\n        category: z.string().optional(),\n        ignoreCategories: z.array(z.string()).optional(),\n      })\n      .strict(),\n    returns: [] as Txn[],\n  },\n  'generate-ai-market-suggestions': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: [] as AIGeneratedMarket[],\n    props: z\n      .object({\n        prompt: z.string(),\n        existingTitles: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'generate-ai-market-suggestions-2': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: [] as AIGeneratedMarket[],\n    props: z\n      .object({\n        prompt: z.string(),\n        existingTitles: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'generate-ai-description': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { description: JSONContent | undefined },\n    props: z\n      .object({\n        question: z.string(),\n        description: z.string().optional(),\n        answers: z.array(z.string()).optional(),\n        outcomeType: z.string().optional(),\n        shouldAnswersSumToOne: coerceBoolean.optional(),\n        addAnswersMode: z\n          .enum(['DISABLED', 'ONLY_CREATOR', 'ANYONE'])\n          .optional(),\n      })\n      .strict(),\n  },\n  'generate-ai-answers': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as {\n      answers: string[]\n      addAnswersMode: 'DISABLED' | 'ONLY_CREATOR' | 'ANYONE'\n    },\n    props: z\n      .object({\n        question: z.string(),\n        answers: z.array(z.string()),\n        shouldAnswersSumToOne: coerceBoolean,\n        description: z.string().optional(),\n      })\n      .strict(),\n  },\n  'get-monthly-bets-2024': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ userId: z.string() }),\n    returns: [] as { month: string; bet_count: number; total_amount: number }[],\n  },\n  'get-max-min-profit-2024': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ userId: z.string() }),\n    returns: [] as {\n      profit: number\n      data: Contract\n      answer_id: string | null\n      has_no_shares: boolean\n      has_yes_shares: boolean\n    }[],\n  },\n  'get-next-loan-amount': {\n    method: 'GET',\n    visibility: 'undocumented',\n    cache: DEFAULT_CACHE_STRATEGY,\n    authed: false,\n    returns: {} as { amount: number },\n    props: z.object({\n      userId: z.string(),\n    }),\n  },\n  'create-task': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as Task,\n    props: z\n      .object({\n        text: z.string(),\n        category_id: z.number().optional(),\n        priority: z.number().default(0),\n        assignee_id: z.string().optional(),\n      })\n      .strict(),\n  },\n  'update-task': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z\n      .object({\n        id: z.number(),\n        text: z.string().optional(),\n        completed: z.boolean().optional(),\n        priority: z.number().optional(),\n        category_id: z.number().optional(),\n        archived: z.boolean().optional(),\n        assignee_id: z.string().optional(),\n      })\n      .strict(),\n  },\n  'create-category': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { id: number },\n    props: z\n      .object({\n        name: z.string(),\n        color: z.string().optional(),\n        displayOrder: z.number().optional(),\n      })\n      .strict(),\n  },\n  'get-categories': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { categories: TaskCategory[] },\n    props: z.object({}).strict(),\n  },\n  'update-category': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z\n      .object({\n        categoryId: z.number(),\n        name: z.string().optional(),\n        color: z.string().optional(),\n        displayOrder: z.number().optional(),\n        archived: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  'get-tasks': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { tasks: Task[] },\n    props: z.object({}).strict(),\n  },\n  'is-sports-interested': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { isSportsInterested: boolean },\n    props: z.object({}).strict(),\n  },\n  'get-site-activity': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as {\n      bets: Bet[]\n      comments: CommentWithTotalReplies[]\n      newContracts: Contract[]\n      relatedContracts: Contract[]\n    },\n    props: z\n      .object({\n        limit: z.coerce.number().default(10),\n        offset: z.coerce.number().default(0),\n        blockedUserIds: z.array(z.string()).optional(),\n        blockedGroupSlugs: z.array(z.string()).optional(),\n        blockedContractIds: z.array(z.string()).optional(),\n        topicIds: z.array(z.string()).optional(),\n        types: z\n          .array(z.enum(['bets', 'comments', 'markets', 'limit-orders']))\n          .optional(),\n        minBetAmount: z.coerce.number().optional(),\n        onlyFollowedTopics: coerceBoolean.optional(),\n        onlyFollowedContracts: coerceBoolean.optional(),\n        onlyFollowedUsers: coerceBoolean.optional(),\n        userId: z.string().optional(),\n      })\n      .strict(),\n  },\n  'get-sports-games': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { schedule: any[] },\n    props: z.object({}).strict(),\n  },\n  'get-market-props': {\n    method: 'GET',\n    visibility: 'public',\n    cache: DEFAULT_CACHE_STRATEGY,\n    // Could set authed false and preferAuth with an api secret if we want it to replace static props\n    authed: true,\n    returns: {} as {\n      manaContract: MarketContract\n      chartAnnotations: ChartAnnotation[]\n      topics: Topic[]\n      comments: ContractComment[]\n      pinnedComments: ContractComment[]\n      userPositionsByOutcome: {\n        YES: ContractMetric[]\n        NO: ContractMetric[]\n      }\n      topContractMetrics: ContractMetric[]\n      totalPositions: number\n      dashboards: Dashboard[]\n      cashContract: MarketContract\n      totalManaBets: number\n      totalCashBets: number\n    },\n    props: z.object({\n      slug: z.string().optional(),\n      id: z.string().optional(),\n    }),\n  },\n  'get-user-contract-metrics-with-contracts': {\n    method: 'GET',\n    visibility: 'public',\n    preferAuth: true,\n    authed: false,\n    returns: {} as {\n      metricsByContract: Dictionary<ContractMetric[]>\n      contracts: MarketContract[]\n    },\n    props: z.object({\n      userId: z.string(),\n      limit: z.coerce.number(),\n      offset: z.coerce.number().gte(0).optional(),\n      perAnswer: coerceBoolean.optional(),\n      inMani: coerceBoolean.optional(),\n    }),\n  },\n  validateIap: {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z.object({\n      receipt: z.string(),\n    }),\n  },\n  'check-sports-event': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as { exists: boolean; existingMarket?: LiteMarket },\n    props: z\n      .object({\n        sportsEventId: z.string(),\n      })\n      .strict(),\n  },\n  'comment-reactions': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Reaction[],\n    props: z\n      .object({\n        contentIds: z.array(z.string()),\n        contentType: z.enum(['comment', 'contract']),\n      })\n      .strict(),\n  },\n  'mark-all-notifications-new': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({}).strict(),\n    returns: {} as { success: boolean },\n  },\n  'get-contract-voters': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z\n      .object({\n        contractId: z.string(),\n      })\n      .strict(),\n    returns: [] as DisplayUser[],\n  },\n  'get-contract-option-voters': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({ contractId: z.string(), optionId: z.string() }),\n    returns: [] as DisplayUser[],\n  },\n  'purchase-contract-boost': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        contractId: z.string(),\n        startTime: z.number().positive().finite().safe(),\n        method: z.enum(['mana', 'cash']),\n      })\n      .strict(),\n    returns: {} as { success: boolean; checkoutUrl?: string },\n  },\n  'generate-ai-numeric-ranges': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as {\n      thresholds: { answers: string[]; midpoints: number[] }\n      buckets: { answers: string[]; midpoints: number[] }\n    },\n    props: z\n      .object({\n        question: z.string(),\n        min: z.number(),\n        max: z.number(),\n        description: z.string().optional(),\n        unit: z.string(),\n      })\n      .strict(),\n  },\n  'infer-numeric-unit': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as {\n      unit: string\n    },\n    props: z\n      .object({\n        question: z.string(),\n        description: z.string().optional(),\n      })\n      .strict(),\n  },\n  'generate-ai-date-ranges': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as {\n      buckets: { answers: string[]; midpoints: number[] }\n      thresholds: { answers: string[]; midpoints: number[] }\n    },\n    props: z\n      .object({\n        question: z.string(),\n        min: z.string(),\n        max: z.string(),\n        description: z.string().optional(),\n      })\n      .strict(),\n  },\n  'regenerate-numeric-midpoints': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { midpoints: number[] },\n    props: z\n      .object({\n        description: z.string().optional(),\n        question: z.string(),\n        answers: z.array(z.string()),\n        min: z.number(),\n        max: z.number(),\n        unit: z.string(),\n        tab: z.enum(['thresholds', 'buckets']),\n      })\n      .strict(),\n  },\n  'regenerate-date-midpoints': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { midpoints: number[] },\n    props: z\n      .object({\n        description: z.string().optional(),\n        question: z.string(),\n        answers: z.array(z.string()),\n        min: z.string(),\n        max: z.string(),\n        tab: z.enum(['thresholds', 'buckets']),\n      })\n      .strict(),\n  },\n\n  'generate-concise-title': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        question: z.string(),\n      })\n      .strict(),\n    returns: {} as { title: string },\n  },\n  'get-close-date': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        question: z.string(),\n        utcOffset: z.number().optional(),\n      })\n      .strict(),\n    returns: {} as { closeTime: number },\n  },\n  'refer-user': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        referredByUsername: z.string(),\n        contractId: z.string().optional(),\n      })\n      .strict(),\n    returns: {} as { success: boolean },\n  },\n\n  'save-market-draft': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { id: number },\n    props: z\n      .object({\n        data: z.object({\n          question: z.string(),\n          description: z.any().optional(),\n          outcomeType: z.string(),\n          answers: z.array(z.string()).optional(),\n          closeDate: z.string().optional(),\n          closeHoursMinutes: z.string().optional(),\n          visibility: z.string(),\n          selectedGroups: z.array(z.any()),\n          savedAt: z.number(),\n        }),\n      })\n      .strict(),\n  },\n\n  'get-market-drafts': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: [] as MarketDraft[],\n    props: z.object({}).strict(),\n  },\n\n  'delete-market-draft': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z\n      .object({\n        id: z.coerce.number(),\n      })\n      .strict(),\n  },\n  'get-season-info': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      season: z.coerce.number().int().positive().optional(),\n    }),\n    returns: {} as {\n      season: number\n      startTime: number // epoch ms\n      endTime: number | null // epoch ms, null if a *mystery* for clients\n      status: 'active' | 'processing' | 'complete'\n    },\n  },\n  'mark-notification-read': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z\n      .object({\n        notificationId: z.string(),\n      })\n      .strict(),\n  },\n} as const)\n\nexport type APIPath = keyof typeof API\nexport type APISchema<N extends APIPath> = (typeof API)[N]\n\nexport type APIParams<N extends APIPath> = z.input<APISchema<N>['props']>\nexport type ValidatedAPIParams<N extends APIPath> = z.output<\n  APISchema<N>['props']\n>\n\nexport type APIResponse<N extends APIPath> = APISchema<N> extends {\n  returns: Record<string, any>\n}\n  ? APISchema<N>['returns']\n  : void\n\nexport type APIResponseOptionalContinue<N extends APIPath> =\n  | { continue: () => Promise<void>; result: APIResponse<N> }\n  | APIResponse<N>\n",
          "postContent": "import { z } from 'zod'\nimport {\n  Group,\n  MAX_ID_LENGTH,\n  MySearchGroupShape,\n  LiteGroup,\n  SearchGroupParams,\n  SearchGroupShape,\n  Topic,\n} from 'common/group'\nimport {\n  createMarketProps,\n  resolveMarketProps,\n  type LiteMarket,\n  FullMarket,\n  updateMarketProps,\n} from './market-types'\nimport { type Answer } from 'common/answer'\nimport {\n  CommentWithTotalReplies,\n  MAX_COMMENT_LENGTH,\n  type ContractComment,\n} from 'common/comment'\nimport { CandidateBet } from 'common/new-bet'\nimport type { Bet, LimitBet } from 'common/bet'\nimport { coerceBoolean, contentSchema } from 'common/api/zod-types'\nimport { Lover } from 'common/love/lover'\nimport { AIGeneratedMarket, Contract, MarketContract } from 'common/contract'\nimport { CompatibilityScore } from 'common/love/compatibility-score'\nimport type { Txn, ManaPayTxn } from 'common/txn'\nimport { LiquidityProvision } from 'common/liquidity-provision'\nimport { DisplayUser, FullUser } from './user-types'\nimport { League } from 'common/leagues'\nimport { searchProps } from './market-search-types'\nimport { MAX_ANSWER_LENGTH } from 'common/answer'\nimport { type LinkPreview } from 'common/link-preview'\nimport { Headline } from 'common/news'\nimport { Row } from 'common/supabase/utils'\nimport { LikeData, ShipData } from './love-types'\nimport { AnyBalanceChangeType } from 'common/balance-change'\nimport { Dashboard } from 'common/dashboard'\nimport { ChatMessage, PrivateChatMessage } from 'common/chat-message'\nimport { PrivateUser, User } from '../user'\nimport { ManaSupply } from 'common/stats'\nimport { Repost } from 'common/repost'\nimport { PERIODS } from 'common/period'\nimport { SWEEPS_MIN_BET } from 'common/economy'\nimport {\n  LivePortfolioMetrics,\n  PortfolioMetrics,\n} from 'common/portfolio-metrics'\nimport { ModReport } from '../mod-report'\n\nimport { RegistrationReturnType } from 'common/reason-codes'\nimport {\n  CheckoutSession,\n  GIDXDocument,\n  GPSProps,\n  PaymentDetail,\n  checkoutParams,\n  verificationParams,\n  cashoutRequestParams,\n  PendingCashoutStatusData,\n  cashoutParams,\n} from 'common/gidx/gidx'\nimport { notification_preference } from 'common/user-notification-preferences'\nimport { PrivateMessageChannel } from 'common/supabase/private-messages'\nimport { Notification } from 'common/notification'\nimport { NON_POINTS_BETS_LIMIT } from 'common/supabase/bets'\nimport { ContractMetric } from 'common/contract-metric'\n\nimport { JSONContent } from '@tiptap/core'\nimport { Task, TaskCategory } from 'common/todo'\nimport { ChartAnnotation } from 'common/supabase/chart-annotations'\nimport { Dictionary } from 'lodash'\nimport { Reaction } from 'common/reaction'\nimport { YEAR_MS } from 'common/util/time'\nimport { MarketDraft } from 'common/drafts'\n// mqp: very unscientific, just balancing our willingness to accept load\n// with user willingness to put up with stale data\nexport const DEFAULT_CACHE_STRATEGY =\n  'public, max-age=5, stale-while-revalidate=10'\nconst MAX_EXPIRES_AT = 1_000 * YEAR_MS\n\ntype APIGenericSchema = {\n  // GET is for retrieval, POST is to mutate something, PUT is idempotent mutation (can be repeated safely)\n  method: 'GET' | 'POST' | 'PUT'\n  //private APIs can only be called from manifold. undocumented endpoints can change or be deleted at any time!\n  visibility: 'public' | 'undocumented' | 'private'\n  // whether the endpoint requires authentication\n  authed: boolean\n  // zod schema for the request body (or for params for GET requests)\n  props: z.ZodType\n  // note this has to be JSON serializable\n  returns?: Record<string, any>\n  // Cache-Control header. like, 'max-age=60'\n  cache?: string\n  // whether the endpoint should prefer authentication even if not required\n  preferAuth?: boolean\n}\n\nlet _apiTypeCheck: { [x: string]: APIGenericSchema }\nexport const API = (_apiTypeCheck = {\n  'refresh-all-clients': {\n    method: 'POST',\n    visibility: 'public',\n    props: z.object({ message: z.string().optional() }),\n    authed: true,\n  },\n  'toggle-system-trading-status': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        token: z.enum(['MANA', 'CASH']),\n      })\n      .strict(),\n    returns: {} as { status: boolean },\n  },\n  comment: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as ContractComment,\n    props: z\n      .object({\n        contractId: z.string(),\n        content: contentSchema.optional(),\n        html: z.string().optional(),\n        markdown: z.string().optional(),\n        replyToCommentId: z.string().optional(),\n        replyToAnswerId: z.string().optional(),\n        replyToBetId: z.string().optional(),\n      })\n      .strict(),\n  },\n\n  'follow-contract': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: true },\n    props: z\n      .object({\n        contractId: z.string(),\n        follow: z.boolean(),\n      })\n      .strict(),\n  },\n  'get-contract': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as Contract,\n    props: z\n      .object({\n        contractId: z.string(),\n      })\n      .strict(),\n  },\n  'answer/:answerId': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as Answer,\n    props: z.object({ answerId: z.string() }).strict(),\n  },\n  'market/:contractId/answers': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: [] as Answer[],\n    props: z.object({ contractId: z.string() }).strict(),\n  },\n  'hide-comment': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ commentPath: z.string() }).strict(),\n  },\n  'pin-comment': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({ commentPath: z.string() }).strict(),\n  },\n  comments: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    // cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as ContractComment[],\n    props: z\n      .object({\n        contractId: z.string().optional(),\n        contractSlug: z.string().optional(),\n        afterTime: z.coerce.number().optional(),\n        limit: z.coerce.number().gte(0).lte(1000).default(1000),\n        page: z.coerce.number().gte(0).default(0),\n        userId: z.string().optional(),\n        isPolitics: coerceBoolean.optional(),\n      })\n      .strict(),\n  },\n  bet: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as CandidateBet & { betId: string },\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gte(SWEEPS_MIN_BET),\n        replyToCommentId: z.string().optional(),\n        limitProb: z.number().gte(0.01).lte(0.99).optional(),\n        expiresMillisAfter: z.number().lt(MAX_EXPIRES_AT).optional(),\n        silent: z.boolean().optional(),\n        expiresAt: z.number().lt(MAX_EXPIRES_AT).optional(),\n        // Used for binary and new multiple choice contracts (cpmm-multi-1).\n        outcome: z.enum(['YES', 'NO']).default('YES'),\n        //Multi\n        answerId: z.string().optional(),\n        dryRun: z.boolean().optional(),\n        deps: z.array(z.string()).optional(),\n        deterministic: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  createuser: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { user: User; privateUser: PrivateUser },\n    props: z\n      .object({\n        deviceToken: z.string().optional(),\n        adminToken: z.string().optional(),\n        visitedContractIds: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'multi-bet': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as (CandidateBet & { betId: string })[],\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gte(1),\n        limitProb: z.number().gte(0).lte(1).optional(),\n        expiresAt: z.number().lt(MAX_EXPIRES_AT).optional(),\n        answerIds: z.array(z.string()).min(1),\n        deterministic: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  'multi-sell': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as (CandidateBet & { betId: string })[],\n    props: z\n      .object({\n        contractId: z.string(),\n        answerIds: z.array(z.string()).min(1),\n        deterministic: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  leaderboard: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as { userId: string; score: number }[],\n    props: z\n      .object({\n        groupId: z.string().optional(),\n        limit: z.coerce.number().min(1).max(100).default(50),\n        token: z.enum(['MANA', 'CASH']).default('MANA'),\n        kind: z.enum(['creator', 'profit', 'loss', 'volume', 'referral']),\n      })\n      .strict(),\n  },\n  'verify-phone-number': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { status: string },\n    props: z\n      .object({\n        phoneNumber: z.string(),\n        code: z.string(),\n      })\n      .strict(),\n  },\n  'request-otp': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { status: string },\n    props: z\n      .object({\n        phoneNumber: z.string(),\n      })\n      .strict(),\n  },\n  'bet/cancel/:betId': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ betId: z.string() }).strict(),\n    returns: {} as LimitBet,\n  },\n  // sell shares\n  'market/:contractId/sell': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as CandidateBet & { betId: string },\n    props: z\n      .object({\n        contractId: z.string(),\n        shares: z.number().positive().optional(), // leave it out to sell all shares\n        outcome: z.enum(['YES', 'NO']),\n        answerId: z.string().optional(), // Required for multi binary markets\n        deterministic: z.boolean().optional(),\n        deps: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'get-user-limit-orders-with-contracts': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as {\n      bets: LimitBet[]\n      contracts: MarketContract[]\n    },\n    props: z\n      .object({\n        userId: z.string(),\n        count: z.coerce.number().lte(5000),\n        includeExpired: coerceBoolean.optional().default(false),\n        includeCancelled: coerceBoolean.optional().default(false),\n        includeFilled: coerceBoolean.optional().default(false),\n      })\n      .strict(),\n  },\n  'get-interesting-groups-from-views': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as (Group & { hasBet: boolean })[],\n    props: z\n      .object({\n        userId: z.string(),\n        contractIds: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  bets: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Bet[],\n    props: z\n      .object({\n        id: z.string().optional(),\n        userId: z.string().optional(),\n        username: z.string().optional(),\n        contractId: z.string().or(z.array(z.string())).optional(),\n        contractSlug: z.string().optional(),\n        answerId: z.string().optional(),\n        // market: z.string().optional(), // deprecated, synonym for `contractSlug`\n        limit: z.coerce\n          .number()\n          .gte(0)\n          .lte(50000)\n          .default(NON_POINTS_BETS_LIMIT),\n        before: z.string().optional(),\n        after: z.string().optional(),\n        beforeTime: z.coerce.number().optional(),\n        afterTime: z.coerce.number().optional(),\n        order: z.enum(['asc', 'desc']).optional(),\n        kinds: z.enum(['open-limit']).optional(),\n        // undocumented fields. idk what a good api interface would be\n        filterRedemptions: coerceBoolean.optional(),\n        includeZeroShareRedemptions: coerceBoolean.optional(),\n        commentRepliesOnly: coerceBoolean.optional(),\n        count: coerceBoolean.optional(),\n        points: coerceBoolean.optional(),\n      })\n      .strict(),\n  },\n  'bet-points': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: 'public, max-age=600, stale-while-revalidate=60',\n    returns: [] as Bet[],\n    props: z\n      .object({\n        contractId: z.string(),\n        answerId: z.string().optional(),\n        limit: z.coerce.number().gte(0).lte(50000).default(5000),\n        beforeTime: z.coerce.number(),\n        afterTime: z.coerce.number(),\n        filterRedemptions: coerceBoolean.optional(),\n        includeZeroShareRedemptions: coerceBoolean.optional(),\n      })\n      .strict(),\n  },\n  'unique-bet-group-count': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as { count: number },\n    props: z\n      .object({\n        contractId: z.string(),\n      })\n      .strict(),\n  },\n  'get-daily-changed-metrics-and-contracts': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    cache: 'public, max-age=900, stale-while-revalidate=90', // 15 minute cache\n    props: z\n      .object({\n        limit: z.coerce.number(),\n        userId: z.string(),\n        balance: z.coerce.number(),\n      })\n      .strict(),\n    returns: {} as {\n      manaMetrics: ContractMetric[]\n      contracts: MarketContract[]\n      manaProfit: number\n      manaInvestmentValue: number\n      balance: number\n    },\n  },\n  // deprecated. use /bets?username= instead\n  'user/:username/bets': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Bet[],\n    props: z\n      .object({\n        username: z.string(),\n        limit: z.coerce.number().gte(0).lte(1000).default(1000),\n      })\n      .strict(),\n  },\n  'group/:slug': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as Group,\n    props: z.object({ slug: z.string() }),\n  },\n  'group/:slug/groups': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as { above: LiteGroup[]; below: LiteGroup[] },\n    props: z.object({ slug: z.string() }).strict(),\n  },\n  'group/:slug/dashboards': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as {\n      id: string\n      title: string\n      slug: string\n      creatorId: string\n    }[],\n    props: z.object({ slug: z.string() }).strict(),\n  },\n  'group/by-id/:id/groups': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as { above: LiteGroup[]; below: LiteGroup[] },\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'group/by-id/:id': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as Group,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  // deprecated. use /markets?groupId= instead\n  'group/by-id/:id/markets': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as LiteMarket[],\n    props: z\n      .object({\n        id: z.string(),\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n      })\n      .strict(),\n  },\n  'group/:slug/delete': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ slug: z.string() }),\n  },\n  'group/by-id/:id/delete': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ id: z.string() }),\n  },\n  'group/:slug/block': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ slug: z.string() }),\n  },\n  'group/:slug/unblock': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ slug: z.string() }).strict(),\n  },\n  'group/by-id/:topId/group/:bottomId': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        topId: z.string(),\n        bottomId: z.string(),\n        remove: z.boolean().optional(),\n      })\n      .strict(),\n    returns: {} as { status: 'success' },\n  },\n  groups: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Group[],\n    props: z\n      .object({\n        availableToUserId: z.string().optional(),\n        beforeTime: z.coerce.number().int().optional(),\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n      })\n      .strict(),\n  },\n  'market/:id': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as LiteMarket | FullMarket,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z.object({ id: z.string(), lite: coerceBoolean.optional() }),\n  },\n  'market/:id/prob': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as {\n      prob?: number\n      answerProbs?: { [answerId: string]: number }\n    },\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'market-probs': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as {\n      [contractId: string]: {\n        prob?: number\n        answerProbs?: { [answerId: string]: number }\n      }\n    },\n    props: z\n      .object({\n        ids: z.array(z.string()).max(100),\n      })\n      .strict(),\n  },\n  'markets-by-ids': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: [] as Contract[],\n    props: z\n      .object({\n        ids: z.array(z.string()).max(100),\n      })\n      .strict(),\n  },\n  // deprecated. use /market/:id?lite=true instead\n  'market/:id/lite': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as LiteMarket,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z.object({ id: z.string() }),\n  },\n  'slug/:slug': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as LiteMarket | FullMarket,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z.object({ slug: z.string(), lite: coerceBoolean.optional() }),\n  },\n  market: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as LiteMarket,\n    props: createMarketProps,\n  },\n  'market/:contractId/update': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: updateMarketProps,\n    returns: {} as { success: true },\n  },\n  'market/:contractId/close': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    // returns: {} as LiteMarket,\n    props: z\n      .object({\n        contractId: z.string(),\n        closeTime: z.number().int().nonnegative().optional(),\n      })\n      .strict(),\n  },\n  'market/:contractId/resolve': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { message: string },\n    props: resolveMarketProps,\n  },\n  'market/:contractId/add-liquidity': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as LiquidityProvision,\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gt(0).finite(),\n      })\n      .strict(),\n  },\n  'market/:contractId/remove-liquidity': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as LiquidityProvision,\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gt(0).finite(),\n      })\n      .strict(),\n  },\n  'market/:contractId/add-bounty': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as Txn,\n    props: z\n      .object({\n        contractId: z.string(),\n        amount: z.number().gt(0).finite(),\n      })\n      .strict(),\n  },\n  'market/:contractId/award-bounty': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as Txn,\n    props: z\n      .object({\n        contractId: z.string(),\n        commentId: z.string(),\n        amount: z.number().gt(0).finite(),\n      })\n      .strict(),\n  },\n  'market/:contractId/group': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        contractId: z.string(),\n        groupId: z.string(),\n        remove: z.boolean().default(false),\n      })\n      .strict(),\n    returns: {} as { success: true },\n  },\n  'market/:contractId/groups': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({ contractId: z.string() }),\n    returns: [] as LiteGroup[],\n  },\n  'market/:contractId/answer': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { newAnswerId: string },\n    props: z\n      .object({\n        contractId: z.string().max(MAX_ANSWER_LENGTH),\n        text: z.string().min(1).max(MAX_ANSWER_LENGTH),\n      })\n      .strict(),\n  },\n  'market/:contractId/block': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ contractId: z.string() }).strict(),\n  },\n  'market/:contractId/unblock': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ contractId: z.string() }).strict(),\n  },\n  unresolve: {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { success: true },\n    props: z\n      .object({\n        contractId: z.string().max(MAX_ANSWER_LENGTH),\n        answerId: z.string().max(MAX_ANSWER_LENGTH).optional(),\n      })\n      .strict(),\n  },\n  leagues: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as League[],\n    props: z\n      .object({\n        userId: z.string().optional(),\n        cohort: z.string().optional(),\n        season: z.coerce.number().optional(),\n      })\n      .strict(),\n  },\n  markets: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as LiteMarket[],\n    props: z\n      .object({\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n        sort: z\n          .enum([\n            'created-time',\n            'updated-time',\n            'last-bet-time',\n            'last-comment-time',\n          ])\n          .optional(),\n        order: z.enum(['asc', 'desc']).optional(),\n        before: z.string().optional(),\n        userId: z.string().optional(),\n        groupId: z.string().optional(),\n      })\n      .strict(),\n  },\n  'search-markets': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as LiteMarket[],\n    props: searchProps,\n  },\n  'search-markets-full': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    preferAuth: true,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Contract[],\n    props: searchProps,\n  },\n  managram: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        amount: z.number().finite(),\n        toIds: z.array(z.string()),\n        message: z.string().max(MAX_COMMENT_LENGTH),\n        groupId: z.string().max(MAX_ID_LENGTH).optional(),\n        token: z.enum(['M$', 'CASH']).default('M$'),\n      })\n      .strict(),\n  },\n  manalink: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { slug: string },\n    props: z\n      .object({\n        amount: z.number().positive().finite().safe(),\n        expiresTime: z.number().lt(MAX_EXPIRES_AT).optional(),\n        maxUses: z.number().optional(),\n        message: z.string().optional(),\n      })\n      .strict(),\n  },\n  donate: {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        amount: z.number().positive().finite().safe(),\n        to: z.string(),\n      })\n      .strict(),\n  },\n  'convert-sp-to-mana': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ amount: z.number().positive().finite().safe() }).strict(),\n  },\n  'convert-cash-to-mana': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ amount: z.number().positive().finite().safe() }).strict(),\n  },\n  'request-loan': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({}),\n    returns: {} as { payout: number },\n  },\n  // deprecated. use /txns instead\n  managrams: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: [] as ManaPayTxn[],\n    props: z\n      .object({\n        toId: z.string().optional(),\n        fromId: z.string().optional(),\n        limit: z.coerce.number().gte(0).lte(100).default(100),\n        before: z.coerce.number().optional(),\n        after: z.coerce.number().optional(),\n      })\n      .strict(),\n  },\n  'market/:id/positions': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as ContractMetric[],\n    props: z\n      .object({\n        id: z.string(),\n        userId: z.string().optional(),\n        answerId: z.string().optional(),\n        summaryOnly: z.boolean().optional(),\n        top: z.undefined().or(z.coerce.number()),\n        bottom: z.undefined().or(z.coerce.number()),\n        order: z.enum(['shares', 'profit']).optional(),\n      })\n      .strict(),\n  },\n  me: {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    cache: DEFAULT_CACHE_STRATEGY,\n    props: z.object({}),\n    returns: {} as FullUser,\n  },\n  'me/update': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({\n      name: z.string().trim().min(1).optional(),\n      username: z.string().trim().min(1).optional(),\n      avatarUrl: z.string().optional(),\n      bio: z.string().optional(),\n      website: z.string().optional(),\n      twitterHandle: z.string().optional(),\n      discordHandle: z.string().optional(),\n      // settings\n      optOutBetWarnings: z.boolean().optional(),\n      isAdvancedTrader: z.boolean().optional(),\n      //internal\n      seenStreakModal: z.boolean().optional(),\n      shouldShowWelcome: z.boolean().optional(),\n      hasSeenContractFollowModal: z.boolean().optional(),\n      hasSeenLoanModal: z.boolean().optional(),\n    }),\n    returns: {} as FullUser,\n  },\n  'me/delete': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({\n      username: z.string(), // just so you're sure\n    }),\n  },\n  'me/private': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z.object({}),\n    returns: {} as PrivateUser,\n  },\n  'me/private/update': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    props: z\n      .object({\n        email: z.string().email().optional(),\n        apiKey: z.string().optional(),\n        pushToken: z.string().optional(),\n        rejectedPushNotificationsOn: z.number().optional(),\n        lastPromptedToEnablePushNotifications: z.number().optional(),\n        interestedInPushNotifications: z.boolean().optional(),\n        hasSeenAppBannerInNotificationsOn: z.number().optional(),\n        installedAppPlatforms: z.array(z.string()).optional(),\n        paymentInfo: z.string().optional(),\n        lastAppReviewTime: z.number().optional(),\n      })\n      .strict(),\n  },\n  'user/:username': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as FullUser,\n    props: z.object({ username: z.string() }).strict(),\n  },\n  'user/:username/lite': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as DisplayUser,\n    props: z.object({ username: z.string() }).strict(),\n  },\n  'user/by-id/:id': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    // Do not add a caching strategy here. New users need up-to-date data.\n    returns: {} as FullUser,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'user/by-id/:id/lite': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as DisplayUser,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'users/by-id': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as DisplayUser[],\n    props: z.object({ ids: z.array(z.string()) }).strict(),\n  },\n  'users/by-id/balance': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as { id: string; balance: number }[],\n    props: z.object({ ids: z.array(z.string()) }).strict(),\n  },\n  'user/by-id/:id/block': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  'user/by-id/:id/unblock': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ id: z.string() }).strict(),\n  },\n  users: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as FullUser[],\n    props: z\n      .object({\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n        before: z.string().optional(),\n      })\n      .strict(),\n  },\n  'search-users': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as FullUser[],\n    props: z\n      .object({\n        term: z.string(),\n        limit: z.coerce.number().gte(0).lte(1000).default(500),\n        page: z.coerce.number().gte(0).default(0),\n      })\n      .strict(),\n  },\n  'search-contract-positions': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as DisplayUser[],\n    props: z\n      .object({\n        term: z.string(),\n        contractId: z.string(),\n        limit: z.coerce.number().gte(0).lte(100).default(10),\n      })\n      .strict(),\n  },\n  'save-twitch': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        twitchInfo: z.object({\n          twitchName: z.string().optional(),\n          controlToken: z.string().optional(),\n          botEnabled: z.boolean().optional(),\n          needsRelinking: z.boolean().optional(),\n        }),\n      })\n      .strict(),\n  },\n  'set-push-token': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({ pushToken: z.string() }).strict(),\n  },\n  'update-notif-settings': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      type: z.string() as z.ZodType<notification_preference>,\n      medium: z.enum(['email', 'browser', 'mobile']),\n      enabled: z.boolean(),\n    }),\n  },\n  headlines: {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: [] as Headline[],\n    props: z.object({\n      slug: z.enum(['politics', 'ai', 'news']).optional(),\n    }),\n  },\n  'politics-headlines': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: [] as Headline[],\n    props: z.object({}),\n  },\n  'set-news': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { success: true },\n    props: z\n      .object({\n        dashboardIds: z.array(z.string()),\n        endpoint: z.enum(['politics', 'ai', 'news']),\n      })\n      .strict(),\n  },\n  react: {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        contentId: z.string(),\n        contentType: z.enum(['comment', 'contract']),\n        remove: z.boolean().optional(),\n        reactionType: z.enum(['like', 'dislike']).optional().default('like'),\n      })\n      .strict(),\n    returns: { success: true },\n  },\n  'compatible-lovers': {\n    method: 'GET',\n    visibility: 'private',\n    authed: false,\n    props: z.object({ userId: z.string() }),\n    returns: {} as {\n      lover: Lover\n      compatibleLovers: Lover[]\n      loverCompatibilityScores: {\n        [userId: string]: CompatibilityScore\n      }\n    },\n  },\n  post: {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    returns: {} as ContractComment,\n    props: z\n      .object({\n        contractId: z.string(),\n        betId: z.string().optional(),\n        commentId: z.string().optional(),\n        content: contentSchema.optional(),\n      })\n      .strict(),\n  },\n  'fetch-link-preview': {\n    method: 'GET',\n    visibility: 'private',\n    authed: false,\n    props: z.object({ url: z.string() }).strict(),\n    cache: 'max-age=86400, stale-while-revalidate=86400',\n    returns: {} as LinkPreview,\n  },\n  'remove-pinned-photo': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    returns: { success: true },\n    props: z\n      .object({\n        userId: z.string(),\n      })\n      .strict(),\n  },\n  'get-related-markets': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    props: z\n      .object({\n        contractId: z.string(),\n        limit: z.coerce.number().gte(0).lte(100),\n        userId: z.string().optional(),\n        question: z.string().optional(),\n        uniqueBettorCount: z.coerce.number().gte(0).optional(),\n      })\n      .strict(),\n    returns: {} as {\n      marketsFromEmbeddings: Contract[]\n    },\n    cache: 'public, max-age=3600, stale-while-revalidate=10',\n  },\n  'get-related-markets-by-group': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    cache: 'public, max-age=3600, stale-while-revalidate=10',\n    returns: {} as {\n      groupContracts: Contract[]\n    },\n    props: z\n      .object({\n        contractId: z.string(),\n        limit: z.coerce.number().gte(0).lte(100),\n        offset: z.coerce.number().gte(0),\n      })\n      .strict(),\n  },\n  'unlist-and-cancel-user-contracts': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        userId: z.string(),\n      })\n      .strict(),\n  },\n  'get-boost-analytics': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: false,\n    props: z\n      .object({\n        contractId: z.string(),\n      })\n      .strict(),\n    returns: {} as {\n      uniqueViewers: number\n      totalViews: number\n      uniquePromotedViewers: number\n      totalPromotedViews: number\n      boostPeriods: {\n        startTime: string\n        endTime: string\n      }[]\n    },\n  },\n  'get-seen-market-ids': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      contractIds: z.array(z.string()),\n      types: z.array(z.enum(['page', 'card', 'promoted'])).optional(),\n      since: z.number(),\n    }),\n    returns: [] as string[],\n  },\n  'get-compatibility-questions': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({}),\n    returns: {} as {\n      status: 'success'\n      questions: (Row<'love_questions'> & {\n        answer_count: number\n        score: number\n      })[]\n    },\n  },\n  'like-lover': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    props: z.object({\n      targetUserId: z.string(),\n      remove: z.boolean().optional(),\n    }),\n    returns: {} as {\n      status: 'success'\n    },\n  },\n  'ship-lovers': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    props: z.object({\n      targetUserId1: z.string(),\n      targetUserId2: z.string(),\n      remove: z.boolean().optional(),\n    }),\n    returns: {} as {\n      status: 'success'\n    },\n  },\n\n  'get-likes-and-ships': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z\n      .object({\n        userId: z.string(),\n      })\n      .strict(),\n    returns: {} as {\n      status: 'success'\n      likesReceived: LikeData[]\n      likesGiven: LikeData[]\n      ships: ShipData[]\n    },\n  },\n  'has-free-like': {\n    method: 'GET',\n    visibility: 'private',\n    authed: true,\n    props: z.object({}).strict(),\n    returns: {} as {\n      status: 'success'\n      hasFreeLike: boolean\n    },\n  },\n  'star-lover': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    props: z.object({\n      targetUserId: z.string(),\n      remove: z.boolean().optional(),\n    }),\n    returns: {} as {\n      status: 'success'\n    },\n  },\n  'get-lovers': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({}).strict(),\n    returns: {} as {\n      status: 'success'\n      lovers: Lover[]\n    },\n  },\n  'get-lover-answers': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({ userId: z.string() }).strict(),\n    returns: {} as {\n      status: 'success'\n      answers: Row<'love_compatibility_answers'>[]\n    },\n  },\n  'search-groups': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    // Is there a way to infer return { lite:[] as LiteGroup[] } if type is 'lite'?\n    returns: {\n      full: [] as Group[],\n      lite: [] as LiteGroup[],\n    },\n    props: SearchGroupParams(SearchGroupShape),\n  },\n  'search-my-groups': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {\n      full: [] as Group[],\n      lite: [] as LiteGroup[],\n    },\n    props: SearchGroupParams(MySearchGroupShape),\n  },\n  'get-groups-with-top-contracts': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as { topic: Topic; contracts: Contract[] }[],\n    props: z.object({}),\n  },\n  'get-balance-changes': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: [] as AnyBalanceChangeType[],\n    props: z\n      .object({\n        before: z.coerce.number().optional(),\n        after: z.coerce.number().default(0),\n        userId: z.string(),\n      })\n      .strict(),\n  },\n  'get-partner-stats': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z\n      .object({\n        userId: z.string(),\n      })\n      .strict(),\n    returns: {} as {\n      status: 'success' | 'error'\n      username: string\n      numContractsCreated: number\n      numUniqueBettors: number\n      numReferrals: number\n      numReferralsWhoRetained: number\n      totalTraderIncome: number\n      totalReferralIncome: number\n      dollarsEarned: number\n    },\n  },\n  'record-contract-view': {\n    method: 'POST',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      userId: z.string().optional(),\n      contractId: z.string(),\n      kind: z.enum(['page', 'card', 'promoted']),\n    }),\n    returns: {} as { status: 'success' },\n  },\n  'record-comment-view': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({\n      contractId: z.string(),\n      commentId: z.string(),\n    }),\n    returns: {} as { status: 'success' },\n  },\n  'record-contract-interaction': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({\n      contractId: z.string(),\n      kind: z.enum([\n        'page bet',\n        'page comment',\n        'page repost',\n        'page like',\n        'card bet',\n        'card click',\n        'promoted click',\n        'card like',\n        'page share',\n        'browse click',\n      ]),\n      commentId: z.string().optional(),\n      feedReasons: z.array(z.string()).optional(),\n      feedType: z.string().optional(),\n      betGroupId: z.string().optional(),\n      betId: z.string().optional(),\n    }),\n    returns: {} as { status: 'success' },\n  },\n  'get-dashboard-from-slug': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      dashboardSlug: z.string(),\n    }),\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: {} as Dashboard,\n  },\n  'create-public-chat-message': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as ChatMessage,\n    props: z.object({\n      content: contentSchema,\n      channelId: z.string(),\n    }),\n  },\n  'get-followed-groups': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      userId: z.string(),\n    }),\n    returns: {} as {\n      groups: Group[]\n    },\n  },\n  'get-user-portfolio': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      userId: z.string(),\n    }),\n    returns: {} as LivePortfolioMetrics,\n  },\n  'get-user-portfolio-history': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      userId: z.string(),\n      period: z.enum(PERIODS),\n    }),\n    returns: {} as PortfolioMetrics[],\n  },\n  'get-channel-memberships': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      channelId: z.coerce.number().optional(),\n      createdTime: z.string().optional(),\n      lastUpdatedTime: z.string().optional(),\n      limit: z.coerce.number(),\n    }),\n    returns: {\n      channels: [] as PrivateMessageChannel[],\n      memberIdsByChannelId: {} as { [channelId: string]: string[] },\n    },\n  },\n  'get-channel-messages': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      channelId: z.coerce.number(),\n      limit: z.coerce.number(),\n      id: z.coerce.number().optional(),\n    }),\n    returns: [] as PrivateChatMessage[],\n  },\n  'get-channel-seen-time': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      channelIds: z.array(z.coerce.number()),\n    }),\n    returns: [] as [number, string][],\n  },\n  'set-channel-seen-time': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z.object({\n      channelId: z.coerce.number(),\n    }),\n  },\n  'get-feed': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as {\n      contracts: Contract[]\n      comments: ContractComment[]\n      bets: Bet[]\n      reposts: Repost[]\n      idsToReason: { [id: string]: string }\n    },\n    props: z\n      .object({\n        userId: z.string(),\n        limit: z.coerce.number().gt(0).lte(100).default(100),\n        offset: z.coerce.number().gte(0).default(0),\n        ignoreContractIds: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'get-mana-supply': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as ManaSupply,\n    props: z.object({}).strict(),\n  },\n  'get-notifications': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as Notification[],\n    props: z\n      .object({\n        after: z.coerce.number().optional(),\n        limit: z.coerce.number().gte(0).lte(1000).default(100),\n      })\n      .strict(),\n  },\n  'update-mod-report': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        reportId: z.number(),\n        updates: z\n          .object({\n            status: z\n              .enum(['new', 'under review', 'resolved', 'needs admin'])\n              .optional(),\n            mod_note: z.string().optional(),\n          })\n          .partial(),\n      })\n      .strict(),\n    returns: {} as { status: string; report: ModReport },\n  },\n  'get-mod-reports': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        statuses: z.array(\n          z.enum(['new', 'under review', 'resolved', 'needs admin'])\n        ),\n        limit: z.coerce.number().gte(0).lte(100).default(25),\n        offset: z.coerce.number().gte(0).default(0),\n        count: coerceBoolean.optional(),\n      })\n      .strict(),\n    returns: {} as {\n      status: string\n      count?: number\n      reports: ModReport[]\n    },\n  },\n  'get-txn-summary-stats': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as Row<'txn_summary_stats'>[],\n    props: z\n      .object({\n        ignoreCategories: z.array(z.string()).optional(),\n        fromType: z.string().optional(),\n        toType: z.string().optional(),\n        limitDays: z.coerce.number(),\n      })\n      .strict(),\n  },\n  'get-mana-summary-stats': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as Row<'mana_supply_stats'>[],\n    props: z\n      .object({\n        limitDays: z.coerce.number(),\n      })\n      .strict(),\n  },\n  'register-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: verificationParams,\n    returns: {} as RegistrationReturnType,\n  },\n  'get-verification-status-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      documents?: GIDXDocument[]\n      message?: string\n      documentStatus?: string\n    },\n    props: z.object({}),\n  },\n  'get-monitor-status-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n    },\n    props: z.object({\n      DeviceGPS: GPSProps,\n    }),\n  },\n  'get-checkout-session-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n      session?: CheckoutSession\n    },\n    props: z.object({\n      PayActionCode: z.enum(['PAY', 'PAYOUT']).default('PAY'),\n      DeviceGPS: GPSProps,\n      userId: z.string().optional(),\n      ip: z.string().optional(),\n    }),\n  },\n  'complete-checkout-session-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n      gidxMessage?: string | null\n      details?: PaymentDetail[]\n    },\n    props: z.object(checkoutParams),\n  },\n  'complete-cashout-session-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n      gidxMessage?: string | null\n      details?: PaymentDetail[]\n    },\n    props: z.object(cashoutParams),\n  },\n  'complete-cashout-request': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      message?: string\n      gidxMessage?: string | null\n      details?: PaymentDetail[]\n    },\n    props: z.object(cashoutRequestParams),\n  },\n  'get-verification-documents-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as {\n      status: string\n      documents: GIDXDocument[]\n      utilityDocuments: GIDXDocument[]\n      idDocuments: GIDXDocument[]\n      rejectedDocuments: GIDXDocument[]\n    },\n    props: z.object({}),\n  },\n  'upload-document-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { status: string },\n    props: z.object({\n      CategoryType: z.number().gte(1).lte(7),\n      fileName: z.string(),\n      fileUrl: z.string(),\n    }),\n  },\n  'identity-callback-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as { Accepted: boolean },\n    props: z.object({\n      MerchantCustomerID: z.string(),\n      NotificationType: z.string(),\n    }),\n  },\n  'payment-callback-gidx': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: false,\n    returns: {} as { MerchantTransactionID: string },\n    props: z\n      .object({\n        MerchantTransactionID: z.string(),\n        TransactionStatusCode: z.coerce.number(),\n        TransactionStatusMessage: z.string(),\n        StatusCode: z.coerce.number(),\n        SessionID: z.string(),\n        MerchantSessionID: z.string(),\n        SessionScore: z.coerce.number(),\n        ReasonCodes: z.array(z.string()).optional(),\n        ServiceType: z.string(),\n        StatusMessage: z.string(),\n      })\n      .strict(),\n  },\n  'get-best-comments': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { comments: ContractComment[]; contracts: Contract[] },\n    props: z.object({\n      limit: z.coerce.number().gte(0).lte(100).default(20),\n      offset: z.coerce.number().gte(0).default(0),\n      ignoreContractIds: z.array(z.string()).optional(),\n      justLikes: z.coerce.number().optional(),\n    }),\n  },\n  'get-redeemable-prize-cash': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { redeemablePrizeCash: number },\n    props: z.object({}),\n  },\n  'get-total-redeemable-prize-cash': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as { total: number },\n    props: z.object({}),\n  },\n  'get-cashouts': {\n    method: 'GET',\n    visibility: 'undocumented',\n    authed: true,\n    returns: [] as PendingCashoutStatusData[],\n    props: z\n      .object({\n        limit: z.coerce.number().gte(0).lte(100).default(10),\n        offset: z.coerce.number().gte(0).default(0),\n        userId: z.string().optional(),\n      })\n      .strict(),\n  },\n  'get-kyc-stats': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({}),\n    returns: {} as {\n      initialVerifications: {\n        count: number\n        day: string\n      }[]\n      phoneVerifications: {\n        count: number\n        day: string\n      }[]\n    },\n  },\n  txns: {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z\n      .object({\n        token: z.string().optional(),\n        offset: z.coerce.number().default(0),\n        limit: z.coerce.number().gte(0).lte(100).default(100),\n        before: z.coerce.number().optional(),\n        after: z.coerce.number().optional(),\n        toId: z.string().optional(),\n        fromId: z.string().optional(),\n        category: z.string().optional(),\n        ignoreCategories: z.array(z.string()).optional(),\n      })\n      .strict(),\n    returns: [] as Txn[],\n  },\n  'generate-ai-market-suggestions': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: [] as AIGeneratedMarket[],\n    props: z\n      .object({\n        prompt: z.string(),\n        existingTitles: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'generate-ai-market-suggestions-2': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: [] as AIGeneratedMarket[],\n    props: z\n      .object({\n        prompt: z.string(),\n        existingTitles: z.array(z.string()).optional(),\n      })\n      .strict(),\n  },\n  'generate-ai-description': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { description: JSONContent | undefined },\n    props: z\n      .object({\n        question: z.string(),\n        description: z.string().optional(),\n        answers: z.array(z.string()).optional(),\n        outcomeType: z.string().optional(),\n        shouldAnswersSumToOne: coerceBoolean.optional(),\n        addAnswersMode: z\n          .enum(['DISABLED', 'ONLY_CREATOR', 'ANYONE'])\n          .optional(),\n      })\n      .strict(),\n  },\n  'generate-ai-answers': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as {\n      answers: string[]\n      addAnswersMode: 'DISABLED' | 'ONLY_CREATOR' | 'ANYONE'\n    },\n    props: z\n      .object({\n        question: z.string(),\n        answers: z.array(z.string()),\n        shouldAnswersSumToOne: coerceBoolean,\n        description: z.string().optional(),\n      })\n      .strict(),\n  },\n  'get-monthly-bets-2024': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ userId: z.string() }),\n    returns: [] as { month: string; bet_count: number; total_amount: number }[],\n  },\n  'get-max-min-profit-2024': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ userId: z.string() }),\n    returns: [] as {\n      profit: number\n      data: Contract\n      answer_id: string | null\n      has_no_shares: boolean\n      has_yes_shares: boolean\n    }[],\n  },\n  'get-next-loan-amount': {\n    method: 'GET',\n    visibility: 'undocumented',\n    cache: DEFAULT_CACHE_STRATEGY,\n    authed: false,\n    returns: {} as { amount: number },\n    props: z.object({\n      userId: z.string(),\n    }),\n  },\n  'create-task': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as Task,\n    props: z\n      .object({\n        text: z.string(),\n        category_id: z.number().optional(),\n        priority: z.number().default(0),\n        assignee_id: z.string().optional(),\n      })\n      .strict(),\n  },\n  'update-task': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z\n      .object({\n        id: z.number(),\n        text: z.string().optional(),\n        completed: z.boolean().optional(),\n        priority: z.number().optional(),\n        category_id: z.number().optional(),\n        archived: z.boolean().optional(),\n        assignee_id: z.string().optional(),\n      })\n      .strict(),\n  },\n  'create-category': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { id: number },\n    props: z\n      .object({\n        name: z.string(),\n        color: z.string().optional(),\n        displayOrder: z.number().optional(),\n      })\n      .strict(),\n  },\n  'get-categories': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { categories: TaskCategory[] },\n    props: z.object({}).strict(),\n  },\n  'update-category': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z\n      .object({\n        categoryId: z.number(),\n        name: z.string().optional(),\n        color: z.string().optional(),\n        displayOrder: z.number().optional(),\n        archived: z.boolean().optional(),\n      })\n      .strict(),\n  },\n  'get-tasks': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { tasks: Task[] },\n    props: z.object({}).strict(),\n  },\n  'is-sports-interested': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { isSportsInterested: boolean },\n    props: z.object({}).strict(),\n  },\n  'get-site-activity': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as {\n      bets: Bet[]\n      comments: CommentWithTotalReplies[]\n      newContracts: Contract[]\n      relatedContracts: Contract[]\n    },\n    props: z\n      .object({\n        limit: z.coerce.number().default(10),\n        offset: z.coerce.number().default(0),\n        blockedUserIds: z.array(z.string()).optional(),\n        blockedGroupSlugs: z.array(z.string()).optional(),\n        blockedContractIds: z.array(z.string()).optional(),\n        topicIds: z.array(z.string()).optional(),\n        types: z\n          .array(z.enum(['bets', 'comments', 'markets', 'limit-orders']))\n          .optional(),\n        minBetAmount: z.coerce.number().optional(),\n        onlyFollowedTopics: coerceBoolean.optional(),\n        onlyFollowedContracts: coerceBoolean.optional(),\n        onlyFollowedUsers: coerceBoolean.optional(),\n        userId: z.string().optional(),\n      })\n      .strict(),\n  },\n  'get-sports-games': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { schedule: any[] },\n    props: z.object({}).strict(),\n  },\n  'get-market-props': {\n    method: 'GET',\n    visibility: 'public',\n    cache: DEFAULT_CACHE_STRATEGY,\n    // Could set authed false and preferAuth with an api secret if we want it to replace static props\n    authed: true,\n    returns: {} as {\n      manaContract: MarketContract\n      chartAnnotations: ChartAnnotation[]\n      topics: Topic[]\n      comments: ContractComment[]\n      pinnedComments: ContractComment[]\n      userPositionsByOutcome: {\n        YES: ContractMetric[]\n        NO: ContractMetric[]\n      }\n      topContractMetrics: ContractMetric[]\n      totalPositions: number\n      dashboards: Dashboard[]\n      cashContract: MarketContract\n      totalManaBets: number\n      totalCashBets: number\n    },\n    props: z.object({\n      slug: z.string().optional(),\n      id: z.string().optional(),\n    }),\n  },\n  'get-user-contract-metrics-with-contracts': {\n    method: 'GET',\n    visibility: 'public',\n    preferAuth: true,\n    authed: false,\n    returns: {} as {\n      metricsByContract: Dictionary<ContractMetric[]>\n      contracts: MarketContract[]\n    },\n    props: z.object({\n      userId: z.string(),\n      limit: z.coerce.number(),\n      offset: z.coerce.number().gte(0).optional(),\n      perAnswer: coerceBoolean.optional(),\n      inMani: coerceBoolean.optional(),\n    }),\n  },\n  validateIap: {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z.object({\n      receipt: z.string(),\n    }),\n  },\n  'check-sports-event': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    returns: {} as { exists: boolean; existingMarket?: LiteMarket },\n    props: z\n      .object({\n        sportsEventId: z.string(),\n      })\n      .strict(),\n  },\n  'comment-reactions': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    cache: DEFAULT_CACHE_STRATEGY,\n    returns: [] as Reaction[],\n    props: z\n      .object({\n        contentIds: z.array(z.string()),\n        contentType: z.enum(['comment', 'contract']),\n      })\n      .strict(),\n  },\n  'mark-all-notifications-new': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z.object({}).strict(),\n    returns: {} as { success: boolean },\n  },\n  'get-contract-voters': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        contractId: z.string(),\n      })\n      .strict(),\n    returns: [] as DisplayUser[],\n  },\n  'get-contract-option-voters': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    props: z.object({ contractId: z.string(), optionId: z.string() }),\n    returns: [] as DisplayUser[],\n  },\n  'purchase-contract-boost': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        contractId: z.string(),\n        startTime: z.number().positive().finite().safe(),\n        method: z.enum(['mana', 'cash']),\n      })\n      .strict(),\n    returns: {} as { success: boolean; checkoutUrl?: string },\n  },\n  'generate-ai-numeric-ranges': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as {\n      thresholds: { answers: string[]; midpoints: number[] }\n      buckets: { answers: string[]; midpoints: number[] }\n    },\n    props: z\n      .object({\n        question: z.string(),\n        min: z.number(),\n        max: z.number(),\n        description: z.string().optional(),\n        unit: z.string(),\n      })\n      .strict(),\n  },\n  'infer-numeric-unit': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as {\n      unit: string\n    },\n    props: z\n      .object({\n        question: z.string(),\n        description: z.string().optional(),\n      })\n      .strict(),\n  },\n  'generate-ai-date-ranges': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as {\n      buckets: { answers: string[]; midpoints: number[] }\n      thresholds: { answers: string[]; midpoints: number[] }\n    },\n    props: z\n      .object({\n        question: z.string(),\n        min: z.string(),\n        max: z.string(),\n        description: z.string().optional(),\n      })\n      .strict(),\n  },\n  'regenerate-numeric-midpoints': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { midpoints: number[] },\n    props: z\n      .object({\n        description: z.string().optional(),\n        question: z.string(),\n        answers: z.array(z.string()),\n        min: z.number(),\n        max: z.number(),\n        unit: z.string(),\n        tab: z.enum(['thresholds', 'buckets']),\n      })\n      .strict(),\n  },\n  'regenerate-date-midpoints': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { midpoints: number[] },\n    props: z\n      .object({\n        description: z.string().optional(),\n        question: z.string(),\n        answers: z.array(z.string()),\n        min: z.string(),\n        max: z.string(),\n        tab: z.enum(['thresholds', 'buckets']),\n      })\n      .strict(),\n  },\n\n  'generate-concise-title': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        question: z.string(),\n      })\n      .strict(),\n    returns: {} as { title: string },\n  },\n  'get-close-date': {\n    method: 'POST',\n    visibility: 'undocumented',\n    authed: true,\n    props: z\n      .object({\n        question: z.string(),\n        utcOffset: z.number().optional(),\n      })\n      .strict(),\n    returns: {} as { closeTime: number },\n  },\n  'refer-user': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    props: z\n      .object({\n        referredByUsername: z.string(),\n        contractId: z.string().optional(),\n      })\n      .strict(),\n    returns: {} as { success: boolean },\n  },\n\n  'save-market-draft': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { id: number },\n    props: z\n      .object({\n        data: z.object({\n          question: z.string(),\n          description: z.any().optional(),\n          outcomeType: z.string(),\n          answers: z.array(z.string()).optional(),\n          closeDate: z.string().optional(),\n          closeHoursMinutes: z.string().optional(),\n          visibility: z.string(),\n          selectedGroups: z.array(z.any()),\n          savedAt: z.number(),\n        }),\n      })\n      .strict(),\n  },\n\n  'get-market-drafts': {\n    method: 'GET',\n    visibility: 'public',\n    authed: true,\n    returns: [] as MarketDraft[],\n    props: z.object({}).strict(),\n  },\n\n  'delete-market-draft': {\n    method: 'POST',\n    visibility: 'public',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z\n      .object({\n        id: z.coerce.number(),\n      })\n      .strict(),\n  },\n  'get-season-info': {\n    method: 'GET',\n    visibility: 'public',\n    authed: false,\n    props: z.object({\n      season: z.coerce.number().int().positive().optional(),\n    }),\n    returns: {} as {\n      season: number\n      startTime: number // epoch ms\n      endTime: number | null // epoch ms, null if a *mystery* for clients\n      status: 'active' | 'processing' | 'complete'\n    },\n  },\n  'mark-notification-read': {\n    method: 'POST',\n    visibility: 'private',\n    authed: true,\n    returns: {} as { success: boolean },\n    props: z\n      .object({\n        notificationId: z.string(),\n      })\n      .strict(),\n  },\n} as const)\n\nexport type APIPath = keyof typeof API\nexport type APISchema<N extends APIPath> = (typeof API)[N]\n\nexport type APIParams<N extends APIPath> = z.input<APISchema<N>['props']>\nexport type ValidatedAPIParams<N extends APIPath> = z.output<\n  APISchema<N>['props']\n>\n\nexport type APIResponse<N extends APIPath> = APISchema<N> extends {\n  returns: Record<string, any>\n}\n  ? APISchema<N>['returns']\n  : void\n\nexport type APIResponseOptionalContinue<N extends APIPath> =\n  | { continue: () => Promise<void>; result: APIResponse<N> }\n  | APIResponse<N>\n"
        },
        {
          "path": "common/src/contract.ts",
          "preContent": "import { JSONContent } from '@tiptap/core'\nimport { getDisplayProbability } from 'common/calculate'\nimport { Topic } from 'common/group'\nimport { ChartAnnotation } from 'common/supabase/chart-annotations'\nimport { sum } from 'lodash'\nimport { Answer } from './answer'\nimport { getLiquidity } from './calculate-cpmm'\nimport { ContractComment } from './comment'\nimport { ContractMetric } from './contract-metric'\nimport { CASH_SUFFIX, ENV_CONFIG } from './envs/constants'\nimport { Fees } from './fees'\nimport { PollOption } from './poll-option'\nimport { formatMoney, formatPercent } from './util/format'\nimport { MultiBase64Points } from './chart'\nimport { DAY_MS } from './util/time'\n\n/************************************************\n\nsupabase status: columns exist for\n  slug: text\n  creatorId: text\n  question: text\n  visibility: text\n  mechanism: text\n  outcomeType: text\n  createdTime: timestamp (from millis)\n  closeTime?: timestamp (from millis)\n  resolutionTime?: timestamp (from millis)\n  resolution?: text\n  resolutionProbability?: numeric\n  popularityScore: numeric\n  importanceScore: numeric\n\nany changes to the type of these columns in firestore will require modifying\nthe supabase trigger, or replication of contracts may fail!\n\n*************************************************/\n\ntype AnyContractType =\n  | (CPMM & Binary)\n  | (CPMM & PseudoNumeric)\n  | QuadraticFunding\n  | (CPMM & Stonk)\n  | CPMMMulti\n  | (NonBet & BountiedQuestion)\n  | (NonBet & Poll)\n  | CPMMNumber\n  | MultiNumeric\n  | MultiDate\nexport type Contract<T extends AnyContractType = AnyContractType> = {\n  id: string\n  slug: string // auto-generated; must be unique\n\n  creatorId: string\n  creatorName: string\n  creatorUsername: string\n  creatorAvatarUrl?: string\n  creatorCreatedTime?: number\n\n  question: string\n  description: string | JSONContent // More info about what the contract is about\n  visibility: Visibility\n\n  createdTime: number // Milliseconds since epoch\n  lastUpdatedTime: number // Updated on any change to the market (metadata, bet, comment)\n  lastBetTime?: number\n  lastCommentTime?: number\n  closeTime?: number // When no more trading is allowed\n  deleted?: boolean // If true, don't show market anywhere.\n\n  isResolved: boolean\n  resolutionTime?: number // When the contract creator resolved the market\n  resolution?: string\n  resolutionProbability?: number\n  resolverId?: string\n  isSpicePayout?: boolean\n\n  closeEmailsSent?: number\n\n  volume: number\n  volume24Hours: number\n  elasticity: number\n\n  collectedFees: Fees\n  uniqueBettorCount: number\n  uniqueBettorCountDay: number\n\n  unlistedById?: string\n  featuredLabel?: string\n  isTwitchContract?: boolean\n\n  coverImageUrl?: string\n  isRanked?: boolean\n\n  gptCommentSummary?: string\n\n  token: ContractToken\n  siblingContractId?: string\n\n  /** @deprecated - no longer used */\n  takerAPIOrdersDisabled?: boolean\n\n  // Manifold.love\n  loverUserId1?: string // The user id's of the pair of lovers referenced in the question.\n  loverUserId2?: string // The user id's of the pair of lovers referenced in the question.\n  matchCreatorId?: string // The user id of the person who proposed the match.\n  isLove?: boolean\n\n  /** @deprecated - no more auto-subsidization */\n  isSubsidized?: boolean // NOTE: not backfilled, undefined = true\n  /** @deprecated - try to use group-contracts table instead */\n  groupSlugs?: string[]\n  /** @deprecated - not deprecated, only updated in native column though*/\n  popularityScore: number\n  /** @deprecated - not deprecated, only updated in native column though*/\n  importanceScore: number\n  /** @deprecated - not deprecated, only updated in native column though*/\n  dailyScore: number\n  /** @deprecated - not deprecated, only updated in native column though*/\n  freshnessScore: number\n  /** @deprecated - not deprecated, only updated in native column though*/\n  conversionScore: number\n  /** @deprecated - not deprecated, only updated in native column though*/\n  viewCount: number\n  /** @deprecated - not deprecated, only updated in native column though*/\n  boosted: boolean\n  /** @deprecated - not up-to-date */\n  likedByUserCount?: number\n} & T\n\nexport type ContractToken = 'MANA' | 'CASH'\nexport type CPMMContract = Contract & CPMM\nexport type CPMMMultiContract = Contract & CPMMMulti\nexport type CPMMNumericContract = Contract & CPMMNumber\nexport type MultiNumericContract = Contract & MultiNumeric\nexport type MultiDateContract = Contract & MultiDate\nexport type MarketContract =\n  | CPMMContract\n  | CPMMMultiContract\n  | CPMMNumericContract\n  | MultiNumericContract\n  | MultiDateContract\nexport type BinaryContract = Contract & Binary\nexport type PseudoNumericContract = Contract & PseudoNumeric\nexport type QuadraticFundingContract = Contract & QuadraticFunding\nexport type StonkContract = Contract & Stonk\nexport type BountiedQuestionContract = Contract & BountiedQuestion\nexport type PollContract = Contract & Poll\nexport type SportsContract = Contract & Sports\nexport type BinaryOrPseudoNumericContract =\n  | BinaryContract\n  | PseudoNumericContract\n  | StonkContract\n\nexport type CPMM = {\n  mechanism: 'cpmm-1'\n  pool: { [outcome: string]: number }\n  p: number // probability constant in y^p * n^(1-p) = k\n  totalLiquidity: number // for historical reasons, this the total subsidy amount added in Ṁ\n  subsidyPool: number // current value of subsidy pool in Ṁ\n  prob: number\n  probChanges: {\n    day: number\n    week: number\n    month: number\n  }\n}\n\nexport type NonBet = {\n  mechanism: 'none'\n}\n\nexport const NON_BETTING_OUTCOMES: OutcomeType[] = ['BOUNTIED_QUESTION', 'POLL']\nexport const NO_CLOSE_TIME_TYPES: OutcomeType[] = NON_BETTING_OUTCOMES.concat([\n  'STONK',\n])\n\n/**\n * Implemented as a set of cpmm-1 binary contracts, one for each answer.\n * The mechanism is stored among the contract's answers, which each\n * reference this contract id.\n */\nexport type CPMMMulti = {\n  mechanism: 'cpmm-multi-1'\n  outcomeType: 'MULTIPLE_CHOICE'\n  shouldAnswersSumToOne: boolean\n  addAnswersMode?: add_answers_mode\n\n  totalLiquidity: number // for historical reasons, this the total subsidy amount added in Ṁ\n  subsidyPool: number // current value of subsidy pool in Ṁ\n  specialLiquidityPerAnswer?: number // Special liquidity mode, where initial ante is copied into each answer's pool, with a min probability, and only one answer can resolve YES. shouldAnswersSumToOne must be false.\n\n  // Answers chosen on resolution, with the weights of each answer.\n  // Weights sum to 100 if shouldAnswersSumToOne is true. Otherwise, range from 0 to 100 for each answerId.\n  resolutions?: { [answerId: string]: number }\n\n  // NOTE: This field is stored in the answers table and must be denormalized to the client.\n  answers: Answer[]\n  sort?: SortType\n}\n\nexport const isSpecialLoveContract = (contract: Contract) =>\n  contract.mechanism === 'cpmm-multi-1' &&\n  contract.outcomeType !== 'NUMBER' &&\n  contract.outcomeType !== 'MULTI_NUMERIC' &&\n  contract.outcomeType !== 'DATE' &&\n  contract.specialLiquidityPerAnswer\n\nexport type CPMMNumber = {\n  mechanism: 'cpmm-multi-1'\n  outcomeType: 'NUMBER'\n  shouldAnswersSumToOne: true\n  addAnswersMode: 'DISABLED'\n  max: number\n  min: number\n\n  totalLiquidity: number // for historical reasons, this the total subsidy amount added in Ṁ\n  subsidyPool: number // current value of subsidy pool in Ṁ\n\n  // Answers chosen on resolution, with the weights of each answer.\n  // Weights sum to 100 if shouldAnswersSumToOne is true. Otherwise, range from 0 to 100 for each answerId.\n  resolutions?: { [answerId: string]: number }\n\n  // NOTE: This field is stored in the answers table and must be denormalized to the client.\n  answers: Answer[]\n  sort?: SortType\n}\n\nexport type add_answers_mode = 'DISABLED' | 'ONLY_CREATOR' | 'ANYONE'\n\nexport type QuadraticFunding = {\n  outcomeType: 'QUADRATIC_FUNDING'\n  mechanism: 'qf'\n  answers: any[]\n  // Mapping of how much each user has contributed to the matching pool\n  // Note: Our codebase assumes every contract has a pool, which is why this isn't just a constant\n  pool: { M$: number }\n\n  // Used when the funding round pays out\n  resolution?: 'MKT' | 'CANCEL'\n  resolutions?: { [outcome: string]: number } // Used for MKT resolution.\n}\n\nexport type Binary = {\n  outcomeType: 'BINARY'\n  initialProbability: number\n  resolutionProbability?: number // Used for BINARY markets resolved to MKT\n  resolution?: resolution\n}\n\nexport type PseudoNumeric = {\n  outcomeType: 'PSEUDO_NUMERIC'\n  min: number\n  max: number\n  isLogScale: boolean\n  resolutionValue?: number\n\n  // same as binary market; map everything to probability\n  initialProbability: number\n  resolutionProbability?: number\n}\n\nexport type Number = {\n  outcomeType: 'NUMBER'\n  answers: Answer[]\n  min: number\n  max: number\n  resolution?: string | 'MKT' | 'CANCEL'\n  resolutions?: { [outcome: string]: number } // Used for MKT resolution.\n}\n\nexport type MultiNumeric = {\n  mechanism: 'cpmm-multi-1'\n  outcomeType: 'MULTI_NUMERIC'\n  unit: string\n  answers: Answer[]\n  shouldAnswersSumToOne: boolean\n  addAnswersMode: 'DISABLED'\n  totalLiquidity: number\n  subsidyPool: number\n  resolutions?: { [answerId: string]: number }\n  resolution?: string | 'CHOOSE_MULTIPLE' | 'CANCEL'\n  sort?: SortType\n}\n\nexport type MultiDate = Omit<MultiNumeric, 'outcomeType' | 'unit'> & {\n  outcomeType: 'DATE'\n  timezone: string\n  display?: 'clock'\n}\n\nexport type Stonk = {\n  outcomeType: 'STONK'\n  initialProbability: number\n}\n\nexport type BountiedQuestion = {\n  outcomeType: 'BOUNTIED_QUESTION'\n  totalBounty: number\n  bountyLeft: number\n  /** @deprecated */\n  bountyTxns?: string[]\n\n  // Special mode where bounty pays out automatically in proportion to likes over 48 hours.\n  isAutoBounty?: boolean\n}\n\nexport type Poll = {\n  outcomeType: 'POLL'\n  options: PollOption[]\n  resolutions?: string[]\n}\n\nexport type Sports = {\n  sportsStartTimestamp: string\n  sportsEventId: string\n  sportsLeague: string\n}\n\nexport type MultiContract =\n  | CPMMMultiContract\n  | CPMMNumericContract\n  | MultiNumericContract\n  | MultiDateContract\n\ntype AnyOutcomeType =\n  | Binary\n  | QuadraticFunding\n  | Stonk\n  | BountiedQuestion\n  | Poll\n  | Number\n  | CPMMMulti\n  | PseudoNumeric\n  | MultiNumeric\n  | MultiDate\n\nexport type OutcomeType = AnyOutcomeType['outcomeType']\nexport type resolution = 'YES' | 'NO' | 'MKT' | 'CANCEL'\nexport const RESOLUTIONS = ['YES', 'NO', 'MKT', 'CANCEL'] as const\nexport const CREATEABLE_OUTCOME_TYPES = [\n  'BINARY',\n  'MULTIPLE_CHOICE',\n  'PSEUDO_NUMERIC',\n  'STONK',\n  'BOUNTIED_QUESTION',\n  'POLL',\n  'NUMBER',\n  'MULTI_NUMERIC',\n  'DATE',\n] as const\n\nexport const CREATEABLE_NON_PREDICTIVE_OUTCOME_TYPES = [\n  'POLL',\n  'BOUNTIED_QUESTION',\n]\n\nexport type CreateableOutcomeType = (typeof CREATEABLE_OUTCOME_TYPES)[number]\n\nexport const renderResolution = (resolution: string, prob?: number) => {\n  return (\n    {\n      YES: 'YES',\n      NO: 'NO',\n      CANCEL: 'N/A',\n      MKT: formatPercent(prob ?? 0),\n    }[resolution] || resolution\n  )\n}\n\nexport function contractPathWithoutContract(\n  creatorUsername: string,\n  slug: string\n) {\n  return `/${creatorUsername}/${slug}`\n}\n\nexport function contractUrl(contract: Contract) {\n  return `https://${ENV_CONFIG.domain}${contractPath(contract)}`\n}\n\nexport function contractPool(contract: Contract) {\n  return contract.mechanism === 'cpmm-1'\n    ? formatMoney(contract.totalLiquidity)\n    : contract.mechanism === 'cpmm-multi-1'\n    ? formatMoney(\n        sum(\n          contract.answers.map((a) =>\n            getLiquidity({ YES: a.poolYes, NO: a.poolNo })\n          )\n        )\n      )\n    : 'Empty pool'\n}\n\nexport const isBinaryMulti = (contract: Contract) =>\n  contract.mechanism === 'cpmm-multi-1' &&\n  contract.outcomeType !== 'NUMBER' &&\n  contract.outcomeType !== 'MULTI_NUMERIC' &&\n  contract.outcomeType !== 'DATE' &&\n  contract.answers.length === 2 &&\n  contract.addAnswersMode === 'DISABLED' &&\n  contract.shouldAnswersSumToOne\n// contract.createdTime > 1708574059795 // In case we don't want to convert pre-commit contracts\n\nexport const isSportsContract = (\n  contract: Contract\n): contract is SportsContract => 'sportsEventId' in contract\n\nexport const getMainBinaryMCAnswer = (contract: Contract) =>\n  isBinaryMulti(contract) && contract.mechanism === 'cpmm-multi-1'\n    ? contract.answers[0]\n    : undefined\n\nexport const getBinaryMCProb = (prob: number, outcome: 'YES' | 'NO' | string) =>\n  outcome === 'YES' ? prob : 1 - prob\n\nexport function getBinaryProbPercent(contract: BinaryContract) {\n  return formatPercent(getDisplayProbability(contract))\n}\n\nexport function tradingAllowed(contract: Contract, answer?: Answer) {\n  return (\n    !contract.isResolved &&\n    (!contract.closeTime || contract.closeTime > Date.now()) &&\n    contract.mechanism !== 'none' &&\n    (!answer || !answer.resolution)\n  )\n}\n\nexport const MAX_QUESTION_LENGTH = 120\nexport const MAX_DESCRIPTION_LENGTH = 16000\n\nexport const CPMM_MIN_POOL_QTY = 0.01\nexport const NUMBER_BUCKETS_MAX = 50\nexport const NUMBER_CREATION_ENABLED = false\n\nexport type Visibility = 'public' | 'unlisted'\nexport const VISIBILITIES = ['public', 'unlisted'] as const\n\nexport const SORTS = [\n  { label: 'High %', value: 'prob-desc' },\n  { label: 'Low %', value: 'prob-asc' },\n  { label: 'Oldest', value: 'old' },\n  { label: 'Newest', value: 'new' },\n  { label: 'Trending', value: 'liquidity' },\n  { label: 'A-Z', value: 'alphabetical' },\n] as const\n\nexport type SortType = (typeof SORTS)[number]['value']\n\nexport const MINUTES_ALLOWED_TO_UNRESOLVE = 10\n\nexport function contractPath(contract: {\n  creatorUsername: string\n  slug: string\n}) {\n  return `/${contract.creatorUsername}/${contract.slug}`\n}\n\nexport function twombaContractPath(contract: {\n  creatorUsername: string\n  slug: string\n  token?: ContractToken\n}) {\n  const isCashContract = contract.token == 'CASH'\n  const cleanedSlug = contract.slug.replace(new RegExp(`${CASH_SUFFIX}$`), '')\n  return `/${contract.creatorUsername}/${cleanedSlug}${\n    isCashContract ? '?play=false' : '?play=true'\n  }`\n}\n\nexport type CashType = {\n  contract: Contract\n  lastBetTime?: number\n  pointsString: string\n  multiPointsString: MultiBase64Points\n  totalPositions: number\n  totalBets: number\n}\n\nexport type ContractParams = {\n  contract: Contract\n  lastBetTime?: number\n  pointsString?: string\n  multiPointsString?: MultiBase64Points\n  comments: ContractComment[]\n  totalPositions: number\n  totalBets: number\n  topContractMetrics: ContractMetric[]\n  relatedContracts: Contract[]\n  chartAnnotations: ChartAnnotation[]\n  topics: Topic[]\n  dashboards: { slug: string; title: string }[]\n  pinnedComments: ContractComment[]\n  cash?: CashType\n}\n\nexport type MaybeAuthedContractParams =\n  | {\n      state: 'authed'\n      params: ContractParams\n    }\n  | {\n      state: 'deleted'\n    }\n\nexport const MAX_CPMM_PROB = 0.99\nexport const MIN_CPMM_PROB = 0.01\nexport const MAX_STONK_PROB = 0.95\nexport const MIN_STONK_PROB = 0.2\n\nexport const isMarketRanked = (contract: Contract) =>\n  contract.isRanked != false &&\n  contract.visibility === 'public' &&\n  contract.deleted !== true\n\nexport const PROFIT_CUTOFF_TIME = 1715805887741\nexport const DPM_CUTOFF_TIMESTAMP = '2023-08-01 18:06:58.813000 +00:00'\nexport const getAdjustedProfit = (\n  contract: Contract,\n  profit: number,\n  answers: Answer[] | undefined,\n  answerId: string | null\n) => {\n  if (contract.mechanism === 'cpmm-multi-1') {\n    // Null answerId stands for the summary of all answer metrics\n    if (!answerId) {\n      return isMarketRanked(contract) &&\n        contract.resolutionTime &&\n        contract.resolutionTime <= PROFIT_CUTOFF_TIME &&\n        contract.createdTime > Date.parse(DPM_CUTOFF_TIMESTAMP)\n        ? 9 * profit\n        : isMarketRanked(contract)\n        ? undefined\n        : -1 * profit\n    }\n    const answer = answers?.find((a) => a.id === answerId)\n    if (!answer) {\n      console.log(\n        `answer with id ${answerId} not found, but is required for cpmm-multi-1 contract: ${contract.id}`\n      )\n      return undefined\n    }\n    return isMarketRanked(contract) &&\n      answer.resolutionTime &&\n      answer.resolutionTime <= PROFIT_CUTOFF_TIME &&\n      contract.createdTime > Date.parse(DPM_CUTOFF_TIMESTAMP)\n      ? 9 * profit\n      : isMarketRanked(contract)\n      ? undefined\n      : -1 * profit\n  }\n\n  return isMarketRanked(contract) &&\n    contract.resolutionTime &&\n    contract.resolutionTime <= PROFIT_CUTOFF_TIME\n    ? 9 * profit\n    : isMarketRanked(contract)\n    ? undefined\n    : -1 * profit\n}\n\n// Add the AIGeneratedMarket type definition here, before the API object\nexport type AIGeneratedMarket = Pick<\n  MarketContract,\n  'question' | 'description'\n> & {\n  outcomeType:\n    | 'INDEPENDENT_MULTIPLE_CHOICE'\n    | 'DEPENDENT_MULTIPLE_CHOICE'\n    | 'BINARY'\n    | 'POLL'\n  descriptionMarkdown: string\n  closeDate: string\n  shouldAnswersSumToOne?: boolean\n  initialProb?: number\n  answers?: string[]\n  reasoning?: string\n  addAnswersMode?: add_answers_mode\n  promptVersion: number\n}\n\nexport const nativeContractColumnsArray = [\n  'data',\n  'importance_score',\n  'freshness_score',\n  'conversion_score',\n  'view_count',\n  'token',\n  'boosted',\n  'daily_score',\n]\n\nexport const clampChange = (currentProb: number, probChange: number) => {\n  if (probChange < 0.01 && probChange > -0.01) return 0\n\n  if (probChange > 0) {\n    // For positive changes, clamp to min of change and current probability\n    return Math.min(probChange, currentProb)\n  } else {\n    // For negative changes, clamp to min of absolute change and (1 - currentProb)\n    return -Math.min(Math.abs(probChange), 1 - currentProb)\n  }\n}\n\nexport const dayProbChange = (contract: CPMMContract) => {\n  const { createdTime } = contract\n  if (Date.now() - createdTime < DAY_MS) {\n    return 0\n  }\n  const change = Math.abs(\n    Math.round(clampChange(contract.prob, contract.probChanges.day) * 100)\n  )\n  return change > 2 ? change : 0\n}\n",
          "postContent": "import { JSONContent } from '@tiptap/core'\nimport { getDisplayProbability } from 'common/calculate'\nimport { Topic } from 'common/group'\nimport { ChartAnnotation } from 'common/supabase/chart-annotations'\nimport { sum } from 'lodash'\nimport { Answer } from './answer'\nimport { getLiquidity } from './calculate-cpmm'\nimport { ContractComment } from './comment'\nimport { ContractMetric } from './contract-metric'\nimport { CASH_SUFFIX, ENV_CONFIG } from './envs/constants'\nimport { Fees } from './fees'\nimport { PollOption } from './poll-option'\nimport { formatMoney, formatPercent } from './util/format'\nimport { MultiBase64Points } from './chart'\nimport { DAY_MS } from './util/time'\n\n/************************************************\n\nsupabase status: columns exist for\n  slug: text\n  creatorId: text\n  question: text\n  visibility: text\n  mechanism: text\n  outcomeType: text\n  createdTime: timestamp (from millis)\n  closeTime?: timestamp (from millis)\n  resolutionTime?: timestamp (from millis)\n  resolution?: text\n  resolutionProbability?: numeric\n  popularityScore: numeric\n  importanceScore: numeric\n\nany changes to the type of these columns in firestore will require modifying\nthe supabase trigger, or replication of contracts may fail!\n\n*************************************************/\n\ntype AnyContractType =\n  | (CPMM & Binary)\n  | (CPMM & PseudoNumeric)\n  | QuadraticFunding\n  | (CPMM & Stonk)\n  | CPMMMulti\n  | (NonBet & BountiedQuestion)\n  | (NonBet & Poll)\n  | CPMMNumber\n  | MultiNumeric\n  | MultiDate\nexport type Contract<T extends AnyContractType = AnyContractType> = {\n  id: string\n  slug: string // auto-generated; must be unique\n\n  creatorId: string\n  creatorName: string\n  creatorUsername: string\n  creatorAvatarUrl?: string\n  creatorCreatedTime?: number\n\n  question: string\n  description: string | JSONContent // More info about what the contract is about\n  visibility: Visibility\n\n  createdTime: number // Milliseconds since epoch\n  lastUpdatedTime: number // Updated on any change to the market (metadata, bet, comment)\n  lastBetTime?: number\n  lastCommentTime?: number\n  closeTime?: number // When no more trading is allowed\n  deleted?: boolean // If true, don't show market anywhere.\n\n  isResolved: boolean\n  resolutionTime?: number // When the contract creator resolved the market\n  resolution?: string\n  resolutionProbability?: number\n  resolverId?: string\n  isSpicePayout?: boolean\n\n  closeEmailsSent?: number\n\n  volume: number\n  volume24Hours: number\n  elasticity: number\n\n  collectedFees: Fees\n  uniqueBettorCount: number\n  uniqueBettorCountDay: number\n\n  unlistedById?: string\n  featuredLabel?: string\n  isTwitchContract?: boolean\n\n  coverImageUrl?: string\n  isRanked?: boolean\n\n  gptCommentSummary?: string\n\n  token: ContractToken\n  siblingContractId?: string\n\n  /** @deprecated - no longer used */\n  takerAPIOrdersDisabled?: boolean\n\n  // Manifold.love\n  loverUserId1?: string // The user id's of the pair of lovers referenced in the question.\n  loverUserId2?: string // The user id's of the pair of lovers referenced in the question.\n  matchCreatorId?: string // The user id of the person who proposed the match.\n  isLove?: boolean\n\n  /** @deprecated - no more auto-subsidization */\n  isSubsidized?: boolean // NOTE: not backfilled, undefined = true\n  /** @deprecated - try to use group-contracts table instead */\n  groupSlugs?: string[]\n  /** @deprecated - not deprecated, only updated in native column though*/\n  popularityScore: number\n  /** @deprecated - not deprecated, only updated in native column though*/\n  importanceScore: number\n  /** @deprecated - not deprecated, only updated in native column though*/\n  dailyScore: number\n  /** @deprecated - not deprecated, only updated in native column though*/\n  freshnessScore: number\n  /** @deprecated - not deprecated, only updated in native column though*/\n  conversionScore: number\n  /** @deprecated - not deprecated, only updated in native column though*/\n  viewCount: number\n  /** @deprecated - not deprecated, only updated in native column though*/\n  boosted: boolean\n  /** @deprecated - not up-to-date */\n  likedByUserCount?: number\n} & T\n\nexport type ContractToken = 'MANA' | 'CASH'\nexport type CPMMContract = Contract & CPMM\nexport type CPMMMultiContract = Contract & CPMMMulti\nexport type CPMMNumericContract = Contract & CPMMNumber\nexport type MultiNumericContract = Contract & MultiNumeric\nexport type MultiDateContract = Contract & MultiDate\nexport type MarketContract =\n  | CPMMContract\n  | CPMMMultiContract\n  | CPMMNumericContract\n  | MultiNumericContract\n  | MultiDateContract\nexport type BinaryContract = Contract & Binary\nexport type PseudoNumericContract = Contract & PseudoNumeric\nexport type QuadraticFundingContract = Contract & QuadraticFunding\nexport type StonkContract = Contract & Stonk\nexport type BountiedQuestionContract = Contract & BountiedQuestion\nexport type PollContract = Contract & Poll\nexport type SportsContract = Contract & Sports\nexport type BinaryOrPseudoNumericContract =\n  | BinaryContract\n  | PseudoNumericContract\n  | StonkContract\n\nexport type CPMM = {\n  mechanism: 'cpmm-1'\n  pool: { [outcome: string]: number }\n  p: number // probability constant in y^p * n^(1-p) = k\n  totalLiquidity: number // for historical reasons, this the total subsidy amount added in Ṁ\n  subsidyPool: number // current value of subsidy pool in Ṁ\n  prob: number\n  probChanges: {\n    day: number\n    week: number\n    month: number\n  }\n}\n\nexport type NonBet = {\n  mechanism: 'none'\n}\n\nexport const NON_BETTING_OUTCOMES: OutcomeType[] = ['BOUNTIED_QUESTION', 'POLL']\nexport const NO_CLOSE_TIME_TYPES: OutcomeType[] = NON_BETTING_OUTCOMES.concat([\n  'STONK',\n])\n\n/**\n * Implemented as a set of cpmm-1 binary contracts, one for each answer.\n * The mechanism is stored among the contract's answers, which each\n * reference this contract id.\n */\nexport type CPMMMulti = {\n  mechanism: 'cpmm-multi-1'\n  outcomeType: 'MULTIPLE_CHOICE'\n  shouldAnswersSumToOne: boolean\n  addAnswersMode?: add_answers_mode\n\n  totalLiquidity: number // for historical reasons, this the total subsidy amount added in Ṁ\n  subsidyPool: number // current value of subsidy pool in Ṁ\n  specialLiquidityPerAnswer?: number // Special liquidity mode, where initial ante is copied into each answer's pool, with a min probability, and only one answer can resolve YES. shouldAnswersSumToOne must be false.\n\n  // Answers chosen on resolution, with the weights of each answer.\n  // Weights sum to 100 if shouldAnswersSumToOne is true. Otherwise, range from 0 to 100 for each answerId.\n  resolutions?: { [answerId: string]: number }\n\n  // NOTE: This field is stored in the answers table and must be denormalized to the client.\n  answers: Answer[]\n  sort?: SortType\n}\n\nexport const isSpecialLoveContract = (contract: Contract) =>\n  contract.mechanism === 'cpmm-multi-1' &&\n  contract.outcomeType !== 'NUMBER' &&\n  contract.outcomeType !== 'MULTI_NUMERIC' &&\n  contract.outcomeType !== 'DATE' &&\n  contract.specialLiquidityPerAnswer\n\nexport type CPMMNumber = {\n  mechanism: 'cpmm-multi-1'\n  outcomeType: 'NUMBER'\n  shouldAnswersSumToOne: true\n  addAnswersMode: 'DISABLED'\n  max: number\n  min: number\n\n  totalLiquidity: number // for historical reasons, this the total subsidy amount added in Ṁ\n  subsidyPool: number // current value of subsidy pool in Ṁ\n\n  // Answers chosen on resolution, with the weights of each answer.\n  // Weights sum to 100 if shouldAnswersSumToOne is true. Otherwise, range from 0 to 100 for each answerId.\n  resolutions?: { [answerId: string]: number }\n\n  // NOTE: This field is stored in the answers table and must be denormalized to the client.\n  answers: Answer[]\n  sort?: SortType\n}\n\nexport type add_answers_mode = 'DISABLED' | 'ONLY_CREATOR' | 'ANYONE'\n\nexport type QuadraticFunding = {\n  outcomeType: 'QUADRATIC_FUNDING'\n  mechanism: 'qf'\n  answers: any[]\n  // Mapping of how much each user has contributed to the matching pool\n  // Note: Our codebase assumes every contract has a pool, which is why this isn't just a constant\n  pool: { M$: number }\n\n  // Used when the funding round pays out\n  resolution?: 'MKT' | 'CANCEL'\n  resolutions?: { [outcome: string]: number } // Used for MKT resolution.\n}\n\nexport type Binary = {\n  outcomeType: 'BINARY'\n  initialProbability: number\n  resolutionProbability?: number // Used for BINARY markets resolved to MKT\n  resolution?: resolution\n}\n\nexport type PseudoNumeric = {\n  outcomeType: 'PSEUDO_NUMERIC'\n  min: number\n  max: number\n  isLogScale: boolean\n  resolutionValue?: number\n\n  // same as binary market; map everything to probability\n  initialProbability: number\n  resolutionProbability?: number\n}\n\nexport type Number = {\n  outcomeType: 'NUMBER'\n  answers: Answer[]\n  min: number\n  max: number\n  resolution?: string | 'MKT' | 'CANCEL'\n  resolutions?: { [outcome: string]: number } // Used for MKT resolution.\n}\n\nexport type MultiNumeric = {\n  mechanism: 'cpmm-multi-1'\n  outcomeType: 'MULTI_NUMERIC'\n  unit: string\n  answers: Answer[]\n  shouldAnswersSumToOne: boolean\n  addAnswersMode: 'DISABLED'\n  totalLiquidity: number\n  subsidyPool: number\n  resolutions?: { [answerId: string]: number }\n  resolution?: string | 'CHOOSE_MULTIPLE' | 'CANCEL'\n  sort?: SortType\n}\n\nexport type MultiDate = Omit<MultiNumeric, 'outcomeType' | 'unit'> & {\n  outcomeType: 'DATE'\n  timezone: string\n  display?: 'clock'\n}\n\nexport type Stonk = {\n  outcomeType: 'STONK'\n  initialProbability: number\n}\n\nexport type BountiedQuestion = {\n  outcomeType: 'BOUNTIED_QUESTION'\n  totalBounty: number\n  bountyLeft: number\n  /** @deprecated */\n  bountyTxns?: string[]\n\n  // Special mode where bounty pays out automatically in proportion to likes over 48 hours.\n  isAutoBounty?: boolean\n}\n\nexport type PollVoterVisibility = 'creator' | 'everyone'\n\nexport type Poll = {\n  outcomeType: 'POLL'\n  options: PollOption[]\n  resolutions?: string[]\n  voterVisibility?: PollVoterVisibility\n}\n\nexport type Sports = {\n  sportsStartTimestamp: string\n  sportsEventId: string\n  sportsLeague: string\n}\n\nexport type MultiContract =\n  | CPMMMultiContract\n  | CPMMNumericContract\n  | MultiNumericContract\n  | MultiDateContract\n\ntype AnyOutcomeType =\n  | Binary\n  | QuadraticFunding\n  | Stonk\n  | BountiedQuestion\n  | Poll\n  | Number\n  | CPMMMulti\n  | PseudoNumeric\n  | MultiNumeric\n  | MultiDate\n\nexport type OutcomeType = AnyOutcomeType['outcomeType']\nexport type resolution = 'YES' | 'NO' | 'MKT' | 'CANCEL'\nexport const RESOLUTIONS = ['YES', 'NO', 'MKT', 'CANCEL'] as const\nexport const CREATEABLE_OUTCOME_TYPES = [\n  'BINARY',\n  'MULTIPLE_CHOICE',\n  'PSEUDO_NUMERIC',\n  'STONK',\n  'BOUNTIED_QUESTION',\n  'POLL',\n  'NUMBER',\n  'MULTI_NUMERIC',\n  'DATE',\n] as const\n\nexport const CREATEABLE_NON_PREDICTIVE_OUTCOME_TYPES = [\n  'POLL',\n  'BOUNTIED_QUESTION',\n]\n\nexport type CreateableOutcomeType = (typeof CREATEABLE_OUTCOME_TYPES)[number]\n\nexport const renderResolution = (resolution: string, prob?: number) => {\n  return (\n    {\n      YES: 'YES',\n      NO: 'NO',\n      CANCEL: 'N/A',\n      MKT: formatPercent(prob ?? 0),\n    }[resolution] || resolution\n  )\n}\n\nexport function contractPathWithoutContract(\n  creatorUsername: string,\n  slug: string\n) {\n  return `/${creatorUsername}/${slug}`\n}\n\nexport function contractUrl(contract: Contract) {\n  return `https://${ENV_CONFIG.domain}${contractPath(contract)}`\n}\n\nexport function contractPool(contract: Contract) {\n  return contract.mechanism === 'cpmm-1'\n    ? formatMoney(contract.totalLiquidity)\n    : contract.mechanism === 'cpmm-multi-1'\n    ? formatMoney(\n        sum(\n          contract.answers.map((a) =>\n            getLiquidity({ YES: a.poolYes, NO: a.poolNo })\n          )\n        )\n      )\n    : 'Empty pool'\n}\n\nexport const isBinaryMulti = (contract: Contract) =>\n  contract.mechanism === 'cpmm-multi-1' &&\n  contract.outcomeType !== 'NUMBER' &&\n  contract.outcomeType !== 'MULTI_NUMERIC' &&\n  contract.outcomeType !== 'DATE' &&\n  contract.answers.length === 2 &&\n  contract.addAnswersMode === 'DISABLED' &&\n  contract.shouldAnswersSumToOne\n// contract.createdTime > 1708574059795 // In case we don't want to convert pre-commit contracts\n\nexport const isSportsContract = (\n  contract: Contract\n): contract is SportsContract => 'sportsEventId' in contract\n\nexport const getMainBinaryMCAnswer = (contract: Contract) =>\n  isBinaryMulti(contract) && contract.mechanism === 'cpmm-multi-1'\n    ? contract.answers[0]\n    : undefined\n\nexport const getBinaryMCProb = (prob: number, outcome: 'YES' | 'NO' | string) =>\n  outcome === 'YES' ? prob : 1 - prob\n\nexport function getBinaryProbPercent(contract: BinaryContract) {\n  return formatPercent(getDisplayProbability(contract))\n}\n\nexport function tradingAllowed(contract: Contract, answer?: Answer) {\n  return (\n    !contract.isResolved &&\n    (!contract.closeTime || contract.closeTime > Date.now()) &&\n    contract.mechanism !== 'none' &&\n    (!answer || !answer.resolution)\n  )\n}\n\nexport const MAX_QUESTION_LENGTH = 120\nexport const MAX_DESCRIPTION_LENGTH = 16000\n\nexport const CPMM_MIN_POOL_QTY = 0.01\nexport const NUMBER_BUCKETS_MAX = 50\nexport const NUMBER_CREATION_ENABLED = false\n\nexport type Visibility = 'public' | 'unlisted'\nexport const VISIBILITIES = ['public', 'unlisted'] as const\n\nexport const SORTS = [\n  { label: 'High %', value: 'prob-desc' },\n  { label: 'Low %', value: 'prob-asc' },\n  { label: 'Oldest', value: 'old' },\n  { label: 'Newest', value: 'new' },\n  { label: 'Trending', value: 'liquidity' },\n  { label: 'A-Z', value: 'alphabetical' },\n] as const\n\nexport type SortType = (typeof SORTS)[number]['value']\n\nexport const MINUTES_ALLOWED_TO_UNRESOLVE = 10\n\nexport function contractPath(contract: {\n  creatorUsername: string\n  slug: string\n}) {\n  return `/${contract.creatorUsername}/${contract.slug}`\n}\n\nexport function twombaContractPath(contract: {\n  creatorUsername: string\n  slug: string\n  token?: ContractToken\n}) {\n  const isCashContract = contract.token == 'CASH'\n  const cleanedSlug = contract.slug.replace(new RegExp(`${CASH_SUFFIX}$`), '')\n  return `/${contract.creatorUsername}/${cleanedSlug}${\n    isCashContract ? '?play=false' : '?play=true'\n  }`\n}\n\nexport type CashType = {\n  contract: Contract\n  lastBetTime?: number\n  pointsString: string\n  multiPointsString: MultiBase64Points\n  totalPositions: number\n  totalBets: number\n}\n\nexport type ContractParams = {\n  contract: Contract\n  lastBetTime?: number\n  pointsString?: string\n  multiPointsString?: MultiBase64Points\n  comments: ContractComment[]\n  totalPositions: number\n  totalBets: number\n  topContractMetrics: ContractMetric[]\n  relatedContracts: Contract[]\n  chartAnnotations: ChartAnnotation[]\n  topics: Topic[]\n  dashboards: { slug: string; title: string }[]\n  pinnedComments: ContractComment[]\n  cash?: CashType\n}\n\nexport type MaybeAuthedContractParams =\n  | {\n      state: 'authed'\n      params: ContractParams\n    }\n  | {\n      state: 'deleted'\n    }\n\nexport const MAX_CPMM_PROB = 0.99\nexport const MIN_CPMM_PROB = 0.01\nexport const MAX_STONK_PROB = 0.95\nexport const MIN_STONK_PROB = 0.2\n\nexport const isMarketRanked = (contract: Contract) =>\n  contract.isRanked != false &&\n  contract.visibility === 'public' &&\n  contract.deleted !== true\n\nexport const PROFIT_CUTOFF_TIME = 1715805887741\nexport const DPM_CUTOFF_TIMESTAMP = '2023-08-01 18:06:58.813000 +00:00'\nexport const getAdjustedProfit = (\n  contract: Contract,\n  profit: number,\n  answers: Answer[] | undefined,\n  answerId: string | null\n) => {\n  if (contract.mechanism === 'cpmm-multi-1') {\n    // Null answerId stands for the summary of all answer metrics\n    if (!answerId) {\n      return isMarketRanked(contract) &&\n        contract.resolutionTime &&\n        contract.resolutionTime <= PROFIT_CUTOFF_TIME &&\n        contract.createdTime > Date.parse(DPM_CUTOFF_TIMESTAMP)\n        ? 9 * profit\n        : isMarketRanked(contract)\n        ? undefined\n        : -1 * profit\n    }\n    const answer = answers?.find((a) => a.id === answerId)\n    if (!answer) {\n      console.log(\n        `answer with id ${answerId} not found, but is required for cpmm-multi-1 contract: ${contract.id}`\n      )\n      return undefined\n    }\n    return isMarketRanked(contract) &&\n      answer.resolutionTime &&\n      answer.resolutionTime <= PROFIT_CUTOFF_TIME &&\n      contract.createdTime > Date.parse(DPM_CUTOFF_TIMESTAMP)\n      ? 9 * profit\n      : isMarketRanked(contract)\n      ? undefined\n      : -1 * profit\n  }\n\n  return isMarketRanked(contract) &&\n    contract.resolutionTime &&\n    contract.resolutionTime <= PROFIT_CUTOFF_TIME\n    ? 9 * profit\n    : isMarketRanked(contract)\n    ? undefined\n    : -1 * profit\n}\n\n// Add the AIGeneratedMarket type definition here, before the API object\nexport type AIGeneratedMarket = Pick<\n  MarketContract,\n  'question' | 'description'\n> & {\n  outcomeType:\n    | 'INDEPENDENT_MULTIPLE_CHOICE'\n    | 'DEPENDENT_MULTIPLE_CHOICE'\n    | 'BINARY'\n    | 'POLL'\n  descriptionMarkdown: string\n  closeDate: string\n  shouldAnswersSumToOne?: boolean\n  initialProb?: number\n  answers?: string[]\n  reasoning?: string\n  addAnswersMode?: add_answers_mode\n  promptVersion: number\n}\n\nexport const nativeContractColumnsArray = [\n  'data',\n  'importance_score',\n  'freshness_score',\n  'conversion_score',\n  'view_count',\n  'token',\n  'boosted',\n  'daily_score',\n]\n\nexport const clampChange = (currentProb: number, probChange: number) => {\n  if (probChange < 0.01 && probChange > -0.01) return 0\n\n  if (probChange > 0) {\n    // For positive changes, clamp to min of change and current probability\n    return Math.min(probChange, currentProb)\n  } else {\n    // For negative changes, clamp to min of absolute change and (1 - currentProb)\n    return -Math.min(Math.abs(probChange), 1 - currentProb)\n  }\n}\n\nexport const dayProbChange = (contract: CPMMContract) => {\n  const { createdTime } = contract\n  if (Date.now() - createdTime < DAY_MS) {\n    return 0\n  }\n  const change = Math.abs(\n    Math.round(clampChange(contract.prob, contract.probChanges.day) * 100)\n  )\n  return change > 2 ? change : 0\n}\n"
        },
        {
          "path": "common/src/new-contract.ts",
          "preContent": "import { Answer } from './answer'\nimport { getMultiCpmmLiquidity } from './calculate-cpmm'\nimport { computeBinaryCpmmElasticityFromAnte } from './calculate-metrics'\nimport {\n  Binary,\n  BountiedQuestion,\n  CPMM,\n  CPMMMulti,\n  CPMMNumber,\n  CREATEABLE_OUTCOME_TYPES,\n  Contract,\n  MultiDate,\n  MultiNumeric,\n  NonBet,\n  Poll,\n  PseudoNumeric,\n  Stonk,\n  add_answers_mode,\n} from './contract'\nimport { PollOption } from './poll-option'\nimport { User } from './user'\nimport { removeUndefinedProps } from './util/object'\nimport { randomString } from './util/random'\n\nexport const NEW_MARKET_IMPORTANCE_SCORE = 0.25\n\nexport function getNewContract(\n  props: Pick<\n    Contract,\n    | 'id'\n    | 'slug'\n    | 'question'\n    | 'description'\n    | 'closeTime'\n    | 'visibility'\n    | 'isTwitchContract'\n    | 'token'\n    | 'takerAPIOrdersDisabled'\n    | 'siblingContractId'\n    | 'coverImageUrl'\n  > & {\n    creator: User\n    outcomeType: (typeof CREATEABLE_OUTCOME_TYPES)[number]\n    initialProb: number\n    ante: number\n\n    // Numeric\n    min: number\n    max: number\n    isLogScale: boolean\n\n    // Multi-choice\n    answers: string[]\n    addAnswersMode?: add_answers_mode | undefined\n    shouldAnswersSumToOne?: boolean | undefined\n    answerShortTexts?: string[]\n    answerImageUrls?: string[]\n\n    // Bountied\n    isAutoBounty?: boolean | undefined\n\n    // Sports\n    sportsStartTimestamp?: string\n    sportsEventId?: string\n    sportsLeague?: string\n\n    // Multi-numeric\n    unit: string | undefined\n    midpoints: number[] | undefined\n    timezone: string | undefined\n  }\n) {\n  const {\n    id,\n    slug,\n    creator,\n    question,\n    outcomeType,\n    description,\n    initialProb,\n    ante,\n    closeTime,\n    visibility,\n    isTwitchContract,\n    min,\n    max,\n    isLogScale,\n    answers,\n    addAnswersMode,\n    shouldAnswersSumToOne,\n    coverImageUrl,\n    isAutoBounty,\n    token,\n    sportsStartTimestamp,\n    sportsEventId,\n    sportsLeague,\n    answerShortTexts,\n    answerImageUrls,\n    takerAPIOrdersDisabled,\n    siblingContractId,\n    unit,\n    midpoints,\n    timezone,\n  } = props\n  const createdTime = Date.now()\n\n  const propsByOutcomeType = {\n    BINARY: () => getBinaryCpmmProps(initialProb, ante),\n    PSEUDO_NUMERIC: () =>\n      getPseudoNumericCpmmProps(initialProb, ante, min, max, isLogScale),\n    MULTIPLE_CHOICE: () =>\n      getMultipleChoiceProps(\n        id,\n        creator.id,\n        answers,\n        addAnswersMode ?? 'DISABLED',\n        shouldAnswersSumToOne ?? true,\n        ante,\n        answerShortTexts,\n        answerImageUrls\n      ),\n    STONK: () => getStonkCpmmProps(initialProb, ante),\n    BOUNTIED_QUESTION: () => getBountiedQuestionProps(ante, isAutoBounty),\n    POLL: () => getPollProps(answers),\n    NUMBER: () => getNumberProps(id, creator.id, min, max, answers, ante),\n    MULTI_NUMERIC: () =>\n      getMultiNumericProps(\n        id,\n        creator.id,\n        answers,\n        midpoints ?? [],\n        ante,\n        unit ?? '',\n        shouldAnswersSumToOne ?? true\n      ),\n    DATE: () =>\n      getDateProps(\n        id,\n        creator.id,\n        answers,\n        midpoints ?? [],\n        ante,\n        shouldAnswersSumToOne ?? true,\n        timezone ?? ''\n      ),\n  }[outcomeType]()\n\n  const contract: Contract = removeUndefinedProps({\n    id,\n    slug,\n    ...propsByOutcomeType,\n\n    creatorId: creator.id,\n    creatorName: creator.name,\n    creatorUsername: creator.username,\n    creatorAvatarUrl: creator.avatarUrl,\n    creatorCreatedTime: creator.createdTime,\n    coverImageUrl,\n\n    question: question.trim(),\n    description,\n    visibility,\n    isResolved: false,\n    createdTime,\n    closeTime,\n    dailyScore: 0,\n    popularityScore: 0,\n    importanceScore: NEW_MARKET_IMPORTANCE_SCORE,\n    freshnessScore: 0,\n    conversionScore: DEFAULT_CONVERSION_SCORE,\n    uniqueBettorCount: 0,\n    uniqueBettorCountDay: 0,\n    viewCount: 0,\n    lastUpdatedTime: createdTime,\n\n    volume: 0,\n    volume24Hours: 0,\n    elasticity:\n      propsByOutcomeType.mechanism === 'cpmm-1'\n        ? computeBinaryCpmmElasticityFromAnte(ante)\n        : propsByOutcomeType.mechanism === 'cpmm-multi-1'\n        ? 4.99 // TODO: calculate\n        : 1_000_000,\n\n    collectedFees: {\n      creatorFee: 0,\n      liquidityFee: 0,\n      platformFee: 0,\n    },\n\n    isTwitchContract,\n    token,\n\n    sportsStartTimestamp,\n    sportsEventId,\n    sportsLeague,\n\n    takerAPIOrdersDisabled,\n    siblingContractId,\n    boosted: false,\n  })\n  if (visibility === 'unlisted') {\n    contract.unlistedById = creator.id\n  }\n\n  return contract as Contract\n}\n\n/*\nimport { PHANTOM_ANTE } from './antes'\nimport { calcDpmInitialPool } from './calculate-dpm'\nconst getBinaryDpmProps = (initialProb: number, ante: number) => {\n  const { sharesYes, sharesNo, poolYes, poolNo, phantomYes, phantomNo } =\n    calcDpmInitialPool(initialProb, ante, PHANTOM_ANTE)\n\n  const system: DPM & Binary = {\n    mechanism: 'dpm-2',\n    outcomeType: 'BINARY',\n    initialProbability: initialProb / 100,\n    phantomShares: { YES: phantomYes, NO: phantomNo },\n    pool: { YES: poolYes, NO: poolNo },\n    totalShares: { YES: sharesYes, NO: sharesNo },\n    totalBets: { YES: poolYes, NO: poolNo },\n  }\n\n  return system\n}\n*/\n\nconst getBinaryCpmmProps = (initialProb: number, ante: number) => {\n  const pool = { YES: ante, NO: ante }\n  const p = initialProb / 100\n\n  const system: CPMM & Binary = {\n    mechanism: 'cpmm-1',\n    outcomeType: 'BINARY',\n    totalLiquidity: ante,\n    subsidyPool: 0,\n    initialProbability: p,\n    p,\n    pool: pool,\n    prob: p,\n    probChanges: { day: 0, week: 0, month: 0 },\n  }\n\n  return system\n}\n\nconst getPseudoNumericCpmmProps = (\n  initialProb: number,\n  ante: number,\n  min: number,\n  max: number,\n  isLogScale: boolean\n) => {\n  const system: CPMM & PseudoNumeric = {\n    ...getBinaryCpmmProps(initialProb, ante),\n    outcomeType: 'PSEUDO_NUMERIC',\n    min,\n    max,\n    isLogScale,\n  }\n\n  return system\n}\nconst getStonkCpmmProps = (initialProb: number, ante: number) => {\n  const system: CPMM & Stonk = {\n    ...getBinaryCpmmProps(initialProb, ante),\n    outcomeType: 'STONK',\n  }\n  return system\n}\n\nexport const VERSUS_COLORS = ['#4e46dc', '#e9a23b']\n\nconst getMultipleChoiceProps = (\n  contractId: string,\n  userId: string,\n  answers: string[],\n  addAnswersMode: add_answers_mode,\n  shouldAnswersSumToOne: boolean,\n  ante: number,\n  shortTexts?: string[],\n  imageUrls?: string[]\n) => {\n  const isBinaryMulti =\n    addAnswersMode === 'DISABLED' &&\n    answers.length === 2 &&\n    shouldAnswersSumToOne\n\n  const answersWithOther = answers.concat(\n    !shouldAnswersSumToOne || addAnswersMode === 'DISABLED' ? [] : ['Other']\n  )\n  const answerObjects = createAnswers(\n    contractId,\n    userId,\n    addAnswersMode,\n    shouldAnswersSumToOne,\n    ante,\n    answersWithOther,\n    removeUndefinedProps({\n      colors: isBinaryMulti ? VERSUS_COLORS : undefined,\n      shortTexts,\n      imageUrls,\n    })\n  )\n  const system: CPMMMulti = {\n    mechanism: 'cpmm-multi-1',\n    outcomeType: 'MULTIPLE_CHOICE',\n    addAnswersMode: addAnswersMode ?? 'DISABLED',\n    shouldAnswersSumToOne: shouldAnswersSumToOne ?? true,\n    answers: answerObjects,\n    totalLiquidity: ante,\n    subsidyPool: 0,\n  }\n\n  return system\n}\n\nconst getNumberProps = (\n  contractId: string,\n  userId: string,\n  min: number,\n  max: number,\n  answers: string[],\n  ante: number\n) => {\n  const answerObjects = createAnswers(\n    contractId,\n    userId,\n    'DISABLED',\n    true,\n    ante,\n    answers\n  )\n  const system: CPMMNumber = {\n    mechanism: 'cpmm-multi-1',\n    outcomeType: 'NUMBER',\n    addAnswersMode: 'DISABLED',\n    shouldAnswersSumToOne: true,\n    answers: answerObjects,\n    totalLiquidity: ante,\n    subsidyPool: 0,\n    max,\n    min,\n  }\n\n  return system\n}\nconst getMultiNumericProps = (\n  contractId: string,\n  userId: string,\n  answers: string[],\n  midpoints: number[],\n  ante: number,\n  unit: string,\n  shouldAnswersSumToOne: boolean\n) => {\n  const answerObjects = createAnswers(\n    contractId,\n    userId,\n    'DISABLED',\n    shouldAnswersSumToOne,\n    ante,\n    answers,\n    { midpoints }\n  )\n  const system: MultiNumeric = {\n    mechanism: 'cpmm-multi-1',\n    outcomeType: 'MULTI_NUMERIC',\n    shouldAnswersSumToOne,\n    addAnswersMode: 'DISABLED',\n    answers: answerObjects,\n    totalLiquidity: ante,\n    subsidyPool: 0,\n    unit,\n  }\n\n  return system\n}\nconst getDateProps = (\n  contractId: string,\n  userId: string,\n  answers: string[],\n  midpoints: number[],\n  ante: number,\n  shouldAnswersSumToOne: boolean,\n  timezone: string\n) => {\n  const answerObjects = createAnswers(\n    contractId,\n    userId,\n    'DISABLED',\n    shouldAnswersSumToOne,\n    ante,\n    answers,\n    { midpoints }\n  )\n  const system: MultiDate = {\n    mechanism: 'cpmm-multi-1',\n    outcomeType: 'DATE',\n    shouldAnswersSumToOne,\n    addAnswersMode: 'DISABLED',\n    answers: answerObjects,\n    totalLiquidity: ante,\n    subsidyPool: 0,\n    timezone,\n  }\n\n  return system\n}\n\nfunction createAnswers(\n  contractId: string,\n  userId: string,\n  addAnswersMode: add_answers_mode,\n  shouldAnswersSumToOne: boolean,\n  ante: number,\n  answers: string[],\n  options: {\n    colors?: string[]\n    shortTexts?: string[]\n    imageUrls?: string[]\n    midpoints?: number[]\n  } = {}\n) {\n  const { colors, shortTexts, imageUrls, midpoints } = options\n  const ids = answers.map(() => randomString())\n\n  let prob = 0.5\n  let poolYes = ante / answers.length\n  let poolNo = ante / answers.length\n\n  if (shouldAnswersSumToOne && answers.length > 1) {\n    const n = answers.length\n    prob = 1 / n\n    // Maximize use of ante given constraint that one answer resolves YES and\n    // the rest resolve NO.\n    // Means that:\n    //   ante = poolYes + (n - 1) * poolNo\n    // because this pays out ante mana to winners in this case.\n    // Also, cpmm identity for probability:\n    //   1 / n = poolNo / (poolYes + poolNo)\n    poolNo = ante / (2 * n - 2)\n    poolYes = ante / 2\n\n    // Naive solution that doesn't maximize liquidity:\n    // poolYes = ante * prob\n    // poolNo = ante * (prob ** 2 / (1 - prob))\n  }\n\n  const now = Date.now()\n\n  return answers.map((text, i) => {\n    const id = ids[i]\n    const answer: Answer = removeUndefinedProps({\n      id,\n      index: i,\n      contractId,\n      userId,\n      text,\n      createdTime: now,\n      color: colors?.[i],\n      shortText: shortTexts?.[i],\n      imageUrl: imageUrls?.[i],\n\n      poolYes,\n      poolNo,\n      prob,\n      totalLiquidity: getMultiCpmmLiquidity({ YES: poolYes, NO: poolNo }),\n      subsidyPool: 0,\n      isOther:\n        shouldAnswersSumToOne &&\n        addAnswersMode !== 'DISABLED' &&\n        i === answers.length - 1,\n      probChanges: { day: 0, week: 0, month: 0 },\n      midpoint: midpoints?.[i],\n    })\n    return answer\n  })\n}\n\nconst getBountiedQuestionProps = (\n  ante: number,\n  isAutoBounty: boolean | undefined\n) => {\n  const system: NonBet & BountiedQuestion = {\n    mechanism: 'none',\n    outcomeType: 'BOUNTIED_QUESTION',\n    totalBounty: ante,\n    bountyLeft: ante,\n    isAutoBounty: isAutoBounty ?? false,\n  }\n\n  return system\n}\n\nconst getPollProps = (answers: string[]) => {\n  const ids = answers.map(() => randomString())\n\n  const options: PollOption[] = answers.map((answer, i) => ({\n    id: ids[i],\n    index: i,\n    text: answer,\n    votes: 0,\n  }))\n\n  const system: NonBet & Poll = {\n    mechanism: 'none',\n    outcomeType: 'POLL',\n    options: options,\n  }\n  return system\n}\n\nexport const DEFAULT_CONVERSION_SCORE_NUMERATOR = 2\nexport const DEFAULT_CONVERSION_SCORE_DENOMINATOR = 15\nconst DEFAULT_CONVERSION_SCORE =\n  DEFAULT_CONVERSION_SCORE_NUMERATOR / DEFAULT_CONVERSION_SCORE_DENOMINATOR\n",
          "postContent": "import { Answer } from './answer'\nimport { getMultiCpmmLiquidity } from './calculate-cpmm'\nimport { computeBinaryCpmmElasticityFromAnte } from './calculate-metrics'\nimport {\n  Binary,\n  BountiedQuestion,\n  CPMM,\n  CPMMMulti,\n  CPMMNumber,\n  CREATEABLE_OUTCOME_TYPES,\n  Contract,\n  MultiDate,\n  MultiNumeric,\n  NonBet,\n  Poll,\n  PollVoterVisibility,\n  PseudoNumeric,\n  Stonk,\n  add_answers_mode,\n} from './contract'\nimport { PollOption } from './poll-option'\nimport { User } from './user'\nimport { removeUndefinedProps } from './util/object'\nimport { randomString } from './util/random'\n\nexport const NEW_MARKET_IMPORTANCE_SCORE = 0.25\n\nexport function getNewContract(\n  props: Pick<\n    Contract,\n    | 'id'\n    | 'slug'\n    | 'question'\n    | 'description'\n    | 'closeTime'\n    | 'visibility'\n    | 'isTwitchContract'\n    | 'token'\n    | 'takerAPIOrdersDisabled'\n    | 'siblingContractId'\n    | 'coverImageUrl'\n  > & {\n    creator: User\n    outcomeType: (typeof CREATEABLE_OUTCOME_TYPES)[number]\n    initialProb: number\n    ante: number\n\n    // Numeric\n    min: number\n    max: number\n    isLogScale: boolean\n\n    // Multi-choice\n    answers: string[]\n    addAnswersMode?: add_answers_mode | undefined\n    shouldAnswersSumToOne?: boolean | undefined\n    answerShortTexts?: string[]\n    answerImageUrls?: string[]\n\n    // Bountied\n    isAutoBounty?: boolean | undefined\n\n    // Sports\n    sportsStartTimestamp?: string\n    sportsEventId?: string\n    sportsLeague?: string\n\n    // Multi-numeric\n    unit: string | undefined\n    midpoints: number[] | undefined\n    timezone: string | undefined\n\n    // Poll\n    voterVisibility: PollVoterVisibility | undefined\n  }\n) {\n  const {\n    id,\n    slug,\n    creator,\n    question,\n    outcomeType,\n    description,\n    initialProb,\n    ante,\n    closeTime,\n    visibility,\n    isTwitchContract,\n    min,\n    max,\n    isLogScale,\n    answers,\n    addAnswersMode,\n    shouldAnswersSumToOne,\n    coverImageUrl,\n    isAutoBounty,\n    token,\n    sportsStartTimestamp,\n    sportsEventId,\n    sportsLeague,\n    answerShortTexts,\n    answerImageUrls,\n    takerAPIOrdersDisabled,\n    siblingContractId,\n    unit,\n    midpoints,\n    timezone,\n    voterVisibility,\n  } = props\n  const createdTime = Date.now()\n\n  const propsByOutcomeType = {\n    BINARY: () => getBinaryCpmmProps(initialProb, ante),\n    PSEUDO_NUMERIC: () =>\n      getPseudoNumericCpmmProps(initialProb, ante, min, max, isLogScale),\n    MULTIPLE_CHOICE: () =>\n      getMultipleChoiceProps(\n        id,\n        creator.id,\n        answers,\n        addAnswersMode ?? 'DISABLED',\n        shouldAnswersSumToOne ?? true,\n        ante,\n        answerShortTexts,\n        answerImageUrls\n      ),\n    STONK: () => getStonkCpmmProps(initialProb, ante),\n    BOUNTIED_QUESTION: () => getBountiedQuestionProps(ante, isAutoBounty),\n    POLL: () => getPollProps(answers, voterVisibility),\n    NUMBER: () => getNumberProps(id, creator.id, min, max, answers, ante),\n    MULTI_NUMERIC: () =>\n      getMultiNumericProps(\n        id,\n        creator.id,\n        answers,\n        midpoints ?? [],\n        ante,\n        unit ?? '',\n        shouldAnswersSumToOne ?? true\n      ),\n    DATE: () =>\n      getDateProps(\n        id,\n        creator.id,\n        answers,\n        midpoints ?? [],\n        ante,\n        shouldAnswersSumToOne ?? true,\n        timezone ?? ''\n      ),\n  }[outcomeType]()\n\n  const contract: Contract = removeUndefinedProps({\n    id,\n    slug,\n    ...propsByOutcomeType,\n\n    creatorId: creator.id,\n    creatorName: creator.name,\n    creatorUsername: creator.username,\n    creatorAvatarUrl: creator.avatarUrl,\n    creatorCreatedTime: creator.createdTime,\n    coverImageUrl,\n\n    question: question.trim(),\n    description,\n    visibility,\n    isResolved: false,\n    createdTime,\n    closeTime,\n    dailyScore: 0,\n    popularityScore: 0,\n    importanceScore: NEW_MARKET_IMPORTANCE_SCORE,\n    freshnessScore: 0,\n    conversionScore: DEFAULT_CONVERSION_SCORE,\n    uniqueBettorCount: 0,\n    uniqueBettorCountDay: 0,\n    viewCount: 0,\n    lastUpdatedTime: createdTime,\n\n    volume: 0,\n    volume24Hours: 0,\n    elasticity:\n      propsByOutcomeType.mechanism === 'cpmm-1'\n        ? computeBinaryCpmmElasticityFromAnte(ante)\n        : propsByOutcomeType.mechanism === 'cpmm-multi-1'\n        ? 4.99 // TODO: calculate\n        : 1_000_000,\n\n    collectedFees: {\n      creatorFee: 0,\n      liquidityFee: 0,\n      platformFee: 0,\n    },\n\n    isTwitchContract,\n    token,\n\n    sportsStartTimestamp,\n    sportsEventId,\n    sportsLeague,\n\n    takerAPIOrdersDisabled,\n    siblingContractId,\n    boosted: false,\n  })\n  if (visibility === 'unlisted') {\n    contract.unlistedById = creator.id\n  }\n\n  return contract as Contract\n}\n\n/*\nimport { PHANTOM_ANTE } from './antes'\nimport { calcDpmInitialPool } from './calculate-dpm'\nconst getBinaryDpmProps = (initialProb: number, ante: number) => {\n  const { sharesYes, sharesNo, poolYes, poolNo, phantomYes, phantomNo } =\n    calcDpmInitialPool(initialProb, ante, PHANTOM_ANTE)\n\n  const system: DPM & Binary = {\n    mechanism: 'dpm-2',\n    outcomeType: 'BINARY',\n    initialProbability: initialProb / 100,\n    phantomShares: { YES: phantomYes, NO: phantomNo },\n    pool: { YES: poolYes, NO: poolNo },\n    totalShares: { YES: sharesYes, NO: sharesNo },\n    totalBets: { YES: poolYes, NO: poolNo },\n  }\n\n  return system\n}\n*/\n\nconst getBinaryCpmmProps = (initialProb: number, ante: number) => {\n  const pool = { YES: ante, NO: ante }\n  const p = initialProb / 100\n\n  const system: CPMM & Binary = {\n    mechanism: 'cpmm-1',\n    outcomeType: 'BINARY',\n    totalLiquidity: ante,\n    subsidyPool: 0,\n    initialProbability: p,\n    p,\n    pool: pool,\n    prob: p,\n    probChanges: { day: 0, week: 0, month: 0 },\n  }\n\n  return system\n}\n\nconst getPseudoNumericCpmmProps = (\n  initialProb: number,\n  ante: number,\n  min: number,\n  max: number,\n  isLogScale: boolean\n) => {\n  const system: CPMM & PseudoNumeric = {\n    ...getBinaryCpmmProps(initialProb, ante),\n    outcomeType: 'PSEUDO_NUMERIC',\n    min,\n    max,\n    isLogScale,\n  }\n\n  return system\n}\nconst getStonkCpmmProps = (initialProb: number, ante: number) => {\n  const system: CPMM & Stonk = {\n    ...getBinaryCpmmProps(initialProb, ante),\n    outcomeType: 'STONK',\n  }\n  return system\n}\n\nexport const VERSUS_COLORS = ['#4e46dc', '#e9a23b']\n\nconst getMultipleChoiceProps = (\n  contractId: string,\n  userId: string,\n  answers: string[],\n  addAnswersMode: add_answers_mode,\n  shouldAnswersSumToOne: boolean,\n  ante: number,\n  shortTexts?: string[],\n  imageUrls?: string[]\n) => {\n  const isBinaryMulti =\n    addAnswersMode === 'DISABLED' &&\n    answers.length === 2 &&\n    shouldAnswersSumToOne\n\n  const answersWithOther = answers.concat(\n    !shouldAnswersSumToOne || addAnswersMode === 'DISABLED' ? [] : ['Other']\n  )\n  const answerObjects = createAnswers(\n    contractId,\n    userId,\n    addAnswersMode,\n    shouldAnswersSumToOne,\n    ante,\n    answersWithOther,\n    removeUndefinedProps({\n      colors: isBinaryMulti ? VERSUS_COLORS : undefined,\n      shortTexts,\n      imageUrls,\n    })\n  )\n  const system: CPMMMulti = {\n    mechanism: 'cpmm-multi-1',\n    outcomeType: 'MULTIPLE_CHOICE',\n    addAnswersMode: addAnswersMode ?? 'DISABLED',\n    shouldAnswersSumToOne: shouldAnswersSumToOne ?? true,\n    answers: answerObjects,\n    totalLiquidity: ante,\n    subsidyPool: 0,\n  }\n\n  return system\n}\n\nconst getNumberProps = (\n  contractId: string,\n  userId: string,\n  min: number,\n  max: number,\n  answers: string[],\n  ante: number\n) => {\n  const answerObjects = createAnswers(\n    contractId,\n    userId,\n    'DISABLED',\n    true,\n    ante,\n    answers\n  )\n  const system: CPMMNumber = {\n    mechanism: 'cpmm-multi-1',\n    outcomeType: 'NUMBER',\n    addAnswersMode: 'DISABLED',\n    shouldAnswersSumToOne: true,\n    answers: answerObjects,\n    totalLiquidity: ante,\n    subsidyPool: 0,\n    max,\n    min,\n  }\n\n  return system\n}\nconst getMultiNumericProps = (\n  contractId: string,\n  userId: string,\n  answers: string[],\n  midpoints: number[],\n  ante: number,\n  unit: string,\n  shouldAnswersSumToOne: boolean\n) => {\n  const answerObjects = createAnswers(\n    contractId,\n    userId,\n    'DISABLED',\n    shouldAnswersSumToOne,\n    ante,\n    answers,\n    { midpoints }\n  )\n  const system: MultiNumeric = {\n    mechanism: 'cpmm-multi-1',\n    outcomeType: 'MULTI_NUMERIC',\n    shouldAnswersSumToOne,\n    addAnswersMode: 'DISABLED',\n    answers: answerObjects,\n    totalLiquidity: ante,\n    subsidyPool: 0,\n    unit,\n  }\n\n  return system\n}\nconst getDateProps = (\n  contractId: string,\n  userId: string,\n  answers: string[],\n  midpoints: number[],\n  ante: number,\n  shouldAnswersSumToOne: boolean,\n  timezone: string\n) => {\n  const answerObjects = createAnswers(\n    contractId,\n    userId,\n    'DISABLED',\n    shouldAnswersSumToOne,\n    ante,\n    answers,\n    { midpoints }\n  )\n  const system: MultiDate = {\n    mechanism: 'cpmm-multi-1',\n    outcomeType: 'DATE',\n    shouldAnswersSumToOne,\n    addAnswersMode: 'DISABLED',\n    answers: answerObjects,\n    totalLiquidity: ante,\n    subsidyPool: 0,\n    timezone,\n  }\n\n  return system\n}\n\nfunction createAnswers(\n  contractId: string,\n  userId: string,\n  addAnswersMode: add_answers_mode,\n  shouldAnswersSumToOne: boolean,\n  ante: number,\n  answers: string[],\n  options: {\n    colors?: string[]\n    shortTexts?: string[]\n    imageUrls?: string[]\n    midpoints?: number[]\n  } = {}\n) {\n  const { colors, shortTexts, imageUrls, midpoints } = options\n  const ids = answers.map(() => randomString())\n\n  let prob = 0.5\n  let poolYes = ante / answers.length\n  let poolNo = ante / answers.length\n\n  if (shouldAnswersSumToOne && answers.length > 1) {\n    const n = answers.length\n    prob = 1 / n\n    // Maximize use of ante given constraint that one answer resolves YES and\n    // the rest resolve NO.\n    // Means that:\n    //   ante = poolYes + (n - 1) * poolNo\n    // because this pays out ante mana to winners in this case.\n    // Also, cpmm identity for probability:\n    //   1 / n = poolNo / (poolYes + poolNo)\n    poolNo = ante / (2 * n - 2)\n    poolYes = ante / 2\n\n    // Naive solution that doesn't maximize liquidity:\n    // poolYes = ante * prob\n    // poolNo = ante * (prob ** 2 / (1 - prob))\n  }\n\n  const now = Date.now()\n\n  return answers.map((text, i) => {\n    const id = ids[i]\n    const answer: Answer = removeUndefinedProps({\n      id,\n      index: i,\n      contractId,\n      userId,\n      text,\n      createdTime: now,\n      color: colors?.[i],\n      shortText: shortTexts?.[i],\n      imageUrl: imageUrls?.[i],\n\n      poolYes,\n      poolNo,\n      prob,\n      totalLiquidity: getMultiCpmmLiquidity({ YES: poolYes, NO: poolNo }),\n      subsidyPool: 0,\n      isOther:\n        shouldAnswersSumToOne &&\n        addAnswersMode !== 'DISABLED' &&\n        i === answers.length - 1,\n      probChanges: { day: 0, week: 0, month: 0 },\n      midpoint: midpoints?.[i],\n    })\n    return answer\n  })\n}\n\nconst getBountiedQuestionProps = (\n  ante: number,\n  isAutoBounty: boolean | undefined\n) => {\n  const system: NonBet & BountiedQuestion = {\n    mechanism: 'none',\n    outcomeType: 'BOUNTIED_QUESTION',\n    totalBounty: ante,\n    bountyLeft: ante,\n    isAutoBounty: isAutoBounty ?? false,\n  }\n\n  return system\n}\n\nconst getPollProps = (\n  answers: string[],\n  voterVisibility: PollVoterVisibility | undefined\n) => {\n  const ids = answers.map(() => randomString())\n\n  const options: PollOption[] = answers.map((answer, i) => ({\n    id: ids[i],\n    index: i,\n    text: answer,\n    votes: 0,\n  }))\n\n  const system: NonBet & Poll = removeUndefinedProps({\n    mechanism: 'none',\n    outcomeType: 'POLL',\n    options: options,\n    voterVisibility,\n  })\n  return system\n}\n\nexport const DEFAULT_CONVERSION_SCORE_NUMERATOR = 2\nexport const DEFAULT_CONVERSION_SCORE_DENOMINATOR = 15\nconst DEFAULT_CONVERSION_SCORE =\n  DEFAULT_CONVERSION_SCORE_NUMERATOR / DEFAULT_CONVERSION_SCORE_DENOMINATOR\n"
        },
        {
          "path": "web/components/new-contract/contract-params-form.tsx",
          "preContent": "import dayjs from 'dayjs'\nimport router from 'next/router'\nimport { useEffect, useState, useCallback } from 'react'\nimport { generateJSON, JSONContent } from '@tiptap/core'\nimport { debounce } from 'lodash'\n\nimport {\n  add_answers_mode,\n  Contract,\n  CreateableOutcomeType,\n  MAX_DESCRIPTION_LENGTH,\n  MAX_QUESTION_LENGTH,\n  NUMBER_BUCKETS_MAX,\n  NON_BETTING_OUTCOMES,\n  twombaContractPath,\n  Visibility,\n} from 'common/contract'\nimport {\n  getAnte,\n  getUniqueBettorBonusAmount,\n  MINIMUM_BOUNTY,\n} from 'common/economy'\nimport { MultipleChoiceAnswers } from 'web/components/answers/multiple-choice-answers'\nimport { Button } from 'web/components/buttons/button'\nimport { Row } from 'web/components/layout/row'\nimport {\n  getEditorLocalStorageKey,\n  TextEditor,\n  useTextEditor,\n} from 'web/components/widgets/editor'\nimport { ExpandingInput } from 'web/components/widgets/expanding-input'\nimport { InfoTooltip } from 'web/components/widgets/info-tooltip'\nimport ShortToggle from 'web/components/widgets/short-toggle'\nimport { Group, MAX_GROUPS_PER_MARKET } from 'common/group'\nimport { STONK_NO, STONK_YES } from 'common/stonk'\nimport { User } from 'common/user'\nimport { removeUndefinedProps } from 'common/util/object'\nimport { extensions, richTextToString } from 'common/util/parse'\nimport {\n  setPersistentLocalState,\n  usePersistentLocalState,\n} from 'web/hooks/use-persistent-local-state'\nimport {\n  api,\n  getSimilarGroupsToContract,\n  searchContracts,\n} from 'web/lib/api/api'\nimport { track } from 'web/lib/service/analytics'\nimport { getGroup, getGroupFromSlug } from 'web/lib/supabase/group'\nimport { safeLocalStorage } from 'web/lib/util/local'\nimport { Col } from '../layout/col'\nimport { BuyAmountInput } from '../widgets/amount-input'\nimport { getContractTypeFromValue } from './create-contract-types'\nimport { NewQuestionParams } from './new-contract-panel'\nimport { filterDefined } from 'common/util/array'\nimport {\n  removePersistentInMemoryState,\n  usePersistentInMemoryState,\n} from 'client-common/hooks/use-persistent-in-memory-state'\nimport { compareTwoStrings } from 'string-similarity'\nimport { CostSection } from 'web/components/new-contract/cost-section'\nimport { CloseTimeSection } from 'web/components/new-contract/close-time-section'\nimport { TopicSelectorSection } from 'web/components/new-contract/topic-selector-section'\nimport { PseudoNumericRangeSection } from 'web/components/new-contract/pseudo-numeric-range-section'\nimport { SimilarContractsSection } from 'web/components/new-contract/similar-contracts-section'\nimport { MultiNumericRangeSection } from './multi-numeric-range-section'\nimport { NumberRangeSection } from './number-range-section'\nimport { getMultiNumericAnswerBucketRangeNames } from 'common/src/number'\nimport { randomString } from 'common/util/random'\nimport { formatWithToken } from 'common/util/format'\nimport { BiUndo } from 'react-icons/bi'\nimport { getAnswerCostFromLiquidity, liquidityTiers } from 'common/tier'\nimport { MultiNumericDateSection } from './multi-numeric-date-section'\nimport { Modal, MODAL_CLASS } from '../layout/modal'\nimport { RelativeTimestamp } from '../relative-timestamp'\nimport { MarketDraft } from 'common/drafts'\nimport { toast } from 'react-hot-toast'\nimport { useEvent } from 'client-common/hooks/use-event'\nexport const seeResultsAnswer = 'See results'\nexport function ContractParamsForm(props: {\n  creator: User\n  outcomeType: CreateableOutcomeType\n  params?: Partial<NewQuestionParams>\n}) {\n  const { creator, params, outcomeType } = props\n\n  const [liquidityTier, setLiquidityTier] = usePersistentLocalState<number>(\n    liquidityTiers[0],\n    'liquidity-tier'\n  )\n\n  const paramsKey =\n    params?.overrideKey ??\n    (params?.q ?? '') +\n      (params?.groupSlugs?.join('') ?? '') +\n      (params?.groupIds?.join('') ?? '') +\n      (params?.rand ?? '')\n  const minStringKey = 'min' + paramsKey\n  const [minString, setMinString] = usePersistentLocalState(\n    params?.min?.toString() ?? '',\n    minStringKey\n  )\n\n  const maxStringKey = 'max' + paramsKey\n  const [maxString, setMaxString] = usePersistentLocalState(\n    params?.max?.toString() ?? '',\n    maxStringKey\n  )\n\n  const precisionKey = 'numeric-precision' + paramsKey\n  const [precision, setPrecision] = usePersistentLocalState<number | undefined>(\n    params?.precision ?? 1,\n    precisionKey\n  )\n\n  const isLogScaleKey = 'new-is-log-scale' + paramsKey\n  const [isLogScale, setIsLogScale] = usePersistentLocalState<boolean>(\n    !!params?.isLogScale,\n    isLogScaleKey\n  )\n\n  const visibilityKey = 'new-visibility' + paramsKey\n  const [visibility, setVisibility] = usePersistentLocalState<Visibility>(\n    (params?.visibility ?? 'public') as Visibility,\n    visibilityKey\n  )\n\n  const initValueKey = 'new-init-value' + paramsKey\n  const [initialValueString, setInitialValueString] = usePersistentLocalState(\n    params?.initValue?.toString(),\n    initValueKey\n  )\n\n  // Don't use the usePersistentLocalState hook for this, because there's too high a risk that it will survive in local storage\n  // longer than it should under a trivial paramsKey like '', and improperly prevent users from creating any new contracts.\n  const [idempotencyKey] = useState(randomString())\n\n  // For multiple choice, init to 2 empty answers\n  const defaultAnswers =\n    outcomeType === 'MULTIPLE_CHOICE' ||\n    outcomeType == 'MULTI_NUMERIC' ||\n    outcomeType == 'DATE'\n      ? ['', '']\n      : outcomeType == 'POLL'\n      ? ['', '', seeResultsAnswer]\n      : []\n\n  const answersKey = 'new-answers-with-other' + paramsKey\n  const [answers, setAnswers] = usePersistentLocalState(\n    params?.answers ?? defaultAnswers,\n    answersKey\n  )\n  const [midpoints, setMidpoints] = usePersistentLocalState<number[]>(\n    params?.midpoints ?? [],\n    'new-numeric-midpoints' + paramsKey\n  )\n  const [multiNumericSumsToOne, setMultiNumericSumsToOne] =\n    usePersistentLocalState<boolean>(\n      params?.shouldAnswersSumToOne ?? true,\n      'multi-numeric-sums-to-one' + paramsKey\n    )\n  const unitKey = 'multi-numeric-unit' + paramsKey\n  const [unit, setUnit] = usePersistentLocalState<string>(\n    params?.unit ?? '',\n    unitKey\n  )\n  const addAnswersModeKey = 'new-add-answers-mode' + paramsKey\n  const [addAnswersMode, setAddAnswersMode] =\n    usePersistentLocalState<add_answers_mode>(\n      params?.addAnswersMode ?? 'DISABLED',\n      addAnswersModeKey\n    )\n  const shouldAnswersSumToOne =\n    outcomeType === 'MULTI_NUMERIC' || outcomeType === 'DATE'\n      ? multiNumericSumsToOne\n      : params?.shouldAnswersSumToOne ?? false\n\n  // NOTE: if you add another user-controlled state variable, you should also add it to the duplication parameters and resetProperties()\n\n  const hasOtherAnswer =\n    addAnswersMode !== 'DISABLED' &&\n    shouldAnswersSumToOne &&\n    outcomeType != 'POLL'\n  const numAnswers = hasOtherAnswer ? answers.length + 1 : answers.length\n\n  useEffect(() => {\n    if (!params?.q) return\n\n    setQuestion(params.q)\n    if (!params.groupIds?.length && !params.groupSlugs?.length) {\n      findTopicsAndSimilarQuestions(params.q)\n    }\n  }, [params?.q])\n\n  useEffect(() => {\n    if (params?.answers) {\n      setAnswers(params.answers)\n    } else if (answers.length && answers.every((a) => a.trim().length === 0)) {\n      setAnswers(defaultAnswers)\n    } else if (outcomeType === 'MULTIPLE_CHOICE' && answers.length < 2) {\n      if (answers.length === 0) setAnswers(defaultAnswers)\n      else setAnswers(answers.concat(['']))\n    }\n  }, [JSON.stringify(params?.answers)])\n\n  useEffect(() => {\n    if (params?.groupIds) {\n      const getAndSetGroups = async (groupIds: string[]) => {\n        const groups = await Promise.all(groupIds.map((id) => getGroup(id)))\n        setSelectedGroups(filterDefined(groups))\n      }\n      getAndSetGroups(params.groupIds)\n    }\n    if (params?.groupSlugs) {\n      const getAndSetGroupsViaSlugs = async (groupSlugs: string[]) => {\n        const groups = await Promise.all(\n          groupSlugs.map((s) => getGroupFromSlug(s))\n        )\n        setSelectedGroups(filterDefined(groups))\n      }\n      getAndSetGroupsViaSlugs(params.groupSlugs)\n    }\n  }, [JSON.stringify(params?.groupIds)])\n\n  useEffect(() => {\n    if (addAnswersMode === 'DISABLED' && answers.length < 2) {\n      if (answers.length === 0) setAnswers(defaultAnswers)\n      else setAnswers((a) => [...a, ''])\n    }\n  }, [addAnswersMode, answers.length])\n  const [isSavingDraft, setIsSavingDraft] = useState(false)\n\n  const questionKey = 'new-question' + paramsKey\n  const [question, setQuestion] = usePersistentLocalState(\n    params?.q ?? '',\n    questionKey\n  )\n\n  const [suggestedTitle, setSuggestedTitle] = useState<string | undefined>()\n  const [applyingTitle, setApplyingTitle] = useState<boolean>(false)\n  const [isGeneratingTitle, setIsGeneratingTitle] = useState(false)\n\n  const generateConciseTitle = useCallback(async (currentQuestion: string) => {\n    if (\n      !currentQuestion ||\n      currentQuestion.length < 20 ||\n      outcomeType === 'MULTIPLE_CHOICE' ||\n      outcomeType === 'BOUNTIED_QUESTION' ||\n      outcomeType === 'POLL' ||\n      outcomeType === 'STONK'\n    ) {\n      if (suggestedTitle) setSuggestedTitle(undefined)\n      return\n    }\n    setIsGeneratingTitle(true)\n    try {\n      const result = await api('generate-concise-title', {\n        question: currentQuestion,\n      })\n      if (result.title) {\n        setSuggestedTitle(\n          result.title !== currentQuestion ? result.title : undefined\n        )\n      }\n    } catch (e) {\n      console.error('Error generating title:', e)\n    }\n    setIsGeneratingTitle(false)\n  }, [])\n\n  const debouncedGenerateTitle = useCallback(\n    debounce((question: string) => {\n      generateConciseTitle(question)\n    }, 1000),\n    []\n  )\n\n  useEffect(() => {\n    if (applyingTitle) return\n    debouncedGenerateTitle(question)\n    return () => debouncedGenerateTitle.cancel()\n  }, [question])\n\n  const categorizedQuestionKey = 'last-categorized-question' + paramsKey\n  const [categorizedQuestion, setCategorizedQuestion] = usePersistentLocalState(\n    '',\n    categorizedQuestionKey\n  )\n  const hasDuplicateCategories =\n    (params?.groupIds?.length ?? 0) > 0 || (params?.groupSlugs?.length ?? 0) > 0\n  const hasChosenCategoryKey = 'has-chosen-category' + paramsKey\n  const [hasChosenCategory, setHasChosenCategory] = usePersistentLocalState(\n    hasDuplicateCategories,\n    hasChosenCategoryKey\n  )\n\n  const similarContractsKey = 'similar-contracts' + paramsKey\n  const [similarContracts, setSimilarContracts] = usePersistentInMemoryState<\n    Contract[]\n  >([], similarContractsKey)\n\n  const dismissedSimilarContractsKey = 'dismissed-similar-contracts'\n  const [dismissedSimilarContractTitles, setDismissedSimilarContractTitles] =\n    usePersistentInMemoryState<string[]>([], dismissedSimilarContractsKey)\n\n  const timeInMs = params?.closeTime ? Number(params.closeTime) : undefined\n  const initDate = (timeInMs ? dayjs(timeInMs) : dayjs().add(7, 'day')).format(\n    'YYYY-MM-DD'\n  )\n  const initTime = timeInMs ? dayjs(timeInMs).format('HH:mm') : '23:59'\n\n  const closeDateKey = 'now-close-date' + paramsKey\n  const [closeDate, setCloseDate] = usePersistentLocalState<undefined | string>(\n    initDate,\n    closeDateKey\n  )\n\n  const closeHoursMinutesKey = 'now-close-time' + paramsKey\n  const [closeHoursMinutes, setCloseHoursMinutes] = usePersistentLocalState<\n    string | undefined\n  >(initTime, closeHoursMinutesKey)\n\n  const selectedGroupsKey = 'new-selected-groups' + paramsKey\n  const [selectedGroups, setSelectedGroups] = usePersistentLocalState<Group[]>(\n    [],\n    selectedGroupsKey\n  )\n\n  const defaultBountyAmount = 1000\n  const bountyKey = 'new-bounty' + paramsKey\n  const [bountyAmount, setBountyAmount] = usePersistentLocalState<\n    number | undefined\n  >(defaultBountyAmount, bountyKey)\n\n  const isAutoBountyKey = 'is-auto-bounty' + paramsKey\n  const [isAutoBounty, setIsAutoBounty] = usePersistentLocalState(\n    false,\n    isAutoBountyKey\n  )\n\n  const { balance } = creator\n\n  const closeTime = closeDate\n    ? dayjs(`${closeDate}T${closeHoursMinutes}`).valueOf()\n    : undefined\n  const hasManuallyEditedCloseDateKey =\n    'has-manually-edited-close-date' + paramsKey\n  const [_, setHasManuallyEditedCloseDate] = usePersistentLocalState<boolean>(\n    false,\n    hasManuallyEditedCloseDateKey\n  )\n  // Only way to get the real state is to read directly from localStorage after await to bypass stale closures\n  const readHasManuallyEditedCloseDate = useCallback(\n    () => safeLocalStorage?.getItem(hasManuallyEditedCloseDateKey) === 'true',\n    [hasManuallyEditedCloseDateKey]\n  )\n\n  const min = minString ? parseFloat(minString) : undefined\n  const max = maxString ? parseFloat(maxString) : undefined\n  const initialValue = initialValueString\n    ? parseFloat(initialValueString)\n    : undefined\n\n  const [neverCloses, setNeverCloses] = useState(false)\n\n  const shouldHaveCloseDate =\n    outcomeType !== 'STONK' && !NON_BETTING_OUTCOMES.includes(outcomeType)\n\n  useEffect(() => {\n    if (!shouldHaveCloseDate) {\n      setCloseDate(undefined)\n      setCloseHoursMinutes(undefined)\n      setNeverCloses(true)\n      if (outcomeType == 'STONK') {\n        if (editor?.isEmpty) {\n          editor?.commands.setContent(\n            generateJSON(\n              `<div>\n            ${STONK_YES}: good<br/>${STONK_NO}: bad<br/>Question trades based on sentiment & never\n            resolves.\n          </div>`,\n              extensions\n            )\n          )\n        }\n      }\n    } else if (!closeDate) {\n      setCloseDate(initDate)\n      setCloseHoursMinutes(initTime)\n    }\n  }, [outcomeType])\n\n  const isValidQuestion =\n    question.length > 0 && question.length <= MAX_QUESTION_LENGTH\n  const hasAnswers =\n    outcomeType === 'MULTIPLE_CHOICE' ||\n    outcomeType === 'POLL' ||\n    outcomeType === 'MULTI_NUMERIC' ||\n    outcomeType === 'DATE'\n  const isValidMultipleChoice =\n    !hasAnswers || answers.every((answer) => answer.trim().length > 0)\n\n  const isValidDate =\n    // closeTime must be in the future\n    !shouldHaveCloseDate || (closeTime ?? Infinity) > Date.now()\n\n  const isValidTopics = selectedGroups.length <= MAX_GROUPS_PER_MARKET\n  const ante = getAnte(outcomeType, numAnswers, liquidityTier)\n  const antePlusOneAnswer = getAnte(outcomeType, numAnswers + 1, liquidityTier)\n  const answerCost = getAnswerCostFromLiquidity(ante, numAnswers)\n  const marginalCost = antePlusOneAnswer > ante ? answerCost : 0\n  const numberOfBuckets = getMultiNumericAnswerBucketRangeNames(\n    min ?? 0,\n    max ?? 0,\n    precision && precision > 0 ? precision : 1\n  ).length\n  const minMaxValid =\n    min !== undefined &&\n    max !== undefined &&\n    isFinite(min) &&\n    isFinite(max) &&\n    min < max\n\n  const midpointsError =\n    outcomeType === 'MULTI_NUMERIC' || outcomeType === 'DATE'\n      ? midpoints.length !== answers.length\n      : false\n\n  const isValid =\n    isValidQuestion &&\n    ante <= balance &&\n    isValidDate &&\n    isValidTopics &&\n    (outcomeType !== 'PSEUDO_NUMERIC' ||\n      (initialValue !== undefined &&\n        minMaxValid &&\n        min < initialValue &&\n        max - min > 0.01 &&\n        initialValue < max)) &&\n    isValidMultipleChoice &&\n    !midpointsError &&\n    (outcomeType !== 'BOUNTIED_QUESTION' || bountyAmount !== undefined) &&\n    (outcomeType === 'NUMBER'\n      ? numberOfBuckets <= NUMBER_BUCKETS_MAX && numberOfBuckets >= 2\n      : true) &&\n    (outcomeType !== 'MULTI_NUMERIC' || (minMaxValid && unit !== ''))\n\n  const [errorText, setErrorText] = useState<string>('')\n  useEffect(() => {\n    setErrorText('')\n    if (isValid) return\n\n    if (!isValidDate) {\n      setErrorText('Close date must be in the future')\n    } else if (!isValidMultipleChoice) {\n      setErrorText(\n        `All ${outcomeType === 'POLL' ? 'options' : 'answers'} must have text`\n      )\n    } else if (!isValidTopics) {\n      // can happen in rare cases when duplicating old question\n      setErrorText(\n        `A question can can have at most up to ${MAX_GROUPS_PER_MARKET} topic tags.`\n      )\n    }\n    if (!isValidQuestion) {\n      setErrorText(\n        `Question must be between 1 and ${MAX_QUESTION_LENGTH} characters`\n      )\n    }\n  }, [\n    isValid,\n    isValidDate,\n    isValidMultipleChoice,\n    isValidQuestion,\n    isValidTopics,\n  ])\n\n  const editorKey = 'create market' + paramsKey\n  const editor = useTextEditor({\n    key: editorKey,\n    size: 'md',\n    max: MAX_DESCRIPTION_LENGTH,\n    placeholder: 'Optional. Provide background info and details.',\n  })\n\n  useEffect(() => {\n    if (!params?.description || !editor) return\n    editor?.commands.setContent(JSON.parse(params.description))\n  }, [params?.description, editor])\n\n  const resetProperties = () => {\n    // This has to work when you navigate away so we can't do:\n    // editor?.commands.clearContent(true)\n    // setQuestion('')\n    // because react hooks have unmounted\n\n    safeLocalStorage?.removeItem(getEditorLocalStorageKey(editorKey))\n    safeLocalStorage?.removeItem(`text create market`) // TODO: why is this here?\n\n    setPersistentLocalState(questionKey, '')\n    safeLocalStorage?.removeItem(closeDateKey)\n    safeLocalStorage?.removeItem(closeHoursMinutesKey)\n    setPersistentLocalState(hasManuallyEditedCloseDateKey, false)\n    setPersistentLocalState(visibilityKey, 'public')\n    setPersistentLocalState(selectedGroupsKey, [])\n    setPersistentLocalState('threshold-answers' + paramsKey, defaultAnswers)\n    setPersistentLocalState('threshold-midpoints' + paramsKey, [])\n    setPersistentLocalState('bucket-answers' + paramsKey, defaultAnswers)\n    setPersistentLocalState('bucket-midpoints' + paramsKey, [])\n    setPersistentLocalState(unitKey, '')\n    setPersistentLocalState(answersKey, defaultAnswers)\n    setPersistentLocalState(minStringKey, '')\n    setPersistentLocalState(maxStringKey, '')\n    setPersistentLocalState(initValueKey, '')\n    setPersistentLocalState(isLogScaleKey, false)\n    setPersistentLocalState(bountyKey, defaultBountyAmount)\n    setPersistentLocalState(hasChosenCategoryKey, false)\n\n    removePersistentInMemoryState(similarContractsKey)\n    removePersistentInMemoryState(dismissedSimilarContractsKey)\n\n    setPersistentLocalState(precisionKey, 1)\n    // market tier is ordinary react state and gets reset automatically\n  }\n\n  const [submitState, setSubmitState] = useState<\n    'EDITING' | 'LOADING' | 'DONE'\n  >('EDITING')\n\n  const [drafts, setDrafts] = useState<MarketDraft[]>([])\n  const [showDraftsModal, setShowDraftsModal] = useState(false)\n\n  useEffect(() => {\n    loadDrafts()\n  }, [])\n\n  const loadDrafts = async () => {\n    try {\n      const drafts = await api('get-market-drafts', {})\n      setDrafts(drafts)\n    } catch (error) {\n      console.error('Error loading drafts:', error)\n    }\n  }\n\n  const saveDraftToDb = async () => {\n    setIsSavingDraft(true)\n    try {\n      const draft = {\n        question,\n        description: editor?.getJSON(),\n        outcomeType,\n        answers,\n        closeDate,\n        closeHoursMinutes,\n        visibility,\n        selectedGroups,\n        savedAt: Date.now(),\n      }\n      await api('save-market-draft', { data: draft })\n      toast.success('Draft saved')\n      await loadDrafts()\n    } catch (error) {\n      console.error('Error saving draft:', error)\n      toast.error('Error saving draft')\n    } finally {\n      setIsSavingDraft(false)\n    }\n  }\n\n  const loadDraftFromDb = async (draft: MarketDraft) => {\n    try {\n      setQuestion(draft.data.question)\n      if (draft.data.description && editor) {\n        editor.commands.setContent(draft.data.description)\n      }\n      setAnswers(draft.data.answers ?? defaultAnswers)\n      setCloseDate(draft.data.closeDate)\n      setCloseHoursMinutes(draft.data.closeHoursMinutes)\n      setVisibility(draft.data.visibility as Visibility)\n      setSelectedGroups(draft.data.selectedGroups)\n      setShowDraftsModal(false)\n    } catch (error) {\n      console.error('Error loading draft:', error)\n    }\n  }\n\n  const deleteDraft = async (id: number) => {\n    try {\n      await api('delete-market-draft', { id })\n      await loadDrafts()\n    } catch (error) {\n      console.error('Error deleting draft:', error)\n    }\n  }\n\n  const submit = async () => {\n    if (!isValid) return\n    setSubmitState('LOADING')\n    try {\n      const createProps = removeUndefinedProps({\n        question,\n        outcomeType,\n        description: editor?.getJSON(),\n        initialProb: 50,\n        closeTime,\n        min,\n        max,\n        initialValue,\n        isLogScale,\n        groupIds: selectedGroups.map((g) => g.id),\n        answers,\n        midpoints,\n        addAnswersMode:\n          outcomeType === 'MULTI_NUMERIC' || outcomeType === 'DATE'\n            ? 'DISABLED'\n            : addAnswersMode,\n        shouldAnswersSumToOne,\n        visibility,\n        utcOffset: new Date().getTimezoneOffset(),\n        totalBounty: bountyAmount,\n        isAutoBounty:\n          outcomeType === 'BOUNTIED_QUESTION' ? isAutoBounty : undefined,\n        precision,\n        liquidityTier,\n        idempotencyKey,\n        sportsStartTimestamp: params?.sportsStartTimestamp,\n        sportsEventId: params?.sportsEventId,\n        sportsLeague: params?.sportsLeague,\n        unit: unit.trim(),\n        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n      })\n\n      const newContract = await api('market', createProps as any)\n\n      track('create market', {\n        slug: newContract.slug,\n        selectedGroups: selectedGroups.map((g) => g.id),\n        outcomeType,\n      })\n\n      // Await to clear form data from localstorage after navigate, since market is created.\n      // Don't clear before navigate, because looks like a bug.\n      const path = twombaContractPath(newContract)\n      await router.push(path)\n      resetProperties()\n    } catch (e) {\n      console.error('error creating contract', e)\n      setErrorText((e as any).message || 'Error creating contract')\n      setSubmitState('EDITING')\n    }\n  }\n  const [bountyError, setBountyError] = useState<string | undefined>(undefined)\n\n  const findTopicsAndSimilarQuestions = useCallback(\n    async (question: string) => {\n      const trimmed = question.toLowerCase().trim()\n      if (trimmed === '') {\n        setHasChosenCategory(false)\n        setSimilarContracts([])\n        return\n      }\n      const [similarGroupsRes, contracts] = await Promise.all([\n        !params?.groupIds?.length &&\n        trimmed !== categorizedQuestion &&\n        !hasChosenCategory\n          ? getSimilarGroupsToContract({ question })\n          : { groups: undefined },\n        !dismissedSimilarContractTitles.includes(trimmed)\n          ? searchContracts({\n              term: question,\n              contractType: outcomeType,\n              filter: 'open',\n              limit: 10,\n              sort: 'most-popular',\n            })\n          : [],\n      ])\n\n      if (similarGroupsRes.groups) {\n        setSelectedGroups(similarGroupsRes.groups)\n        setCategorizedQuestion(trimmed)\n      }\n      setSimilarContracts(\n        contracts?.filter((c) => compareTwoStrings(c.question, question) > 0.25)\n      )\n    },\n    [dismissedSimilarContractTitles, categorizedQuestion, hasChosenCategory]\n  )\n\n  const isMulti = outcomeType === 'MULTIPLE_CHOICE'\n  const isPoll = outcomeType === 'POLL'\n  const isNumber = outcomeType === 'NUMBER'\n  const isMultiNumeric = outcomeType === 'MULTI_NUMERIC'\n  const isDate = outcomeType === 'DATE'\n\n  const [isGeneratingDescription, setIsGeneratingDescription] = useState(false)\n  const [preGenerateContent, setPreGenerateContent] = useState<\n    JSONContent | undefined\n  >()\n\n  const generateAIDescription = async () => {\n    if (!question) return\n    setIsGeneratingDescription(true)\n    try {\n      // Store current content before generating\n      setPreGenerateContent(editor?.getJSON())\n\n      const result = await api('generate-ai-description', {\n        question,\n        description: editor?.getHTML(),\n        answers,\n        outcomeType,\n        shouldAnswersSumToOne,\n        addAnswersMode,\n      })\n      if (result.description && editor) {\n        const endPos = editor.state.doc.content.size\n        editor.commands.setTextSelection(endPos)\n        editor.commands.insertContent(result.description)\n      }\n    } catch (e) {\n      console.error('Error generating description:', e)\n      // Reset preGenerateContent on error\n      setPreGenerateContent(undefined)\n    }\n    setIsGeneratingDescription(false)\n  }\n  const [isGeneratingAnswers, setIsGeneratingAnswers] = useState(false)\n\n  const generateAnswers = async () => {\n    if (!question || outcomeType !== 'MULTIPLE_CHOICE') return\n    setIsGeneratingAnswers(true)\n    try {\n      const result = await api('generate-ai-answers', {\n        question,\n        description: editor?.getHTML(),\n        shouldAnswersSumToOne,\n        answers,\n      })\n      setAnswers([...answers, ...result.answers])\n      setAddAnswersMode(result.addAnswersMode)\n    } catch (e) {\n      console.error('Error generating answers:', e)\n    }\n    setIsGeneratingAnswers(false)\n  }\n\n  const undoGeneration = () => {\n    if (preGenerateContent && editor) {\n      editor.commands.setContent(preGenerateContent)\n      setPreGenerateContent(undefined)\n    }\n  }\n\n  const inferUnit = async () => {\n    if (!question || unit !== '') return\n    try {\n      const result = await api('infer-numeric-unit', {\n        question,\n        description: editor?.getHTML(),\n      })\n      if (result.unit) {\n        setUnit(result.unit)\n      }\n    } catch (e) {\n      console.error('Error inferring unit:', e)\n    }\n  }\n\n  // Function to get AI-suggested close date\n  const getAISuggestedCloseDate = useEvent(async (currentQuestion: string) => {\n    if (\n      !currentQuestion ||\n      currentQuestion.length < 20 ||\n      !shouldHaveCloseDate\n    ) {\n      return\n    }\n    try {\n      const result = await api('get-close-date', {\n        question: currentQuestion,\n        utcOffset: new Date().getTimezoneOffset() * -1,\n      })\n      const latestManualEditState = readHasManuallyEditedCloseDate()\n      if (result?.closeTime && !latestManualEditState) {\n        const date = dayjs(result.closeTime).format('YYYY-MM-DD')\n        const time = dayjs(result.closeTime).format('HH:mm')\n        setCloseDate(date)\n        setCloseHoursMinutes(time)\n      }\n    } catch (e) {\n      console.error('Error getting suggested close date:', e)\n    }\n  })\n\n  const handleSetCloseDate = (date: string | undefined) => {\n    setCloseDate(date)\n    setHasManuallyEditedCloseDate(true)\n  }\n\n  const handleSetCloseHoursMinutes = (time: string | undefined) => {\n    setCloseHoursMinutes(time)\n    setHasManuallyEditedCloseDate(true)\n  }\n\n  const handleSetNeverCloses = (never: boolean) => {\n    setNeverCloses(never)\n    setHasManuallyEditedCloseDate(true)\n  }\n\n  return (\n    <Col className=\"gap-6\">\n      <Col>\n        <label className=\"px-1 pb-3 pt-2\">\n          Question<span className={'text-scarlet-500'}>*</span>\n        </label>\n\n        <ExpandingInput\n          placeholder={getContractTypeFromValue(outcomeType, 'example')}\n          autoFocus\n          maxLength={MAX_QUESTION_LENGTH}\n          value={question}\n          onChange={(e) => setQuestion(e.target.value || '')}\n          onBlur={(e) => {\n            if (outcomeType === 'MULTI_NUMERIC') inferUnit()\n            findTopicsAndSimilarQuestions(e.target.value || '')\n            getAISuggestedCloseDate(e.target.value || '')\n          }}\n        />\n\n        <Row className=\"text-ink-600 -mb-3 mt-2 h-6 items-center gap-2 text-sm\">\n          {suggestedTitle && suggestedTitle !== '' ? (\n            <>\n              <span className=\"\">{suggestedTitle}</span>\n              <Button\n                color=\"gray-outline\"\n                size=\"2xs\"\n                loading={isGeneratingTitle}\n                disabled={isGeneratingTitle}\n                onClick={() => {\n                  setApplyingTitle(true)\n                  setQuestion(suggestedTitle)\n                  setSuggestedTitle(undefined)\n                  track('apply concise title', {\n                    title: suggestedTitle,\n                  })\n                  setTimeout(() => {\n                    setApplyingTitle(false)\n                  }, 1000)\n                }}\n              >\n                Accept\n              </Button>\n            </>\n          ) : isGeneratingTitle && !suggestedTitle ? (\n            <span>Generating concise title...</span>\n          ) : null}\n        </Row>\n      </Col>\n      {similarContracts.length ? (\n        <SimilarContractsSection\n          similarContracts={similarContracts}\n          setSimilarContracts={setSimilarContracts}\n          setDismissedSimilarContractTitles={setDismissedSimilarContractTitles}\n          outcomeType={outcomeType}\n          question={question}\n        />\n      ) : null}\n      {(isMulti || isPoll) && !isNumber && (\n        <MultipleChoiceAnswers\n          answers={answers}\n          setAnswers={setAnswers}\n          addAnswersMode={addAnswersMode}\n          setAddAnswersMode={setAddAnswersMode}\n          shouldAnswersSumToOne={shouldAnswersSumToOne}\n          outcomeType={outcomeType}\n          placeholder={isMulti ? 'Type your answer..' : undefined}\n          question={question}\n          generateAnswers={generateAnswers}\n          isGeneratingAnswers={isGeneratingAnswers}\n          marginalCost={marginalCost}\n        />\n      )}\n      {outcomeType == 'BOUNTIED_QUESTION' && (\n        <Col className=\"gap-2\">\n          <label className=\"gap-2 px-1 py-2\">\n            <span className=\"mb-1 mr-1\">Bounty</span>\n            <InfoTooltip text=\"The award you give good answers. You can divide this amongst answers however you'd like.\" />\n          </label>\n          <BuyAmountInput\n            minimumAmount={MINIMUM_BOUNTY}\n            amount={bountyAmount}\n            onChange={(newAmount) => setBountyAmount(newAmount)}\n            error={bountyError}\n            setError={setBountyError}\n            quickButtonAmountSize=\"large\"\n          />\n          <Row className=\"mt-2 items-center gap-2\">\n            <span>\n              Auto-award bounty{' '}\n              <InfoTooltip\n                text={\n                  'Automatically pay out the bounty to commenters in proportion to likes over 48 hours.'\n                }\n              />\n            </span>\n            <ShortToggle on={isAutoBounty} setOn={setIsAutoBounty} />\n          </Row>\n        </Col>\n      )}\n      {outcomeType === 'STONK' && (\n        <div className=\"text-primary-500 ml-1 mt-1 text-sm\">\n          Tradeable shares of a stock based on sentiment. Never resolves.\n        </div>\n      )}\n      {outcomeType === 'PSEUDO_NUMERIC' && (\n        <div className=\"text-primary-500 ml-1 mt-1 text-sm\">\n          Predict the value of a number.\n        </div>\n      )}\n      {isMultiNumeric && (\n        <MultiNumericRangeSection\n          paramsKey={paramsKey}\n          submitState={submitState}\n          question={question}\n          description={editor?.getHTML()}\n          answers={answers}\n          setAnswers={setAnswers}\n          midpoints={midpoints}\n          setMidpoints={setMidpoints}\n          minString={minString}\n          setMinString={setMinString}\n          maxString={maxString}\n          setMaxString={setMaxString}\n          min={min}\n          max={max}\n          shouldAnswersSumToOne={shouldAnswersSumToOne}\n          setShouldAnswersSumToOne={setMultiNumericSumsToOne}\n          unit={unit}\n          setUnit={setUnit}\n          marginalCost={marginalCost}\n        />\n      )}{' '}\n      {isDate && (\n        <MultiNumericDateSection\n          paramsKey={paramsKey}\n          submitState={submitState}\n          question={question}\n          description={editor?.getHTML()}\n          answers={answers}\n          setAnswers={setAnswers}\n          midpoints={midpoints}\n          setMidpoints={setMidpoints}\n          minString={minString}\n          setMinString={setMinString}\n          maxString={maxString}\n          setMaxString={setMaxString}\n          shouldAnswersSumToOne={shouldAnswersSumToOne}\n          setShouldAnswersSumToOne={setMultiNumericSumsToOne}\n          marginalCost={marginalCost}\n        />\n      )}\n      {outcomeType === 'PSEUDO_NUMERIC' && (\n        <PseudoNumericRangeSection\n          minString={minString}\n          setMinString={setMinString}\n          maxString={maxString}\n          setMaxString={setMaxString}\n          initialValueString={initialValueString}\n          setInitialValueString={setInitialValueString}\n          isLogScale={isLogScale}\n          setIsLogScale={setIsLogScale}\n          submitState={submitState}\n          initialValue={initialValue}\n          min={min}\n          max={max}\n        />\n      )}{' '}\n      {isNumber && (\n        <NumberRangeSection\n          minString={minString}\n          setMinString={setMinString}\n          maxString={maxString}\n          setMaxString={setMaxString}\n          submitState={submitState}\n          precision={precision}\n          setPrecision={setPrecision}\n          min={min}\n          max={max}\n          paramsKey={paramsKey}\n        />\n      )}\n      <TopicSelectorSection\n        selectedGroups={selectedGroups}\n        setSelectedGroups={setSelectedGroups}\n        setHasChosenCategory={setHasChosenCategory}\n        question={question}\n      />\n      <Col className=\"items-start gap-3\">\n        <Row className=\"w-full items-center justify-between\">\n          <label className=\"px-1\">\n            <span>Description</span>\n          </label>\n          <Row className=\"gap-2\">\n            {preGenerateContent && (\n              <Button\n                color=\"gray-outline\"\n                size=\"xs\"\n                disabled={isGeneratingDescription}\n                onClick={undoGeneration}\n                className=\"gap-1\"\n              >\n                <BiUndo className=\"h-4 w-4\" />\n              </Button>\n            )}\n            <Button\n              color=\"indigo-outline\"\n              size=\"xs\"\n              loading={isGeneratingDescription}\n              onClick={generateAIDescription}\n              disabled={!question || isGeneratingDescription}\n            >\n              Generate with AI\n            </Button>\n          </Row>\n        </Row>\n        <TextEditor editor={editor} />\n      </Col>\n      <CloseTimeSection\n        closeDate={closeDate}\n        setCloseDate={handleSetCloseDate}\n        closeHoursMinutes={closeHoursMinutes}\n        setCloseHoursMinutes={handleSetCloseHoursMinutes}\n        neverCloses={neverCloses}\n        setNeverCloses={handleSetNeverCloses}\n        submitState={submitState}\n        outcomeType={outcomeType}\n        initTime={initTime}\n      />\n      <Row className=\"mt-2 items-center gap-2\">\n        <span>\n          Publicly listed{' '}\n          <InfoTooltip\n            text={\n              visibility === 'public'\n                ? 'Visible on home page and search results'\n                : \"Only visible via link. Won't notify followers\"\n            }\n          />\n        </span>\n        <ShortToggle\n          on={visibility === 'public'}\n          setOn={(on) => {\n            setVisibility(on ? 'public' : 'unlisted')\n          }}\n        />\n      </Row>\n      <CostSection\n        balance={balance}\n        numAnswers={numAnswers}\n        outcomeType={outcomeType}\n        liquidityTier={liquidityTier}\n        setLiquidityTier={setLiquidityTier}\n      />\n      {outcomeType !== 'POLL' && outcomeType !== 'BOUNTIED_QUESTION' && (\n        <div className=\"text-ink-600 -mt-3 text-sm\">\n          Earn back your creation cost! Get a{' '}\n          <b>\n            {formatWithToken({\n              amount: getUniqueBettorBonusAmount(ante, numAnswers),\n              short: true,\n              token: 'M$',\n            })}{' '}\n            bonus\n          </b>{' '}\n          for each unique trader on your question.\n        </div>\n      )}\n      {errorText && <span className={'text-error'}>{errorText}</span>}\n      <Button\n        className=\"w-full\"\n        type=\"submit\"\n        color={submitState === 'DONE' ? 'green' : 'indigo'}\n        size=\"xl\"\n        loading={submitState === 'LOADING'}\n        disabled={\n          !isValid ||\n          editor?.storage.upload.mutation.isLoading ||\n          (outcomeType == 'BOUNTIED_QUESTION' && bountyError)\n        }\n        onClick={(e) => {\n          e.preventDefault()\n          submit()\n        }}\n      >\n        {submitState === 'EDITING'\n          ? `Create question for ${formatWithToken({\n              amount: ante,\n              short: true,\n              token: 'M$',\n            })}`\n          : submitState === 'LOADING'\n          ? 'Creating...'\n          : 'Created!'}\n      </Button>\n      <Row className=\"-mt-2 w-full gap-2\">\n        <Button\n          size=\"sm\"\n          className=\"w-full\"\n          color=\"gray-outline\"\n          onClick={saveDraftToDb}\n          disabled={isSavingDraft}\n          loading={isSavingDraft}\n        >\n          Save draft\n        </Button>\n        <Button\n          size=\"sm\"\n          className=\"w-full\"\n          disabled={drafts.length === 0}\n          color={'gray-outline'}\n          onClick={() => setShowDraftsModal(true)}\n        >\n          View drafts ({drafts.length})\n        </Button>\n      </Row>\n      <DraftsModal\n        showDraftsModal={showDraftsModal}\n        setShowDraftsModal={setShowDraftsModal}\n        drafts={drafts}\n        loadDraftFromDb={loadDraftFromDb}\n        deleteDraft={deleteDraft}\n      />\n    </Col>\n  )\n}\n\ninterface DraftsModalProps {\n  showDraftsModal: boolean\n  setShowDraftsModal: (show: boolean) => void\n  drafts: MarketDraft[]\n  loadDraftFromDb: (draft: MarketDraft) => void\n  deleteDraft: (id: number) => void\n}\n\nfunction DraftsModal(props: DraftsModalProps) {\n  const {\n    showDraftsModal,\n    setShowDraftsModal,\n    drafts,\n    loadDraftFromDb,\n    deleteDraft,\n  } = props\n\n  return (\n    <Modal\n      className={MODAL_CLASS}\n      open={showDraftsModal}\n      setOpen={setShowDraftsModal}\n    >\n      <div className=\"max-h-[80vh] overflow-y-auto p-6\">\n        <h3 className=\"mb-4 text-xl font-semibold\">Saved Drafts</h3>\n        {drafts.length === 0 ? (\n          <p>No saved drafts</p>\n        ) : (\n          <div className=\"flex flex-col gap-4\">\n            {drafts.map((draft) => (\n              <div\n                key={draft.id}\n                className=\"flex flex-col gap-2 rounded border p-4\"\n              >\n                <div className=\"flex items-center justify-between\">\n                  <div className=\"flex-1\">\n                    <p className=\"font-medium\">\n                      {draft.data.question || 'Untitled'}\n                    </p>\n                    <p className=\"text-ink-600 text-sm\">\n                      <RelativeTimestamp\n                        time={new Date(draft.createdAt).getTime()}\n                      />\n                    </p>\n                  </div>\n                  <div className=\"flex gap-2\">\n                    <Button\n                      color=\"gray-outline\"\n                      onClick={() => loadDraftFromDb(draft)}\n                    >\n                      Load\n                    </Button>\n                    <Button\n                      color=\"red-outline\"\n                      onClick={() => deleteDraft(draft.id)}\n                    >\n                      Delete\n                    </Button>\n                  </div>\n                </div>\n\n                <div className=\"text-ink-600 text-sm\">\n                  <p>Type: {draft.data.outcomeType}</p>\n                  {draft.data.answers.length > 0 && (\n                    <p>\n                      Answers: {draft.data.answers.slice(0, 5).join(', ')}\n                      {draft.data.answers.length > 5 && '...'}\n                    </p>\n                  )}\n                  {draft.data.description && (\n                    <p className=\"line-clamp-2\">\n                      Description: {richTextToString(draft.data.description)}\n                    </p>\n                  )}\n                </div>\n              </div>\n            ))}\n          </div>\n        )}\n      </div>\n    </Modal>\n  )\n}\n",
          "postContent": "import dayjs from 'dayjs'\nimport router from 'next/router'\nimport { useEffect, useState, useCallback } from 'react'\nimport { generateJSON, JSONContent } from '@tiptap/core'\nimport { debounce } from 'lodash'\n\nimport {\n  add_answers_mode,\n  Contract,\n  CreateableOutcomeType,\n  MAX_DESCRIPTION_LENGTH,\n  MAX_QUESTION_LENGTH,\n  NUMBER_BUCKETS_MAX,\n  NON_BETTING_OUTCOMES,\n  twombaContractPath,\n  Visibility,\n  PollVoterVisibility,\n} from 'common/contract'\nimport {\n  getAnte,\n  getUniqueBettorBonusAmount,\n  MINIMUM_BOUNTY,\n} from 'common/economy'\nimport { MultipleChoiceAnswers } from 'web/components/answers/multiple-choice-answers'\nimport { Button } from 'web/components/buttons/button'\nimport { Row } from 'web/components/layout/row'\nimport {\n  getEditorLocalStorageKey,\n  TextEditor,\n  useTextEditor,\n} from 'web/components/widgets/editor'\nimport { ExpandingInput } from 'web/components/widgets/expanding-input'\nimport { InfoTooltip } from 'web/components/widgets/info-tooltip'\nimport ShortToggle from 'web/components/widgets/short-toggle'\nimport { Group, MAX_GROUPS_PER_MARKET } from 'common/group'\nimport { STONK_NO, STONK_YES } from 'common/stonk'\nimport { User } from 'common/user'\nimport { removeUndefinedProps } from 'common/util/object'\nimport { extensions, richTextToString } from 'common/util/parse'\nimport {\n  setPersistentLocalState,\n  usePersistentLocalState,\n} from 'web/hooks/use-persistent-local-state'\nimport {\n  api,\n  getSimilarGroupsToContract,\n  searchContracts,\n} from 'web/lib/api/api'\nimport { track } from 'web/lib/service/analytics'\nimport { getGroup, getGroupFromSlug } from 'web/lib/supabase/group'\nimport { safeLocalStorage } from 'web/lib/util/local'\nimport { Col } from '../layout/col'\nimport { BuyAmountInput } from '../widgets/amount-input'\nimport { getContractTypeFromValue } from './create-contract-types'\nimport { NewQuestionParams } from './new-contract-panel'\nimport { filterDefined } from 'common/util/array'\nimport {\n  removePersistentInMemoryState,\n  usePersistentInMemoryState,\n} from 'client-common/hooks/use-persistent-in-memory-state'\nimport { compareTwoStrings } from 'string-similarity'\nimport { CostSection } from 'web/components/new-contract/cost-section'\nimport { CloseTimeSection } from 'web/components/new-contract/close-time-section'\nimport { TopicSelectorSection } from 'web/components/new-contract/topic-selector-section'\nimport { PseudoNumericRangeSection } from 'web/components/new-contract/pseudo-numeric-range-section'\nimport { SimilarContractsSection } from 'web/components/new-contract/similar-contracts-section'\nimport { MultiNumericRangeSection } from './multi-numeric-range-section'\nimport { NumberRangeSection } from './number-range-section'\nimport { getMultiNumericAnswerBucketRangeNames } from 'common/src/number'\nimport { randomString } from 'common/util/random'\nimport { formatWithToken } from 'common/util/format'\nimport { BiUndo } from 'react-icons/bi'\nimport { getAnswerCostFromLiquidity, liquidityTiers } from 'common/tier'\nimport { MultiNumericDateSection } from './multi-numeric-date-section'\nimport { Modal, MODAL_CLASS } from '../layout/modal'\nimport { RelativeTimestamp } from '../relative-timestamp'\nimport { MarketDraft } from 'common/drafts'\nimport { toast } from 'react-hot-toast'\nimport { useEvent } from 'client-common/hooks/use-event'\nimport { ChoicesToggleGroup } from '../widgets/choices-toggle-group'\n\nexport const seeResultsAnswer = 'See results'\nexport function ContractParamsForm(props: {\n  creator: User\n  outcomeType: CreateableOutcomeType\n  params?: Partial<NewQuestionParams>\n}) {\n  const { creator, params, outcomeType } = props\n\n  const [liquidityTier, setLiquidityTier] = usePersistentLocalState<number>(\n    liquidityTiers[0],\n    'liquidity-tier'\n  )\n\n  const paramsKey =\n    params?.overrideKey ??\n    (params?.q ?? '') +\n      (params?.groupSlugs?.join('') ?? '') +\n      (params?.groupIds?.join('') ?? '') +\n      (params?.rand ?? '')\n  const minStringKey = 'min' + paramsKey\n  const [minString, setMinString] = usePersistentLocalState(\n    params?.min?.toString() ?? '',\n    minStringKey\n  )\n\n  const maxStringKey = 'max' + paramsKey\n  const [maxString, setMaxString] = usePersistentLocalState(\n    params?.max?.toString() ?? '',\n    maxStringKey\n  )\n\n  const precisionKey = 'numeric-precision' + paramsKey\n  const [precision, setPrecision] = usePersistentLocalState<number | undefined>(\n    params?.precision ?? 1,\n    precisionKey\n  )\n\n  const isLogScaleKey = 'new-is-log-scale' + paramsKey\n  const [isLogScale, setIsLogScale] = usePersistentLocalState<boolean>(\n    !!params?.isLogScale,\n    isLogScaleKey\n  )\n\n  const visibilityKey = 'new-visibility' + paramsKey\n  const [visibility, setVisibility] = usePersistentLocalState<Visibility>(\n    (params?.visibility ?? 'public') as Visibility,\n    visibilityKey\n  )\n\n  const initValueKey = 'new-init-value' + paramsKey\n  const [initialValueString, setInitialValueString] = usePersistentLocalState(\n    params?.initValue?.toString(),\n    initValueKey\n  )\n\n  // Don't use the usePersistentLocalState hook for this, because there's too high a risk that it will survive in local storage\n  // longer than it should under a trivial paramsKey like '', and improperly prevent users from creating any new contracts.\n  const [idempotencyKey] = useState(randomString())\n\n  // For multiple choice, init to 2 empty answers\n  const defaultAnswers =\n    outcomeType === 'MULTIPLE_CHOICE' ||\n    outcomeType == 'MULTI_NUMERIC' ||\n    outcomeType == 'DATE'\n      ? ['', '']\n      : outcomeType == 'POLL'\n      ? ['', '', seeResultsAnswer]\n      : []\n\n  const answersKey = 'new-answers-with-other' + paramsKey\n  const [answers, setAnswers] = usePersistentLocalState(\n    params?.answers ?? defaultAnswers,\n    answersKey\n  )\n  const [midpoints, setMidpoints] = usePersistentLocalState<number[]>(\n    params?.midpoints ?? [],\n    'new-numeric-midpoints' + paramsKey\n  )\n  const [multiNumericSumsToOne, setMultiNumericSumsToOne] =\n    usePersistentLocalState<boolean>(\n      params?.shouldAnswersSumToOne ?? true,\n      'multi-numeric-sums-to-one' + paramsKey\n    )\n  const unitKey = 'multi-numeric-unit' + paramsKey\n  const [unit, setUnit] = usePersistentLocalState<string>(\n    params?.unit ?? '',\n    unitKey\n  )\n  const addAnswersModeKey = 'new-add-answers-mode' + paramsKey\n  const [addAnswersMode, setAddAnswersMode] =\n    usePersistentLocalState<add_answers_mode>(\n      params?.addAnswersMode ?? 'DISABLED',\n      addAnswersModeKey\n    )\n  const shouldAnswersSumToOne =\n    outcomeType === 'MULTI_NUMERIC' || outcomeType === 'DATE'\n      ? multiNumericSumsToOne\n      : params?.shouldAnswersSumToOne ?? false\n\n  // NOTE: if you add another user-controlled state variable, you should also add it to the duplication parameters and resetProperties()\n\n  const hasOtherAnswer =\n    addAnswersMode !== 'DISABLED' &&\n    shouldAnswersSumToOne &&\n    outcomeType != 'POLL'\n  const numAnswers = hasOtherAnswer ? answers.length + 1 : answers.length\n\n  useEffect(() => {\n    if (!params?.q) return\n\n    setQuestion(params.q)\n    if (!params.groupIds?.length && !params.groupSlugs?.length) {\n      findTopicsAndSimilarQuestions(params.q)\n    }\n  }, [params?.q])\n\n  useEffect(() => {\n    if (params?.answers) {\n      setAnswers(params.answers)\n    } else if (answers.length && answers.every((a) => a.trim().length === 0)) {\n      setAnswers(defaultAnswers)\n    } else if (outcomeType === 'MULTIPLE_CHOICE' && answers.length < 2) {\n      if (answers.length === 0) setAnswers(defaultAnswers)\n      else setAnswers(answers.concat(['']))\n    }\n  }, [JSON.stringify(params?.answers)])\n\n  useEffect(() => {\n    if (params?.groupIds) {\n      const getAndSetGroups = async (groupIds: string[]) => {\n        const groups = await Promise.all(groupIds.map((id) => getGroup(id)))\n        setSelectedGroups(filterDefined(groups))\n      }\n      getAndSetGroups(params.groupIds)\n    }\n    if (params?.groupSlugs) {\n      const getAndSetGroupsViaSlugs = async (groupSlugs: string[]) => {\n        const groups = await Promise.all(\n          groupSlugs.map((s) => getGroupFromSlug(s))\n        )\n        setSelectedGroups(filterDefined(groups))\n      }\n      getAndSetGroupsViaSlugs(params.groupSlugs)\n    }\n  }, [JSON.stringify(params?.groupIds)])\n\n  useEffect(() => {\n    if (addAnswersMode === 'DISABLED' && answers.length < 2) {\n      if (answers.length === 0) setAnswers(defaultAnswers)\n      else setAnswers((a) => [...a, ''])\n    }\n  }, [addAnswersMode, answers.length])\n  const [isSavingDraft, setIsSavingDraft] = useState(false)\n\n  const questionKey = 'new-question' + paramsKey\n  const [question, setQuestion] = usePersistentLocalState(\n    params?.q ?? '',\n    questionKey\n  )\n\n  const [suggestedTitle, setSuggestedTitle] = useState<string | undefined>()\n  const [applyingTitle, setApplyingTitle] = useState<boolean>(false)\n  const [isGeneratingTitle, setIsGeneratingTitle] = useState(false)\n\n  const generateConciseTitle = useCallback(async (currentQuestion: string) => {\n    if (\n      !currentQuestion ||\n      currentQuestion.length < 20 ||\n      outcomeType === 'MULTIPLE_CHOICE' ||\n      outcomeType === 'BOUNTIED_QUESTION' ||\n      outcomeType === 'POLL' ||\n      outcomeType === 'STONK'\n    ) {\n      if (suggestedTitle) setSuggestedTitle(undefined)\n      return\n    }\n    setIsGeneratingTitle(true)\n    try {\n      const result = await api('generate-concise-title', {\n        question: currentQuestion,\n      })\n      if (result.title) {\n        setSuggestedTitle(\n          result.title !== currentQuestion ? result.title : undefined\n        )\n      }\n    } catch (e) {\n      console.error('Error generating title:', e)\n    }\n    setIsGeneratingTitle(false)\n  }, [])\n\n  const debouncedGenerateTitle = useCallback(\n    debounce((question: string) => {\n      generateConciseTitle(question)\n    }, 1000),\n    []\n  )\n\n  useEffect(() => {\n    if (applyingTitle) return\n    debouncedGenerateTitle(question)\n    return () => debouncedGenerateTitle.cancel()\n  }, [question])\n\n  const categorizedQuestionKey = 'last-categorized-question' + paramsKey\n  const [categorizedQuestion, setCategorizedQuestion] = usePersistentLocalState(\n    '',\n    categorizedQuestionKey\n  )\n  const hasDuplicateCategories =\n    (params?.groupIds?.length ?? 0) > 0 || (params?.groupSlugs?.length ?? 0) > 0\n  const hasChosenCategoryKey = 'has-chosen-category' + paramsKey\n  const [hasChosenCategory, setHasChosenCategory] = usePersistentLocalState(\n    hasDuplicateCategories,\n    hasChosenCategoryKey\n  )\n\n  const similarContractsKey = 'similar-contracts' + paramsKey\n  const [similarContracts, setSimilarContracts] = usePersistentInMemoryState<\n    Contract[]\n  >([], similarContractsKey)\n\n  const dismissedSimilarContractsKey = 'dismissed-similar-contracts'\n  const [dismissedSimilarContractTitles, setDismissedSimilarContractTitles] =\n    usePersistentInMemoryState<string[]>([], dismissedSimilarContractsKey)\n\n  const timeInMs = params?.closeTime ? Number(params.closeTime) : undefined\n  const initDate = (timeInMs ? dayjs(timeInMs) : dayjs().add(7, 'day')).format(\n    'YYYY-MM-DD'\n  )\n  const initTime = timeInMs ? dayjs(timeInMs).format('HH:mm') : '23:59'\n\n  const closeDateKey = 'now-close-date' + paramsKey\n  const [closeDate, setCloseDate] = usePersistentLocalState<undefined | string>(\n    initDate,\n    closeDateKey\n  )\n\n  const closeHoursMinutesKey = 'now-close-time' + paramsKey\n  const [closeHoursMinutes, setCloseHoursMinutes] = usePersistentLocalState<\n    string | undefined\n  >(initTime, closeHoursMinutesKey)\n\n  const selectedGroupsKey = 'new-selected-groups' + paramsKey\n  const [selectedGroups, setSelectedGroups] = usePersistentLocalState<Group[]>(\n    [],\n    selectedGroupsKey\n  )\n\n  const defaultBountyAmount = 1000\n  const bountyKey = 'new-bounty' + paramsKey\n  const [bountyAmount, setBountyAmount] = usePersistentLocalState<\n    number | undefined\n  >(defaultBountyAmount, bountyKey)\n\n  const isAutoBountyKey = 'is-auto-bounty' + paramsKey\n  const [isAutoBounty, setIsAutoBounty] = usePersistentLocalState(\n    false,\n    isAutoBountyKey\n  )\n\n  const { balance } = creator\n\n  const closeTime = closeDate\n    ? dayjs(`${closeDate}T${closeHoursMinutes}`).valueOf()\n    : undefined\n  const hasManuallyEditedCloseDateKey =\n    'has-manually-edited-close-date' + paramsKey\n  const [_, setHasManuallyEditedCloseDate] = usePersistentLocalState<boolean>(\n    false,\n    hasManuallyEditedCloseDateKey\n  )\n  // Only way to get the real state is to read directly from localStorage after await to bypass stale closures\n  const readHasManuallyEditedCloseDate = useCallback(\n    () => safeLocalStorage?.getItem(hasManuallyEditedCloseDateKey) === 'true',\n    [hasManuallyEditedCloseDateKey]\n  )\n\n  const min = minString ? parseFloat(minString) : undefined\n  const max = maxString ? parseFloat(maxString) : undefined\n  const initialValue = initialValueString\n    ? parseFloat(initialValueString)\n    : undefined\n\n  const [neverCloses, setNeverCloses] = useState(false)\n\n  const shouldHaveCloseDate =\n    outcomeType !== 'STONK' && !NON_BETTING_OUTCOMES.includes(outcomeType)\n\n  useEffect(() => {\n    if (!shouldHaveCloseDate) {\n      setCloseDate(undefined)\n      setCloseHoursMinutes(undefined)\n      setNeverCloses(true)\n      if (outcomeType == 'STONK') {\n        if (editor?.isEmpty) {\n          editor?.commands.setContent(\n            generateJSON(\n              `<div>\n            ${STONK_YES}: good<br/>${STONK_NO}: bad<br/>Question trades based on sentiment & never\n            resolves.\n          </div>`,\n              extensions\n            )\n          )\n        }\n      }\n    } else if (!closeDate) {\n      setCloseDate(initDate)\n      setCloseHoursMinutes(initTime)\n    }\n  }, [outcomeType])\n  const pollVoterVisibilityKey = 'poll-voter-visibility' + paramsKey\n  const [voterVisibility, setVoterVisibility] =\n    usePersistentLocalState<PollVoterVisibility>(\n      'everyone',\n      pollVoterVisibilityKey\n    )\n\n  const isValidQuestion =\n    question.length > 0 && question.length <= MAX_QUESTION_LENGTH\n  const hasAnswers =\n    outcomeType === 'MULTIPLE_CHOICE' ||\n    outcomeType === 'POLL' ||\n    outcomeType === 'MULTI_NUMERIC' ||\n    outcomeType === 'DATE'\n  const isValidMultipleChoice =\n    !hasAnswers || answers.every((answer) => answer.trim().length > 0)\n\n  const isValidDate =\n    // closeTime must be in the future\n    !shouldHaveCloseDate || (closeTime ?? Infinity) > Date.now()\n\n  const isValidTopics = selectedGroups.length <= MAX_GROUPS_PER_MARKET\n  const ante = getAnte(outcomeType, numAnswers, liquidityTier)\n  const antePlusOneAnswer = getAnte(outcomeType, numAnswers + 1, liquidityTier)\n  const answerCost = getAnswerCostFromLiquidity(ante, numAnswers)\n  const marginalCost = antePlusOneAnswer > ante ? answerCost : 0\n  const numberOfBuckets = getMultiNumericAnswerBucketRangeNames(\n    min ?? 0,\n    max ?? 0,\n    precision && precision > 0 ? precision : 1\n  ).length\n  const minMaxValid =\n    min !== undefined &&\n    max !== undefined &&\n    isFinite(min) &&\n    isFinite(max) &&\n    min < max\n\n  const midpointsError =\n    outcomeType === 'MULTI_NUMERIC' || outcomeType === 'DATE'\n      ? midpoints.length !== answers.length\n      : false\n\n  const isValid =\n    isValidQuestion &&\n    ante <= balance &&\n    isValidDate &&\n    isValidTopics &&\n    (outcomeType !== 'PSEUDO_NUMERIC' ||\n      (initialValue !== undefined &&\n        minMaxValid &&\n        min < initialValue &&\n        max - min > 0.01 &&\n        initialValue < max)) &&\n    isValidMultipleChoice &&\n    !midpointsError &&\n    (outcomeType !== 'BOUNTIED_QUESTION' || bountyAmount !== undefined) &&\n    (outcomeType === 'NUMBER'\n      ? numberOfBuckets <= NUMBER_BUCKETS_MAX && numberOfBuckets >= 2\n      : true) &&\n    (outcomeType !== 'MULTI_NUMERIC' || (minMaxValid && unit !== ''))\n\n  const [errorText, setErrorText] = useState<string>('')\n  useEffect(() => {\n    setErrorText('')\n    if (isValid) return\n\n    if (!isValidDate) {\n      setErrorText('Close date must be in the future')\n    } else if (!isValidMultipleChoice) {\n      setErrorText(\n        `All ${outcomeType === 'POLL' ? 'options' : 'answers'} must have text`\n      )\n    } else if (!isValidTopics) {\n      // can happen in rare cases when duplicating old question\n      setErrorText(\n        `A question can can have at most up to ${MAX_GROUPS_PER_MARKET} topic tags.`\n      )\n    }\n    if (!isValidQuestion) {\n      setErrorText(\n        `Question must be between 1 and ${MAX_QUESTION_LENGTH} characters`\n      )\n    }\n  }, [\n    isValid,\n    isValidDate,\n    isValidMultipleChoice,\n    isValidQuestion,\n    isValidTopics,\n  ])\n\n  const editorKey = 'create market' + paramsKey\n  const editor = useTextEditor({\n    key: editorKey,\n    size: 'md',\n    max: MAX_DESCRIPTION_LENGTH,\n    placeholder: 'Optional. Provide background info and details.',\n  })\n\n  useEffect(() => {\n    if (!params?.description || !editor) return\n    editor?.commands.setContent(JSON.parse(params.description))\n  }, [params?.description, editor])\n\n  const resetProperties = () => {\n    // This has to work when you navigate away so we can't do:\n    // editor?.commands.clearContent(true)\n    // setQuestion('')\n    // because react hooks have unmounted\n\n    safeLocalStorage?.removeItem(getEditorLocalStorageKey(editorKey))\n    safeLocalStorage?.removeItem(`text create market`) // TODO: why is this here?\n\n    setPersistentLocalState(questionKey, '')\n    safeLocalStorage?.removeItem(closeDateKey)\n    safeLocalStorage?.removeItem(closeHoursMinutesKey)\n    setPersistentLocalState(hasManuallyEditedCloseDateKey, false)\n    setPersistentLocalState(visibilityKey, 'public')\n    setPersistentLocalState(selectedGroupsKey, [])\n    setPersistentLocalState('threshold-answers' + paramsKey, defaultAnswers)\n    setPersistentLocalState('threshold-midpoints' + paramsKey, [])\n    setPersistentLocalState('bucket-answers' + paramsKey, defaultAnswers)\n    setPersistentLocalState('bucket-midpoints' + paramsKey, [])\n    setPersistentLocalState(unitKey, '')\n    setPersistentLocalState(answersKey, defaultAnswers)\n    setPersistentLocalState(minStringKey, '')\n    setPersistentLocalState(maxStringKey, '')\n    setPersistentLocalState(initValueKey, '')\n    setPersistentLocalState(isLogScaleKey, false)\n    setPersistentLocalState(bountyKey, defaultBountyAmount)\n    setPersistentLocalState(hasChosenCategoryKey, false)\n    setPersistentLocalState(pollVoterVisibilityKey, 'everyone')\n    removePersistentInMemoryState(similarContractsKey)\n    removePersistentInMemoryState(dismissedSimilarContractsKey)\n\n    setPersistentLocalState(precisionKey, 1)\n    // market tier is ordinary react state and gets reset automatically\n  }\n\n  const [submitState, setSubmitState] = useState<\n    'EDITING' | 'LOADING' | 'DONE'\n  >('EDITING')\n\n  const [drafts, setDrafts] = useState<MarketDraft[]>([])\n  const [showDraftsModal, setShowDraftsModal] = useState(false)\n\n  useEffect(() => {\n    loadDrafts()\n  }, [])\n\n  const loadDrafts = async () => {\n    try {\n      const drafts = await api('get-market-drafts', {})\n      setDrafts(drafts)\n    } catch (error) {\n      console.error('Error loading drafts:', error)\n    }\n  }\n\n  const saveDraftToDb = async () => {\n    setIsSavingDraft(true)\n    try {\n      const draft = {\n        question,\n        description: editor?.getJSON(),\n        outcomeType,\n        answers,\n        closeDate,\n        closeHoursMinutes,\n        visibility,\n        selectedGroups,\n        savedAt: Date.now(),\n      }\n      await api('save-market-draft', { data: draft })\n      toast.success('Draft saved')\n      await loadDrafts()\n    } catch (error) {\n      console.error('Error saving draft:', error)\n      toast.error('Error saving draft')\n    } finally {\n      setIsSavingDraft(false)\n    }\n  }\n\n  const loadDraftFromDb = async (draft: MarketDraft) => {\n    try {\n      setQuestion(draft.data.question)\n      if (draft.data.description && editor) {\n        editor.commands.setContent(draft.data.description)\n      }\n      setAnswers(draft.data.answers ?? defaultAnswers)\n      setCloseDate(draft.data.closeDate)\n      setCloseHoursMinutes(draft.data.closeHoursMinutes)\n      setVisibility(draft.data.visibility as Visibility)\n      setSelectedGroups(draft.data.selectedGroups)\n      setShowDraftsModal(false)\n    } catch (error) {\n      console.error('Error loading draft:', error)\n    }\n  }\n\n  const deleteDraft = async (id: number) => {\n    try {\n      await api('delete-market-draft', { id })\n      await loadDrafts()\n    } catch (error) {\n      console.error('Error deleting draft:', error)\n    }\n  }\n\n  const submit = async () => {\n    if (!isValid) return\n    setSubmitState('LOADING')\n    try {\n      const createProps = removeUndefinedProps({\n        question,\n        outcomeType,\n        description: editor?.getJSON(),\n        initialProb: 50,\n        closeTime,\n        min,\n        max,\n        initialValue,\n        isLogScale,\n        groupIds: selectedGroups.map((g) => g.id),\n        answers,\n        midpoints,\n        addAnswersMode:\n          outcomeType === 'MULTI_NUMERIC' || outcomeType === 'DATE'\n            ? 'DISABLED'\n            : addAnswersMode,\n        shouldAnswersSumToOne,\n        visibility,\n        utcOffset: new Date().getTimezoneOffset(),\n        totalBounty: bountyAmount,\n        isAutoBounty:\n          outcomeType === 'BOUNTIED_QUESTION' ? isAutoBounty : undefined,\n        precision,\n        liquidityTier,\n        idempotencyKey,\n        sportsStartTimestamp: params?.sportsStartTimestamp,\n        sportsEventId: params?.sportsEventId,\n        sportsLeague: params?.sportsLeague,\n        unit: unit.trim(),\n        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n        voterVisibility: outcomeType === 'POLL' ? voterVisibility : undefined,\n      })\n\n      const newContract = await api('market', createProps as any)\n\n      track('create market', {\n        slug: newContract.slug,\n        selectedGroups: selectedGroups.map((g) => g.id),\n        outcomeType,\n      })\n\n      // Await to clear form data from localstorage after navigate, since market is created.\n      // Don't clear before navigate, because looks like a bug.\n      const path = twombaContractPath(newContract)\n      await router.push(path)\n      resetProperties()\n    } catch (e) {\n      console.error('error creating contract', e)\n      setErrorText((e as any).message || 'Error creating contract')\n      setSubmitState('EDITING')\n    }\n  }\n  const [bountyError, setBountyError] = useState<string | undefined>(undefined)\n\n  const findTopicsAndSimilarQuestions = useCallback(\n    async (question: string) => {\n      const trimmed = question.toLowerCase().trim()\n      if (trimmed === '') {\n        setHasChosenCategory(false)\n        setSimilarContracts([])\n        return\n      }\n      const [similarGroupsRes, contracts] = await Promise.all([\n        !params?.groupIds?.length &&\n        trimmed !== categorizedQuestion &&\n        !hasChosenCategory\n          ? getSimilarGroupsToContract({ question })\n          : { groups: undefined },\n        !dismissedSimilarContractTitles.includes(trimmed)\n          ? searchContracts({\n              term: question,\n              contractType: outcomeType,\n              filter: 'open',\n              limit: 10,\n              sort: 'most-popular',\n            })\n          : [],\n      ])\n\n      if (similarGroupsRes.groups) {\n        setSelectedGroups(similarGroupsRes.groups)\n        setCategorizedQuestion(trimmed)\n      }\n      setSimilarContracts(\n        contracts?.filter((c) => compareTwoStrings(c.question, question) > 0.25)\n      )\n    },\n    [dismissedSimilarContractTitles, categorizedQuestion, hasChosenCategory]\n  )\n\n  const isMulti = outcomeType === 'MULTIPLE_CHOICE'\n  const isPoll = outcomeType === 'POLL'\n  const isNumber = outcomeType === 'NUMBER'\n  const isMultiNumeric = outcomeType === 'MULTI_NUMERIC'\n  const isDate = outcomeType === 'DATE'\n\n  const [isGeneratingDescription, setIsGeneratingDescription] = useState(false)\n  const [preGenerateContent, setPreGenerateContent] = useState<\n    JSONContent | undefined\n  >()\n\n  const generateAIDescription = async () => {\n    if (!question) return\n    setIsGeneratingDescription(true)\n    try {\n      // Store current content before generating\n      setPreGenerateContent(editor?.getJSON())\n\n      const result = await api('generate-ai-description', {\n        question,\n        description: editor?.getHTML(),\n        answers,\n        outcomeType,\n        shouldAnswersSumToOne,\n        addAnswersMode,\n      })\n      if (result.description && editor) {\n        const endPos = editor.state.doc.content.size\n        editor.commands.setTextSelection(endPos)\n        editor.commands.insertContent(result.description)\n      }\n    } catch (e) {\n      console.error('Error generating description:', e)\n      // Reset preGenerateContent on error\n      setPreGenerateContent(undefined)\n    }\n    setIsGeneratingDescription(false)\n  }\n  const [isGeneratingAnswers, setIsGeneratingAnswers] = useState(false)\n\n  const generateAnswers = async () => {\n    if (!question || outcomeType !== 'MULTIPLE_CHOICE') return\n    setIsGeneratingAnswers(true)\n    try {\n      const result = await api('generate-ai-answers', {\n        question,\n        description: editor?.getHTML(),\n        shouldAnswersSumToOne,\n        answers,\n      })\n      setAnswers([...answers, ...result.answers])\n      setAddAnswersMode(result.addAnswersMode)\n    } catch (e) {\n      console.error('Error generating answers:', e)\n    }\n    setIsGeneratingAnswers(false)\n  }\n\n  const undoGeneration = () => {\n    if (preGenerateContent && editor) {\n      editor.commands.setContent(preGenerateContent)\n      setPreGenerateContent(undefined)\n    }\n  }\n\n  const inferUnit = async () => {\n    if (!question || unit !== '') return\n    try {\n      const result = await api('infer-numeric-unit', {\n        question,\n        description: editor?.getHTML(),\n      })\n      if (result.unit) {\n        setUnit(result.unit)\n      }\n    } catch (e) {\n      console.error('Error inferring unit:', e)\n    }\n  }\n\n  // Function to get AI-suggested close date\n  const getAISuggestedCloseDate = useEvent(async (currentQuestion: string) => {\n    if (\n      !currentQuestion ||\n      currentQuestion.length < 20 ||\n      !shouldHaveCloseDate\n    ) {\n      return\n    }\n    try {\n      const result = await api('get-close-date', {\n        question: currentQuestion,\n        utcOffset: new Date().getTimezoneOffset() * -1,\n      })\n      const latestManualEditState = readHasManuallyEditedCloseDate()\n      if (result?.closeTime && !latestManualEditState) {\n        const date = dayjs(result.closeTime).format('YYYY-MM-DD')\n        const time = dayjs(result.closeTime).format('HH:mm')\n        setCloseDate(date)\n        setCloseHoursMinutes(time)\n      }\n    } catch (e) {\n      console.error('Error getting suggested close date:', e)\n    }\n  })\n\n  const handleSetCloseDate = (date: string | undefined) => {\n    setCloseDate(date)\n    setHasManuallyEditedCloseDate(true)\n  }\n\n  const handleSetCloseHoursMinutes = (time: string | undefined) => {\n    setCloseHoursMinutes(time)\n    setHasManuallyEditedCloseDate(true)\n  }\n\n  const handleSetNeverCloses = (never: boolean) => {\n    setNeverCloses(never)\n    setHasManuallyEditedCloseDate(true)\n  }\n\n  return (\n    <Col className=\"gap-6\">\n      <Col>\n        <label className=\"px-1 pb-3 pt-2\">\n          Question<span className={'text-scarlet-500'}>*</span>\n        </label>\n\n        <ExpandingInput\n          placeholder={getContractTypeFromValue(outcomeType, 'example')}\n          autoFocus\n          maxLength={MAX_QUESTION_LENGTH}\n          value={question}\n          onChange={(e) => setQuestion(e.target.value || '')}\n          onBlur={(e) => {\n            if (outcomeType === 'MULTI_NUMERIC') inferUnit()\n            findTopicsAndSimilarQuestions(e.target.value || '')\n            getAISuggestedCloseDate(e.target.value || '')\n          }}\n        />\n\n        <Row className=\"text-ink-600 -mb-3 mt-2 h-6 items-center gap-2 text-sm\">\n          {suggestedTitle && suggestedTitle !== '' ? (\n            <>\n              <span className=\"\">{suggestedTitle}</span>\n              <Button\n                color=\"gray-outline\"\n                size=\"2xs\"\n                loading={isGeneratingTitle}\n                disabled={isGeneratingTitle}\n                onClick={() => {\n                  setApplyingTitle(true)\n                  setQuestion(suggestedTitle)\n                  setSuggestedTitle(undefined)\n                  track('apply concise title', {\n                    title: suggestedTitle,\n                  })\n                  setTimeout(() => {\n                    setApplyingTitle(false)\n                  }, 1000)\n                }}\n              >\n                Accept\n              </Button>\n            </>\n          ) : isGeneratingTitle && !suggestedTitle ? (\n            <span>Generating concise title...</span>\n          ) : null}\n        </Row>\n      </Col>\n      {similarContracts.length ? (\n        <SimilarContractsSection\n          similarContracts={similarContracts}\n          setSimilarContracts={setSimilarContracts}\n          setDismissedSimilarContractTitles={setDismissedSimilarContractTitles}\n          outcomeType={outcomeType}\n          question={question}\n        />\n      ) : null}\n      {(isMulti || isPoll) && !isNumber && (\n        <MultipleChoiceAnswers\n          answers={answers}\n          setAnswers={setAnswers}\n          addAnswersMode={addAnswersMode}\n          setAddAnswersMode={setAddAnswersMode}\n          shouldAnswersSumToOne={shouldAnswersSumToOne}\n          outcomeType={outcomeType}\n          placeholder={isMulti ? 'Type your answer..' : undefined}\n          question={question}\n          generateAnswers={generateAnswers}\n          isGeneratingAnswers={isGeneratingAnswers}\n          marginalCost={marginalCost}\n        />\n      )}\n      {outcomeType == 'BOUNTIED_QUESTION' && (\n        <Col className=\"gap-2\">\n          <label className=\"gap-2 px-1 py-2\">\n            <span className=\"mb-1 mr-1\">Bounty</span>\n            <InfoTooltip text=\"The award you give good answers. You can divide this amongst answers however you'd like.\" />\n          </label>\n          <BuyAmountInput\n            minimumAmount={MINIMUM_BOUNTY}\n            amount={bountyAmount}\n            onChange={(newAmount) => setBountyAmount(newAmount)}\n            error={bountyError}\n            setError={setBountyError}\n            quickButtonAmountSize=\"large\"\n          />\n          <Row className=\"mt-2 items-center gap-2\">\n            <span>\n              Auto-award bounty{' '}\n              <InfoTooltip\n                text={\n                  'Automatically pay out the bounty to commenters in proportion to likes over 48 hours.'\n                }\n              />\n            </span>\n            <ShortToggle on={isAutoBounty} setOn={setIsAutoBounty} />\n          </Row>\n        </Col>\n      )}\n      {outcomeType === 'STONK' && (\n        <div className=\"text-primary-500 ml-1 mt-1 text-sm\">\n          Tradeable shares of a stock based on sentiment. Never resolves.\n        </div>\n      )}\n      {outcomeType === 'PSEUDO_NUMERIC' && (\n        <div className=\"text-primary-500 ml-1 mt-1 text-sm\">\n          Predict the value of a number.\n        </div>\n      )}\n      {isMultiNumeric && (\n        <MultiNumericRangeSection\n          paramsKey={paramsKey}\n          submitState={submitState}\n          question={question}\n          description={editor?.getHTML()}\n          answers={answers}\n          setAnswers={setAnswers}\n          midpoints={midpoints}\n          setMidpoints={setMidpoints}\n          minString={minString}\n          setMinString={setMinString}\n          maxString={maxString}\n          setMaxString={setMaxString}\n          min={min}\n          max={max}\n          shouldAnswersSumToOne={shouldAnswersSumToOne}\n          setShouldAnswersSumToOne={setMultiNumericSumsToOne}\n          unit={unit}\n          setUnit={setUnit}\n          marginalCost={marginalCost}\n        />\n      )}{' '}\n      {isDate && (\n        <MultiNumericDateSection\n          paramsKey={paramsKey}\n          submitState={submitState}\n          question={question}\n          description={editor?.getHTML()}\n          answers={answers}\n          setAnswers={setAnswers}\n          midpoints={midpoints}\n          setMidpoints={setMidpoints}\n          minString={minString}\n          setMinString={setMinString}\n          maxString={maxString}\n          setMaxString={setMaxString}\n          shouldAnswersSumToOne={shouldAnswersSumToOne}\n          setShouldAnswersSumToOne={setMultiNumericSumsToOne}\n          marginalCost={marginalCost}\n        />\n      )}\n      {outcomeType === 'PSEUDO_NUMERIC' && (\n        <PseudoNumericRangeSection\n          minString={minString}\n          setMinString={setMinString}\n          maxString={maxString}\n          setMaxString={setMaxString}\n          initialValueString={initialValueString}\n          setInitialValueString={setInitialValueString}\n          isLogScale={isLogScale}\n          setIsLogScale={setIsLogScale}\n          submitState={submitState}\n          initialValue={initialValue}\n          min={min}\n          max={max}\n        />\n      )}{' '}\n      {isNumber && (\n        <NumberRangeSection\n          minString={minString}\n          setMinString={setMinString}\n          maxString={maxString}\n          setMaxString={setMaxString}\n          submitState={submitState}\n          precision={precision}\n          setPrecision={setPrecision}\n          min={min}\n          max={max}\n          paramsKey={paramsKey}\n        />\n      )}\n      <TopicSelectorSection\n        selectedGroups={selectedGroups}\n        setSelectedGroups={setSelectedGroups}\n        setHasChosenCategory={setHasChosenCategory}\n        question={question}\n      />\n      <Col className=\"items-start gap-3\">\n        <Row className=\"w-full items-center justify-between\">\n          <label className=\"px-1\">\n            <span>Description</span>\n          </label>\n          <Row className=\"gap-2\">\n            {preGenerateContent && (\n              <Button\n                color=\"gray-outline\"\n                size=\"xs\"\n                disabled={isGeneratingDescription}\n                onClick={undoGeneration}\n                className=\"gap-1\"\n              >\n                <BiUndo className=\"h-4 w-4\" />\n              </Button>\n            )}\n            <Button\n              color=\"indigo-outline\"\n              size=\"xs\"\n              loading={isGeneratingDescription}\n              onClick={generateAIDescription}\n              disabled={!question || isGeneratingDescription}\n            >\n              Generate with AI\n            </Button>\n          </Row>\n        </Row>\n        <TextEditor editor={editor} />\n      </Col>\n      <CloseTimeSection\n        closeDate={closeDate}\n        setCloseDate={handleSetCloseDate}\n        closeHoursMinutes={closeHoursMinutes}\n        setCloseHoursMinutes={handleSetCloseHoursMinutes}\n        neverCloses={neverCloses}\n        setNeverCloses={handleSetNeverCloses}\n        submitState={submitState}\n        outcomeType={outcomeType}\n        initTime={initTime}\n      />\n      {outcomeType === 'POLL' && (\n        <>\n          <Col className=\"gap-2\">\n            <label className=\"gap-1\">\n              <span className=\"mb-1\">Who can see who voted?</span>\n            </label>\n            <ChoicesToggleGroup\n              className=\"w-fit\"\n              currentChoice={voterVisibility}\n              choicesMap={{\n                Everyone: 'everyone',\n                'Only me': 'creator',\n              }}\n              setChoice={(val) =>\n                setVoterVisibility(val as PollVoterVisibility)\n              }\n            />\n          </Col>\n        </>\n      )}\n      <Row className=\"mt-2 items-center gap-2\">\n        <span>\n          Publicly listed{' '}\n          <InfoTooltip\n            text={\n              visibility === 'public'\n                ? 'Visible on home page and search results'\n                : \"Only visible via link. Won't notify followers\"\n            }\n          />\n        </span>\n        <ShortToggle\n          on={visibility === 'public'}\n          setOn={(on) => {\n            setVisibility(on ? 'public' : 'unlisted')\n          }}\n        />\n      </Row>\n      <CostSection\n        balance={balance}\n        numAnswers={numAnswers}\n        outcomeType={outcomeType}\n        liquidityTier={liquidityTier}\n        setLiquidityTier={setLiquidityTier}\n      />\n      {outcomeType !== 'POLL' && outcomeType !== 'BOUNTIED_QUESTION' && (\n        <div className=\"text-ink-600 -mt-3 text-sm\">\n          Earn back your creation cost! Get a{' '}\n          <b>\n            {formatWithToken({\n              amount: getUniqueBettorBonusAmount(ante, numAnswers),\n              short: true,\n              token: 'M$',\n            })}{' '}\n            bonus\n          </b>{' '}\n          for each unique trader on your question.\n        </div>\n      )}\n      {errorText && <span className={'text-error'}>{errorText}</span>}\n      <Button\n        className=\"w-full\"\n        type=\"submit\"\n        color={submitState === 'DONE' ? 'green' : 'indigo'}\n        size=\"xl\"\n        loading={submitState === 'LOADING'}\n        disabled={\n          !isValid ||\n          editor?.storage.upload.mutation.isLoading ||\n          (outcomeType == 'BOUNTIED_QUESTION' && bountyError)\n        }\n        onClick={(e) => {\n          e.preventDefault()\n          submit()\n        }}\n      >\n        {submitState === 'EDITING'\n          ? `Create question for ${formatWithToken({\n              amount: ante,\n              short: true,\n              token: 'M$',\n            })}`\n          : submitState === 'LOADING'\n          ? 'Creating...'\n          : 'Created!'}\n      </Button>\n      <Row className=\"-mt-2 w-full gap-2\">\n        <Button\n          size=\"sm\"\n          className=\"w-full\"\n          color=\"gray-outline\"\n          onClick={saveDraftToDb}\n          disabled={isSavingDraft}\n          loading={isSavingDraft}\n        >\n          Save draft\n        </Button>\n        <Button\n          size=\"sm\"\n          className=\"w-full\"\n          disabled={drafts.length === 0}\n          color={'gray-outline'}\n          onClick={() => setShowDraftsModal(true)}\n        >\n          View drafts ({drafts.length})\n        </Button>\n      </Row>\n      <DraftsModal\n        showDraftsModal={showDraftsModal}\n        setShowDraftsModal={setShowDraftsModal}\n        drafts={drafts}\n        loadDraftFromDb={loadDraftFromDb}\n        deleteDraft={deleteDraft}\n      />\n    </Col>\n  )\n}\n\ninterface DraftsModalProps {\n  showDraftsModal: boolean\n  setShowDraftsModal: (show: boolean) => void\n  drafts: MarketDraft[]\n  loadDraftFromDb: (draft: MarketDraft) => void\n  deleteDraft: (id: number) => void\n}\n\nfunction DraftsModal(props: DraftsModalProps) {\n  const {\n    showDraftsModal,\n    setShowDraftsModal,\n    drafts,\n    loadDraftFromDb,\n    deleteDraft,\n  } = props\n\n  return (\n    <Modal\n      className={MODAL_CLASS}\n      open={showDraftsModal}\n      setOpen={setShowDraftsModal}\n    >\n      <div className=\"max-h-[80vh] overflow-y-auto p-6\">\n        <h3 className=\"mb-4 text-xl font-semibold\">Saved Drafts</h3>\n        {drafts.length === 0 ? (\n          <p>No saved drafts</p>\n        ) : (\n          <div className=\"flex flex-col gap-4\">\n            {drafts.map((draft) => (\n              <div\n                key={draft.id}\n                className=\"flex flex-col gap-2 rounded border p-4\"\n              >\n                <div className=\"flex items-center justify-between\">\n                  <div className=\"flex-1\">\n                    <p className=\"font-medium\">\n                      {draft.data.question || 'Untitled'}\n                    </p>\n                    <p className=\"text-ink-600 text-sm\">\n                      <RelativeTimestamp\n                        time={new Date(draft.createdAt).getTime()}\n                      />\n                    </p>\n                  </div>\n                  <div className=\"flex gap-2\">\n                    <Button\n                      color=\"gray-outline\"\n                      onClick={() => loadDraftFromDb(draft)}\n                    >\n                      Load\n                    </Button>\n                    <Button\n                      color=\"red-outline\"\n                      onClick={() => deleteDraft(draft.id)}\n                    >\n                      Delete\n                    </Button>\n                  </div>\n                </div>\n\n                <div className=\"text-ink-600 text-sm\">\n                  <p>Type: {draft.data.outcomeType}</p>\n                  {draft.data.answers.length > 0 && (\n                    <p>\n                      Answers: {draft.data.answers.slice(0, 5).join(', ')}\n                      {draft.data.answers.length > 5 && '...'}\n                    </p>\n                  )}\n                  {draft.data.description && (\n                    <p className=\"line-clamp-2\">\n                      Description: {richTextToString(draft.data.description)}\n                    </p>\n                  )}\n                </div>\n              </div>\n            ))}\n          </div>\n        )}\n      </div>\n    </Modal>\n  )\n}\n"
        },
        {
          "path": "web/components/poll/poll-panel.tsx",
          "preContent": "import { PollContract, contractPath } from 'common/contract'\nimport { PollOption } from 'common/poll-option'\nimport { useEffect, useState } from 'react'\nimport { useUser } from 'web/hooks/use-user'\nimport { castPollVote } from 'web/lib/api/api'\nimport { firebaseLogin } from 'web/lib/firebase/users'\nimport { AnswerBar } from '../answers/answer-components'\nimport { Button } from '../buttons/button'\nimport { Col } from '../layout/col'\nimport { sumBy } from 'lodash'\nimport Link from 'next/link'\nimport { ArrowRightIcon, StarIcon } from '@heroicons/react/solid'\nimport { MODAL_CLASS, Modal, SCROLLABLE_MODAL_CLASS } from '../layout/modal'\nimport clsx from 'clsx'\nimport { LoadingIndicator } from '../widgets/loading-indicator'\nimport { Row } from '../layout/row'\nimport { Avatar } from '../widgets/avatar'\nimport { UserLink } from '../widgets/user-link'\nimport { getUserVote } from 'web/lib/supabase/polls'\nimport { Tooltip } from '../widgets/tooltip'\nimport { UserHovercard } from '../user/user-hovercard'\nimport { maybePluralize } from 'common/util/format'\nimport { useAPIGetter } from 'web/hooks/use-api-getter'\n\nexport function PollPanel(props: {\n  contract: PollContract\n  maxOptions?: number\n  showResults?: boolean\n}) {\n  const { contract, maxOptions, showResults } = props\n  const { options, closeTime } = contract\n  const totalVotes = sumBy(options, (option) => option.votes)\n  const votingOpen = !closeTime || closeTime > Date.now()\n  const [hasVoted, setHasVoted] = useState<boolean | undefined>(undefined)\n  const [userVotedId, setUserVotedId] = useState<string | undefined>(undefined)\n\n  const user = useUser()\n  useEffect(() => {\n    if (!user) {\n      setHasVoted(false)\n      setUserVotedId(undefined)\n    } else {\n      getUserVote(contract.id, user?.id).then((result) => {\n        if (!result) {\n          setHasVoted(false)\n          setUserVotedId(undefined)\n        } else {\n          setHasVoted(true)\n          setUserVotedId(result)\n        }\n      })\n    }\n  }, [contract.id, user])\n\n  const castVote = (voteId: string) => {\n    if (!user) {\n      firebaseLogin()\n      return\n    }\n    setUserVotedId(voteId)\n    castPollVote({ contractId: contract.id, voteId: voteId }).then(() => {\n      setHasVoted(true)\n    })\n  }\n\n  const optionsToShow = maxOptions ? options.slice(0, maxOptions) : options\n  const isCreator = user?.id === contract.creatorId\n\n  return (\n    <Col className=\"text-ink-1000 gap-2\">\n      {optionsToShow.map((option: PollOption) => {\n        const prob = option.votes === 0 ? 0 : option.votes / totalVotes\n\n        return (\n          <AnswerBar\n            key={option.id}\n            color={'#818cf8'} // indigo-400\n            prob={prob}\n            resolvedProb={\n              contract.isResolved &&\n              contract.resolutions?.some((s) => s == option.id)\n                ? 1\n                : undefined\n            }\n            label={<div>{option.text}</div>}\n            end={\n              <Row className=\"gap-3\">\n                {(hasVoted || !votingOpen || isCreator) && (\n                  <SeeVotesButton\n                    option={option}\n                    contractId={contract.id}\n                    userVotedId={userVotedId}\n                  />\n                )}\n                {!hasVoted && votingOpen && (\n                  <VoteButton\n                    loading={!!userVotedId && userVotedId === option.id}\n                    onClick={() => castVote(option.id)}\n                    disabled={!!userVotedId}\n                  />\n                )}\n              </Row>\n            }\n            hideBar={\n              !showResults &&\n              !hasVoted &&\n              (!closeTime || closeTime < Date.now()) &&\n              !isCreator\n            }\n            className={'min-h-[40px]'}\n          />\n        )\n      })}\n      {optionsToShow.length < options.length && (\n        <Link\n          className=\"text-ink-500 hover:text-primary-500\"\n          href={contractPath(contract)}\n        >\n          See {options.length - optionsToShow.length} more options{' '}\n          <ArrowRightIcon className=\"inline h-4 w-4\" />\n        </Link>\n      )}\n    </Col>\n  )\n}\n\nexport function SeeVotesButton(props: {\n  option: PollOption\n  contractId: string\n  userVotedId?: string\n}) {\n  const { option, contractId, userVotedId } = props\n  const [open, setOpen] = useState(false)\n  const disabled = option.votes === 0\n  return (\n    <>\n      {option.id == userVotedId && (\n        <Tooltip text=\"You voted\">\n          <StarIcon className=\"h-4 w-4\" />\n        </Tooltip>\n      )}\n      <button\n        className=\"disabled:text-ink-900/60 disabled:pointer-none hover:text-primary-700 group whitespace-nowrap transition-colors disabled:cursor-not-allowed\"\n        onClick={(e) => {\n          e.preventDefault()\n          setOpen(true)\n        }}\n        disabled={disabled}\n      >\n        <span>{option.votes}</span>{' '}\n        <span className={clsx('text-xs opacity-80')}>\n          {maybePluralize('vote', option.votes)}\n        </span>\n      </button>\n      <Modal open={open} setOpen={setOpen}>\n        <SeeVotesModalContent option={option} contractId={contractId} />\n      </Modal>\n    </>\n  )\n}\n\nexport function SeeVotesModalContent(props: {\n  option: PollOption\n  contractId: string\n}) {\n  const { option, contractId } = props\n  const { data: voters } = useAPIGetter('get-contract-option-voters', {\n    contractId,\n    optionId: option.id,\n  })\n  return (\n    <Col className={clsx(MODAL_CLASS)}>\n      <div className=\"line-clamp-2 w-full\">\n        Votes on <b>{option.text}</b>\n      </div>\n      {/* <Spacer h={2} /> */}\n      <Col className={clsx(SCROLLABLE_MODAL_CLASS, 'w-full gap-2')}>\n        {!voters ? (\n          <LoadingIndicator />\n        ) : voters.length == 0 ? (\n          'No votes yet...'\n        ) : (\n          voters.map((voter) => {\n            return (\n              <UserHovercard userId={voter.id} key={voter.id}>\n                <Row className=\"w-full items-center gap-2\">\n                  <Avatar\n                    username={voter.username}\n                    avatarUrl={voter.avatarUrl}\n                    size={'sm'}\n                  />\n                  <UserLink user={voter} />\n                </Row>\n              </UserHovercard>\n            )\n          })\n        )}\n      </Col>\n    </Col>\n  )\n}\n\nexport function VoteButton(props: {\n  loading: boolean\n  onClick: () => void\n  disabled: boolean\n}) {\n  const { loading, onClick, disabled } = props\n  return (\n    <Button\n      onClick={(e) => {\n        e.preventDefault()\n        onClick()\n      }}\n      size=\"2xs\"\n      loading={loading}\n      color=\"indigo-outline\"\n      className=\"!ring-1\"\n      disabled={disabled}\n    >\n      Vote\n    </Button>\n  )\n}\n",
          "postContent": "import {\n  PollContract,\n  PollVoterVisibility,\n  contractPath,\n} from 'common/contract'\nimport { PollOption } from 'common/poll-option'\nimport { useEffect, useState, useMemo } from 'react'\nimport { useUser } from 'web/hooks/use-user'\nimport { castPollVote } from 'web/lib/api/api'\nimport { firebaseLogin } from 'web/lib/firebase/users'\nimport { AnswerBar } from '../answers/answer-components'\nimport { Button } from '../buttons/button'\nimport { Col } from '../layout/col'\nimport { sumBy } from 'lodash'\nimport Link from 'next/link'\nimport { ArrowRightIcon, StarIcon } from '@heroicons/react/solid'\nimport { MODAL_CLASS, Modal, SCROLLABLE_MODAL_CLASS } from '../layout/modal'\nimport clsx from 'clsx'\nimport { LoadingIndicator } from '../widgets/loading-indicator'\nimport { Row } from '../layout/row'\nimport { Avatar } from '../widgets/avatar'\nimport { UserLink } from '../widgets/user-link'\nimport { getUserVote } from 'web/lib/supabase/polls'\nimport { Tooltip } from '../widgets/tooltip'\nimport { UserHovercard } from '../user/user-hovercard'\nimport { maybePluralize } from 'common/util/format'\nimport { useAPIGetter } from 'web/hooks/use-api-getter'\n\nexport function PollPanel(props: {\n  contract: PollContract\n  maxOptions?: number\n  showResults?: boolean\n}) {\n  const { contract, maxOptions } = props\n  const { options, closeTime, voterVisibility = 'everyone' } = contract\n  const totalVotes = sumBy(options, (option) => option.votes)\n  const votingOpen = !closeTime || closeTime > Date.now()\n  const [hasVoted, setHasVoted] = useState<boolean | undefined>(undefined)\n  const [userVotedId, setUserVotedId] = useState<string | undefined>(undefined)\n\n  const user = useUser()\n  const isCreator = user?.id === contract.creatorId\n\n  useEffect(() => {\n    if (!user) {\n      setHasVoted(false)\n      setUserVotedId(undefined)\n    } else {\n      getUserVote(contract.id, user?.id).then((result) => {\n        if (!result) {\n          setHasVoted(false)\n          setUserVotedId(undefined)\n        } else {\n          setHasVoted(true)\n          setUserVotedId(result)\n        }\n      })\n    }\n  }, [contract.id, user])\n\n  const shouldShowResults = useMemo(() => {\n    if (isCreator) return true\n    if (hasVoted) return true\n    if (!votingOpen) return true\n    return false\n  }, [hasVoted, votingOpen, isCreator])\n\n  const castVote = (voteId: string) => {\n    if (!user) {\n      firebaseLogin()\n      return\n    }\n    setUserVotedId(voteId)\n    castPollVote({ contractId: contract.id, voteId: voteId }).then(() => {\n      setHasVoted(true)\n    })\n  }\n\n  const optionsToShow = maxOptions ? options.slice(0, maxOptions) : options\n\n  return (\n    <Col className=\"text-ink-1000 gap-2\">\n      {optionsToShow.map((option: PollOption) => {\n        const prob = option.votes === 0 ? 0 : option.votes / totalVotes\n\n        return (\n          <AnswerBar\n            key={option.id}\n            color={'#818cf8'} // indigo-400\n            prob={prob}\n            resolvedProb={\n              contract.isResolved &&\n              contract.resolutions?.some((s) => s == option.id)\n                ? 1\n                : undefined\n            }\n            label={<div>{option.text}</div>}\n            end={\n              <Row className=\"gap-3\">\n                {(hasVoted || !votingOpen || isCreator) && (\n                  <SeeVotesButton\n                    option={option}\n                    contractId={contract.id}\n                    userVotedId={userVotedId}\n                    voterVisibility={voterVisibility}\n                    isCreator={isCreator}\n                  />\n                )}\n                {!hasVoted && votingOpen && (\n                  <VoteButton\n                    loading={!!userVotedId && userVotedId === option.id}\n                    onClick={() => castVote(option.id)}\n                    disabled={!!userVotedId}\n                  />\n                )}\n              </Row>\n            }\n            hideBar={!shouldShowResults}\n            className={'min-h-[40px]'}\n          />\n        )\n      })}\n      {optionsToShow.length < options.length && (\n        <Link\n          className=\"text-ink-500 hover:text-primary-500\"\n          href={contractPath(contract)}\n        >\n          See {options.length - optionsToShow.length} more options{' '}\n          <ArrowRightIcon className=\"inline h-4 w-4\" />\n        </Link>\n      )}\n    </Col>\n  )\n}\n\nexport function SeeVotesButton(props: {\n  option: PollOption\n  contractId: string\n  userVotedId?: string\n  voterVisibility: PollVoterVisibility\n  isCreator: boolean\n}) {\n  const { option, contractId, userVotedId, voterVisibility, isCreator } = props\n  const [open, setOpen] = useState(false)\n  const disabled = option.votes === 0\n\n  const canSeeVoters = useMemo(() => {\n    if (voterVisibility === 'everyone') return true\n    if (voterVisibility === 'creator' && isCreator) return true\n    return false\n  }, [voterVisibility, isCreator])\n\n  return (\n    <>\n      {option.id == userVotedId && (\n        <Tooltip text=\"You voted\">\n          <StarIcon className=\"h-4 w-4\" />\n        </Tooltip>\n      )}\n      <button\n        className=\"disabled:text-ink-900/60 disabled:pointer-none hover:text-primary-700 group whitespace-nowrap transition-colors disabled:cursor-not-allowed\"\n        onClick={(e) => {\n          e.preventDefault()\n          setOpen(true)\n        }}\n        disabled={disabled || !canSeeVoters}\n      >\n        <span>{option.votes}</span>{' '}\n        <span className={clsx('text-xs opacity-80')}>\n          {maybePluralize('vote', option.votes)}\n        </span>\n      </button>\n      <Modal open={open} setOpen={setOpen}>\n        <SeeVotesModalContent\n          option={option}\n          contractId={contractId}\n          canSeeVoters={canSeeVoters}\n        />\n      </Modal>\n    </>\n  )\n}\n\nexport function SeeVotesModalContent(props: {\n  option: PollOption\n  contractId: string\n  canSeeVoters: boolean\n}) {\n  const { option, contractId, canSeeVoters } = props\n  const { data: voters } = useAPIGetter('get-contract-option-voters', {\n    contractId,\n    optionId: option.id,\n  })\n\n  return (\n    <Col className={clsx(MODAL_CLASS)}>\n      <div className=\"line-clamp-2 w-full\">\n        Votes on <b>{option.text}</b>\n      </div>\n      <Col className={clsx(SCROLLABLE_MODAL_CLASS, 'w-full gap-2')}>\n        {!canSeeVoters ? (\n          <div className=\"text-ink-700\">\n            Voter identities are private for this poll.\n          </div>\n        ) : !voters ? (\n          <LoadingIndicator />\n        ) : voters.length == 0 ? (\n          'No votes yet...'\n        ) : (\n          voters.map((voter) => {\n            return (\n              <UserHovercard userId={voter.id} key={voter.id}>\n                <Row className=\"w-full items-center gap-2\">\n                  <Avatar\n                    username={voter.username}\n                    avatarUrl={voter.avatarUrl}\n                    size={'sm'}\n                  />\n                  <UserLink user={voter} />\n                </Row>\n              </UserHovercard>\n            )\n          })\n        )}\n      </Col>\n    </Col>\n  )\n}\n\nexport function VoteButton(props: {\n  loading: boolean\n  onClick: () => void\n  disabled: boolean\n}) {\n  const { loading, onClick, disabled } = props\n  return (\n    <Button\n      onClick={(e) => {\n        e.preventDefault()\n        onClick()\n      }}\n      size=\"2xs\"\n      loading={loading}\n      color=\"indigo-outline\"\n      className=\"!ring-1\"\n      disabled={disabled}\n    >\n      Vote\n    </Button>\n  )\n}\n"
        }
      ]
    }
  ]
}